CVE ID: CVE-2022-49297
Description: In the Linux kernel, the following vulnerability has been resolved:

nbd: fix io hung while disconnecting device

In our tests, "qemu-nbd" triggers a io hung:

INFO: task qemu-nbd:11445 blocked for more than 368 seconds.
      Not tainted 5.18.0-rc3-next-20220422-00003-g2176915513ca #884
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
task:qemu-nbd        state:D stack:    0 pid:11445 ppid:     1 flags:0x00000000
Call Trace:
 <TASK>
 __schedule+0x480/0x1050
 ? _raw_spin_lock_irqsave+0x3e/0xb0
 schedule+0x9c/0x1b0
 blk_mq_freeze_queue_wait+0x9d/0xf0
 ? ipi_rseq+0x70/0x70
 blk_mq_freeze_queue+0x2b/0x40
 nbd_add_socket+0x6b/0x270 [nbd]
 nbd_ioctl+0x383/0x510 [nbd]
 blkdev_ioctl+0x18e/0x3e0
 __x64_sys_ioctl+0xac/0x120
 do_syscall_64+0x35/0x80
 entry_SYSCALL_64_after_hwframe+0x44/0xae
RIP: 0033:0x7fd8ff706577
RSP: 002b:00007fd8fcdfebf8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 0000000040000000 RCX: 00007fd8ff706577
RDX: 000000000000000d RSI: 000000000000ab00 RDI: 000000000000000f
RBP: 000000000000000f R08: 000000000000fbe8 R09: 000055fe497c62b0
R10: 00000002aff20000 R11: 0000000000000246 R12: 000000000000006d
R13: 0000000000000000 R14: 00007ffe82dc5e70 R15: 00007fd8fcdff9c0

"qemu-ndb -d" will call ioctl 'NBD_DISCONNECT' first, however, following
message was found:

block nbd0: Send disconnect failed -32

Which indicate that something is wrong with the server. Then,
"qemu-nbd -d" will call ioctl 'NBD_CLEAR_SOCK', however ioctl can't clear
requests after commit 2516ab1543fd("nbd: only clear the queue on device
teardown"). And in the meantime, request can't complete through timeout
because nbd_xmit_timeout() will always return 'BLK_EH_RESET_TIMER', which
means such request will never be completed in this situation.

Now that the flag 'NBD_CMD_INFLIGHT' can make sure requests won't
complete multiple times, switch back to call nbd_clear_sock() in
nbd_clear_sock_ioctl(), so that inflight requests can be cleared.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09dadb5985023e27d4740ebd17e6fea4640110e5
  - https://git.kernel.org/stable/c/141318e62db87105b0103fccc59c9c5940da248d
  - https://git.kernel.org/stable/c/54b06dc2a206b4d67349bb56b92d4bd32700b7b1
  - https://git.kernel.org/stable/c/62d227f67a8c25d5e16f40e5290607f9306d2188
  - https://git.kernel.org/stable/c/67e403136a0e1a55fef6a05f103a3979a39ad3fd
  - https://git.kernel.org/stable/c/69893d6d7f5c10d8306c1b5fc64b71efc91aa6cd
  - https://git.kernel.org/stable/c/c4ba982bd5084fa659ef518aaf159e4dab02ecda
  - https://git.kernel.org/stable/c/f72df77600a43e59b3189e53b47f8685739867d3

------------------------------------------------------------

CVE ID: CVE-2022-49298
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: rtl8712: fix uninit-value in r871xu_drv_init()

When 'tmpU1b' returns from r8712_read8(padapter, EE_9346CR) is 0,
'mac[6]' will not be initialized.

BUG: KMSAN: uninit-value in r871xu_drv_init+0x2d54/0x3070 drivers/staging/rtl8712/usb_intf.c:541
 r871xu_drv_init+0x2d54/0x3070 drivers/staging/rtl8712/usb_intf.c:541
 usb_probe_interface+0xf19/0x1600 drivers/usb/core/driver.c:396
 really_probe+0x653/0x14b0 drivers/base/dd.c:596
 __driver_probe_device+0x3e9/0x530 drivers/base/dd.c:752
 driver_probe_device drivers/base/dd.c:782 [inline]
 __device_attach_driver+0x79f/0x1120 drivers/base/dd.c:899
 bus_for_each_drv+0x2d6/0x3f0 drivers/base/bus.c:427
 __device_attach+0x593/0x8e0 drivers/base/dd.c:970
 device_initial_probe+0x4a/0x60 drivers/base/dd.c:1017
 bus_probe_device+0x17b/0x3e0 drivers/base/bus.c:487
 device_add+0x1fff/0x26e0 drivers/base/core.c:3405
 usb_set_configuration+0x37e9/0x3ed0 drivers/usb/core/message.c:2170
 usb_generic_driver_probe+0x13c/0x300 drivers/usb/core/generic.c:238
 usb_probe_device+0x309/0x570 drivers/usb/core/driver.c:293
 really_probe+0x653/0x14b0 drivers/base/dd.c:596
 __driver_probe_device+0x3e9/0x530 drivers/base/dd.c:752
 driver_probe_device drivers/base/dd.c:782 [inline]
 __device_attach_driver+0x79f/0x1120 drivers/base/dd.c:899
 bus_for_each_drv+0x2d6/0x3f0 drivers/base/bus.c:427
 __device_attach+0x593/0x8e0 drivers/base/dd.c:970
 device_initial_probe+0x4a/0x60 drivers/base/dd.c:1017
 bus_probe_device+0x17b/0x3e0 drivers/base/bus.c:487
 device_add+0x1fff/0x26e0 drivers/base/core.c:3405
 usb_new_device+0x1b8e/0x2950 drivers/usb/core/hub.c:2566
 hub_port_connect drivers/usb/core/hub.c:5358 [inline]
 hub_port_connect_change drivers/usb/core/hub.c:5502 [inline]
 port_event drivers/usb/core/hub.c:5660 [inline]
 hub_event+0x58e3/0x89e0 drivers/usb/core/hub.c:5742
 process_one_work+0xdb6/0x1820 kernel/workqueue.c:2307
 worker_thread+0x10b3/0x21e0 kernel/workqueue.c:2454
 kthread+0x3c7/0x500 kernel/kthread.c:377
 ret_from_fork+0x1f/0x30

Local variable mac created at:
 r871xu_drv_init+0x1771/0x3070 drivers/staging/rtl8712/usb_intf.c:394
 usb_probe_interface+0xf19/0x1600 drivers/usb/core/driver.c:396

KMSAN: uninit-value in r871xu_drv_init
https://syzkaller.appspot.com/bug?id=3cd92b1d85428b128503bfa7a250294c9ae00bd8
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/0458e5428e5e959d201a40ffe71d762a79ecedc4
  - https://git.kernel.org/stable/c/0b7371a22489cbb2e8e826ca03fb5ce92afb04fe
  - https://git.kernel.org/stable/c/277faa442fe0c59f418ac53f47a78e1266addd65
  - https://git.kernel.org/stable/c/52a0d88c328098b4e9fb8f2f3877fec0eff4104b
  - https://git.kernel.org/stable/c/70df04433fd351ba72bc635bd0b5fe443d9ac964
  - https://git.kernel.org/stable/c/76a964ad0ea8f2b10abd69a7532e174a28258283
  - https://git.kernel.org/stable/c/a6535d00a9d54ce1c2a8d86a85001ffb6844f9b2
  - https://git.kernel.org/stable/c/f36e754a1f0bafb9feeea63463de78080acb6de0
  - https://git.kernel.org/stable/c/ff727ab0b7d7a56b5ef281f12abd00c4b85894e9

------------------------------------------------------------

CVE ID: CVE-2022-49299
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: dwc2: gadget: don't reset gadget's driver->bus

UDC driver should not touch gadget's driver internals, especially it
should not reset driver->bus. This wasn't harmful so far, but since
commit fc274c1e9973 ("USB: gadget: Add a new bus for gadgets") gadget
subsystem got it's own bus and messing with ->bus triggers the
following NULL pointer dereference:

dwc2 12480000.hsotg: bound driver g_ether
8<--- cut here ---
Unable to handle kernel NULL pointer dereference at virtual address 00000000
[00000000] *pgd=00000000
Internal error: Oops: 5 [#1] SMP ARM
Modules linked in: ...
CPU: 0 PID: 620 Comm: modprobe Not tainted 5.18.0-rc5-next-20220504 #11862
Hardware name: Samsung Exynos (Flattened Device Tree)
PC is at module_add_driver+0x44/0xe8
LR is at sysfs_do_create_link_sd+0x84/0xe0
...
Process modprobe (pid: 620, stack limit = 0x(ptrval))
...
 module_add_driver from bus_add_driver+0xf4/0x1e4
 bus_add_driver from driver_register+0x78/0x10c
 driver_register from usb_gadget_register_driver_owner+0x40/0xb4
 usb_gadget_register_driver_owner from do_one_initcall+0x44/0x1e0
 do_one_initcall from do_init_module+0x44/0x1c8
 do_init_module from load_module+0x19b8/0x1b9c
 load_module from sys_finit_module+0xdc/0xfc
 sys_finit_module from ret_fast_syscall+0x0/0x54
Exception stack(0xf1771fa8 to 0xf1771ff0)
...
dwc2 12480000.hsotg: new device is high-speed
---[ end trace 0000000000000000 ]---

Fix this by removing driver->bus entry reset.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/172cfc167c8ee6238f24f9c16efd598602af643c
  - https://git.kernel.org/stable/c/3120aac6d0ecd9accf56894aeac0e265f74d3d5a
  - https://git.kernel.org/stable/c/5127c0f365265bb69cd776ad6e4b872c309f3fa8
  - https://git.kernel.org/stable/c/547ebdc200b862dff761ff4890f66d8217c33316
  - https://git.kernel.org/stable/c/5b0c0298f7c3b57417f1729ec4071f76864b72dd
  - https://git.kernel.org/stable/c/bee8f9808a7e82addfc73a0973b16a8bb684205b
  - https://git.kernel.org/stable/c/d2159feb9d28ce496d77df98313ab454646372ac
  - https://git.kernel.org/stable/c/d232ca0bbc7d03144bad0ffd1792c3352bfd03fa
  - https://git.kernel.org/stable/c/efb15ff4a77fe053c941281775fefa91c87770e0

------------------------------------------------------------

CVE ID: CVE-2022-49300
Description: In the Linux kernel, the following vulnerability has been resolved:

nbd: fix race between nbd_alloc_config() and module removal

When nbd module is being removing, nbd_alloc_config() may be
called concurrently by nbd_genl_connect(), although try_module_get()
will return false, but nbd_alloc_config() doesn't handle it.

The race may lead to the leak of nbd_config and its related
resources (e.g, recv_workq) and oops in nbd_read_stat() due
to the unload of nbd module as shown below:

  BUG: kernel NULL pointer dereference, address: 0000000000000040
  Oops: 0000 [#1] SMP PTI
  CPU: 5 PID: 13840 Comm: kworker/u17:33 Not tainted 5.14.0+ #1
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
  Workqueue: knbd16-recv recv_work [nbd]
  RIP: 0010:nbd_read_stat.cold+0x130/0x1a4 [nbd]
  Call Trace:
   recv_work+0x3b/0xb0 [nbd]
   process_one_work+0x1ed/0x390
   worker_thread+0x4a/0x3d0
   kthread+0x12a/0x150
   ret_from_fork+0x22/0x30

Fixing it by checking the return value of try_module_get()
in nbd_alloc_config(). As nbd_alloc_config() may return ERR_PTR(-ENODEV),
assign nbd->config only when nbd_alloc_config() succeeds to ensure
the value of nbd->config is binary (valid or NULL).

Also adding a debug message to check the reference counter
of nbd_config during module removal.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/122e4adaff2439f1cc18cc7e931980fa7560df5c
  - https://git.kernel.org/stable/c/165cf2e0019fa6cedc75b456490c41494c34abb4
  - https://git.kernel.org/stable/c/2573f2375b64280be977431701ed5d33b75b9ad0
  - https://git.kernel.org/stable/c/2888fa41985f93ed0a6837cfbb06bcbfd7fa2314
  - https://git.kernel.org/stable/c/71c142f910da44421213ade601bcbd23ceae19fa
  - https://git.kernel.org/stable/c/8a7da4ced236ce6637fe70f14ca18e718d4bf9e9
  - https://git.kernel.org/stable/c/c55b2b983b0fa012942c3eb16384b2b722caa810
  - https://git.kernel.org/stable/c/d09525720dd5201756f698bee1076de9aefd4602

------------------------------------------------------------

CVE ID: CVE-2022-49301
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: rtl8712: fix uninit-value in usb_read8() and friends

When r8712_usbctrl_vendorreq() returns negative, 'data' in
usb_read{8,16,32} will not be initialized.

BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:643 [inline]
BUG: KMSAN: uninit-value in string+0x4ec/0x6f0 lib/vsprintf.c:725
 string_nocheck lib/vsprintf.c:643 [inline]
 string+0x4ec/0x6f0 lib/vsprintf.c:725
 vsnprintf+0x2222/0x3650 lib/vsprintf.c:2806
 va_format lib/vsprintf.c:1704 [inline]
 pointer+0x18e6/0x1f70 lib/vsprintf.c:2443
 vsnprintf+0x1a9b/0x3650 lib/vsprintf.c:2810
 vprintk_store+0x537/0x2150 kernel/printk/printk.c:2158
 vprintk_emit+0x28b/0xab0 kernel/printk/printk.c:2256
 dev_vprintk_emit+0x5ef/0x6d0 drivers/base/core.c:4604
 dev_printk_emit+0x1dd/0x21f drivers/base/core.c:4615
 __dev_printk+0x3be/0x440 drivers/base/core.c:4627
 _dev_info+0x1ea/0x22f drivers/base/core.c:4673
 r871xu_drv_init+0x1929/0x3070 drivers/staging/rtl8712/usb_intf.c:401
 usb_probe_interface+0xf19/0x1600 drivers/usb/core/driver.c:396
 really_probe+0x6c7/0x1350 drivers/base/dd.c:621
 __driver_probe_device+0x3e9/0x530 drivers/base/dd.c:752
 driver_probe_device drivers/base/dd.c:782 [inline]
 __device_attach_driver+0x79f/0x1120 drivers/base/dd.c:899
 bus_for_each_drv+0x2d6/0x3f0 drivers/base/bus.c:427
 __device_attach+0x593/0x8e0 drivers/base/dd.c:970
 device_initial_probe+0x4a/0x60 drivers/base/dd.c:1017
 bus_probe_device+0x17b/0x3e0 drivers/base/bus.c:487
 device_add+0x1fff/0x26e0 drivers/base/core.c:3405
 usb_set_configuration+0x37e9/0x3ed0 drivers/usb/core/message.c:2170
 usb_generic_driver_probe+0x13c/0x300 drivers/usb/core/generic.c:238
 usb_probe_device+0x309/0x570 drivers/usb/core/driver.c:293
 really_probe+0x6c7/0x1350 drivers/base/dd.c:621
 __driver_probe_device+0x3e9/0x530 drivers/base/dd.c:752
 driver_probe_device drivers/base/dd.c:782 [inline]
 __device_attach_driver+0x79f/0x1120 drivers/base/dd.c:899
 bus_for_each_drv+0x2d6/0x3f0 drivers/base/bus.c:427
 __device_attach+0x593/0x8e0 drivers/base/dd.c:970
 device_initial_probe+0x4a/0x60 drivers/base/dd.c:1017
 bus_probe_device+0x17b/0x3e0 drivers/base/bus.c:487
 device_add+0x1fff/0x26e0 drivers/base/core.c:3405
 usb_new_device+0x1b91/0x2950 drivers/usb/core/hub.c:2566
 hub_port_connect drivers/usb/core/hub.c:5363 [inline]
 hub_port_connect_change drivers/usb/core/hub.c:5507 [inline]
 port_event drivers/usb/core/hub.c:5665 [inline]
 hub_event+0x58e3/0x89e0 drivers/usb/core/hub.c:5747
 process_one_work+0xdb6/0x1820 kernel/workqueue.c:2289
 worker_thread+0x10d0/0x2240 kernel/workqueue.c:2436
 kthread+0x3c7/0x500 kernel/kthread.c:376
 ret_from_fork+0x1f/0x30

Local variable data created at:
 usb_read8+0x5d/0x130 drivers/staging/rtl8712/usb_ops.c:33
 r8712_read8+0xa5/0xd0 drivers/staging/rtl8712/rtl8712_io.c:29

KMSAN: uninit-value in r871xu_drv_init
https://syzkaller.appspot.com/bug?id=3cd92b1d85428b128503bfa7a250294c9ae00bd8
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/33ef21d55418ab6a62a63fd550b2dbe297433372
  - https://git.kernel.org/stable/c/58762f1c63c75cbe1dc393eed3c9cf8e38310ca1
  - https://git.kernel.org/stable/c/95b0f54f8a898072a2810c05fab34d971f23a612
  - https://git.kernel.org/stable/c/d1b57669732d09da7e13ef86d058dab0cd57f6e0
  - https://git.kernel.org/stable/c/d7ed3c85da0b230bcdf5329acfe012ed093f3daa
  - https://git.kernel.org/stable/c/de075af8c404f7d59ed34df230aedd9f645fb846

------------------------------------------------------------

CVE ID: CVE-2022-49302
Description: In the Linux kernel, the following vulnerability has been resolved:

USB: host: isp116x: check return value after calling platform_get_resource()

It will cause null-ptr-deref if platform_get_resource() returns NULL,
we need check the return value.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/134a3408c2d3f7e23eb0e4556e0a2d9f36c2614e
  - https://git.kernel.org/stable/c/3592cfd8b848bf0c4d7740d78a87a7b8f6e1fa9a
  - https://git.kernel.org/stable/c/3825db88d8c704e7992b685618a03f82bffcf2ef
  - https://git.kernel.org/stable/c/7bffda1560a6f255fdf504e059fbbdb5d46b9e44
  - https://git.kernel.org/stable/c/804de302ada3544699c5f48c5314b249af76faa3
  - https://git.kernel.org/stable/c/82a101f14943f479fd190b1e5b40d91c77e2ac1b
  - https://git.kernel.org/stable/c/aca0cab0e9ed33b6371aafb519a6c38f2850ffc3
  - https://git.kernel.org/stable/c/c91a74b1f0f2d2d7e728742ae55e3ffe9ba7853d
  - https://git.kernel.org/stable/c/ee105039d3653444de4d3ede642383c92855dc1e

------------------------------------------------------------

CVE ID: CVE-2022-49303
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: staging: rtl8192eu: Fix deadlock in rtw_joinbss_event_prehandle

There is a deadlock in rtw_joinbss_event_prehandle(), which is shown below:

   (Thread 1)                |      (Thread 2)
                             | _set_timer()
rtw_joinbss_event_prehandle()|  mod_timer()
 spin_lock_bh() //(1)        |  (wait a time)
 ...                         | rtw_join_timeout_handler()
                             |  _rtw_join_timeout_handler()
 del_timer_sync()            |   spin_lock_bh() //(2)
 (wait timer to stop)        |   ...

We hold pmlmepriv->lock in position (1) of thread 1 and
use del_timer_sync() to wait timer to stop, but timer handler
also need pmlmepriv->lock in position (2) of thread 2.
As a result, rtw_joinbss_event_prehandle() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_bh(), which could let timer handler to obtain
the needed lock. What`s more, we change spin_lock_bh() to
spin_lock_irq() in _rtw_join_timeout_handler() in order to
prevent deadlock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/0fcddf9c7c10202946d5b19409efbdff744fba88
  - https://git.kernel.org/stable/c/25cf414b0610fea29d8e045f315648d9007c9a46

------------------------------------------------------------

CVE ID: CVE-2022-49304
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: tty: serial: Fix deadlock in sa1100_set_termios()

There is a deadlock in sa1100_set_termios(), which is shown
below:

   (Thread 1)              |      (Thread 2)
                           | sa1100_enable_ms()
sa1100_set_termios()       |  mod_timer()
 spin_lock_irqsave() //(1) |  (wait a time)
 ...                       | sa1100_timeout()
 del_timer_sync()          |  spin_lock_irqsave() //(2)
 (wait timer to stop)      |  ...

We hold sport->port.lock in position (1) of thread 1 and
use del_timer_sync() to wait timer to stop, but timer handler
also need sport->port.lock in position (2) of thread 2. As a result,
sa1100_set_termios() will block forever.

This patch moves del_timer_sync() before spin_lock_irqsave()
in order to prevent the deadlock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/0976808d0d171ec837d4bd3e9f4ad4a00ab703b8
  - https://git.kernel.org/stable/c/09a5958a2452ad22d0cb638711ef34ea1863a829
  - https://git.kernel.org/stable/c/2cbfc38df580bff5b2fe19f21c1a7520efcc4b3b
  - https://git.kernel.org/stable/c/34d91e555e5582cffdbcbb75517bc9217866823e
  - https://git.kernel.org/stable/c/553213432ef0c295becdc08c0207d2094468f673
  - https://git.kernel.org/stable/c/62b2caef400c1738b6d22f636c628d9f85cd4c4c
  - https://git.kernel.org/stable/c/6e2273eefab54a521d9c59efb6e1114e742bdf41
  - https://git.kernel.org/stable/c/85e20f8bd31a46d8c60103d0274a8ebe8f47f2b2
  - https://git.kernel.org/stable/c/920f0ae7a129ffee98a106e3bbdfd61a2a59e939

------------------------------------------------------------

CVE ID: CVE-2022-49305
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: staging: rtl8192u: Fix deadlock in ieee80211_beacons_stop()

There is a deadlock in ieee80211_beacons_stop(), which is shown below:

   (Thread 1)              |      (Thread 2)
                           | ieee80211_send_beacon()
ieee80211_beacons_stop()   |  mod_timer()
 spin_lock_irqsave() //(1) |  (wait a time)
 ...                       | ieee80211_send_beacon_cb()
 del_timer_sync()          |  spin_lock_irqsave() //(2)
 (wait timer to stop)      |  ...

We hold ieee->beacon_lock in position (1) of thread 1 and use
del_timer_sync() to wait timer to stop, but timer handler
also need ieee->beacon_lock in position (2) of thread 2.
As a result, ieee80211_beacons_stop() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_irqsave(), which could let timer handler to obtain
the needed lock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/042915c1bfedd684c1d98a841794ee203200571a
  - https://git.kernel.org/stable/c/1fbe033c52480f7954c057510040fa6286c4ea25
  - https://git.kernel.org/stable/c/66f769762f65d957f688f3258755c6ec410bf710
  - https://git.kernel.org/stable/c/806c7b53414934ba2a39449b31fd1a038e500273
  - https://git.kernel.org/stable/c/b34cb54923a6e5ddefbaf358c85c922c6ab456e2
  - https://git.kernel.org/stable/c/b465bb2ebf666116c1ac745cb80c65154dc0d27e
  - https://git.kernel.org/stable/c/ffc9cab7243f8151be37966301307bfd3cda2db3

------------------------------------------------------------

CVE ID: CVE-2022-49306
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: dwc3: host: Stop setting the ACPI companion

It is no longer needed. The sysdev pointer is now used when
assigning the ACPI companions to the xHCI ports and USB
devices.

Assigning the ACPI companion here resulted in the
fwnode->secondary pointer to be replaced also for the parent
dwc3 device since the primary fwnode (the ACPI companion)
was shared. That was unintentional and it created potential
side effects like resource leaks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7fd069d65da2e20b1caec3b7bcf9dfbe28c04bb2
  - https://git.kernel.org/stable/c/9c185fde906a48368bd2d2a8c17d4b6fb3d670af
  - https://git.kernel.org/stable/c/d7f35934f7ab67bfd9adabc84207e59da9c19108

------------------------------------------------------------

CVE ID: CVE-2022-49307
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: synclink_gt: Fix null-pointer-dereference in slgt_clean()

When the driver fails at alloc_hdlcdev(), and then we remove the driver
module, we will get the following splat:

[   25.065966] general protection fault, probably for non-canonical address 0xdffffc0000000182: 0000 [#1] PREEMPT SMP KASAN PTI
[   25.066914] KASAN: null-ptr-deref in range [0x0000000000000c10-0x0000000000000c17]
[   25.069262] RIP: 0010:detach_hdlc_protocol+0x2a/0x3e0
[   25.077709] Call Trace:
[   25.077924]  <TASK>
[   25.078108]  unregister_hdlc_device+0x16/0x30
[   25.078481]  slgt_cleanup+0x157/0x9f0 [synclink_gt]

Fix this by checking whether the 'info->netdev' is a null pointer first.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/078212ad15dbd88840c82c97f12c93d83703c8fd
  - https://git.kernel.org/stable/c/1ceb4ca9543a8a788febf6bc8dad2e605e172d5e
  - https://git.kernel.org/stable/c/50c341f9a2adc4c32a8ad5a39eb99d9c4a419e0d
  - https://git.kernel.org/stable/c/689ca31c542687709ba21ec2195c1fbce34fd029
  - https://git.kernel.org/stable/c/8a95696bdc0e13f8980f05b54a3b9081963d1256
  - https://git.kernel.org/stable/c/ba08cbc5b53e151d0acf1930fb526fc65b7f3e65
  - https://git.kernel.org/stable/c/d68d5e68b7f64de7170f8e04dd9b995c36b2c71c
  - https://git.kernel.org/stable/c/ddd67751ab86c6a65f95c35293c42f85a42ac05d
  - https://git.kernel.org/stable/c/f6e07eb7ebec53ffe81fc2489589320fbe4a6b75

------------------------------------------------------------

CVE ID: CVE-2022-49308
Description: In the Linux kernel, the following vulnerability has been resolved:

extcon: Modify extcon device to be created after driver data is set

Currently, someone can invoke the sysfs such as state_show()
intermittently before dev_set_drvdata() is done.
And it can be a cause of kernel Oops because of edev is Null at that time.
So modified the driver registration to after setting drviver data.

- Oops's backtrace.

Backtrace:
[<c067865c>] (state_show) from [<c05222e8>] (dev_attr_show)
[<c05222c0>] (dev_attr_show) from [<c02c66e0>] (sysfs_kf_seq_show)
[<c02c6648>] (sysfs_kf_seq_show) from [<c02c496c>] (kernfs_seq_show)
[<c02c4938>] (kernfs_seq_show) from [<c025e2a0>] (seq_read)
[<c025e11c>] (seq_read) from [<c02c50a0>] (kernfs_fop_read)
[<c02c5064>] (kernfs_fop_read) from [<c0231cac>] (__vfs_read)
[<c0231c5c>] (__vfs_read) from [<c0231ee0>] (vfs_read)
[<c0231e34>] (vfs_read) from [<c0232464>] (ksys_read)
[<c02323f0>] (ksys_read) from [<c02324fc>] (sys_read)
[<c02324e4>] (sys_read) from [<c00091d0>] (__sys_trace_return)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/033ec4e7e59ae5e1ef1e8c10bc6552926044ed1c
  - https://git.kernel.org/stable/c/35ff1ac55d301efb3f467cf5426faaeb3452994b
  - https://git.kernel.org/stable/c/368e68ad6da4317fc4170e8d92b51c13d1bfe7a7
  - https://git.kernel.org/stable/c/5dcc2afe716d69f5112ce035cb14f007461ff189
  - https://git.kernel.org/stable/c/6e721f3ad0535b24f19a62420f4da95212cf069c
  - https://git.kernel.org/stable/c/abf3b222614f49f98e606fccdd269161c0d70204
  - https://git.kernel.org/stable/c/cb81ea998c461868d1168411a867d8ffee12f23f
  - https://git.kernel.org/stable/c/d472c78cc82999d07bd09193a6718016ce9cd386

------------------------------------------------------------

CVE ID: CVE-2022-49309
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: staging: rtl8723bs: Fix deadlock in rtw_surveydone_event_callback()

There is a deadlock in rtw_surveydone_event_callback(),
which is shown below:

   (Thread 1)                  |      (Thread 2)
                               | _set_timer()
rtw_surveydone_event_callback()|  mod_timer()
 spin_lock_bh() //(1)          |  (wait a time)
 ...                           | rtw_scan_timeout_handler()
 del_timer_sync()              |  spin_lock_bh() //(2)
 (wait timer to stop)          |  ...

We hold pmlmepriv->lock in position (1) of thread 1 and use
del_timer_sync() to wait timer to stop, but timer handler
also need pmlmepriv->lock in position (2) of thread 2.
As a result, rtw_surveydone_event_callback() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_bh(), which could let timer handler to obtain
the needed lock. What`s more, we change spin_lock_bh() in
rtw_scan_timeout_handler() to spin_lock_irq(). Otherwise,
spin_lock_bh() will also cause deadlock() in timer handler.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/2c41f5c341853f84b7bc2f32605d4e2782e8c279
  - https://git.kernel.org/stable/c/c84e5c819600ee0628f61b33d145258ae0f3d7a7
  - https://git.kernel.org/stable/c/cc7ad0d77b51c872d629bcd98aea463a3c4109e7
  - https://git.kernel.org/stable/c/ce129d3efd181da5fd56f4360cc8827122afa67e
  - https://git.kernel.org/stable/c/f89f6c3ebf69623b8ea48200bd690e9e210335a1

------------------------------------------------------------

CVE ID: CVE-2022-49310
Description: In the Linux kernel, the following vulnerability has been resolved:

char: xillybus: fix a refcount leak in cleanup_dev()

usb_get_dev is called in xillyusb_probe. So it is better to call
usb_put_dev before xdev is released.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/21f1f167d727f3f857e26d509ef5a6d47fd31bc3
  - https://git.kernel.org/stable/c/b67d19662fdee275c479d21853bc1239600a798f
  - https://git.kernel.org/stable/c/bc8fceda3b89006e8a7dda8a097d36045d044c25
  - https://git.kernel.org/stable/c/e277b95acdab84cd5d2f8d537a37aef6d21e988b

------------------------------------------------------------

CVE ID: CVE-2022-49311
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: staging: rtl8192bs: Fix deadlock in rtw_joinbss_event_prehandle()

There is a deadlock in rtw_joinbss_event_prehandle(), which is shown
below:

   (Thread 1)                |      (Thread 2)
                             | _set_timer()
rtw_joinbss_event_prehandle()|  mod_timer()
 spin_lock_bh() //(1)        |  (wait a time)
 ...                         | _rtw_join_timeout_handler()
 del_timer_sync()            |  spin_lock_bh() //(2)
 (wait timer to stop)        |  ...

We hold pmlmepriv->lock in position (1) of thread 1 and
use del_timer_sync() to wait timer to stop, but timer handler
also need pmlmepriv->lock in position (2) of thread 2.
As a result, rtw_joinbss_event_prehandle() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_bh(), which could let timer handler to obtain
the needed lock. What`s more, we change spin_lock_bh() to
spin_lock_irq() in _rtw_join_timeout_handler() in order to
prevent deadlock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/041879b12ddb0c6c83ed9c0bdd10dc82a056f2fc
  - https://git.kernel.org/stable/c/1f6c99b94ca3caad346876b3e22e3ca3d25bc8ee
  - https://git.kernel.org/stable/c/ae60744d5fad840b9d056d35b4b652d95e755846
  - https://git.kernel.org/stable/c/eca9748d9267a38d532464e3305a38629e9c35a9

------------------------------------------------------------

CVE ID: CVE-2022-49312
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: rtl8712: fix a potential memory leak in r871xu_drv_init()

In r871xu_drv_init(), if r8712_init_drv_sw() fails, then the memory
allocated by r8712_alloc_io_queue() in r8712_usb_dvobj_init() is not
properly released as there is no action will be performed by
r8712_usb_dvobj_deinit().
To properly release it, we should call r8712_free_io_queue() in
r8712_usb_dvobj_deinit().

Besides, in r871xu_dev_remove(), r8712_usb_dvobj_deinit() will be called
by r871x_dev_unload() under condition `padapter->bup` and
r8712_free_io_queue() is called by r8712_free_drv_sw().
However, r8712_usb_dvobj_deinit() does not rely on `padapter->bup` and
calling r8712_free_io_queue() in r8712_free_drv_sw() is negative for
better understading the code.
So I move r8712_usb_dvobj_deinit() into r871xu_dev_remove(), and remove
r8712_free_io_queue() from r8712_free_drv_sw().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/205e039fead72e87ad2838f5e649a4c4834f648b
  - https://git.kernel.org/stable/c/5a89a92efc342dd7c44b6056da87debc598f9c73
  - https://git.kernel.org/stable/c/7288ff561de650d4139fab80e9cb0da9b5b32434
  - https://git.kernel.org/stable/c/8eb42d6d10f8fe509117859defddf9e72b4fa4d0
  - https://git.kernel.org/stable/c/a2882b8baad068d21c99fb2ab5a85a2bdbd5b834

------------------------------------------------------------

CVE ID: CVE-2022-49313
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: usb: host: Fix deadlock in oxu_bus_suspend()

There is a deadlock in oxu_bus_suspend(), which is shown below:

   (Thread 1)              |      (Thread 2)
                           | timer_action()
oxu_bus_suspend()          |  mod_timer()
 spin_lock_irq() //(1)     |  (wait a time)
 ...                       | oxu_watchdog()
 del_timer_sync()          |  spin_lock_irq() //(2)
 (wait timer to stop)      |  ...

We hold oxu->lock in position (1) of thread 1, and use
del_timer_sync() to wait timer to stop, but timer handler
also need oxu->lock in position (2) of thread 2. As a result,
oxu_bus_suspend() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_irq(), which could let timer handler to obtain
the needed lock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/2dcec0bc142be2096af71a5703d63237127db204
  - https://git.kernel.org/stable/c/4187b291a76664a3c03d3f0d9bfadc8322881868
  - https://git.kernel.org/stable/c/4d378f2ae58138d4c55684e1d274e7dd94aa6524
  - https://git.kernel.org/stable/c/9b58d255f27b0ed6a2e43208960864d67579db58
  - https://git.kernel.org/stable/c/a3d380188bde8900c3f604e82b56572896499124
  - https://git.kernel.org/stable/c/b97aae8b43b718314012e8170b7e03dbfd2e7677
  - https://git.kernel.org/stable/c/d888753872190abd18f68a7d77b9c7c367f0a7ab
  - https://git.kernel.org/stable/c/f8242044c91cafbba9e320b0fb31abf2429a3221
  - https://git.kernel.org/stable/c/ffe9440d698274c6462d2e304562c6ddfc8c84df

------------------------------------------------------------

CVE ID: CVE-2022-49314
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: Fix a possible resource leak in icom_probe

When pci_read_config_dword failed, call pci_release_regions() and
pci_disable_device() to recycle the resource previously allocated.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/23e155b51d403c0ccedc60c0d6c3c452afed07fe
  - https://git.kernel.org/stable/c/5f9b2e4ca88cab1a96b86ecd45544e488ca43faf
  - https://git.kernel.org/stable/c/8c014373f178a4f13a08e045ef63bdb23f62e892
  - https://git.kernel.org/stable/c/9a8305f357a8d03698fc7bc855ff9c6865d5486b
  - https://git.kernel.org/stable/c/a2df0b4d080cc770b4da7bff487048c803dfd07e
  - https://git.kernel.org/stable/c/cb7147afd328c07edeeee287710d8d96ac0459f5
  - https://git.kernel.org/stable/c/d703d912a985c1c5b50dd38c3181fc3540fa77cb
  - https://git.kernel.org/stable/c/ee157a79e7c82b01ae4c25de0ac75899801f322c
  - https://git.kernel.org/stable/c/f4c836d90da1ece88905d62ce2ce39a962f25d1a

------------------------------------------------------------

CVE ID: CVE-2022-49315
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: staging: rtl8192e: Fix deadlock in rtllib_beacons_stop()

There is a deadlock in rtllib_beacons_stop(), which is shown
below:

   (Thread 1)              |      (Thread 2)
                           | rtllib_send_beacon()
rtllib_beacons_stop()      |  mod_timer()
 spin_lock_irqsave() //(1) |  (wait a time)
 ...                       | rtllib_send_beacon_cb()
 del_timer_sync()          |  spin_lock_irqsave() //(2)
 (wait timer to stop)      |  ...

We hold ieee->beacon_lock in position (1) of thread 1 and
use del_timer_sync() to wait timer to stop, but timer handler
also need ieee->beacon_lock in position (2) of thread 2.
As a result, rtllib_beacons_stop() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_irqsave(), which could let timer handler to obtain
the needed lock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/08bacf871c019163ccd1389d0bc957a43324967a
  - https://git.kernel.org/stable/c/0f69d7d5e918aa43423d86bd17ddb11b1b5e8ada
  - https://git.kernel.org/stable/c/381045dc64d23a2229c47c5524c06bfc33d34446
  - https://git.kernel.org/stable/c/4681129fda9e8555392eaaadb239ec6a6e2b3e12
  - https://git.kernel.org/stable/c/46c861009bf437a18417df24cea0d181741b7d72
  - https://git.kernel.org/stable/c/64b05fa212c7e4d057676e8b7e7120c6eb2f615b
  - https://git.kernel.org/stable/c/9b6bdbd9337de3917945847bde262a34a87a6303
  - https://git.kernel.org/stable/c/fef451f0fbbe85dbd2962b18379d02e2965610db
  - https://git.kernel.org/stable/c/ffd4c4d5293e4985092ea45ba21cad9326e2e434

------------------------------------------------------------

CVE ID: CVE-2022-49316
Description: In the Linux kernel, the following vulnerability has been resolved:

NFSv4: Don't hold the layoutget locks across multiple RPC calls

When doing layoutget as part of the open() compound, we have to be
careful to release the layout locks before we can call any further RPC
calls, such as setattr(). The reason is that those calls could trigger
a recall, which could deadlock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/08d7a26d115cc7892668baa9750f64bd8baca29b
  - https://git.kernel.org/stable/c/0ee5b9644f06b4d3cdcd9544f43f63312e425a4c
  - https://git.kernel.org/stable/c/6949493884fe88500de4af182588e071cf1544ee
  - https://git.kernel.org/stable/c/6b3fc1496e7227cd6a39a80bbfb7588ef7c7a010
  - https://git.kernel.org/stable/c/a2b3be930e79cc5d9d829f158e31172b2043f0cd
  - https://git.kernel.org/stable/c/d4c2a041ed3ba114502d5ed6ace5b1a48d637a8e
  - https://git.kernel.org/stable/c/ea759ae0a9ae5acee677d722129710ac89cc59c1

------------------------------------------------------------

CVE ID: CVE-2022-49317
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: avoid infinite loop to flush node pages

xfstests/generic/475 can give EIO all the time which give an infinite loop
to flush node page like below. Let's avoid it.

[16418.518551] Call Trace:
[16418.518553]  ? dm_submit_bio+0x48/0x400
[16418.518574]  ? submit_bio_checks+0x1ac/0x5a0
[16418.525207]  __submit_bio+0x1a9/0x230
[16418.525210]  ? kmem_cache_alloc+0x29e/0x3c0
[16418.525223]  submit_bio_noacct+0xa8/0x2b0
[16418.525226]  submit_bio+0x4d/0x130
[16418.525238]  __submit_bio+0x49/0x310 [f2fs]
[16418.525339]  ? bio_add_page+0x6a/0x90
[16418.525344]  f2fs_submit_page_bio+0x134/0x1f0 [f2fs]
[16418.525365]  read_node_page+0x125/0x1b0 [f2fs]
[16418.525388]  __get_node_page.part.0+0x58/0x3f0 [f2fs]
[16418.525409]  __get_node_page+0x2f/0x60 [f2fs]
[16418.525431]  f2fs_get_dnode_of_data+0x423/0x860 [f2fs]
[16418.525452]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
[16418.525458]  ? __mod_memcg_state.part.0+0x2a/0x30
[16418.525465]  ? __mod_memcg_lruvec_state+0x27/0x40
[16418.525467]  ? __xa_set_mark+0x57/0x70
[16418.525472]  f2fs_do_write_data_page+0x10e/0x7b0 [f2fs]
[16418.525493]  f2fs_write_single_data_page+0x555/0x830 [f2fs]
[16418.525514]  ? sysvec_apic_timer_interrupt+0x4e/0x90
[16418.525518]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
[16418.525523]  f2fs_write_cache_pages+0x303/0x880 [f2fs]
[16418.525545]  ? blk_flush_plug_list+0x47/0x100
[16418.525548]  f2fs_write_data_pages+0xfd/0x320 [f2fs]
[16418.525569]  do_writepages+0xd5/0x210
[16418.525648]  filemap_fdatawrite_wbc+0x7d/0xc0
[16418.525655]  filemap_fdatawrite+0x50/0x70
[16418.525658]  f2fs_sync_dirty_inodes+0xa4/0x230 [f2fs]
[16418.525679]  f2fs_write_checkpoint+0x16d/0x1720 [f2fs]
[16418.525699]  ? ttwu_do_wakeup+0x1c/0x160
[16418.525709]  ? ttwu_do_activate+0x6d/0xd0
[16418.525711]  ? __wait_for_common+0x11d/0x150
[16418.525715]  kill_f2fs_super+0xca/0x100 [f2fs]
[16418.525733]  deactivate_locked_super+0x3b/0xb0
[16418.525739]  deactivate_super+0x40/0x50
[16418.525741]  cleanup_mnt+0x139/0x190
[16418.525747]  __cleanup_mnt+0x12/0x20
[16418.525749]  task_work_run+0x6d/0xa0
[16418.525765]  exit_to_user_mode_prepare+0x1ad/0x1b0
[16418.525771]  syscall_exit_to_user_mode+0x27/0x50
[16418.525774]  do_syscall_64+0x48/0xc0
[16418.525776]  entry_SYSCALL_64_after_hwframe+0x44/0xae
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/a7b8618aa2f0f926ce85f2486ac835a85c753ca7
  - https://git.kernel.org/stable/c/bd47ea5d776d8b524fb6f60de3240f95603901dd

------------------------------------------------------------

CVE ID: CVE-2022-49318
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: remove WARN_ON in f2fs_is_valid_blkaddr

Syzbot triggers two WARNs in f2fs_is_valid_blkaddr and
__is_bitmap_valid. For example, in f2fs_is_valid_blkaddr,
if type is DATA_GENERIC_ENHANCE or DATA_GENERIC_ENHANCE_READ,
it invokes WARN_ON if blkaddr is not in the right range.
The call trace is as follows:

 f2fs_get_node_info+0x45f/0x1070
 read_node_page+0x577/0x1190
 __get_node_page.part.0+0x9e/0x10e0
 __get_node_page
 f2fs_get_node_page+0x109/0x180
 do_read_inode
 f2fs_iget+0x2a5/0x58b0
 f2fs_fill_super+0x3b39/0x7ca0

Fix these two WARNs by replacing WARN_ON with dump_stack.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/0a7a1fc7e71eecf2e5053a6c312c9f0dcbb9b8fd
  - https://git.kernel.org/stable/c/32bea51fe4c6e92c00403739f7547c89219bea88
  - https://git.kernel.org/stable/c/8c62c5e26345c34d199b4b8c8e69255ba3d0e751
  - https://git.kernel.org/stable/c/99c09b298e47ebbe345a6da9f268b32a6b0f4582
  - https://git.kernel.org/stable/c/cd6374af36cc548464d8c47a93fdba7303bb82a4
  - https://git.kernel.org/stable/c/dc2f78e2d4cc844a1458653d57ce1b54d4a29f21

------------------------------------------------------------

CVE ID: CVE-2022-49319
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/arm-smmu-v3: check return value after calling platform_get_resource()

It will cause null-ptr-deref if platform_get_resource() returns NULL,
we need check the return value.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/54c1e0e3bbcab2abe25b2874a43050ae5df87831
  - https://git.kernel.org/stable/c/54cf47da0c7532d151d76e5d63f5936191698c44
  - https://git.kernel.org/stable/c/b131fa8c1d2afd05d0b7598621114674289c2fbb
  - https://git.kernel.org/stable/c/db728a891f9177b044aaca89b678f6b5e24d5cc3
  - https://git.kernel.org/stable/c/fb0f1c5eb8d60b3e018ba7c87da249b52674ebe6

------------------------------------------------------------

CVE ID: CVE-2022-49320
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: zynqmp_dma: In struct zynqmp_dma_chan fix desc_size data type

In zynqmp_dma_alloc/free_chan_resources functions there is a
potential overflow in the below expressions.

dma_alloc_coherent(chan->dev, (2 * chan->desc_size *
		   ZYNQMP_DMA_NUM_DESCS),
		   &chan->desc_pool_p, GFP_KERNEL);

dma_free_coherent(chan->dev,(2 * ZYNQMP_DMA_DESC_SIZE(chan) *
                 ZYNQMP_DMA_NUM_DESCS),
                chan->desc_pool_v, chan->desc_pool_p);

The arguments desc_size and ZYNQMP_DMA_NUM_DESCS were 32 bit. Though
this overflow condition is not observed but it is a potential problem
in the case of 32-bit multiplication. Hence fix it by changing the
desc_size data type to size_t.

In addition to coverity fix it also reuse ZYNQMP_DMA_DESC_SIZE macro in
dma_alloc_coherent API argument.

Addresses-Coverity: Event overflow_before_widen.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4838969e4d95d2bd2995d1605b20d3144fcb3e74
  - https://git.kernel.org/stable/c/7b5488f4721fed6e121e661e165bab06ae2f8675
  - https://git.kernel.org/stable/c/83960276ffc9bf5570d4106490346b61e61be5f3
  - https://git.kernel.org/stable/c/90aefae2e3a770a6909d339f5d8a988c0b0ceaf0
  - https://git.kernel.org/stable/c/95a0ba85c1b51b36e909841c02d205cd223ab753
  - https://git.kernel.org/stable/c/f9a9f43a62a04ec3183fb0da9226c7706eed0115

------------------------------------------------------------

CVE ID: CVE-2022-49321
Description: In the Linux kernel, the following vulnerability has been resolved:

xprtrdma: treat all calls not a bcall when bc_serv is NULL

When a rdma server returns a fault format reply, nfs v3 client may
treats it as a bcall when bc service is not exist.

The debug message at rpcrdma_bc_receive_call are,

[56579.837169] RPC:       rpcrdma_bc_receive_call: callback XID
00000001, length=20
[56579.837174] RPC:       rpcrdma_bc_receive_call: 00 00 00 01 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 04

After that, rpcrdma_bc_receive_call will meets NULL pointer as,

[  226.057890] BUG: unable to handle kernel NULL pointer dereference at
00000000000000c8
...
[  226.058704] RIP: 0010:_raw_spin_lock+0xc/0x20
...
[  226.059732] Call Trace:
[  226.059878]  rpcrdma_bc_receive_call+0x138/0x327 [rpcrdma]
[  226.060011]  __ib_process_cq+0x89/0x170 [ib_core]
[  226.060092]  ib_cq_poll_work+0x26/0x80 [ib_core]
[  226.060257]  process_one_work+0x1a7/0x360
[  226.060367]  ? create_worker+0x1a0/0x1a0
[  226.060440]  worker_thread+0x30/0x390
[  226.060500]  ? create_worker+0x1a0/0x1a0
[  226.060574]  kthread+0x116/0x130
[  226.060661]  ? kthread_flush_work_fn+0x10/0x10
[  226.060724]  ret_from_fork+0x35/0x40
...
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/11270e7ca268e8d61b5d9e5c3a54bd1550642c9c
  - https://git.kernel.org/stable/c/8dbae5affbdbf524b48000f9d357925bb001e5f4
  - https://git.kernel.org/stable/c/8e3943c50764dc7c5f25911970c3ff062ec1f18c
  - https://git.kernel.org/stable/c/90c4f73104016748533a5707ecd15930fbeff402
  - https://git.kernel.org/stable/c/91784f3d77b73885e1b2e6b59d3cbf0de0a1126a
  - https://git.kernel.org/stable/c/998d35a2aff4b81a1c784f3aa45cd3afff6814c1
  - https://git.kernel.org/stable/c/a3fc8051ee061e31db13e2fe011e8e0b71a7f815
  - https://git.kernel.org/stable/c/da99331fa62131a38a0947a8204c5208de7b0454

------------------------------------------------------------

CVE ID: CVE-2022-49322
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix sleeping function called from invalid context on RT kernel

When setting bootparams="trace_event=initcall:initcall_start tp_printk=1" in the
cmdline, the output_printk() was called, and the spin_lock_irqsave() was called in the
atomic and irq disable interrupt context suitation. On the PREEMPT_RT kernel,
these locks are replaced with sleepable rt-spinlock, so the stack calltrace will
be triggered.
Fix it by raw_spin_lock_irqsave when PREEMPT_RT and "trace_event=initcall:initcall_start
tp_printk=1" enabled.

 BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46
 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0
 preempt_count: 2, expected: 0
 RCU nest depth: 0, expected: 0
 Preemption disabled at:
 [<ffffffff8992303e>] try_to_wake_up+0x7e/0xba0
 CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.17.1-rt17+ #19 34c5812404187a875f32bee7977f7367f9679ea7
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
 Call Trace:
  <TASK>
  dump_stack_lvl+0x60/0x8c
  dump_stack+0x10/0x12
  __might_resched.cold+0x11d/0x155
  rt_spin_lock+0x40/0x70
  trace_event_buffer_commit+0x2fa/0x4c0
  ? map_vsyscall+0x93/0x93
  trace_event_raw_event_initcall_start+0xbe/0x110
  ? perf_trace_initcall_finish+0x210/0x210
  ? probe_sched_wakeup+0x34/0x40
  ? ttwu_do_wakeup+0xda/0x310
  ? trace_hardirqs_on+0x35/0x170
  ? map_vsyscall+0x93/0x93
  do_one_initcall+0x217/0x3c0
  ? trace_event_raw_event_initcall_level+0x170/0x170
  ? push_cpu_stop+0x400/0x400
  ? cblist_init_generic+0x241/0x290
  kernel_init_freeable+0x1ac/0x347
  ? _raw_spin_unlock_irq+0x65/0x80
  ? rest_init+0xf0/0xf0
  kernel_init+0x1e/0x150
  ret_from_fork+0x22/0x30
  </TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/12025abdc8539ed9d5014e2d647a3fd1bd3de5cd
  - https://git.kernel.org/stable/c/1788e6dbb61286215442b1af99e51405a6206762
  - https://git.kernel.org/stable/c/40f9fde06b25884baa0c4bd138b909a9b67218b4
  - https://git.kernel.org/stable/c/43bfc4dccc416c964b53cbdc430e814f8b6f770b
  - https://git.kernel.org/stable/c/48c6ee7d6c614f09b2c8553a95eefef6ecf196e0
  - https://git.kernel.org/stable/c/9abf3db8bdb63ab545034148ef2118f4d088ca59
  - https://git.kernel.org/stable/c/9b534640a2c6a8d88168febc82ec6d161184f2ec
  - https://git.kernel.org/stable/c/be1f323fb9d9b14a505ca22d742d321769454de1

------------------------------------------------------------

CVE ID: CVE-2022-49323
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/arm-smmu: fix possible null-ptr-deref in arm_smmu_device_probe()

It will cause null-ptr-deref when using 'res', if platform_get_resource()
returns NULL, so move using 'res' after devm_ioremap_resource() that
will check it to avoid null-ptr-deref.
And use devm_platform_get_and_ioremap_resource() to simplify code.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/3660db29b0305f9a1d95979c7af0f5db6ea99f5d
  - https://git.kernel.org/stable/c/449fc4561762ad9ad85362d5f01f0d0df397457a
  - https://git.kernel.org/stable/c/80776a71340f57d6a4952635fc89f0342072f3ca
  - https://git.kernel.org/stable/c/98dd53a92825747395649f54d23512a13c3ed471
  - https://git.kernel.org/stable/c/d9ed8af1dee37f181096631fb03729ece98ba816

------------------------------------------------------------

CVE ID: CVE-2022-49324
Description: In the Linux kernel, the following vulnerability has been resolved:

mips: cpc: Fix refcount leak in mips_cpc_default_phys_base

Add the missing of_node_put() to release the refcount incremented
by of_find_compatible_node().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/1699ec1bfb59304a788901474f6bb003f7831b61
  - https://git.kernel.org/stable/c/4107fa700f314592850e2c64608f6ede4c077476
  - https://git.kernel.org/stable/c/8f843cdfc202caaa5d67db3395d893e56362e43a
  - https://git.kernel.org/stable/c/961ee8a6eeef4632a215d995d837b204f8c7c2d4
  - https://git.kernel.org/stable/c/aae6b4bb63c694bc91714412718f15468407fe51
  - https://git.kernel.org/stable/c/bed702566dcdb6ebe300bc0c62bf3600cf4d5874
  - https://git.kernel.org/stable/c/c667b3872a4c435a3f29d4e15971cd8c378b0043
  - https://git.kernel.org/stable/c/cc0aed22d33ced9e266c50bdf1cbe668c5acfdf8

------------------------------------------------------------

CVE ID: CVE-2022-49325
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: add accessors to read/set tp->snd_cwnd

We had various bugs over the years with code
breaking the assumption that tp->snd_cwnd is greater
than zero.

Lately, syzbot reported the WARN_ON_ONCE(!tp->prior_cwnd) added
in commit 8b8a321ff72c ("tcp: fix zero cwnd in tcp_cwnd_reduction")
can trigger, and without a repro we would have to spend
considerable time finding the bug.

Instead of complaining too late, we want to catch where
and when tp->snd_cwnd is set to an illegal value.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3308676ec525901bf1656014003c443a60730a04
  - https://git.kernel.org/stable/c/40570375356c874b1578e05c1dcc3ff7c1322dbe
  - https://git.kernel.org/stable/c/41e191fe72282e193a7744e2fc1786b23156c9e4
  - https://git.kernel.org/stable/c/5aba0ad44fb4a7fb78c5076c313456de199a3c29

------------------------------------------------------------

CVE ID: CVE-2022-49326
Description: In the Linux kernel, the following vulnerability has been resolved:

rtl818x: Prevent using not initialized queues

Using not existing queues can panic the kernel with rtl8180/rtl8185 cards.
Ignore the skb priority for those cards, they only have one tx queue. Pierre
Asselin (pa@panix.com) reported the kernel crash in the Gentoo forum:

https://forums.gentoo.org/viewtopic-t-1147832-postdays-0-postorder-asc-start-25.html

He also confirmed that this patch fixes the issue. In summary this happened:

After updating wpa_supplicant from 2.9 to 2.10 the kernel crashed with a
"divide error: 0000" when connecting to an AP. Control port tx now tries to
use IEEE80211_AC_VO for the priority, which wpa_supplicants starts to use in
2.10.

Since only the rtl8187se part of the driver supports QoS, the priority
of the skb is set to IEEE80211_AC_BE (2) by mac80211 for rtl8180/rtl8185
cards.

rtl8180 is then unconditionally reading out the priority and finally crashes on
drivers/net/wireless/realtek/rtl818x/rtl8180/dev.c line 544 without this
patch:
	idx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries

"ring->entries" is zero for rtl8180/rtl8185 cards, tx_ring[2] never got
initialized.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/6ad81ad0cf5744738ce94c8e64051ddd80a1734c
  - https://git.kernel.org/stable/c/746285cf81dc19502ab238249d75f5990bd2d231
  - https://git.kernel.org/stable/c/769ec2a824deae2f1268dfda14999a4d14d0d0c5
  - https://git.kernel.org/stable/c/98e55b0b876bde3353f4e074883d66ecb55c65a3
  - https://git.kernel.org/stable/c/9ad1981fc4de3afb7db3e8eb5a6a52d4c7d0d577
  - https://git.kernel.org/stable/c/9d5e96cc1f1720019ce27b127a31695148d38bb0
  - https://git.kernel.org/stable/c/b5dca2cd3f0239512da808598b4e70557eb4c2a1
  - https://git.kernel.org/stable/c/b8ce58ab80faaea015c206382041ff3bcf5495ff
  - https://git.kernel.org/stable/c/d7e30dfc166d33470bba31a42f9bbc346e5409d5

------------------------------------------------------------

CVE ID: CVE-2022-49327
Description: In the Linux kernel, the following vulnerability has been resolved:

bcache: avoid journal no-space deadlock by reserving 1 journal bucket

The journal no-space deadlock was reported time to time. Such deadlock
can happen in the following situation.

When all journal buckets are fully filled by active jset with heavy
write I/O load, the cache set registration (after a reboot) will load
all active jsets and inserting them into the btree again (which is
called journal replay). If a journaled bkey is inserted into a btree
node and results btree node split, new journal request might be
triggered. For example, the btree grows one more level after the node
split, then the root node record in cache device super block will be
upgrade by bch_journal_meta() from bch_btree_set_root(). But there is no
space in journal buckets, the journal replay has to wait for new journal
bucket to be reclaimed after at least one journal bucket replayed. This
is one example that how the journal no-space deadlock happens.

The solution to avoid the deadlock is to reserve 1 journal bucket in
run time, and only permit the reserved journal bucket to be used during
cache set registration procedure for things like journal replay. Then
the journal space will never be fully filled, there is no chance for
journal no-space deadlock to happen anymore.

This patch adds a new member "bool do_reserve" in struct journal, it is
inititalized to 0 (false) when struct journal is allocated, and set to
1 (true) by bch_journal_space_reserve() when all initialization done in
run_cache_set(). In the run time when journal_reclaim() tries to
allocate a new journal bucket, free_journal_buckets() is called to check
whether there are enough free journal buckets to use. If there is only
1 free journal bucket and journal->do_reserve is 1 (true), the last
bucket is reserved and free_journal_buckets() will return 0 to indicate
no free journal bucket. Then journal_reclaim() will give up, and try
next time to see whetheer there is free journal bucket to allocate. By
this method, there is always 1 jouranl bucket reserved in run time.

During the cache set registration, journal->do_reserve is 0 (false), so
the reserved journal bucket can be used to avoid the no-space deadlock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1dda32aed6f62c163f38ff947ef5b3360e329159
  - https://git.kernel.org/stable/c/32feee36c30ea06e38ccb8ae6e5c44c6eec790a6
  - https://git.kernel.org/stable/c/5607652823ac65e2c6885e73bd46d5a4f9a20363
  - https://git.kernel.org/stable/c/59afd4f287900c8187e968a4153ed35e6b48efce
  - https://git.kernel.org/stable/c/6332ea3e35efa12dc08f0cbf5faea5e6e8eb0497

------------------------------------------------------------

CVE ID: CVE-2022-49328
Description: In the Linux kernel, the following vulnerability has been resolved:

mt76: fix use-after-free by removing a non-RCU wcid pointer

Fixes an issue caught by KASAN about use-after-free in mt76_txq_schedule
by protecting mtxq->wcid with rcu_lock between mt76_txq_schedule and
sta_info_[alloc, free].

[18853.876689] ==================================================================
[18853.876751] BUG: KASAN: use-after-free in mt76_txq_schedule+0x204/0xaf8 [mt76]
[18853.876773] Read of size 8 at addr ffffffaf989a2138 by task mt76-tx phy0/883
[18853.876786]
[18853.876810] CPU: 5 PID: 883 Comm: mt76-tx phy0 Not tainted 5.10.100-fix-510-56778d365941-kasan #5 0b01fbbcf41a530f52043508fec2e31a4215

[18853.876840] Call trace:
[18853.876861]  dump_backtrace+0x0/0x3ec
[18853.876878]  show_stack+0x20/0x2c
[18853.876899]  dump_stack+0x11c/0x1ac
[18853.876918]  print_address_description+0x74/0x514
[18853.876934]  kasan_report+0x134/0x174
[18853.876948]  __asan_report_load8_noabort+0x44/0x50
[18853.876976]  mt76_txq_schedule+0x204/0xaf8 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]
[18853.877002]  mt76_txq_schedule_all+0x2c/0x48 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]
[18853.877030]  mt7921_tx_worker+0xa0/0x1cc [mt7921_common f0875ebac9d7b4754e1010549e7db50fbd90a047]
[18853.877054]  __mt76_worker_fn+0x190/0x22c [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]
[18853.877071]  kthread+0x2f8/0x3b8
[18853.877087]  ret_from_fork+0x10/0x30
[18853.877098]
[18853.877112] Allocated by task 941:
[18853.877131]  kasan_save_stack+0x38/0x68
[18853.877147]  __kasan_kmalloc+0xd4/0xfc
[18853.877163]  kasan_kmalloc+0x10/0x1c
[18853.877177]  __kmalloc+0x264/0x3c4
[18853.877294]  sta_info_alloc+0x460/0xf88 [mac80211]
[18853.877410]  ieee80211_prep_connection+0x204/0x1ee0 [mac80211]
[18853.877523]  ieee80211_mgd_auth+0x6c4/0xa4c [mac80211]
[18853.877635]  ieee80211_auth+0x20/0x2c [mac80211]
[18853.877733]  rdev_auth+0x7c/0x438 [cfg80211]
[18853.877826]  cfg80211_mlme_auth+0x26c/0x390 [cfg80211]
[18853.877919]  nl80211_authenticate+0x6d4/0x904 [cfg80211]
[18853.877938]  genl_rcv_msg+0x748/0x93c
[18853.877954]  netlink_rcv_skb+0x160/0x2a8
[18853.877969]  genl_rcv+0x3c/0x54
[18853.877985]  netlink_unicast_kernel+0x104/0x1ec
[18853.877999]  netlink_unicast+0x178/0x268
[18853.878015]  netlink_sendmsg+0x3cc/0x5f0
[18853.878030]  sock_sendmsg+0xb4/0xd8
[18853.878043]  ____sys_sendmsg+0x2f8/0x53c
[18853.878058]  ___sys_sendmsg+0xe8/0x150
[18853.878071]  __sys_sendmsg+0xc4/0x1f4
[18853.878087]  __arm64_compat_sys_sendmsg+0x88/0x9c
[18853.878101]  el0_svc_common+0x1b4/0x390
[18853.878115]  do_el0_svc_compat+0x8c/0xdc
[18853.878131]  el0_svc_compat+0x10/0x1c
[18853.878146]  el0_sync_compat_handler+0xa8/0xcc
[18853.878161]  el0_sync_compat+0x188/0x1c0
[18853.878171]
[18853.878183] Freed by task 10927:
[18853.878200]  kasan_save_stack+0x38/0x68
[18853.878215]  kasan_set_track+0x28/0x3c
[18853.878228]  kasan_set_free_info+0x24/0x48
[18853.878244]  __kasan_slab_free+0x11c/0x154
[18853.878259]  kasan_slab_free+0x14/0x24
[18853.878273]  slab_free_freelist_hook+0xac/0x1b0
[18853.878287]  kfree+0x104/0x390
[18853.878402]  sta_info_free+0x198/0x210 [mac80211]
[18853.878515]  __sta_info_destroy_part2+0x230/0x2d4 [mac80211]
[18853.878628]  __sta_info_flush+0x300/0x37c [mac80211]
[18853.878740]  ieee80211_set_disassoc+0x2cc/0xa7c [mac80211]
[18853.878851]  ieee80211_mgd_deauth+0x4a4/0x10a0 [mac80211]
[18853.878962]  ieee80211_deauth+0x20/0x2c [mac80211]
[18853.879057]  rdev_deauth+0x7c/0x438 [cfg80211]
[18853.879150]  cfg80211_mlme_deauth+0x274/0x414 [cfg80211]
[18853.879243]  cfg80211_mlme_down+0xe4/0x118 [cfg80211]
[18853.879335]  cfg80211_disconnect+0x218/0x2d8 [cfg80211]
[18853.879427]  __cfg80211_leave+0x17c/0x240 [cfg80211]
[18853.879519]  cfg80211_leave+0x3c/0x58 [cfg80211]
[18853.879611]  wiphy_suspend+0xdc/0x200 [cfg80211]
[18853.879628]  dpm_run_callback+0x58/0x408
[18853.879642]  __device_suspend+0x4cc/0x864
[18853.879658]  async_suspend+0x34/0xf4
[18
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/4448327b41738dbfcda680eb4935ff835568f468
  - https://git.kernel.org/stable/c/51fb1278aa57ae0fc54adaa786e1965362bed4fb
  - https://git.kernel.org/stable/c/d5f77f1dbb59feae81f88e44551e8e1d8a802d9a
  - https://git.kernel.org/stable/c/e55bcdd0bf34a8b10d45ce80ebb3164c5292a17d

------------------------------------------------------------

CVE ID: CVE-2022-49329
Description: In the Linux kernel, the following vulnerability has been resolved:

vduse: Fix NULL pointer dereference on sysfs access

The control device has no drvdata. So we will get a
NULL pointer dereference when accessing control
device's msg_timeout attribute via sysfs:

[ 132.841881][ T3644] BUG: kernel NULL pointer dereference, address: 00000000000000f8
[ 132.850619][ T3644] RIP: 0010:msg_timeout_show (drivers/vdpa/vdpa_user/vduse_dev.c:1271)
[ 132.869447][ T3644] dev_attr_show (drivers/base/core.c:2094)
[ 132.870215][ T3644] sysfs_kf_seq_show (fs/sysfs/file.c:59)
[ 132.871164][ T3644] ? device_remove_bin_file (drivers/base/core.c:2088)
[ 132.872082][ T3644] kernfs_seq_show (fs/kernfs/file.c:164)
[ 132.872838][ T3644] seq_read_iter (fs/seq_file.c:230)
[ 132.873578][ T3644] ? __vmalloc_area_node (mm/vmalloc.c:3041)
[ 132.874532][ T3644] kernfs_fop_read_iter (fs/kernfs/file.c:238)
[ 132.875513][ T3644] __kernel_read (fs/read_write.c:440 (discriminator 1))
[ 132.876319][ T3644] kernel_read (fs/read_write.c:459)
[ 132.877129][ T3644] kernel_read_file (fs/kernel_read_file.c:94)
[ 132.877978][ T3644] kernel_read_file_from_fd (include/linux/file.h:45 fs/kernel_read_file.c:186)
[ 132.879019][ T3644] __do_sys_finit_module (kernel/module.c:4207)
[ 132.879930][ T3644] __ia32_sys_finit_module (kernel/module.c:4189)
[ 132.880930][ T3644] do_int80_syscall_32 (arch/x86/entry/common.c:112 arch/x86/entry/common.c:132)
[ 132.881847][ T3644] entry_INT80_compat (arch/x86/entry/entry_64_compat.S:419)

To fix it, don't create the unneeded attribute for
control device anymore.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/30fd1b56621e187346f65d01fe34870634b15188
  - https://git.kernel.org/stable/c/3a7a81f4835dfda11f39fdd27586da14331896eb
  - https://git.kernel.org/stable/c/b22fdee17ec62604060fb0fda5e1414b634666e1
  - https://git.kernel.org/stable/c/b27ee76c74dc831d6e092eaebc2dfc9c0beed1c9

------------------------------------------------------------

CVE ID: CVE-2022-49330
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: fix tcp_mtup_probe_success vs wrong snd_cwnd

syzbot got a new report [1] finally pointing to a very old bug,
added in initial support for MTU probing.

tcp_mtu_probe() has checks about starting an MTU probe if
tcp_snd_cwnd(tp) >= 11.

But nothing prevents tcp_snd_cwnd(tp) to be reduced later
and before the MTU probe succeeds.

This bug would lead to potential zero-divides.

Debugging added in commit 40570375356c ("tcp: add accessors
to read/set tp->snd_cwnd") has paid off :)

While we are at it, address potential overflows in this code.

[1]
WARNING: CPU: 1 PID: 14132 at include/net/tcp.h:1219 tcp_mtup_probe_success+0x366/0x570 net/ipv4/tcp_input.c:2712
Modules linked in:
CPU: 1 PID: 14132 Comm: syz-executor.2 Not tainted 5.18.0-syzkaller-07857-gbabf0bb978e3 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:tcp_snd_cwnd_set include/net/tcp.h:1219 [inline]
RIP: 0010:tcp_mtup_probe_success+0x366/0x570 net/ipv4/tcp_input.c:2712
Code: 74 08 48 89 ef e8 da 80 17 f9 48 8b 45 00 65 48 ff 80 80 03 00 00 48 83 c4 30 5b 41 5c 41 5d 41 5e 41 5f 5d c3 e8 aa b0 c5 f8 <0f> 0b e9 16 fe ff ff 48 8b 4c 24 08 80 e1 07 38 c1 0f 8c c7 fc ff
RSP: 0018:ffffc900079e70f8 EFLAGS: 00010287
RAX: ffffffff88c0f7f6 RBX: ffff8880756e7a80 RCX: 0000000000040000
RDX: ffffc9000c6c4000 RSI: 0000000000031f9e RDI: 0000000000031f9f
RBP: 0000000000000000 R08: ffffffff88c0f606 R09: ffffc900079e7520
R10: ffffed101011226d R11: 1ffff1101011226c R12: 1ffff1100eadcf50
R13: ffff8880756e72c0 R14: 1ffff1100eadcf89 R15: dffffc0000000000
FS:  00007f643236e700(0000) GS:ffff8880b9b00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f1ab3f1e2a0 CR3: 0000000064fe7000 CR4: 00000000003506e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 tcp_clean_rtx_queue+0x223a/0x2da0 net/ipv4/tcp_input.c:3356
 tcp_ack+0x1962/0x3c90 net/ipv4/tcp_input.c:3861
 tcp_rcv_established+0x7c8/0x1ac0 net/ipv4/tcp_input.c:5973
 tcp_v6_do_rcv+0x57b/0x1210 net/ipv6/tcp_ipv6.c:1476
 sk_backlog_rcv include/net/sock.h:1061 [inline]
 __release_sock+0x1d8/0x4c0 net/core/sock.c:2849
 release_sock+0x5d/0x1c0 net/core/sock.c:3404
 sk_stream_wait_memory+0x700/0xdc0 net/core/stream.c:145
 tcp_sendmsg_locked+0x111d/0x3fc0 net/ipv4/tcp.c:1410
 tcp_sendmsg+0x2c/0x40 net/ipv4/tcp.c:1448
 sock_sendmsg_nosec net/socket.c:714 [inline]
 sock_sendmsg net/socket.c:734 [inline]
 __sys_sendto+0x439/0x5c0 net/socket.c:2119
 __do_sys_sendto net/socket.c:2131 [inline]
 __se_sys_sendto net/socket.c:2127 [inline]
 __x64_sys_sendto+0xda/0xf0 net/socket.c:2127
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x46/0xb0
RIP: 0033:0x7f6431289109
Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f643236e168 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
RAX: ffffffffffffffda RBX: 00007f643139c100 RCX: 00007f6431289109
RDX: 00000000d0d0c2ac RSI: 0000000020000080 RDI: 000000000000000a
RBP: 00007f64312e308d R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000246 R12: 0000000000000000
R13: 00007fff372533af R14: 00007f643236e300 R15: 0000000000022000
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11825765291a93d8e7f44230da67b9f607c777bf
  - https://git.kernel.org/stable/c/29e13f6b38f0816af2012e0725507754e8f4569c
  - https://git.kernel.org/stable/c/38ca71a24cd4845021eed35fd2594d89dba9a5a8
  - https://git.kernel.org/stable/c/42726877453afdbe1508a8a96884ea907741d9a7
  - https://git.kernel.org/stable/c/602b338e3c3cd7f935f3f5011882961d074e5ac1
  - https://git.kernel.org/stable/c/90385f2b65d0cd2b3b1ac8909f0cc6dd31062cfc
  - https://git.kernel.org/stable/c/9ba2b4ac35935f05ac98cff722f36ba07d62270e
  - https://git.kernel.org/stable/c/aa7f333efd1138a68517a6a6a69ae540dd59d800
  - https://git.kernel.org/stable/c/f2845e1504a3bc4f3381394f057e8b63cb5f3f7a

------------------------------------------------------------

CVE ID: CVE-2022-49331
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: st21nfca: fix memory leaks in EVT_TRANSACTION handling

Error paths do not free previously allocated memory. Add devm_kfree() to
those failure paths.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3eca2c42daa4659965db6817479027cbc6df7899
  - https://git.kernel.org/stable/c/54423649bc0ed464b75807a7cf2857a5871f738f
  - https://git.kernel.org/stable/c/55904086041ba4ee4070187b36590f8f8d6df4cd
  - https://git.kernel.org/stable/c/593773088d615a46a42c97e01a0550d192bb7f74
  - https://git.kernel.org/stable/c/6fce324b530dd74750ad870699e33eeed1029ded
  - https://git.kernel.org/stable/c/996419e0594abb311fb958553809f24f38e7abbe
  - https://git.kernel.org/stable/c/d221ce54ce331c1a23be71eebf57f6a088632383
  - https://git.kernel.org/stable/c/db836b97464d44340b568e041fd24602858713f7
  - https://git.kernel.org/stable/c/f444ecd3f57f4ba5090fe8b6756933e37de4226e

------------------------------------------------------------

CVE ID: CVE-2022-49332
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Address NULL pointer dereference after starget_to_rport()

Calls to starget_to_rport() may return NULL.  Add check for NULL rport
before dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/68fcff1127e4995ddbd4b6861892a25c23db3f70
  - https://git.kernel.org/stable/c/6f808bd78e8296b4ded813b7182988d57e1f6176

------------------------------------------------------------

CVE ID: CVE-2022-49333
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: E-Switch, pair only capable devices

OFFLOADS paring using devcom is possible only on devices
that support LAG. Filter based on lag capabilities.

This fixes an issue where mlx5_get_next_phys_dev() was
called without holding the interface lock.

This issue was found when commit
bc4c2f2e0179 ("net/mlx5: Lag, filter non compatible devices")
added an assert that verifies the interface lock is held.

WARNING: CPU: 9 PID: 1706 at drivers/net/ethernet/mellanox/mlx5/core/dev.c:642 mlx5_get_next_phys_dev+0xd2/0x100 [mlx5_core]
Modules linked in: mlx5_vdpa vringh vhost_iotlb vdpa mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_umad ib_ipoib ib_cm ib_uverbs ib_core overlay fuse [last unloaded: mlx5_core]
CPU: 9 PID: 1706 Comm: devlink Not tainted 5.18.0-rc7+ #11
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
RIP: 0010:mlx5_get_next_phys_dev+0xd2/0x100 [mlx5_core]
Code: 02 00 75 48 48 8b 85 80 04 00 00 5d c3 31 c0 5d c3 be ff ff ff ff 48 c7 c7 08 41 5b a0 e8 36 87 28 e3 85 c0 0f 85 6f ff ff ff <0f> 0b e9 68 ff ff ff 48 c7 c7 0c 91 cc 84 e8 cb 36 6f e1 e9 4d ff
RSP: 0018:ffff88811bf47458 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff88811b398000 RCX: 0000000000000001
RDX: 0000000080000000 RSI: ffffffffa05b4108 RDI: ffff88812daaaa78
RBP: ffff88812d050380 R08: 0000000000000001 R09: ffff88811d6b3437
R10: 0000000000000001 R11: 00000000fddd3581 R12: ffff88815238c000
R13: ffff88812d050380 R14: ffff8881018aa7e0 R15: ffff88811d6b3428
FS:  00007fc82e18ae80(0000) GS:ffff88842e080000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f9630d1b421 CR3: 0000000149802004 CR4: 0000000000370ea0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 mlx5_esw_offloads_devcom_event+0x99/0x3b0 [mlx5_core]
 mlx5_devcom_send_event+0x167/0x1d0 [mlx5_core]
 esw_offloads_enable+0x1153/0x1500 [mlx5_core]
 ? mlx5_esw_offloads_controller_valid+0x170/0x170 [mlx5_core]
 ? wait_for_completion_io_timeout+0x20/0x20
 ? mlx5_rescan_drivers_locked+0x318/0x810 [mlx5_core]
 mlx5_eswitch_enable_locked+0x586/0xc50 [mlx5_core]
 ? mlx5_eswitch_disable_pf_vf_vports+0x1d0/0x1d0 [mlx5_core]
 ? mlx5_esw_try_lock+0x1b/0xb0 [mlx5_core]
 ? mlx5_eswitch_enable+0x270/0x270 [mlx5_core]
 ? __debugfs_create_file+0x260/0x3e0
 mlx5_devlink_eswitch_mode_set+0x27e/0x870 [mlx5_core]
 ? mutex_lock_io_nested+0x12c0/0x12c0
 ? esw_offloads_disable+0x250/0x250 [mlx5_core]
 ? devlink_nl_cmd_trap_get_dumpit+0x470/0x470
 ? rcu_read_lock_sched_held+0x3f/0x70
 devlink_nl_cmd_eswitch_set_doit+0x217/0x620
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0cef0b7eb044bb8cfdaff4c1db55a8fd442f6bc9
  - https://git.kernel.org/stable/c/3008e6a0049361e731b803c60fe8f3ab44e1d73f
  - https://git.kernel.org/stable/c/cdbcdddb8076a09aa6ddaf20fd911fc787dca0e5

------------------------------------------------------------

CVE ID: CVE-2022-49334
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/huge_memory: Fix xarray node memory leak

If xas_split_alloc() fails to allocate the necessary nodes to complete the
xarray entry split, it sets the xa_state to -ENOMEM, which xas_nomem()
then interprets as "Please allocate more memory", not as "Please free
any unnecessary memory" (which was the intended outcome).  It's confusing
to use xas_nomem() to free memory in this context, so call xas_destroy()
instead.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/69a37a8ba1b408a1c7616494aa7018e4b3844cbe
  - https://git.kernel.org/stable/c/95c8181b4947e000f3b9b8e5918d899fce77b93d
  - https://git.kernel.org/stable/c/c0c84962e297927ba57fd6ddc2bb000c9d149655

------------------------------------------------------------

CVE ID: CVE-2022-49335
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu/cs: make commands with 0 chunks illegal behaviour.

Submitting a cs with 0 chunks, causes an oops later, found trying
to execute the wrong userspace driver.

MESA_LOADER_DRIVER_OVERRIDE=v3d glxinfo

[172536.665184] BUG: kernel NULL pointer dereference, address: 00000000000001d8
[172536.665188] #PF: supervisor read access in kernel mode
[172536.665189] #PF: error_code(0x0000) - not-present page
[172536.665191] PGD 6712a0067 P4D 6712a0067 PUD 5af9ff067 PMD 0
[172536.665195] Oops: 0000 [#1] SMP NOPTI
[172536.665197] CPU: 7 PID: 2769838 Comm: glxinfo Tainted: P           O      5.10.81 #1-NixOS
[172536.665199] Hardware name: To be filled by O.E.M. To be filled by O.E.M./CROSSHAIR V FORMULA-Z, BIOS 2201 03/23/2015
[172536.665272] RIP: 0010:amdgpu_cs_ioctl+0x96/0x1ce0 [amdgpu]
[172536.665274] Code: 75 18 00 00 4c 8b b2 88 00 00 00 8b 46 08 48 89 54 24 68 49 89 f7 4c 89 5c 24 60 31 d2 4c 89 74 24 30 85 c0 0f 85 c0 01 00 00 <48> 83 ba d8 01 00 00 00 48 8b b4 24 90 00 00 00 74 16 48 8b 46 10
[172536.665276] RSP: 0018:ffffb47c0e81bbe0 EFLAGS: 00010246
[172536.665277] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
[172536.665278] RDX: 0000000000000000 RSI: ffffb47c0e81be28 RDI: ffffb47c0e81bd68
[172536.665279] RBP: ffff936524080010 R08: 0000000000000000 R09: ffffb47c0e81be38
[172536.665281] R10: ffff936524080010 R11: ffff936524080000 R12: ffffb47c0e81bc40
[172536.665282] R13: ffffb47c0e81be28 R14: ffff9367bc410000 R15: ffffb47c0e81be28
[172536.665283] FS:  00007fe35e05d740(0000) GS:ffff936c1edc0000(0000) knlGS:0000000000000000
[172536.665284] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[172536.665286] CR2: 00000000000001d8 CR3: 0000000532e46000 CR4: 00000000000406e0
[172536.665287] Call Trace:
[172536.665322]  ? amdgpu_cs_find_mapping+0x110/0x110 [amdgpu]
[172536.665332]  drm_ioctl_kernel+0xaa/0xf0 [drm]
[172536.665338]  drm_ioctl+0x201/0x3b0 [drm]
[172536.665369]  ? amdgpu_cs_find_mapping+0x110/0x110 [amdgpu]
[172536.665372]  ? selinux_file_ioctl+0x135/0x230
[172536.665399]  amdgpu_drm_ioctl+0x49/0x80 [amdgpu]
[172536.665403]  __x64_sys_ioctl+0x83/0xb0
[172536.665406]  do_syscall_64+0x33/0x40
[172536.665409]  entry_SYSCALL_64_after_hwframe+0x44/0xa9

Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/2018
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/15c3bcc9b5349d40207e5f8d4d799b8b4b7d13b8
  - https://git.kernel.org/stable/c/20b947e5a3c74c5084d661c097517a554989d462
  - https://git.kernel.org/stable/c/31ab27b14daaa75541a415c6794d6f3567fea44a
  - https://git.kernel.org/stable/c/70276460e914d560e96bfc208695a872fe9469c9
  - https://git.kernel.org/stable/c/7086a23890d255bb5761604e39174b20d06231a4
  - https://git.kernel.org/stable/c/8189f44270db1be78169e11eec51a3eeb980bc63
  - https://git.kernel.org/stable/c/aa25acbe96692e4bf8482311c293f72d8c6034c0
  - https://git.kernel.org/stable/c/be585921f29df5422a39c952d188b418ad48ffab
  - https://git.kernel.org/stable/c/c12984cdb077b9042d2dc20ca18cb16a87bcc774

------------------------------------------------------------

CVE ID: CVE-2022-49336
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/etnaviv: check for reaped mapping in etnaviv_iommu_unmap_gem

When the mapping is already reaped the unmap must be a no-op, as we
would otherwise try to remove the mapping twice, corrupting the involved
data structures.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/03bd455a79f69d97fee3e3b212ab754442f10e5c
  - https://git.kernel.org/stable/c/19323b3671a85788569d15685c8f83a05ec48cbb
  - https://git.kernel.org/stable/c/436cff507f2a41230baacc3e2ef1d3b2d2653f40
  - https://git.kernel.org/stable/c/461c0fdf9434188875da9f10cfc86065866bb797
  - https://git.kernel.org/stable/c/64f4edec081cb7c97c5e928529d0e1b0dbbffb83
  - https://git.kernel.org/stable/c/e168c25526cd0368af098095c2ded4a008007e1b

------------------------------------------------------------

CVE ID: CVE-2022-49337
Description: In the Linux kernel, the following vulnerability has been resolved:

ocfs2: dlmfs: fix error handling of user_dlm_destroy_lock

When user_dlm_destroy_lock failed, it didn't clean up the flags it set
before exit.  For USER_LOCK_IN_TEARDOWN, if this function fails because of
lock is still in used, next time when unlink invokes this function, it
will return succeed, and then unlink will remove inode and dentry if lock
is not in used(file closed), but the dlm lock is still linked in dlm lock
resource, then when bast come in, it will trigger a panic due to
user-after-free.  See the following panic call trace.  To fix this,
USER_LOCK_IN_TEARDOWN should be reverted if fail.  And also error should
be returned if USER_LOCK_IN_TEARDOWN is set to let user know that unlink
fail.

For the case of ocfs2_dlm_unlock failure, besides USER_LOCK_IN_TEARDOWN,
USER_LOCK_BUSY is also required to be cleared.  Even though spin lock is
released in between, but USER_LOCK_IN_TEARDOWN is still set, for
USER_LOCK_BUSY, if before every place that waits on this flag,
USER_LOCK_IN_TEARDOWN is checked to bail out, that will make sure no flow
waits on the busy flag set by user_dlm_destroy_lock(), then we can
simplely revert USER_LOCK_BUSY when ocfs2_dlm_unlock fails.  Fix
user_dlm_cluster_lock() which is the only function not following this.

[  941.336392] (python,26174,16):dlmfs_unlink:562 ERROR: unlink
004fb0000060000b5a90b8c847b72e1, error -16 from destroy
[  989.757536] ------------[ cut here ]------------
[  989.757709] kernel BUG at fs/ocfs2/dlmfs/userdlm.c:173!
[  989.757876] invalid opcode: 0000 [#1] SMP
[  989.758027] Modules linked in: ksplice_2zhuk2jr_ib_ipoib_new(O)
ksplice_2zhuk2jr(O) mptctl mptbase xen_netback xen_blkback xen_gntalloc
xen_gntdev xen_evtchn cdc_ether usbnet mii ocfs2 jbd2 rpcsec_gss_krb5
auth_rpcgss nfsv4 nfsv3 nfs_acl nfs fscache lockd grace ocfs2_dlmfs
ocfs2_stack_o2cb ocfs2_dlm ocfs2_nodemanager ocfs2_stackglue configfs bnx2fc
fcoe libfcoe libfc scsi_transport_fc sunrpc ipmi_devintf bridge stp llc
rds_rdma rds bonding ib_sdp ib_ipoib rdma_ucm ib_ucm ib_uverbs ib_umad
rdma_cm ib_cm iw_cm falcon_lsm_serviceable(PE) falcon_nf_netcontain(PE)
mlx4_vnic falcon_kal(E) falcon_lsm_pinned_13402(E) mlx4_ib ib_sa ib_mad
ib_core ib_addr xenfs xen_privcmd dm_multipath iTCO_wdt iTCO_vendor_support
pcspkr sb_edac edac_core i2c_i801 lpc_ich mfd_core ipmi_ssif i2c_core ipmi_si
ipmi_msghandler
[  989.760686]  ioatdma sg ext3 jbd mbcache sd_mod ahci libahci ixgbe dca ptp
pps_core vxlan udp_tunnel ip6_udp_tunnel megaraid_sas mlx4_core crc32c_intel
be2iscsi bnx2i cnic uio cxgb4i cxgb4 cxgb3i libcxgbi ipv6 cxgb3 mdio
libiscsi_tcp qla4xxx iscsi_boot_sysfs libiscsi scsi_transport_iscsi wmi
dm_mirror dm_region_hash dm_log dm_mod [last unloaded:
ksplice_2zhuk2jr_ib_ipoib_old]
[  989.761987] CPU: 10 PID: 19102 Comm: dlm_thread Tainted: P           OE
4.1.12-124.57.1.el6uek.x86_64 #2
[  989.762290] Hardware name: Oracle Corporation ORACLE SERVER
X5-2/ASM,MOTHERBOARD,1U, BIOS 30350100 06/17/2021
[  989.762599] task: ffff880178af6200 ti: ffff88017f7c8000 task.ti:
ffff88017f7c8000
[  989.762848] RIP: e030:[<ffffffffc07d4316>]  [<ffffffffc07d4316>]
__user_dlm_queue_lockres.part.4+0x76/0x80 [ocfs2_dlmfs]
[  989.763185] RSP: e02b:ffff88017f7cbcb8  EFLAGS: 00010246
[  989.763353] RAX: 0000000000000000 RBX: ffff880174d48008 RCX:
0000000000000003
[  989.763565] RDX: 0000000000120012 RSI: 0000000000000003 RDI:
ffff880174d48170
[  989.763778] RBP: ffff88017f7cbcc8 R08: ffff88021f4293b0 R09:
0000000000000000
[  989.763991] R10: ffff880179c8c000 R11: 0000000000000003 R12:
ffff880174d48008
[  989.764204] R13: 0000000000000003 R14: ffff880179c8c000 R15:
ffff88021db7a000
[  989.764422] FS:  0000000000000000(0000) GS:ffff880247480000(0000)
knlGS:ffff880247480000
[  989.764685] CS:  e033 DS: 0000 ES: 0000 CR0: 0000000080050033
[  989.764865] CR2: ffff8000007f6800 CR3: 0000000001ae0000 CR4:
0000000000042660
[  989.765081] Stack:
[  989.765167]  00000000000
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/02480e2e82ae0e5588374bbbcf4fa6e4959fa174
  - https://git.kernel.org/stable/c/1434cd71ad9f3a6beda3036972983b6c4869207c
  - https://git.kernel.org/stable/c/2c5e26a626fe46675bceba853e12aaf13c712e10
  - https://git.kernel.org/stable/c/337e36550788dbe03254f0593a231c1c4873b20d
  - https://git.kernel.org/stable/c/733a35c00ef363a1c774d7ea486e0735b7c13a15
  - https://git.kernel.org/stable/c/82bf8e7271fade40184177cb406203addc34c4a0
  - https://git.kernel.org/stable/c/863e0d81b6683c4cbc588ad831f560c90e494bef
  - https://git.kernel.org/stable/c/9c96238fac045b289993d7bc5aae7b2d72b25c76
  - https://git.kernel.org/stable/c/efb54ec548829e1d3605f0434526f86e345b1b28

------------------------------------------------------------

CVE ID: CVE-2022-49338
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: CT: Fix cleanup of CT before cleanup of TC ct rules

CT cleanup assumes that all tc rules were deleted first, and so
is free to delete the CT shared resources (e.g the dr_action
fwd_action which is shared for all tuples). But currently for
uplink, this is happens in reverse, causing the below trace.

CT cleanup is called from:
mlx5e_cleanup_rep_tx()->mlx5e_cleanup_uplink_rep_tx()->
mlx5e_rep_tc_cleanup()->mlx5e_tc_esw_cleanup()->
mlx5_tc_ct_clean()

Only afterwards, tc cleanup is called from:
mlx5e_cleanup_rep_tx()->mlx5e_tc_ht_cleanup()
which would have deleted all the tc ct rules, and so delete
all the offloaded tuples.

Fix this reversing the order of init and on cleanup, which
will result in tc cleanup then ct cleanup.

[ 9443.593347] WARNING: CPU: 2 PID: 206774 at drivers/net/ethernet/mellanox/mlx5/core/steering/dr_action.c:1882 mlx5dr_action_destroy+0x188/0x1a0 [mlx5_core]
[ 9443.593349] Modules linked in: act_ct nf_flow_table rdma_ucm(O) rdma_cm(O) iw_cm(O) ib_ipoib(O) ib_cm(O) ib_umad(O) mlx5_core(O-) mlxfw(O) mlxdevm(O) auxiliary(O) ib_uverbs(O) psample ib_core(O) mlx_compat(O) ip_gre gre ip_tunnel act_vlan bonding geneve esp6_offload esp6 esp4_offload esp4 act_tunnel_key vxlan ip6_udp_tunnel udp_tunnel act_mirred act_skbedit act_gact cls_flower sch_ingress nfnetlink_cttimeout nfnetlink xfrm_user xfrm_algo 8021q garp stp ipmi_devintf mrp ipmi_msghandler llc openvswitch nsh nf_conncount nf_nat mst_pciconf(O) dm_multipath sbsa_gwdt uio_pdrv_genirq uio mlxbf_pmc mlxbf_pka mlx_trio mlx_bootctl(O) bluefield_edac sch_fq_codel ip_tables ipv6 crc_ccitt btrfs zstd_compress raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor xor_neon raid6_pq raid1 raid0 crct10dif_ce i2c_mlxbf gpio_mlxbf2 mlxbf_gige aes_neon_bs aes_neon_blk [last unloaded: mlx5_ib]
[ 9443.593419] CPU: 2 PID: 206774 Comm: modprobe Tainted: G           O      5.4.0-1023.24.gc14613d-bluefield #1
[ 9443.593422] Hardware name: https://www.mellanox.com BlueField SoC/BlueField SoC, BIOS BlueField:143ebaf Jan 11 2022
[ 9443.593424] pstate: 20000005 (nzCv daif -PAN -UAO)
[ 9443.593489] pc : mlx5dr_action_destroy+0x188/0x1a0 [mlx5_core]
[ 9443.593545] lr : mlx5_ct_fs_smfs_destroy+0x24/0x30 [mlx5_core]
[ 9443.593546] sp : ffff8000135dbab0
[ 9443.593548] x29: ffff8000135dbab0 x28: ffff0003a6ab8e80
[ 9443.593550] x27: 0000000000000000 x26: ffff0003e07d7000
[ 9443.593552] x25: ffff800009609de0 x24: ffff000397fb2120
[ 9443.593554] x23: ffff0003975c0000 x22: 0000000000000000
[ 9443.593556] x21: ffff0003975f08c0 x20: ffff800009609de0
[ 9443.593558] x19: ffff0003c8a13380 x18: 0000000000000014
[ 9443.593560] x17: 0000000067f5f125 x16: 000000006529c620
[ 9443.593561] x15: 000000000000000b x14: 0000000000000000
[ 9443.593563] x13: 0000000000000002 x12: 0000000000000001
[ 9443.593565] x11: ffff800011108868 x10: 0000000000000000
[ 9443.593567] x9 : 0000000000000000 x8 : ffff8000117fb270
[ 9443.593569] x7 : ffff0003ebc01288 x6 : 0000000000000000
[ 9443.593571] x5 : ffff800009591ab8 x4 : fffffe000f6d9a20
[ 9443.593572] x3 : 0000000080040001 x2 : fffffe000f6d9a20
[ 9443.593574] x1 : ffff8000095901d8 x0 : 0000000000000025
[ 9443.593577] Call trace:
[ 9443.593634]  mlx5dr_action_destroy+0x188/0x1a0 [mlx5_core]
[ 9443.593688]  mlx5_ct_fs_smfs_destroy+0x24/0x30 [mlx5_core]
[ 9443.593743]  mlx5_tc_ct_clean+0x34/0xa8 [mlx5_core]
[ 9443.593797]  mlx5e_tc_esw_cleanup+0x58/0x88 [mlx5_core]
[ 9443.593851]  mlx5e_rep_tc_cleanup+0x24/0x30 [mlx5_core]
[ 9443.593905]  mlx5e_cleanup_rep_tx+0x6c/0x78 [mlx5_core]
[ 9443.593959]  mlx5e_detach_netdev+0x74/0x98 [mlx5_core]
[ 9443.594013]  mlx5e_netdev_change_profile+0x70/0x180 [mlx5_core]
[ 9443.594067]  mlx5e_netdev_attach_nic_profile+0x34/0x40 [mlx5_core]
[ 9443.594122]  mlx5e_vport_rep_unload+0x15c/0x1a8 [mlx5_core]
[ 9443.594177]  mlx5_eswitch_unregister_vport_reps+0x228/0x298 [mlx5_core]
[ 9443.594231]  mlx5e_rep_remove+0x2c/0x38
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11bcc79f4bcd244145e6a2c04d5dc755303492a8
  - https://git.kernel.org/stable/c/15ef9efa855cf405fadd78272e1e5d04e09a1cf3

------------------------------------------------------------

CVE ID: CVE-2022-49339
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ipv6: unexport __init-annotated seg6_hmac_init()

EXPORT_SYMBOL and __init is a bad combination because the .init.text
section is freed up after the initialization. Hence, modules cannot
use symbols annotated __init. The access to a freed symbol may end up
with kernel panic.

modpost used to detect it, but it has been broken for a decade.

Recently, I fixed modpost so it started to warn it again, then this
showed up in linux-next builds.

There are two ways to fix it:

  - Remove __init
  - Remove EXPORT_SYMBOL

I chose the latter for this case because the caller (net/ipv6/seg6.c)
and the callee (net/ipv6/seg6_hmac.c) belong to the same module.
It seems an internal function call in ipv6.ko.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1084716f76c8045eadf92a9d9a62641f3c8d8c90
  - https://git.kernel.org/stable/c/317260b3eb6384a05a8af212308fa50f3b2e8290
  - https://git.kernel.org/stable/c/3e6de5037148c5a93a436b1e8d2edad3dac11755
  - https://git.kernel.org/stable/c/5801f064e35181c71857a80ff18af4dbec3c5f5c
  - https://git.kernel.org/stable/c/5d9c1b081ad28c852a97e10dd75412546497694a
  - https://git.kernel.org/stable/c/64aef8efe96c1616142c4476a05731306fc4494e
  - https://git.kernel.org/stable/c/9ba4416b831eeb4d185e88e73488d1d21288e63a
  - https://git.kernel.org/stable/c/ab8b2c2de273ec1d698a18e399896a6febb5cda0

------------------------------------------------------------

CVE ID: CVE-2022-49340
Description: In the Linux kernel, the following vulnerability has been resolved:

ip_gre: test csum_start instead of transport header

GRE with TUNNEL_CSUM will apply local checksum offload on
CHECKSUM_PARTIAL packets.

ipgre_xmit must validate csum_start after an optional skb_pull,
else lco_csum may trigger an overflow. The original check was

	if (csum && skb_checksum_start(skb) < skb->data)
		return -EINVAL;

This had false positives when skb_checksum_start is undefined:
when ip_summed is not CHECKSUM_PARTIAL. A discussed refinement
was straightforward

	if (csum && skb->ip_summed == CHECKSUM_PARTIAL &&
	    skb_checksum_start(skb) < skb->data)
		return -EINVAL;

But was eventually revised more thoroughly:
- restrict the check to the only branch where needed, in an
  uncommon GRE path that uses header_ops and calls skb_pull.
- test skb_transport_header, which is set along with csum_start
  in skb_partial_csum_set in the normal header_ops datapath.

Turns out skbs can arrive in this branch without the transport
header set, e.g., through BPF redirection.

Revise the check back to check csum_start directly, and only if
CHECKSUM_PARTIAL. Do leave the check in the updated location.
Check field regardless of whether TUNNEL_CSUM is configured.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c92d813c7c9ca2212ecd879232e7d87362fce98
  - https://git.kernel.org/stable/c/0ffa268724656633af5f37a38c212326d98ebe8c
  - https://git.kernel.org/stable/c/3d08bc3a5d9b2106f5c8bcf1adb73147824aa006
  - https://git.kernel.org/stable/c/7596bd7920985f7fc8579a92e48bc53ce4475b21
  - https://git.kernel.org/stable/c/8d21e9963bec1aad2280cdd034c8993033ef2948
  - https://git.kernel.org/stable/c/e6b6f98fc7605c06c0a3baa70f62c534d7b4ce58
  - https://git.kernel.org/stable/c/fbeb8dfa8b87ef259eef0c89e39b53962a3cf604

------------------------------------------------------------

CVE ID: CVE-2022-49341
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, arm64: Clear prog->jited_len along prog->jited

syzbot reported an illegal copy_to_user() attempt
from bpf_prog_get_info_by_fd() [1]

There was no repro yet on this bug, but I think
that commit 0aef499f3172 ("mm/usercopy: Detect vmalloc overruns")
is exposing a prior bug in bpf arm64.

bpf_prog_get_info_by_fd() looks at prog->jited_len
to determine if the JIT image can be copied out to user space.

My theory is that syzbot managed to get a prog where prog->jited_len
has been set to 43, while prog->bpf_func has ben cleared.

It is not clear why copy_to_user(uinsns, NULL, ulen) is triggering
this particular warning.

I thought find_vma_area(NULL) would not find a vm_struct.
As we do not hold vmap_area_lock spinlock, it might be possible
that the found vm_struct was garbage.

[1]
usercopy: Kernel memory exposure attempt detected from vmalloc (offset 792633534417210172, size 43)!
kernel BUG at mm/usercopy.c:101!
Internal error: Oops - BUG: 0 [#1] PREEMPT SMP
Modules linked in:
CPU: 0 PID: 25002 Comm: syz-executor.1 Not tainted 5.18.0-syzkaller-10139-g8291eaafed36 #0
Hardware name: linux,dummy-virt (DT)
pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : usercopy_abort+0x90/0x94 mm/usercopy.c:101
lr : usercopy_abort+0x90/0x94 mm/usercopy.c:89
sp : ffff80000b773a20
x29: ffff80000b773a30 x28: faff80000b745000 x27: ffff80000b773b48
x26: 0000000000000000 x25: 000000000000002b x24: 0000000000000000
x23: 00000000000000e0 x22: ffff80000b75db67 x21: 0000000000000001
x20: 000000000000002b x19: ffff80000b75db3c x18: 00000000fffffffd
x17: 2820636f6c6c616d x16: 76206d6f72662064 x15: 6574636574656420
x14: 74706d6574746120 x13: 2129333420657a69 x12: 73202c3237313031
x11: 3237313434333533 x10: 3336323937207465 x9 : 657275736f707865
x8 : ffff80000a30c550 x7 : ffff80000b773830 x6 : ffff80000b773830
x5 : 0000000000000000 x4 : ffff00007fbbaa10 x3 : 0000000000000000
x2 : 0000000000000000 x1 : f7ff000028fc0000 x0 : 0000000000000064
Call trace:
 usercopy_abort+0x90/0x94 mm/usercopy.c:89
 check_heap_object mm/usercopy.c:186 [inline]
 __check_object_size mm/usercopy.c:252 [inline]
 __check_object_size+0x198/0x36c mm/usercopy.c:214
 check_object_size include/linux/thread_info.h:199 [inline]
 check_copy_size include/linux/thread_info.h:235 [inline]
 copy_to_user include/linux/uaccess.h:159 [inline]
 bpf_prog_get_info_by_fd.isra.0+0xf14/0xfdc kernel/bpf/syscall.c:3993
 bpf_obj_get_info_by_fd+0x12c/0x510 kernel/bpf/syscall.c:4253
 __sys_bpf+0x900/0x2150 kernel/bpf/syscall.c:4956
 __do_sys_bpf kernel/bpf/syscall.c:5021 [inline]
 __se_sys_bpf kernel/bpf/syscall.c:5019 [inline]
 __arm64_sys_bpf+0x28/0x40 kernel/bpf/syscall.c:5019
 __invoke_syscall arch/arm64/kernel/syscall.c:38 [inline]
 invoke_syscall+0x48/0x114 arch/arm64/kernel/syscall.c:52
 el0_svc_common.constprop.0+0x44/0xec arch/arm64/kernel/syscall.c:142
 do_el0_svc+0xa0/0xc0 arch/arm64/kernel/syscall.c:206
 el0_svc+0x44/0xb0 arch/arm64/kernel/entry-common.c:624
 el0t_64_sync_handler+0x1ac/0x1b0 arch/arm64/kernel/entry-common.c:642
 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:581
Code: aa0003e3 d00038c0 91248000 97fff65f (d4210000)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0cf7aaff290cdc4d7cee683d4a18138b0dacac48
  - https://git.kernel.org/stable/c/10f3b29c65bb2fe0d47c2945cd0b4087be1c5218
  - https://git.kernel.org/stable/c/3f4d5e727aeaa610688d46c9f101f78b7f712583
  - https://git.kernel.org/stable/c/41f7c4f85d402043687e863627a1a84fa867c62d
  - https://git.kernel.org/stable/c/5c25a3040bc0486c41a7b63a1fb0de7cdb846ad7
  - https://git.kernel.org/stable/c/aaf61a312af63e1cfe2264c4c5b8cd4ea3626025
  - https://git.kernel.org/stable/c/e412b3d178ea4bf746f6b8ee086761613704c6be

------------------------------------------------------------

CVE ID: CVE-2022-49342
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: bgmac: Fix refcount leak in bcma_mdio_mii_register

of_get_child_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.8, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/7fb1fe7d9a167205413f1de8db9f7d0f82c78286
  - https://git.kernel.org/stable/c/b51996e35bbfcc7a27d94dfeed5cc2429b2c0df4
  - https://git.kernel.org/stable/c/b8d91399775c55162073bb2aca061ec42e3d4bc1

------------------------------------------------------------

CVE ID: CVE-2022-49343
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: avoid cycles in directory h-tree

A maliciously corrupted filesystem can contain cycles in the h-tree
stored inside a directory. That can easily lead to the kernel corrupting
tree nodes that were already verified under its hands while doing a node
split and consequently accessing unallocated memory. Fix the problem by
verifying traversed block numbers are unique.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/24b8206fec1db21d7e82f21f0b2ff5e5672cf5b3
  - https://git.kernel.org/stable/c/3a3ce941645407cd0b0b7f01ad9e2ea3770f46cc
  - https://git.kernel.org/stable/c/3ba733f879c2a88910744647e41edeefbc0d92b2
  - https://git.kernel.org/stable/c/6084240bfc44bf265ab6ae7d96980469b05be0f1
  - https://git.kernel.org/stable/c/b3ad9ff6f06c1dc6abf7437691c88ca3d6da3ac0
  - https://git.kernel.org/stable/c/d5a16a6df2c16eaf4de04948553ef0089dee463f
  - https://git.kernel.org/stable/c/e157c8f87e8fac112d6c955e69a60cdb9bc80a60
  - https://git.kernel.org/stable/c/ff4cafa51762da3824881a9000ca421d4b78b138

------------------------------------------------------------

CVE ID: CVE-2022-49344
Description: In the Linux kernel, the following vulnerability has been resolved:

af_unix: Fix a data-race in unix_dgram_peer_wake_me().

unix_dgram_poll() calls unix_dgram_peer_wake_me() without `other`'s
lock held and check if its receive queue is full.  Here we need to
use unix_recvq_full_lockless() instead of unix_recvq_full(), otherwise
KCSAN will report a data-race.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.2.75, Last Version (Excluding): 3.3
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.4.111, Last Version (Excluding): 3.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.10.95, Last Version (Excluding): 3.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.12.52, Last Version (Excluding): 3.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.14.59, Last Version (Excluding): 3.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18.26, Last Version (Excluding): 3.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.1.15, Last Version (Excluding): 4.2
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2.8, Last Version (Excluding): 4.3
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.3.3, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/556720013c36c193d9cbfb06e7b33e51f0c39fbf
  - https://git.kernel.org/stable/c/662a80946ce13633ae90a55379f1346c10f0c432
  - https://git.kernel.org/stable/c/71e8bfc7f838cabc60cba24e09ca84c4f8321ab2
  - https://git.kernel.org/stable/c/8801eb3ccd2e4e3b1a01449383e3321ae6dbd9d6
  - https://git.kernel.org/stable/c/95f0ba806277733bf6024e23e27e1be773701cca
  - https://git.kernel.org/stable/c/c61848500a3fd6867dfa4834b8c7f97133eceb9f
  - https://git.kernel.org/stable/c/c926ae58f24f7bd55aa2ea4add9f952032507913

------------------------------------------------------------

CVE ID: CVE-2022-49345
Description: In the Linux kernel, the following vulnerability has been resolved:

net: xfrm: unexport __init-annotated xfrm4_protocol_init()

EXPORT_SYMBOL and __init is a bad combination because the .init.text
section is freed up after the initialization. Hence, modules cannot
use symbols annotated __init. The access to a freed symbol may end up
with kernel panic.

modpost used to detect it, but it has been broken for a decade.

Recently, I fixed modpost so it started to warn it again, then this
showed up in linux-next builds.

There are two ways to fix it:

  - Remove __init
  - Remove EXPORT_SYMBOL

I chose the latter for this case because the only in-tree call-site,
net/ipv4/xfrm4_policy.c is never compiled as modular.
(CONFIG_XFRM is boolean)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b253fbc9f7b5db18d716436bdcf8ecef09fd63d
  - https://git.kernel.org/stable/c/31f3c6a4dcd3260a386e62cef2d5b36e902600a1
  - https://git.kernel.org/stable/c/4a388f08d8784af48f352193d2b72aaf167a57a1
  - https://git.kernel.org/stable/c/85a055c03691e51499123194a14a0c249cf33227
  - https://git.kernel.org/stable/c/be3884d5cd04ccd58294b83a02d70b7c5fca19d3
  - https://git.kernel.org/stable/c/c58d82a1264813e69119c13e9804e2e60b664ad5
  - https://git.kernel.org/stable/c/e04d59cfe0c0129df7aba7ef7bb17b96be2a64f2
  - https://git.kernel.org/stable/c/e53cd3814504b2cadaba4d5a8a07eeea9ddacd03
  - https://git.kernel.org/stable/c/ef6d2354de238b065d8799c80da4be9a6af18e39

------------------------------------------------------------

CVE ID: CVE-2022-49346
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: lantiq_gswip: Fix refcount leak in gswip_gphy_fw_list

Every iteration of for_each_available_child_of_node() decrements
the reference count of the previous node.
when breaking early from a for_each_available_child_of_node() loop,
we need to explicitly call of_node_put() on the gphy_fw_np.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0737e018a05e2aa352828c52bdeed3b02cff2930
  - https://git.kernel.org/stable/c/2e007ac6fa7c9c94ad84da075c5c504afad690a0
  - https://git.kernel.org/stable/c/32cd78c5610f02a929f63cac985e73692d05f33e
  - https://git.kernel.org/stable/c/54d6802c4d83fa8de7696cfec06f475d5fd92d27
  - https://git.kernel.org/stable/c/7c8df6fad43d9d5d77f281f794b2a93cd02fd1a9
  - https://git.kernel.org/stable/c/c2ae49a113a5344232f1ebb93bcf18bbd11e9c39

------------------------------------------------------------

CVE ID: CVE-2022-49347
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix bug_on in ext4_writepages

we got issue as follows:
EXT4-fs error (device loop0): ext4_mb_generate_buddy:1141: group 0, block bitmap and bg descriptor inconsistent: 25 vs 31513 free cls
------------[ cut here ]------------
kernel BUG at fs/ext4/inode.c:2708!
invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
CPU: 2 PID: 2147 Comm: rep Not tainted 5.18.0-rc2-next-20220413+ #155
RIP: 0010:ext4_writepages+0x1977/0x1c10
RSP: 0018:ffff88811d3e7880 EFLAGS: 00010246
RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88811c098000
RDX: 0000000000000000 RSI: ffff88811c098000 RDI: 0000000000000002
RBP: ffff888128140f50 R08: ffffffffb1ff6387 R09: 0000000000000000
R10: 0000000000000007 R11: ffffed10250281ea R12: 0000000000000001
R13: 00000000000000a4 R14: ffff88811d3e7bb8 R15: ffff888128141028
FS:  00007f443aed9740(0000) GS:ffff8883aef00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000020007200 CR3: 000000011c2a4000 CR4: 00000000000006e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 do_writepages+0x130/0x3a0
 filemap_fdatawrite_wbc+0x83/0xa0
 filemap_flush+0xab/0xe0
 ext4_alloc_da_blocks+0x51/0x120
 __ext4_ioctl+0x1534/0x3210
 __x64_sys_ioctl+0x12c/0x170
 do_syscall_64+0x3b/0x90

It may happen as follows:
1. write inline_data inode
vfs_write
  new_sync_write
    ext4_file_write_iter
      ext4_buffered_write_iter
        generic_perform_write
          ext4_da_write_begin
            ext4_da_write_inline_data_begin -> If inline data size too
            small will allocate block to write, then mapping will has
            dirty page
                ext4_da_convert_inline_data_to_extent ->clear EXT4_STATE_MAY_INLINE_DATA
2. fallocate
do_vfs_ioctl
  ioctl_preallocate
    vfs_fallocate
      ext4_fallocate
        ext4_convert_inline_data
          ext4_convert_inline_data_nolock
            ext4_map_blocks -> fail will goto restore data
            ext4_restore_inline_data
              ext4_create_inline_data
              ext4_write_inline_data
              ext4_set_inode_state -> set inode EXT4_STATE_MAY_INLINE_DATA
3. writepages
__ext4_ioctl
  ext4_alloc_da_blocks
    filemap_flush
      filemap_fdatawrite_wbc
        do_writepages
          ext4_writepages
            if (ext4_has_inline_data(inode))
              BUG_ON(ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))

The root cause of this issue is we destory inline data until call
ext4_writepages under delay allocation mode.  But there maybe already
convert from inline to extent.  To solve this issue, we call
filemap_flush first..
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/013f12bdedb96816aaa27ee04349f4433d361f52
  - https://git.kernel.org/stable/c/18a759f7f99f0b65a08ff5b7e745fc405a42bde4
  - https://git.kernel.org/stable/c/19918ec7717d87d5ab825884a46b26b21375d7ce
  - https://git.kernel.org/stable/c/1b061af037646c9cdb0afd8a8d2f1e1c06285866
  - https://git.kernel.org/stable/c/1cde35417edc0370fb0179a4e38b78a15350a8d0
  - https://git.kernel.org/stable/c/73fd5b19285197078ee8a2e651d75d5b094a4de9
  - https://git.kernel.org/stable/c/b2b78f5bf2d453dda3903955efee059260787a42
  - https://git.kernel.org/stable/c/de1732b5c1693ad489c5d254f124f67cb775f37d
  - https://git.kernel.org/stable/c/ef09ed5d37b84d18562b30cf7253e57062d0db05

------------------------------------------------------------

CVE ID: CVE-2022-49348
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: filter out EXT4_FC_REPLAY from on-disk superblock field s_state

The EXT4_FC_REPLAY bit in sbi->s_mount_state is used to indicate that
we are in the middle of replay the fast commit journal.  This was
actually a mistake, since the sbi->s_mount_info is initialized from
es->s_state.  Arguably s_mount_state is misleadingly named, but the
name is historical --- s_mount_state and s_state dates back to ext2.

What should have been used is the ext4_{set,clear,test}_mount_flag()
inline functions, which sets EXT4_MF_* bits in sbi->s_mount_flags.

The problem with using EXT4_FC_REPLAY is that a maliciously corrupted
superblock could result in EXT4_FC_REPLAY getting set in
s_mount_state.  This bypasses some sanity checks, and this can trigger
a BUG() in ext4_es_cache_extent().  As a easy-to-backport-fix, filter
out the EXT4_FC_REPLAY bit for now.  We should eventually transition
away from EXT4_FC_REPLAY to something like EXT4_MF_REPLAY.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/55b4dbb29054a05d839562f6d635ce05669b016d
  - https://git.kernel.org/stable/c/af2f1932743fb52ebcb008ad7ac500d9df0aa796
  - https://git.kernel.org/stable/c/b99fd73418350dea360da8311e87a6a7b0e15a4c
  - https://git.kernel.org/stable/c/c878bea3c9d724ddfa05a813f30de3d25a0ba83f
  - https://git.kernel.org/stable/c/cc5b09cb6dacd4b32640537929ab4ee8fb2b9e04

------------------------------------------------------------

CVE ID: CVE-2022-49349
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix use-after-free in ext4_rename_dir_prepare

We got issue as follows:
EXT4-fs (loop0): mounted filesystem without journal. Opts: ,errors=continue
ext4_get_first_dir_block: bh->b_data=0xffff88810bee6000 len=34478
ext4_get_first_dir_block: *parent_de=0xffff88810beee6ae bh->b_data=0xffff88810bee6000
ext4_rename_dir_prepare: [1] parent_de=0xffff88810beee6ae
==================================================================
BUG: KASAN: use-after-free in ext4_rename_dir_prepare+0x152/0x220
Read of size 4 at addr ffff88810beee6ae by task rep/1895

CPU: 13 PID: 1895 Comm: rep Not tainted 5.10.0+ #241
Call Trace:
 dump_stack+0xbe/0xf9
 print_address_description.constprop.0+0x1e/0x220
 kasan_report.cold+0x37/0x7f
 ext4_rename_dir_prepare+0x152/0x220
 ext4_rename+0xf44/0x1ad0
 ext4_rename2+0x11c/0x170
 vfs_rename+0xa84/0x1440
 do_renameat2+0x683/0x8f0
 __x64_sys_renameat+0x53/0x60
 do_syscall_64+0x33/0x40
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x7f45a6fc41c9
RSP: 002b:00007ffc5a470218 EFLAGS: 00000246 ORIG_RAX: 0000000000000108
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f45a6fc41c9
RDX: 0000000000000005 RSI: 0000000020000180 RDI: 0000000000000005
RBP: 00007ffc5a470240 R08: 00007ffc5a470160 R09: 0000000020000080
R10: 00000000200001c0 R11: 0000000000000246 R12: 0000000000400bb0
R13: 00007ffc5a470320 R14: 0000000000000000 R15: 0000000000000000

The buggy address belongs to the page:
page:00000000440015ce refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x10beee
flags: 0x200000000000000()
raw: 0200000000000000 ffffea00043ff4c8 ffffea0004325608 0000000000000000
raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 ffff88810beee580: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
 ffff88810beee600: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>ffff88810beee680: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                                  ^
 ffff88810beee700: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
 ffff88810beee780: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
==================================================================
Disabling lock debugging due to kernel taint
ext4_rename_dir_prepare: [2] parent_de->inode=3537895424
ext4_rename_dir_prepare: [3] dir=0xffff888124170140
ext4_rename_dir_prepare: [4] ino=2
ext4_rename_dir_prepare: ent->dir->i_ino=2 parent=-757071872

Reason is first directory entry which 'rec_len' is 34478, then will get illegal
parent entry. Now, we do not check directory entry after read directory block
in 'ext4_get_first_dir_block'.
To solve this issue, check directory entry in 'ext4_get_first_dir_block'.

[ Trigger an ext4_error() instead of just warning if the directory is
  missing a '.' or '..' entry.   Also make sure we return an error code
  if the file system is corrupted.  -TYT ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0be698ecbe4471fcad80e81ec6a05001421041b3
  - https://git.kernel.org/stable/c/0ff38b99fa075ddd246487a28cb9af049f4ceef1
  - https://git.kernel.org/stable/c/10801095224de0d0ab06ae60698680c1f883a3ae
  - https://git.kernel.org/stable/c/1a3a15bf6f9963d755270cbdb282863b84839195
  - https://git.kernel.org/stable/c/364380c00912bed9b5d99eb485018360b0ecf64f
  - https://git.kernel.org/stable/c/4a2bea60cf7ff957b3eda0b17750d483876a02fa
  - https://git.kernel.org/stable/c/97f802a652a749422dede32071d29a53cf4bd034
  - https://git.kernel.org/stable/c/dd887f83ea54aea5b780a84527e23ab95f777fed
  - https://git.kernel.org/stable/c/eaecf7ebfd5dd09038a80b14be46b844f54cfc5c

------------------------------------------------------------

CVE ID: CVE-2022-49350
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mdio: unexport __init-annotated mdio_bus_init()

EXPORT_SYMBOL and __init is a bad combination because the .init.text
section is freed up after the initialization. Hence, modules cannot
use symbols annotated __init. The access to a freed symbol may end up
with kernel panic.

modpost used to detect it, but it has been broken for a decade.

Recently, I fixed modpost so it started to warn it again, then this
showed up in linux-next builds.

There are two ways to fix it:

  - Remove __init
  - Remove EXPORT_SYMBOL

I chose the latter for this case because the only in-tree call-site,
drivers/net/phy/phy_device.c is never compiled as modular.
(CONFIG_PHYLIB is boolean)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/35b42dce619701f1300fb8498dae82c9bb1f0263
  - https://git.kernel.org/stable/c/5534bcd7c40299862237c4a8fd9c5031b3db1538
  - https://git.kernel.org/stable/c/59fa94cddf9eef8d8dae587373eed8b8f4eb11d7
  - https://git.kernel.org/stable/c/6a90a44d53428a3bf01bd80df9ba78b19959270c
  - https://git.kernel.org/stable/c/7759c3222815b945a94b212bc0c6cdec475cfec2
  - https://git.kernel.org/stable/c/ab64ec2c75683f30ccde9eaaf0761002f901aa12
  - https://git.kernel.org/stable/c/f2f0f8c18b60ca64ff50892ed899cf1c77864755
  - https://git.kernel.org/stable/c/f5c68137f1191ba3fcf6260ec71b30be2e2bf4c3

------------------------------------------------------------

CVE ID: CVE-2022-49351
Description: In the Linux kernel, the following vulnerability has been resolved:

net: altera: Fix refcount leak in altera_tse_mdio_create

Every iteration of for_each_child_of_node() decrements
the reference count of the previous node.
When break from a for_each_child_of_node() loop,
we need to explicitly call of_node_put() on the child node when
not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.15, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/11ec18b1d8d92b9df307d31950dcba0b3dd7283c
  - https://git.kernel.org/stable/c/1fd12298a0e0ca23478c715e672ee64c85670584
  - https://git.kernel.org/stable/c/4f850fe0a32c3f1e19b76996a3b1ca32637a14de
  - https://git.kernel.org/stable/c/5cd0e22fa11f4a21a8c09cc258f20b1474c95801
  - https://git.kernel.org/stable/c/803b217f1fb49a2dbb2123acdb45111b9c48b8be
  - https://git.kernel.org/stable/c/8174acbef87b8dd8bf3731eba2a5af1ac857e239
  - https://git.kernel.org/stable/c/96bf5ed057df2d157274d4e2079002f9a9404bb8
  - https://git.kernel.org/stable/c/a013fa884d8738ad8455aa1a843b8c9d80c6c833
  - https://git.kernel.org/stable/c/e31d9ba169860687dba19bdc8fccbfd34077f655

------------------------------------------------------------

CVE ID: CVE-2022-49352
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix warning in ext4_handle_inode_extension

We got issue as follows:
EXT4-fs error (device loop0) in ext4_reserve_inode_write:5741: Out of memory
EXT4-fs error (device loop0): ext4_setattr:5462: inode #13: comm syz-executor.0: mark_inode_dirty error
EXT4-fs error (device loop0) in ext4_setattr:5519: Out of memory
EXT4-fs error (device loop0): ext4_ind_map_blocks:595: inode #13: comm syz-executor.0: Can't allocate blocks for non-extent mapped inodes with bigalloc
------------[ cut here ]------------
WARNING: CPU: 1 PID: 4361 at fs/ext4/file.c:301 ext4_file_write_iter+0x11c9/0x1220
Modules linked in:
CPU: 1 PID: 4361 Comm: syz-executor.0 Not tainted 5.10.0+ #1
RIP: 0010:ext4_file_write_iter+0x11c9/0x1220
RSP: 0018:ffff924d80b27c00 EFLAGS: 00010282
RAX: ffffffff815a3379 RBX: 0000000000000000 RCX: 000000003b000000
RDX: ffff924d81601000 RSI: 00000000000009cc RDI: 00000000000009cd
RBP: 000000000000000d R08: ffffffffbc5a2c6b R09: 0000902e0e52a96f
R10: ffff902e2b7c1b40 R11: ffff902e2b7c1b40 R12: 000000000000000a
R13: 0000000000000001 R14: ffff902e0e52aa10 R15: ffffffffffffff8b
FS:  00007f81a7f65700(0000) GS:ffff902e3bc80000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: ffffffffff600400 CR3: 000000012db88001 CR4: 00000000003706e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 do_iter_readv_writev+0x2e5/0x360
 do_iter_write+0x112/0x4c0
 do_pwritev+0x1e5/0x390
 __x64_sys_pwritev2+0x7e/0xa0
 do_syscall_64+0x37/0x50
 entry_SYSCALL_64_after_hwframe+0x44/0xa9

Above issue may happen as follows:
Assume
inode.i_size=4096
EXT4_I(inode)->i_disksize=4096

step 1: set inode->i_isize = 8192
ext4_setattr
  if (attr->ia_size != inode->i_size)
    EXT4_I(inode)->i_disksize = attr->ia_size;
    rc = ext4_mark_inode_dirty
       ext4_reserve_inode_write
          ext4_get_inode_loc
            __ext4_get_inode_loc
              sb_getblk --> return -ENOMEM
   ...
   if (!error)  ->will not update i_size
     i_size_write(inode, attr->ia_size);
Now:
inode.i_size=4096
EXT4_I(inode)->i_disksize=8192

step 2: Direct write 4096 bytes
ext4_file_write_iter
 ext4_dio_write_iter
   iomap_dio_rw ->return error
 if (extend)
   ext4_handle_inode_extension
     WARN_ON_ONCE(i_size_read(inode) < EXT4_I(inode)->i_disksize);
->Then trigger warning.

To solve above issue, if mark inode dirty failed in ext4_setattr just
set 'EXT4_I(inode)->i_disksize' with old value.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0ab308d72af7548f21e4499d025c25887da0c26a
  - https://git.kernel.org/stable/c/1bcce88da60eccc946c0f4ed942b0f08cd565778
  - https://git.kernel.org/stable/c/adf490083ca52ebfb0b2fe64ff1ead00c0452dd7
  - https://git.kernel.org/stable/c/b81d2ff6885e38fc745eeaf9565775055778fc0b
  - https://git.kernel.org/stable/c/e383c2aa5f02ab571530dc5c5696479672478c25
  - https://git.kernel.org/stable/c/f4534c9fc94d22383f187b9409abb3f9df2e3db3

------------------------------------------------------------

CVE ID: CVE-2022-49353
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/papr_scm: don't requests stats with '0' sized stats buffer

Sachin reported [1] that on a POWER-10 lpar he is seeing a kernel panic being
reported with vPMEM when papr_scm probe is being called. The panic is of the
form below and is observed only with following option disabled(profile) for the
said LPAR 'Enable Performance Information Collection' in the HMC:

 Kernel attempted to write user page (1c) - exploit attempt? (uid: 0)
 BUG: Kernel NULL pointer dereference on write at 0x0000001c
 Faulting instruction address: 0xc008000001b90844
 Oops: Kernel access of bad area, sig: 11 [#1]
<snip>
 NIP [c008000001b90844] drc_pmem_query_stats+0x5c/0x270 [papr_scm]
 LR [c008000001b92794] papr_scm_probe+0x2ac/0x6ec [papr_scm]
 Call Trace:
       0xc00000000941bca0 (unreliable)
       papr_scm_probe+0x2ac/0x6ec [papr_scm]
       platform_probe+0x98/0x150
       really_probe+0xfc/0x510
       __driver_probe_device+0x17c/0x230
<snip>
 ---[ end trace 0000000000000000 ]---
 Kernel panic - not syncing: Fatal exception

On investigation looks like this panic was caused due to a 'stat_buffer' of
size==0 being provided to drc_pmem_query_stats() to fetch all performance
stats-ids of an NVDIMM. However drc_pmem_query_stats() shouldn't have been called
since the vPMEM NVDIMM doesn't support and performance stat-id's. This was caused
due to missing check for 'p->stat_buffer_len' at the beginning of
papr_scm_pmu_check_events() which indicates that the NVDIMM doesn't support
performance-stats.

Fix this by introducing the check for 'p->stat_buffer_len' at the beginning of
papr_scm_pmu_check_events().

[1] https://lore.kernel.org/all/6B3A522A-6A5F-4CC9-B268-0C63AA6E07D3@linux.ibm.com
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: 5.18.3, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07bf9431b1590d1cd7a8d62075d0b50b073f0495
  - https://git.kernel.org/stable/c/e1295aab2ebcda1c1a9ed342baedc080e5c393e5

------------------------------------------------------------

CVE ID: CVE-2022-49354
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: pata_octeon_cf: Fix refcount leak in octeon_cf_probe

of_find_device_by_node() takes reference, we should use put_device()
to release it when not need anymore.
Add missing put_device() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.8, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/10d6bdf532902be1d8aa5900b3c03c5671612aa2
  - https://git.kernel.org/stable/c/19cb3ece14547cb1ca2021798aaf49a3f82643d1
  - https://git.kernel.org/stable/c/7bd85c5ba1687daf54e3b6907673c3604b1e75cf
  - https://git.kernel.org/stable/c/888312dc297a8a103f6371ef668c7e04f57a7679
  - https://git.kernel.org/stable/c/8d8ad067b90f231b8fdb14acee673ca4012f6045
  - https://git.kernel.org/stable/c/a4d3e5f1d7d4f8b5e3834fec0f057a762c55806b
  - https://git.kernel.org/stable/c/c9782e1b21bee4b783a64b2a91e7e71406c21a21
  - https://git.kernel.org/stable/c/d5a1e7f33c88780b279835d63665d7e38ccb671f
  - https://git.kernel.org/stable/c/fb2cb409b504bb3a69e65a17f3120328c8e50219

------------------------------------------------------------

CVE ID: CVE-2022-49356
Description: In the Linux kernel, the following vulnerability has been resolved:

SUNRPC: Trap RDMA segment overflows

Prevent svc_rdma_build_writes() from walking off the end of a Write
chunk's segment array. Caught with KASAN.

The test that this fix replaces is invalid, and might have been left
over from an earlier prototype of the PCL work.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/659f7568e09593945c221bf20217a82ebdfe1328
  - https://git.kernel.org/stable/c/812c13521d4a72469c78ce06d8cdc8dc5b5557b5
  - https://git.kernel.org/stable/c/ea26bf5eca1459b5a7824997d7823409ce38214e
  - https://git.kernel.org/stable/c/f012e95b377c73c0283f009823c633104dedb337

------------------------------------------------------------

CVE ID: CVE-2022-49357
Description: In the Linux kernel, the following vulnerability has been resolved:

efi: Do not import certificates from UEFI Secure Boot for T2 Macs

On Apple T2 Macs, when Linux attempts to read the db and dbx efi variables
at early boot to load UEFI Secure Boot certificates, a page fault occurs
in Apple firmware code and EFI runtime services are disabled with the
following logs:

[Firmware Bug]: Page fault caused by firmware at PA: 0xffffb1edc0068000
WARNING: CPU: 3 PID: 104 at arch/x86/platform/efi/quirks.c:735 efi_crash_gracefully_on_page_fault+0x50/0xf0
(Removed some logs from here)
Call Trace:
 <TASK>
 page_fault_oops+0x4f/0x2c0
 ? search_bpf_extables+0x6b/0x80
 ? search_module_extables+0x50/0x80
 ? search_exception_tables+0x5b/0x60
 kernelmode_fixup_or_oops+0x9e/0x110
 __bad_area_nosemaphore+0x155/0x190
 bad_area_nosemaphore+0x16/0x20
 do_kern_addr_fault+0x8c/0xa0
 exc_page_fault+0xd8/0x180
 asm_exc_page_fault+0x1e/0x30
(Removed some logs from here)
 ? __efi_call+0x28/0x30
 ? switch_mm+0x20/0x30
 ? efi_call_rts+0x19a/0x8e0
 ? process_one_work+0x222/0x3f0
 ? worker_thread+0x4a/0x3d0
 ? kthread+0x17a/0x1a0
 ? process_one_work+0x3f0/0x3f0
 ? set_kthread_struct+0x40/0x40
 ? ret_from_fork+0x22/0x30
 </TASK>
---[ end trace 1f82023595a5927f ]---
efi: Froze efi_rts_wq and disabled EFI Runtime Services
integrity: Couldn't get size: 0x8000000000000015
integrity: MODSIGN: Couldn't get UEFI db list
efi: EFI Runtime Services are disabled!
integrity: Couldn't get size: 0x8000000000000015
integrity: Couldn't get UEFI dbx list
integrity: Couldn't get size: 0x8000000000000015
integrity: Couldn't get mokx list
integrity: Couldn't get size: 0x80000000

So we avoid reading these UEFI variables and thus prevent the crash.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/155ca952c7ca19aa32ecfb7373a32bbc2e1ec6eb
  - https://git.kernel.org/stable/c/1f7264f0510f519b4e4f575a8f0579ea65e7592e
  - https://git.kernel.org/stable/c/65237307f88f5200782ae7f243bdd385e37cde5d
  - https://git.kernel.org/stable/c/b1cda6dd2c44771f042d65f0d17bec322ef99a0a
  - https://git.kernel.org/stable/c/b34786b25d75f9c119696e6bdf3827f54ae3601b
  - https://git.kernel.org/stable/c/c072cab98bac11f6ef9db640fb51834d9552e2e6

------------------------------------------------------------

CVE ID: CVE-2022-49358
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: memleak flow rule from commit path

Abort path release flow rule object, however, commit path does not.
Update code to destroy these objects before releasing the transaction.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.3, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/330c0c6cd2150a2d7f47af16aa590078b0d2f736
  - https://git.kernel.org/stable/c/5b8d63489c3b701eb2a76f848ec94d8cbc9373b9
  - https://git.kernel.org/stable/c/80de9ea1f5b808a6601e91111fae601df2b26369
  - https://git.kernel.org/stable/c/9dd732e0bdf538b1b76dc7c157e2b5e560ff30d3
  - https://git.kernel.org/stable/c/ab9f34a30c23f656e76f4c5b83125a4e7b53c86e
  - https://git.kernel.org/stable/c/e33d9bd563e71f6c6528b96008d65524a459c4dc

------------------------------------------------------------

CVE ID: CVE-2022-49359
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/panfrost: Job should reference MMU not file_priv

For a while now it's been allowed for a MMU context to outlive it's
corresponding panfrost_priv, however the job structure still references
panfrost_priv to get hold of the MMU context. If panfrost_priv has been
freed this is a use-after-free which I've been able to trigger resulting
in a splat.

To fix this, drop the reference to panfrost_priv in the job structure
and add a direct reference to the MMU structure which is what's actually
needed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.67, Last Version (Excluding): 5.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13.19, Last Version (Excluding): 5.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14.6, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/472dd7ea5e19a1aeabf1711ddc756777e05ee7c2
  - https://git.kernel.org/stable/c/6e516faf04317db2c46cbec4e3b78b4653a5b109
  - https://git.kernel.org/stable/c/8c8e8cc91a6ffc79865108279a74fd57d9070a17

------------------------------------------------------------

CVE ID: CVE-2022-49360
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check on total_data_blocks

As Yanming reported in bugzilla:

https://bugzilla.kernel.org/show_bug.cgi?id=215916

The kernel message is shown below:

kernel BUG at fs/f2fs/segment.c:2560!
Call Trace:
 allocate_segment_by_default+0x228/0x440
 f2fs_allocate_data_block+0x13d1/0x31f0
 do_write_page+0x18d/0x710
 f2fs_outplace_write_data+0x151/0x250
 f2fs_do_write_data_page+0xef9/0x1980
 move_data_page+0x6af/0xbc0
 do_garbage_collect+0x312f/0x46f0
 f2fs_gc+0x6b0/0x3bc0
 f2fs_balance_fs+0x921/0x2260
 f2fs_write_single_data_page+0x16be/0x2370
 f2fs_write_cache_pages+0x428/0xd00
 f2fs_write_data_pages+0x96e/0xd50
 do_writepages+0x168/0x550
 __writeback_single_inode+0x9f/0x870
 writeback_sb_inodes+0x47d/0xb20
 __writeback_inodes_wb+0xb2/0x200
 wb_writeback+0x4bd/0x660
 wb_workfn+0x5f3/0xab0
 process_one_work+0x79f/0x13e0
 worker_thread+0x89/0xf60
 kthread+0x26a/0x300
 ret_from_fork+0x22/0x30
RIP: 0010:new_curseg+0xe8d/0x15f0

The root cause is: ckpt.valid_block_count is inconsistent with SIT table,
stat info indicates filesystem has free blocks, but SIT table indicates
filesystem has no free segment.

So that during garbage colloection, it triggers panic when LFS allocator
fails to find free segment.

This patch tries to fix this issue by checking consistency in between
ckpt.valid_block_count and block accounted from SIT.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/071b1269a3b3ad9cec16ed76a48015bfffd9aee8
  - https://git.kernel.org/stable/c/6b8beca0edd32075a769bfe4178ca00c0dcd22a9
  - https://git.kernel.org/stable/c/c9e4cd5b0ccd7168801d6a811919171b185c5cf8
  - https://git.kernel.org/stable/c/cc8c9df19971e59ebbe669ce710080e347dfec32
  - https://git.kernel.org/stable/c/ef221b738b26d8c9f7e7967f4586db2dd3bd5288

------------------------------------------------------------

CVE ID: CVE-2022-49361
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check for inline inode

Yanming reported a kernel bug in Bugzilla kernel [1], which can be
reproduced. The bug message is:

The kernel message is shown below:

kernel BUG at fs/inode.c:611!
Call Trace:
 evict+0x282/0x4e0
 __dentry_kill+0x2b2/0x4d0
 dput+0x2dd/0x720
 do_renameat2+0x596/0x970
 __x64_sys_rename+0x78/0x90
 do_syscall_64+0x3b/0x90

[1] https://bugzilla.kernel.org/show_bug.cgi?id=215895

The bug is due to fuzzed inode has both inline_data and encrypted flags.
During f2fs_evict_inode(), as the inode was deleted by rename(), it
will cause inline data conversion due to conflicting flags. The page
cache will be polluted and the panic will be triggered in clear_inode().

Try fixing the bug by doing more sanity checks for inline data inode in
sanity_check_inode().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11c1cd032df85df3c096a57a7f27d57819956e4a
  - https://git.kernel.org/stable/c/198fd9faa271dd54dca6fc8eb6873f42dfd3b4d8
  - https://git.kernel.org/stable/c/677a82b44ebf263d4f9a0cfbd576a6ade797a07b
  - https://git.kernel.org/stable/c/7cfe2d43becaf76e562b9617d2c2d9b445f86761
  - https://git.kernel.org/stable/c/efdefbe8b7564602ab446474788225a1f2a323b5

------------------------------------------------------------

CVE ID: CVE-2022-49362
Description: In the Linux kernel, the following vulnerability has been resolved:

NFSD: Fix potential use-after-free in nfsd_file_put()

nfsd_file_put_noref() can free @nf, so don't dereference @nf
immediately upon return from nfsd_file_put_noref().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/261eabe19cb28e4a8587a4442d257b543d7c2d57
  - https://git.kernel.org/stable/c/333dcc94ebf53f79f3dc0e7a7c16700bc7ff7e57
  - https://git.kernel.org/stable/c/ada1757b259f353cade47037ee0a0249b4cddad3
  - https://git.kernel.org/stable/c/b6c71c66b0ad8f2b59d9bc08c7a5079b110bec01

------------------------------------------------------------

CVE ID: CVE-2022-49363
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check on block address in f2fs_do_zero_range()

As Yanming reported in bugzilla:

https://bugzilla.kernel.org/show_bug.cgi?id=215894

I have encountered a bug in F2FS file system in kernel v5.17.

I have uploaded the system call sequence as case.c, and a fuzzed image can
be found in google net disk

The kernel should enable CONFIG_KASAN=y and CONFIG_KASAN_INLINE=y. You can
reproduce the bug by running the following commands:

kernel BUG at fs/f2fs/segment.c:2291!
Call Trace:
 f2fs_invalidate_blocks+0x193/0x2d0
 f2fs_fallocate+0x2593/0x4a70
 vfs_fallocate+0x2a5/0xac0
 ksys_fallocate+0x35/0x70
 __x64_sys_fallocate+0x8e/0xf0
 do_syscall_64+0x3b/0x90
 entry_SYSCALL_64_after_hwframe+0x44/0xae

The root cause is, after image was fuzzed, block mapping info in inode
will be inconsistent with SIT table, so in f2fs_fallocate(), it will cause
panic when updating SIT with invalid blkaddr.

Let's fix the issue by adding sanity check on block address before updating
SIT table with it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/25f8236213a91efdf708b9d77e9e51b6fc3e141c
  - https://git.kernel.org/stable/c/470493be19a5730ed432e3ac0f29a2ee7fc6c557
  - https://git.kernel.org/stable/c/7361c9f2bd6a8f0cbb41cdea9aff04765ff23f67
  - https://git.kernel.org/stable/c/805b48b234a2803cb7daec7f158af12f0fbaefac
  - https://git.kernel.org/stable/c/a34d7b49894b0533222188a52e2958750f830efd
  - https://git.kernel.org/stable/c/f2e1c38b5ac64eb1a16a89c52fb419409d12c25b

------------------------------------------------------------

CVE ID: CVE-2022-49364
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to clear dirty inode in f2fs_evict_inode()

As Yanming reported in bugzilla:

https://bugzilla.kernel.org/show_bug.cgi?id=215904

The kernel message is shown below:

kernel BUG at fs/f2fs/inode.c:825!
Call Trace:
 evict+0x282/0x4e0
 __dentry_kill+0x2b2/0x4d0
 shrink_dentry_list+0x17c/0x4f0
 shrink_dcache_parent+0x143/0x1e0
 do_one_tree+0x9/0x30
 shrink_dcache_for_umount+0x51/0x120
 generic_shutdown_super+0x5c/0x3a0
 kill_block_super+0x90/0xd0
 kill_f2fs_super+0x225/0x310
 deactivate_locked_super+0x78/0xc0
 cleanup_mnt+0x2b7/0x480
 task_work_run+0xc8/0x150
 exit_to_user_mode_prepare+0x14a/0x150
 syscall_exit_to_user_mode+0x1d/0x40
 do_syscall_64+0x48/0x90

The root cause is: inode node and dnode node share the same nid,
so during f2fs_evict_inode(), dnode node truncation will invalidate
its NAT entry, so when truncating inode node, it fails due to
invalid NAT entry, result in inode is still marked as dirty, fix
this issue by clearing dirty for inode and setting SBI_NEED_FSCK
flag in filesystem.

output from dump.f2fs:
[print_node_info: 354] Node ID [0xf:15] is inode
i_nid[0]                      		[0x       f : 15]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/03c9373b15fa1c245ec99b2b5e7ba209eae4ef42
  - https://git.kernel.org/stable/c/54c116615c99e22aa08aa950757ed726e2f60821
  - https://git.kernel.org/stable/c/c469953917b319d415fd621b9e5d0ea5203565cd
  - https://git.kernel.org/stable/c/c9196d21359be8c7ee231029d13682273925fd00
  - https://git.kernel.org/stable/c/ccd58045beb997544b94558a9156be4742628491
  - https://git.kernel.org/stable/c/f2db71053dc0409fae785096ad19cce4c8a95af7

------------------------------------------------------------

CVE ID: CVE-2022-49365
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Off by one in dm_dmub_outbox1_low_irq()

The > ARRAY_SIZE() should be >= ARRAY_SIZE() to prevent an out of bounds
access.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/607c5cd1a08e196d9f2bd3b25a8083ed27ad7ceb
  - https://git.kernel.org/stable/c/a35faec3db0e13aac8ea720bc1a3503081dd5a3d
  - https://git.kernel.org/stable/c/b0808b7a04157b3f56e919f27023fec37a075fad
  - https://git.kernel.org/stable/c/ec9ec3bc08b18c5b1b2feafd306ea7c348013898

------------------------------------------------------------

CVE ID: CVE-2022-49366
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix reference count leak in smb_check_perm_dacl()

The issue happens in a specific path in smb_check_perm_dacl(). When
"id" and "uid" have the same value, the function simply jumps out of
the loop without decrementing the reference count of the object
"posix_acls", which is increased by get_acl() earlier. This may
result in memory leaks.

Fix it by decreasing the reference count of "posix_acls" before
jumping to label "check_access_bits".
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/248d71b440aef829f5cc5f6545ca113ef5062900
  - https://git.kernel.org/stable/c/9758a6653c27867d810de02b4e5697163dda9883
  - https://git.kernel.org/stable/c/cf824b95c12a1abacadbc2d069931963221a3414
  - https://git.kernel.org/stable/c/d21a580dafc69aa04f46e6099616146a536b0724

------------------------------------------------------------

CVE ID: CVE-2022-49367
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: mv88e6xxx: Fix refcount leak in mv88e6xxx_mdios_register

of_get_child_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.

mv88e6xxx_mdio_register() pass the device node to of_mdiobus_register().
We don't need the device node after it.

Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.11, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/02ded5a173619b11728b8bf75a3fd995a2c1ff28
  - https://git.kernel.org/stable/c/42658e47f1abbbe592007d3ba303de466114d0bb
  - https://git.kernel.org/stable/c/86c3c5f8e4bd1325e24f6fba9017cade29933377
  - https://git.kernel.org/stable/c/8a1a1255152da4fb934290e7ababc66f24985520
  - https://git.kernel.org/stable/c/a101793994c0a14c70bb4e44c7fda597eeebba0a
  - https://git.kernel.org/stable/c/c1df9cb756e5a9ba1841648c44ee5d92306b9c65
  - https://git.kernel.org/stable/c/dc1cf8c6f9793546696fded437a5b4c84944c48b
  - https://git.kernel.org/stable/c/e0d763d0c7665c7897e4f5a0847ab0c82543345f

------------------------------------------------------------

CVE ID: CVE-2022-49368
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: mtk_eth_soc: out of bounds read in mtk_hwlro_get_fdir_entry()

The "fsp->location" variable comes from user via ethtool_get_rxnfc().
Check that it is valid to prevent an out of bounds read.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/0b238f75b65ed4462ef4cdfa718cac0ac7fce3b8
  - https://git.kernel.org/stable/c/2bd1faedb74dc2a2be3972abcd4239b75a3e7b00
  - https://git.kernel.org/stable/c/4cde554c70d7397cfa2e4116bacb4accdfb6fd48
  - https://git.kernel.org/stable/c/5ba81f82607ead85fe36f50869fc4f5661359ab8
  - https://git.kernel.org/stable/c/657e7174603f0aab2cdedc64ac81edffd2a87afe
  - https://git.kernel.org/stable/c/71ae30662ec610b92644d13f79c78f76f17873b3
  - https://git.kernel.org/stable/c/b24ca1cf846273361d5bd73a35de95a486a54b6d
  - https://git.kernel.org/stable/c/b4f0e57ea0d867aacffad7999527e48bd4ea9293
  - https://git.kernel.org/stable/c/e7e7104e2d5ddf3806a28695670f21bef471f1e1

------------------------------------------------------------

CVE ID: CVE-2022-49369
Description: In the Linux kernel, the following vulnerability has been resolved:

amt: fix possible memory leak in amt_rcv()

If an amt receives packets and it finds socket.
If it can't find a socket, it should free a received skb.
But it doesn't.
So, a memory leak would possibly occur.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/1a1a0e80e005cbdc2c250fc858e1d8570f4e4acb
  - https://git.kernel.org/stable/c/4b8032d39b276c52db57ff834c300405b9da2691
  - https://git.kernel.org/stable/c/60d9c020c69977e138727b3577bc6a0458325e9c

------------------------------------------------------------

CVE ID: CVE-2022-49370
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: dmi-sysfs: Fix memory leak in dmi_sysfs_register_handle

kobject_init_and_add() takes reference even when it fails.
According to the doc of kobject_init_and_add()

   If this function returns an error, kobject_put() must be called to
   properly clean up the memory associated with the object.

Fix this issue by calling kobject_put().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.39, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/3ba359ebe914ac3f8c6c832b28007c14c39d3766
  - https://git.kernel.org/stable/c/660ba678f9998aca6db74f2dd912fa5124f0fa31
  - https://git.kernel.org/stable/c/985706bd3bbeffc8737bc05965ca8d24837bc7db
  - https://git.kernel.org/stable/c/a724634b2a49f6ff0177a9e19a5a92fc1545e1b7
  - https://git.kernel.org/stable/c/a9bfb37d6ba7c376b0d53337a4c5f5ff324bd725
  - https://git.kernel.org/stable/c/c66cc3c62870a27ea8f060a7e4c1ad8d26dd3f0d
  - https://git.kernel.org/stable/c/ec752973aa721ee281d5441e497364637c626c7b
  - https://git.kernel.org/stable/c/ed38d04342dfbe9e5aca745c8b5eb4188a74f0ef
  - https://git.kernel.org/stable/c/fdffa4ad8f6bf1ece877edfb807f2b2c729d8578

------------------------------------------------------------

CVE ID: CVE-2022-49371
Description: In the Linux kernel, the following vulnerability has been resolved:

driver core: fix deadlock in __device_attach

In __device_attach function, The lock holding logic is as follows:
...
__device_attach
device_lock(dev)      // get lock dev
  async_schedule_dev(__device_attach_async_helper, dev); // func
    async_schedule_node
      async_schedule_node_domain(func)
        entry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);
	/* when fail or work limit, sync to execute func, but
	   __device_attach_async_helper will get lock dev as
	   well, which will lead to A-A deadlock.  */
	if (!entry || atomic_read(&entry_count) > MAX_WORK) {
	  func;
	else
	  queue_work_node(node, system_unbound_wq, &entry->work)
  device_unlock(dev)

As shown above, when it is allowed to do async probes, because of
out of memory or work limit, async work is not allowed, to do
sync execute instead. it will lead to A-A deadlock because of
__device_attach_async_helper getting lock dev.

To fix the deadlock, move the async_schedule_dev outside device_lock,
as we can see, in async_schedule_node_domain, the parameter of
queue_work_node is system_unbound_wq, so it can accept concurrent
operations. which will also not change the code logic, and will
not lead to deadlock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/34fdd9b7def9d2fcb71bb7b0bc4848dd7313767e
  - https://git.kernel.org/stable/c/36ee9ffca8ef56c302f2855c4a5fccf61c0c1ada
  - https://git.kernel.org/stable/c/593b595332bd2d65e1a5c1ae7897996c157f5468
  - https://git.kernel.org/stable/c/b232b02bf3c205b13a26dcec08e53baddd8e59ed
  - https://git.kernel.org/stable/c/d53a227bfcd5160ce1b61d9954901968a20651e7
  - https://git.kernel.org/stable/c/df6de52b80aa3b46f5ac804412355ffe2e1df93e

------------------------------------------------------------

CVE ID: CVE-2022-49372
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: tcp_rtx_synack() can be called from process context

Laurent reported the enclosed report [1]

This bug triggers with following coditions:

0) Kernel built with CONFIG_DEBUG_PREEMPT=y

1) A new passive FastOpen TCP socket is created.
   This FO socket waits for an ACK coming from client to be a complete
   ESTABLISHED one.
2) A socket operation on this socket goes through lock_sock()
   release_sock() dance.
3) While the socket is owned by the user in step 2),
   a retransmit of the SYN is received and stored in socket backlog.
4) At release_sock() time, the socket backlog is processed while
   in process context.
5) A SYNACK packet is cooked in response of the SYN retransmit.
6) -> tcp_rtx_synack() is called in process context.

Before blamed commit, tcp_rtx_synack() was always called from BH handler,
from a timer handler.

Fix this by using TCP_INC_STATS() & NET_INC_STATS()
which do not assume caller is in non preemptible context.

[1]
BUG: using __this_cpu_add() in preemptible [00000000] code: epollpep/2180
caller is tcp_rtx_synack.part.0+0x36/0xc0
CPU: 10 PID: 2180 Comm: epollpep Tainted: G           OE     5.16.0-0.bpo.4-amd64 #1  Debian 5.16.12-1~bpo11+1
Hardware name: Supermicro SYS-5039MC-H8TRF/X11SCD-F, BIOS 1.7 11/23/2021
Call Trace:
 <TASK>
 dump_stack_lvl+0x48/0x5e
 check_preemption_disabled+0xde/0xe0
 tcp_rtx_synack.part.0+0x36/0xc0
 tcp_rtx_synack+0x8d/0xa0
 ? kmem_cache_alloc+0x2e0/0x3e0
 ? apparmor_file_alloc_security+0x3b/0x1f0
 inet_rtx_syn_ack+0x16/0x30
 tcp_check_req+0x367/0x610
 tcp_rcv_state_process+0x91/0xf60
 ? get_nohz_timer_target+0x18/0x1a0
 ? lock_timer_base+0x61/0x80
 ? preempt_count_add+0x68/0xa0
 tcp_v4_do_rcv+0xbd/0x270
 __release_sock+0x6d/0xb0
 release_sock+0x2b/0x90
 sock_setsockopt+0x138/0x1140
 ? __sys_getsockname+0x7e/0xc0
 ? aa_sk_perm+0x3e/0x1a0
 __sys_setsockopt+0x198/0x1e0
 __x64_sys_setsockopt+0x21/0x30
 do_syscall_64+0x38/0xc0
 entry_SYSCALL_64_after_hwframe+0x44/0xae
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a0f7f84148445c9f02f226928803a870139d820
  - https://git.kernel.org/stable/c/0a375c822497ed6ad6b5da0792a12a6f1af10c0b
  - https://git.kernel.org/stable/c/3db889f883e65bbd3b1401279bfc1e9ed255c481
  - https://git.kernel.org/stable/c/58bd38cbc961fd799842b7be8c5222310f04b908
  - https://git.kernel.org/stable/c/88cd232146207ff1d41dededed5e77c0d4438113
  - https://git.kernel.org/stable/c/bdc28a8fb43cc476e33b11519235adb816ce00e8
  - https://git.kernel.org/stable/c/c348b0f8d035fc4bdc040796889beec7218bd1b8
  - https://git.kernel.org/stable/c/d05c2fdf8e10528bb6751bd95243e862d5402a9b
  - https://git.kernel.org/stable/c/d8e1bc6029acac796293310aacef7b7336f35b6a

------------------------------------------------------------

CVE ID: CVE-2022-49373
Description: In the Linux kernel, the following vulnerability has been resolved:

watchdog: ts4800_wdt: Fix refcount leak in ts4800_wdt_probe

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add  missing of_node_put() in some error paths.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.5, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/5b110d940417942bc87d9e4bea6d4f24e05ed483
  - https://git.kernel.org/stable/c/5d24df3d690809952528e7a19a43d84bc5b99d44
  - https://git.kernel.org/stable/c/7a4afd8a003d6abf1f5d159c2bb67e6b7cbde253
  - https://git.kernel.org/stable/c/910b1cdf6c50ae8fb222e46657d04fb181577017
  - https://git.kernel.org/stable/c/91fa5aa53f68b85e779164b3127c7e23cad5c457
  - https://git.kernel.org/stable/c/f067b5286edfd83d2d3903e8578b561599d62539

------------------------------------------------------------

CVE ID: CVE-2022-49374
Description: In the Linux kernel, the following vulnerability has been resolved:

tipc: check attribute length for bearer name

syzbot reported uninit-value:
=====================================================
BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:644 [inline]
BUG: KMSAN: uninit-value in string+0x4f9/0x6f0 lib/vsprintf.c:725
 string_nocheck lib/vsprintf.c:644 [inline]
 string+0x4f9/0x6f0 lib/vsprintf.c:725
 vsnprintf+0x2222/0x3650 lib/vsprintf.c:2806
 vprintk_store+0x537/0x2150 kernel/printk/printk.c:2158
 vprintk_emit+0x28b/0xab0 kernel/printk/printk.c:2256
 vprintk_default+0x86/0xa0 kernel/printk/printk.c:2283
 vprintk+0x15f/0x180 kernel/printk/printk_safe.c:50
 _printk+0x18d/0x1cf kernel/printk/printk.c:2293
 tipc_enable_bearer net/tipc/bearer.c:371 [inline]
 __tipc_nl_bearer_enable+0x2022/0x22a0 net/tipc/bearer.c:1033
 tipc_nl_bearer_enable+0x6c/0xb0 net/tipc/bearer.c:1042
 genl_family_rcv_msg_doit net/netlink/genetlink.c:731 [inline]

- Do sanity check the attribute length for TIPC_NLA_BEARER_NAME.
- Do not use 'illegal name' in printing message.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.17, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/292be63c382ce20673ee61dff1ee9ed4a3dcaae7
  - https://git.kernel.org/stable/c/3af15272cde28fe5c8489174b8624e232c1775ec
  - https://git.kernel.org/stable/c/7f36f798f89bf32c0164049cb0e3fd1af613d0bb
  - https://git.kernel.org/stable/c/8b91d0dfc839e67708c905648cd0e7507a2263e5
  - https://git.kernel.org/stable/c/92a930fcf4250fe961f6238b99af0bc405799f39
  - https://git.kernel.org/stable/c/b8fac8e321044a9ac50f7185b4e9d91a7745e4b0
  - https://git.kernel.org/stable/c/f07670871f4d19e613740eebe210e7e9ea535973

------------------------------------------------------------

CVE ID: CVE-2022-49375
Description: In the Linux kernel, the following vulnerability has been resolved:

rtc: mt6397: check return value after calling platform_get_resource()

It will cause null-ptr-deref if platform_get_resource() returns NULL,
we need check the return value.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/3867f0bbb94773d41e789257abec0d14f37da217
  - https://git.kernel.org/stable/c/58a729c55ce3a432eb827fdaa24c7909cd3b0a6b
  - https://git.kernel.org/stable/c/6ecd4d5c28408df36a1a6f0b1973f633c949ac1f
  - https://git.kernel.org/stable/c/79fa3f5758d8712df0678df98161f948fc4370e5
  - https://git.kernel.org/stable/c/82bfea344e8f7e9a0e0b1bf9af27552baa756620
  - https://git.kernel.org/stable/c/865051de2d9eaa50630e055b73921ceaf3c4a7fc
  - https://git.kernel.org/stable/c/d3b43eb505bffb8e4cdf6800c15660c001553fe6
  - https://git.kernel.org/stable/c/d77f28c1bc9d3043a52069fe42e4a26fbf961ebd
  - https://git.kernel.org/stable/c/da38e86d6cf6dd3bc65c602d998f357145aa1a0b

------------------------------------------------------------

CVE ID: CVE-2022-49376
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: sd: Fix potential NULL pointer dereference

If sd_probe() sees an early error before sdkp->device is initialized,
sd_zbc_release_disk() is called. This causes a NULL pointer dereference
when sd_is_zoned() is called inside that function. Avoid this by removing
the call to sd_zbc_release_disk() in sd_probe() error path.

This change is safe and does not result in zone information memory leakage
because the zone information for a zoned disk is allocated only when
sd_revalidate_disk() is called, at which point sdkp->disk_dev is fully set,
resulting in sd_disk_release() being called when needed to cleanup a disk
zone information using sd_zbc_release_disk().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/05fbde3a77a4f1d62e4c4428f384288c1f1a0be5
  - https://git.kernel.org/stable/c/0fcb0b131cc90c8f523a293d84c58d0c7273c96f
  - https://git.kernel.org/stable/c/3733439593ad12f7b54ae35c273ea6f15d692de3
  - https://git.kernel.org/stable/c/78f8e96df06e2d04d82d4071c299b59d28744f47
  - https://git.kernel.org/stable/c/c1f0187025905e9981000d44a92e159468b561a8

------------------------------------------------------------

CVE ID: CVE-2022-49377
Description: In the Linux kernel, the following vulnerability has been resolved:

blk-mq: don't touch ->tagset in blk_mq_get_sq_hctx

blk_mq_run_hw_queues() could be run when there isn't queued request and
after queue is cleaned up, at that time tagset is freed, because tagset
lifetime is covered by driver, and often freed after blk_cleanup_queue()
returns.

So don't touch ->tagset for figuring out current default hctx by the mapping
built in request queue, so use-after-free on tagset can be avoided. Meantime
this way should be fast than retrieving mapping from tagset.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/460aa288c5cd0544dcf933a2f0ad0e8c6d2d35ff
  - https://git.kernel.org/stable/c/5d05426e2d5fd7df8afc866b78c36b37b00188b7
  - https://git.kernel.org/stable/c/70fdd922c7bf8949f8df109cf2635dff64c90392
  - https://git.kernel.org/stable/c/b140bac470b4f707cda59c7266214246238661df

------------------------------------------------------------

CVE ID: CVE-2022-49378
Description: In the Linux kernel, the following vulnerability has been resolved:

sfc: fix considering that all channels have TX queues

Normally, all channels have RX and TX queues, but this is not true if
modparam efx_separate_tx_channels=1 is used. In that cases, some
channels only have RX queues and others only TX queues (or more
preciselly, they have them allocated, but not initialized).

Fix efx_channel_has_tx_queues to return the correct value for this case
too.

Messages shown at probe time before the fix:
 sfc 0000:03:00.0 ens6f0np0: MC command 0x82 inlen 544 failed rc=-22 (raw=0) arg=0
 ------------[ cut here ]------------
 netdevice: ens6f0np0: failed to initialise TXQ -1
 WARNING: CPU: 1 PID: 626 at drivers/net/ethernet/sfc/ef10.c:2393 efx_ef10_tx_init+0x201/0x300 [sfc]
 [...] stripped
 RIP: 0010:efx_ef10_tx_init+0x201/0x300 [sfc]
 [...] stripped
 Call Trace:
  efx_init_tx_queue+0xaa/0xf0 [sfc]
  efx_start_channels+0x49/0x120 [sfc]
  efx_start_all+0x1f8/0x430 [sfc]
  efx_net_open+0x5a/0xe0 [sfc]
  __dev_open+0xd0/0x190
  __dev_change_flags+0x1b3/0x220
  dev_change_flags+0x21/0x60
 [...] stripped

Messages shown at remove time before the fix:
 sfc 0000:03:00.0 ens6f0np0: failed to flush 10 queues
 sfc 0000:03:00.0 ens6f0np0: failed to flush queues
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2e102b53f8a778f872dc137f4c7ac548705817aa
  - https://git.kernel.org/stable/c/5567d69b95b9c07e1c56f15cf0301251d12e5f97
  - https://git.kernel.org/stable/c/8f81a4113e1e574d2cbde4f2cd599380a9189c0f
  - https://git.kernel.org/stable/c/913d45f02d346ce41c4aad057eaf53a8ed449dc3
  - https://git.kernel.org/stable/c/e7e8d5e25dc762b70f9c88ec6b7d451d0816eead

------------------------------------------------------------

CVE ID: CVE-2022-49379
Description: In the Linux kernel, the following vulnerability has been resolved:

driver core: Fix wait_for_device_probe() & deferred_probe_timeout interaction

Mounting NFS rootfs was timing out when deferred_probe_timeout was
non-zero [1].  This was because ip_auto_config() initcall times out
waiting for the network interfaces to show up when
deferred_probe_timeout was non-zero. While ip_auto_config() calls
wait_for_device_probe() to make sure any currently running deferred
probe work or asynchronous probe finishes, that wasn't sufficient to
account for devices being deferred until deferred_probe_timeout.

Commit 35a672363ab3 ("driver core: Ensure wait_for_device_probe() waits
until the deferred_probe_timeout fires") tried to fix that by making
sure wait_for_device_probe() waits for deferred_probe_timeout to expire
before returning.

However, if wait_for_device_probe() is called from the kernel_init()
context:

- Before deferred_probe_initcall() [2], it causes the boot process to
  hang due to a deadlock.

- After deferred_probe_initcall() [3], it blocks kernel_init() from
  continuing till deferred_probe_timeout expires and beats the point of
  deferred_probe_timeout that's trying to wait for userspace to load
  modules.

Neither of this is good. So revert the changes to
wait_for_device_probe().

[1] - https://lore.kernel.org/lkml/TYAPR01MB45443DF63B9EF29054F7C41FD8C60@TYAPR01MB4544.jpnprd01.prod.outlook.com/
[2] - https://lore.kernel.org/lkml/YowHNo4sBjr9ijZr@dev-arch.thelio-3990X/
[3] - https://lore.kernel.org/lkml/Yo3WvGnNk3LvLb7R@linutronix.de/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/29357883a89193863f3cc6a2c5e0b42ceb022761
  - https://git.kernel.org/stable/c/4ad6af07efcca85369c21e4897b3020cff2c170b
  - https://git.kernel.org/stable/c/528229474e1cbb1b3451cb713d94aecb5f6ee264
  - https://git.kernel.org/stable/c/5ee76c256e928455212ab759c51d198fedbe7523
  - https://git.kernel.org/stable/c/71cbce75031aed26c72c2dc8a83111d181685f1b

------------------------------------------------------------

CVE ID: CVE-2022-49380
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to avoid f2fs_bug_on() in dec_valid_node_count()

As Yanming reported in bugzilla:

https://bugzilla.kernel.org/show_bug.cgi?id=215897

I have encountered a bug in F2FS file system in kernel v5.17.

The kernel should enable CONFIG_KASAN=y and CONFIG_KASAN_INLINE=y. You can
reproduce the bug by running the following commands:

The kernel message is shown below:

kernel BUG at fs/f2fs/f2fs.h:2511!
Call Trace:
 f2fs_remove_inode_page+0x2a2/0x830
 f2fs_evict_inode+0x9b7/0x1510
 evict+0x282/0x4e0
 do_unlinkat+0x33a/0x540
 __x64_sys_unlinkat+0x8e/0xd0
 do_syscall_64+0x3b/0x90
 entry_SYSCALL_64_after_hwframe+0x44/0xae

The root cause is: .total_valid_block_count or .total_valid_node_count
could fuzzed to zero, then once dec_valid_node_count() was called, it
will cause BUG_ON(), this patch fixes to print warning info and set
SBI_NEED_FSCK into CP instead of panic.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2766ddaf45b69252bb8fe526b5b6e56904a9ae7a
  - https://git.kernel.org/stable/c/4d17e6fe9293d57081ffdc11e1cf313e25e8fd9e
  - https://git.kernel.org/stable/c/89d9a48d0cd30429463ea4e37ca83be6773ed5eb
  - https://git.kernel.org/stable/c/bce859358d3d5940aa858e40ceee70ee6e76130e
  - https://git.kernel.org/stable/c/ccffa99ae6a1f44797b57444c6a80382a42928fe
  - https://git.kernel.org/stable/c/f8b3c3fcf33105bc1ee7788e3b51b0a1ae42ae53

------------------------------------------------------------

CVE ID: CVE-2022-49381
Description: In the Linux kernel, the following vulnerability has been resolved:

jffs2: fix memory leak in jffs2_do_fill_super

If jffs2_iget() or d_make_root() in jffs2_do_fill_super() returns
an error, we can observe the following kmemleak report:

--------------------------------------------
unreferenced object 0xffff888105a65340 (size 64):
  comm "mount", pid 710, jiffies 4302851558 (age 58.239s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<ffffffff859c45e5>] kmem_cache_alloc_trace+0x475/0x8a0
    [<ffffffff86160146>] jffs2_sum_init+0x96/0x1a0
    [<ffffffff86140e25>] jffs2_do_mount_fs+0x745/0x2120
    [<ffffffff86149fec>] jffs2_do_fill_super+0x35c/0x810
    [<ffffffff8614aae9>] jffs2_fill_super+0x2b9/0x3b0
    [...]
unreferenced object 0xffff8881bd7f0000 (size 65536):
  comm "mount", pid 710, jiffies 4302851558 (age 58.239s)
  hex dump (first 32 bytes):
    bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb  ................
    bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb  ................
  backtrace:
    [<ffffffff858579ba>] kmalloc_order+0xda/0x110
    [<ffffffff85857a11>] kmalloc_order_trace+0x21/0x130
    [<ffffffff859c2ed1>] __kmalloc+0x711/0x8a0
    [<ffffffff86160189>] jffs2_sum_init+0xd9/0x1a0
    [<ffffffff86140e25>] jffs2_do_mount_fs+0x745/0x2120
    [<ffffffff86149fec>] jffs2_do_fill_super+0x35c/0x810
    [<ffffffff8614aae9>] jffs2_fill_super+0x2b9/0x3b0
    [...]
--------------------------------------------

This is because the resources allocated in jffs2_sum_init() are not
released. Call jffs2_sum_exit() to release these resources to solve
the problem.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.15, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/28048a4cf3813b7cf5cc8cce629dfdc7951cb1c2
  - https://git.kernel.org/stable/c/3252d327f977b14663a10967f3b0930d6c325687
  - https://git.kernel.org/stable/c/4ba7bbeab8009faf3a726e565d98816593ddd5b0
  - https://git.kernel.org/stable/c/4da8763a3d2b684c773b72ed80fad40bc264bc40
  - https://git.kernel.org/stable/c/69295267c481545f636b69ff341b8db75aa136b9
  - https://git.kernel.org/stable/c/c14adb1cf70a984ed081c67e9d27bc3caad9537c
  - https://git.kernel.org/stable/c/cf9db013e167bc8fc2ecd7a13ed97a37df0c9dab
  - https://git.kernel.org/stable/c/d3a4fff1e7e408c32649030daa7c2c42a7e19a95
  - https://git.kernel.org/stable/c/ecc53e58596542791e82eff00702f8af7a313f70

------------------------------------------------------------

CVE ID: CVE-2022-49382
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: rockchip: Fix refcount leak in rockchip_grf_init

of_find_matching_node_and_match returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.11, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/042571fe1d171773655ad706715ecc865913d9a4
  - https://git.kernel.org/stable/c/28133325526b92921f3269fdf97a20d90b92b217
  - https://git.kernel.org/stable/c/5b3e990f85eb034faa461e691e719e8ce9e2a3c8
  - https://git.kernel.org/stable/c/69a30b2ed620c2206cbbd1e9c112e4fc584e02bd
  - https://git.kernel.org/stable/c/8f64e84924604bb969ee1fbc4b8d7d09b9214889
  - https://git.kernel.org/stable/c/9b59588d8be91c96bfb0371e912ceb4f16315dbf
  - https://git.kernel.org/stable/c/aab25b669cb9fd3698c2631be4435f4fe92d9e59
  - https://git.kernel.org/stable/c/d5422f323858cad3ac3581075f9a3a5e0d41c0d8

------------------------------------------------------------

CVE ID: CVE-2022-49383
Description: In the Linux kernel, the following vulnerability has been resolved:

watchdog: rzg2l_wdt: Fix 'BUG: Invalid wait context'

This patch fixes the issue 'BUG: Invalid wait context' during restart()
callback by using clk_prepare_enable() instead of pm_runtime_get_sync()
for turning on the clocks during restart.

This issue is noticed when testing with renesas_defconfig.

[   42.213802] reboot: Restarting system
[   42.217860]
[   42.219364] =============================
[   42.223368] [ BUG: Invalid wait context ]
[   42.227372] 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522 Not tainted
[   42.234153] -----------------------------
[   42.238155] systemd-shutdow/1 is trying to lock:
[   42.242766] ffff00000a650828 (&genpd->mlock){+.+.}-{3:3}, at: genpd_lock_mtx+0x14/0x20
[   42.250709] other info that might help us debug this:
[   42.255753] context-{4:4}
[   42.258368] 2 locks held by systemd-shutdow/1:
[   42.262806]  #0: ffff80000944e1c8 (system_transition_mutex#2){+.+.}-{3:3}, at: __do_sys_reboot+0xd0/0x250
[   42.272388]  #1: ffff8000094c4e40 (rcu_read_lock){....}-{1:2}, at: atomic_notifier_call_chain+0x0/0x150
[   42.281795] stack backtrace:
[   42.284672] CPU: 0 PID: 1 Comm: systemd-shutdow Not tainted 5.17.0-rc5-arm64-renesas-00002-g10393723e35e #522
[   42.294577] Hardware name: Renesas SMARC EVK based on r9a07g044c2 (DT)
[   42.301096] Call trace:
[   42.303538]  dump_backtrace+0xcc/0xd8
[   42.307203]  show_stack+0x14/0x30
[   42.310517]  dump_stack_lvl+0x88/0xb0
[   42.314180]  dump_stack+0x14/0x2c
[   42.317492]  __lock_acquire+0x1b24/0x1b50
[   42.321502]  lock_acquire+0x120/0x3a8
[   42.325162]  __mutex_lock+0x84/0x8f8
[   42.328737]  mutex_lock_nested+0x30/0x58
[   42.332658]  genpd_lock_mtx+0x14/0x20
[   42.336319]  genpd_runtime_resume+0xc4/0x228
[   42.340587]  __rpm_callback+0x44/0x170
[   42.344337]  rpm_callback+0x64/0x70
[   42.347824]  rpm_resume+0x4e0/0x6b8
[   42.351310]  __pm_runtime_resume+0x50/0x78
[   42.355404]  rzg2l_wdt_restart+0x28/0x68
[   42.359329]  watchdog_restart_notifier+0x1c/0x30
[   42.363943]  atomic_notifier_call_chain+0x94/0x150
[   42.368732]  do_kernel_restart+0x24/0x30
[   42.372652]  machine_restart+0x44/0x70
[   42.376399]  kernel_restart+0x3c/0x60
[   42.380058]  __do_sys_reboot+0x228/0x250
[   42.383977]  __arm64_sys_reboot+0x20/0x28
[   42.387983]  invoke_syscall+0x40/0xf8
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a635239cd5484d8f2e702713ccc49ec82aa7594
  - https://git.kernel.org/stable/c/6505541e5298cea2b79da68ee626f583f8e18784
  - https://git.kernel.org/stable/c/e4cf89596c1f1e33309556699f910ced4abbaf44

------------------------------------------------------------

CVE ID: CVE-2022-49384
Description: In the Linux kernel, the following vulnerability has been resolved:

md: fix double free of io_acct_set bioset

Now io_acct_set is alloc and free in personality. Remove the codes that
free io_acct_set in md_free and md_stop.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.17, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16.3, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/36a2fc44c574a59ee3b5e2cb327182f227b2b07e
  - https://git.kernel.org/stable/c/42b805af102471f53e3c7867b8c2b502ea4eef7e
  - https://git.kernel.org/stable/c/ea7d7bd90079d96f9c86bdaf0b106e0cd2a70661
  - https://git.kernel.org/stable/c/f99d5b5dc8a42c807b5f1176b925aa45d61962ab

------------------------------------------------------------

CVE ID: CVE-2022-49385
Description: In the Linux kernel, the following vulnerability has been resolved:

driver: base: fix UAF when driver_attach failed

When driver_attach(drv); failed, the driver_private will be freed.
But it has been added to the bus, which caused a UAF.

To fix it, we need to delete it from the bus when failed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.9, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/310862e574001a97ad02272bac0fd13f75f42a27
  - https://git.kernel.org/stable/c/5389101257828d1913d713d9a40acbe14f5961df
  - https://git.kernel.org/stable/c/5d709f58c743166fe1c6914b9de0ae8868600d9b
  - https://git.kernel.org/stable/c/823f24f2e329babd0330200d0b74882516fe57f4
  - https://git.kernel.org/stable/c/c059665c84feab46b7173d3a1bf36c2fb7f9df86
  - https://git.kernel.org/stable/c/cdf1a683a01583bca4b618dd16223cbd6e462e21

------------------------------------------------------------

CVE ID: CVE-2022-49386
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw-nuss: Fix some refcount leaks

of_get_child_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
am65_cpsw_init_cpts() and am65_cpsw_nuss_probe() don't release
the refcount in error case.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/2e44f21c384503562713b7d3b673c40bed20af3d
  - https://git.kernel.org/stable/c/5dd89d2fc438457811cbbec07999ce0d80051ff5
  - https://git.kernel.org/stable/c/78aca10a16f001c9f49f1cc4dadfee8d444bb173
  - https://git.kernel.org/stable/c/a4b7ef3b159805ba6be061d0cd2403d84b9b0063
  - https://git.kernel.org/stable/c/f7ba2cc57f404d2d9f26fb85bd3833d35a477829

------------------------------------------------------------

CVE ID: CVE-2022-49387
Description: In the Linux kernel, the following vulnerability has been resolved:

watchdog: rzg2l_wdt: Fix 32bit overflow issue

The value of timer_cycle_us can be 0 due to 32bit overflow.
For eg:- If we assign the counter value "0xfff" for computing
maxval.

This patch fixes this issue by appending ULL to 1024, so that
it is promoted to 64bit.

This patch also fixes the warning message, 'watchdog: Invalid min and
max timeout values, resetting to 0!'.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/b95a47667d34e76c2c9013f8e3b1e5039a5a0b76
  - https://git.kernel.org/stable/c/e07b9fa0dc32b492de85528caaf9f0c605d8424f
  - https://git.kernel.org/stable/c/ea2949df22a533cdf75e4583c00b1ce94cd5a83b

------------------------------------------------------------

CVE ID: CVE-2022-49388
Description: In the Linux kernel, the following vulnerability has been resolved:

ubi: ubi_create_volume: Fix use-after-free when volume creation failed

There is an use-after-free problem for 'eba_tbl' in ubi_create_volume()'s
error handling path:

  ubi_eba_replace_table(vol, eba_tbl)
    vol->eba_tbl = tbl
out_mapping:
  ubi_eba_destroy_table(eba_tbl)   // Free 'eba_tbl'
out_unlock:
  put_device(&vol->dev)
    vol_release
      kfree(tbl->entries)	  // UAF

Fix it by removing redundant 'eba_tbl' releasing.
Fetch a reproducer in [Link].
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/1174ab8ba36a48025b68b5ff1085000b1e510217
  - https://git.kernel.org/stable/c/25ff1e3a1351c0d936dd1ac2f9e58231ea1510c9
  - https://git.kernel.org/stable/c/5ff2514e4fb55dcf3d88294686040ca73ea0c1a2
  - https://git.kernel.org/stable/c/6d8d3f68cbecfd31925796f0fb668eb21ab06734
  - https://git.kernel.org/stable/c/8302620aeb940f386817321d272b12411ae7d39f
  - https://git.kernel.org/stable/c/8c03a1c21d72210f81cb369cc528e3fde4b45411
  - https://git.kernel.org/stable/c/abb67043060f2bf4c03d7c3debb9ae980e2b6db3
  - https://git.kernel.org/stable/c/e27ecf325e51abd06aaefba57a6322a46fa4178b

------------------------------------------------------------

CVE ID: CVE-2022-49389
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: usbip: fix a refcount leak in stub_probe()

usb_get_dev() is called in stub_device_alloc(). When stub_probe() fails
after that, usb_put_dev() needs to be called to release the reference.

Fix this by moving usb_put_dev() to sdev_free error path handling.

Find this by code review.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16.58, Last Version (Excluding): 3.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18.110, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.122
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/11c65408bd0ba1d9cd1307caa38169292de9cdfb
  - https://git.kernel.org/stable/c/247d3809e45a34d9e1a3a2bb7012e31ed8b46031
  - https://git.kernel.org/stable/c/2f0ae93ec33c8456cdfbf7876b80403a6318ebce
  - https://git.kernel.org/stable/c/51422046be504515eb5a591adf0f424b62f46804
  - https://git.kernel.org/stable/c/6bafee2f18af5e5ac125e42960bc65496d0e56a0
  - https://git.kernel.org/stable/c/8afb048800919d0ab10c57983940eba956339f21
  - https://git.kernel.org/stable/c/9ec4cbf1cc55d126759051acfe328d489c5d6e60
  - https://git.kernel.org/stable/c/bcbb795a9e78180d74c6ab21518da87e803dfdce
  - https://git.kernel.org/stable/c/f20d2d3b3364ce6525c050a8b6b4c54c8c19674d

------------------------------------------------------------

CVE ID: CVE-2022-49390
Description: In the Linux kernel, the following vulnerability has been resolved:

macsec: fix UAF bug for real_dev

Create a new macsec device but not get reference to real_dev. That can
not ensure that real_dev is freed after macsec. That will trigger the
UAF bug for real_dev as following:

==================================================================
BUG: KASAN: use-after-free in macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662
Call Trace:
 ...
 macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662
 dev_get_iflink+0x73/0xe0 net/core/dev.c:637
 default_operstate net/core/link_watch.c:42 [inline]
 rfc2863_policy+0x233/0x2d0 net/core/link_watch.c:54
 linkwatch_do_dev+0x2a/0x150 net/core/link_watch.c:161

Allocated by task 22209:
 ...
 alloc_netdev_mqs+0x98/0x1100 net/core/dev.c:10549
 rtnl_create_link+0x9d7/0xc00 net/core/rtnetlink.c:3235
 veth_newlink+0x20e/0xa90 drivers/net/veth.c:1748

Freed by task 8:
 ...
 kfree+0xd6/0x4d0 mm/slub.c:4552
 kvfree+0x42/0x50 mm/util.c:615
 device_release+0x9f/0x240 drivers/base/core.c:2229
 kobject_cleanup lib/kobject.c:673 [inline]
 kobject_release lib/kobject.c:704 [inline]
 kref_put include/linux/kref.h:65 [inline]
 kobject_put+0x1c8/0x540 lib/kobject.c:721
 netdev_run_todo+0x72e/0x10b0 net/core/dev.c:10327

After commit faab39f63c1f ("net: allow out-of-order netdev unregistration")
and commit e5f80fcf869a ("ipv6: give an IPv6 dev to blackhole_netdev"), we
can add dev_hold_track() in macsec_dev_init() and dev_put_track() in
macsec_free_netdev() to fix the problem.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.154, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.84, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.3.11, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/196a888ca6571deb344468e1d7138e3273206335
  - https://git.kernel.org/stable/c/78933cbc143b82d02330e00900d2fd08f2682f4e
  - https://git.kernel.org/stable/c/d130282179aa6051449ac8f8df1115769998a665

------------------------------------------------------------

CVE ID: CVE-2022-49391
Description: In the Linux kernel, the following vulnerability has been resolved:

remoteproc: mtk_scp: Fix a potential double free

'scp->rproc' is allocated using devm_rproc_alloc(), so there is no need
to free it explicitly in the remove function.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/adc02700236613b344a947a897fc2741d52a43b9
  - https://git.kernel.org/stable/c/eac3e5b1c12f85732e60f5f8b985444d273866bb

------------------------------------------------------------

CVE ID: CVE-2022-49392
Description: In the Linux kernel, the following vulnerability has been resolved:

serial: 8250_aspeed_vuart: Fix potential NULL dereference in aspeed_vuart_probe

platform_get_resource() may fail and return NULL, so we should
better check it's return value to avoid a NULL pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.47
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.4
References:
  - https://git.kernel.org/stable/c/0e0fd55719fa081de6f9e5d9e6cef48efb04d34a
  - https://git.kernel.org/stable/c/90a6b6fc52bfdcfe9698454bf5bea26112abbcd1
  - https://git.kernel.org/stable/c/923d34ce069e8e51a4d003caa6b66a8cd6ecd0ed
  - https://git.kernel.org/stable/c/d5f1275f101e0e8a172d300d897f5a12e87e3485

------------------------------------------------------------

CVE ID: CVE-2022-49393
Description: In the Linux kernel, the following vulnerability has been resolved:

misc: fastrpc: fix list iterator in fastrpc_req_mem_unmap_impl

This is another instance of incorrect use of list iterator and
checking it for NULL.

The list iterator value 'map' will *always* be set and non-NULL
by list_for_each_entry(), so it is incorrect to assume that the
iterator value will be NULL if the list is empty (in this case, the
check 'if (!map) {' will always be false and never exit as expected).

To fix the bug, use a new variable 'iter' as the list iterator,
while use the original variable 'map' as a dedicated pointer to
point to the found element.

Without this patch, Kernel crashes with below trace:

Unable to handle kernel access to user memory outside uaccess routines
 at virtual address 0000ffff7fb03750
...
Call trace:
 fastrpc_map_create+0x70/0x290 [fastrpc]
 fastrpc_req_mem_map+0xf0/0x2dc [fastrpc]
 fastrpc_device_ioctl+0x138/0xc60 [fastrpc]
 __arm64_sys_ioctl+0xa8/0xec
 invoke_syscall+0x48/0x114
 el0_svc_common.constprop.0+0xd4/0xfc
 do_el0_svc+0x28/0x90
 el0_svc+0x3c/0x130
 el0t_64_sync_handler+0xa4/0x130
 el0t_64_sync+0x18c/0x190
Code: 14000016 f94000a5 eb05029f 54000260 (b94018a6)
---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d12905aad462383f4e7a5fdb024d2b7ae2d10cf
  - https://git.kernel.org/stable/c/c5c07c5958cf0c9af6e76813e6de15d42ee49822

------------------------------------------------------------

CVE ID: CVE-2022-49394
Description: In the Linux kernel, the following vulnerability has been resolved:

blk-iolatency: Fix inflight count imbalances and IO hangs on offline

iolatency needs to track the number of inflight IOs per cgroup. As this
tracking can be expensive, it is disabled when no cgroup has iolatency
configured for the device. To ensure that the inflight counters stay
balanced, iolatency_set_limit() freezes the request_queue while manipulating
the enabled counter, which ensures that no IO is in flight and thus all
counters are zero.

Unfortunately, iolatency_set_limit() isn't the only place where the enabled
counter is manipulated. iolatency_pd_offline() can also dec the counter and
trigger disabling. As this disabling happens without freezing the q, this
can easily happen while some IOs are in flight and thus leak the counts.

This can be easily demonstrated by turning on iolatency on an one empty
cgroup while IOs are in flight in other cgroups and then removing the
cgroup. Note that iolatency shouldn't have been enabled elsewhere in the
system to ensure that removing the cgroup disables iolatency for the whole
device.

The following keeps flipping on and off iolatency on sda:

  echo +io > /sys/fs/cgroup/cgroup.subtree_control
  while true; do
      mkdir -p /sys/fs/cgroup/test
      echo '8:0 target=100000' > /sys/fs/cgroup/test/io.latency
      sleep 1
      rmdir /sys/fs/cgroup/test
      sleep 1
  done

and there's concurrent fio generating direct rand reads:

  fio --name test --filename=/dev/sda --direct=1 --rw=randread \
      --runtime=600 --time_based --iodepth=256 --numjobs=4 --bs=4k

while monitoring with the following drgn script:

  while True:
    for css in css_for_each_descendant_pre(prog['blkcg_root'].css.address_of_()):
        for pos in hlist_for_each(container_of(css, 'struct blkcg', 'css').blkg_list):
            blkg = container_of(pos, 'struct blkcg_gq', 'blkcg_node')
            pd = blkg.pd[prog['blkcg_policy_iolatency'].plid]
            if pd.value_() == 0:
                continue
            iolat = container_of(pd, 'struct iolatency_grp', 'pd')
            inflight = iolat.rq_wait.inflight.counter.value_()
            if inflight:
                print(f'inflight={inflight} {disk_name(blkg.q.disk).decode("utf-8")} '
                      f'{cgroup_path(css.cgroup).decode("utf-8")}')
    time.sleep(1)

The monitoring output looks like the following:

  inflight=1 sda /user.slice
  inflight=1 sda /user.slice
  ...
  inflight=14 sda /user.slice
  inflight=13 sda /user.slice
  inflight=17 sda /user.slice
  inflight=15 sda /user.slice
  inflight=18 sda /user.slice
  inflight=17 sda /user.slice
  inflight=20 sda /user.slice
  inflight=19 sda /user.slice <- fio stopped, inflight stuck at 19
  inflight=19 sda /user.slice
  inflight=19 sda /user.slice

If a cgroup with stuck inflight ends up getting throttled, the throttled IOs
will never get issued as there's no completion event to wake it up leading
to an indefinite hang.

This patch fixes the bug by unifying enable handling into a work item which
is automatically kicked off from iolatency_set_min_lat_nsec() which is
called from both iolatency_set_limit() and iolatency_pd_offline() paths.
Punting to a work item is necessary as iolatency_pd_offline() is called
under spinlocks while freezing a request_queue requires a sleepable context.

This also simplifies the code reducing LOC sans the comments and avoids the
unnecessary freezes which were happening whenever a cgroup's latency target
is newly set or cleared.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/515d077ee3085ae343b6bea7fd031f9906645f38
  - https://git.kernel.org/stable/c/5b0ff3ebbef791341695b718f8d2870869cf1d01
  - https://git.kernel.org/stable/c/77692c02e1517c54f2fd0535f41aa4286ac9f140
  - https://git.kernel.org/stable/c/8a177a36da6c54c98b8685d4f914cb3637d53c0d
  - https://git.kernel.org/stable/c/968f7a239c590454ffba79c126fbe0e963a0ba78
  - https://git.kernel.org/stable/c/a30acbb5dfb7bcc813ad6a18ca31011ac44e5547
  - https://git.kernel.org/stable/c/d19fa8f252000d141f9199ca32959c50314e1f05

------------------------------------------------------------

CVE ID: CVE-2022-49395
Description: In the Linux kernel, the following vulnerability has been resolved:

um: Fix out-of-bounds read in LDT setup

syscall_stub_data() expects the data_count parameter to be the number of
longs, not bytes.

 ==================================================================
 BUG: KASAN: stack-out-of-bounds in syscall_stub_data+0x70/0xe0
 Read of size 128 at addr 000000006411f6f0 by task swapper/1

 CPU: 0 PID: 1 Comm: swapper Not tainted 5.18.0+ #18
 Call Trace:
  show_stack.cold+0x166/0x2a7
  __dump_stack+0x3a/0x43
  dump_stack_lvl+0x1f/0x27
  print_report.cold+0xdb/0xf81
  kasan_report+0x119/0x1f0
  kasan_check_range+0x3a3/0x440
  memcpy+0x52/0x140
  syscall_stub_data+0x70/0xe0
  write_ldt_entry+0xac/0x190
  init_new_ldt+0x515/0x960
  init_new_context+0x2c4/0x4d0
  mm_init.constprop.0+0x5ed/0x760
  mm_alloc+0x118/0x170
  0x60033f48
  do_one_initcall+0x1d7/0x860
  0x60003e7b
  kernel_init+0x6e/0x3d4
  new_thread_handler+0x1e7/0x2c0

 The buggy address belongs to stack of task swapper/1
  and is located at offset 64 in frame:
  init_new_ldt+0x0/0x960

 This frame has 2 objects:
  [32, 40) 'addr'
  [64, 80) 'desc'
 ==================================================================
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.15, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/10995a382271254bd276627ec74136da4a23c4a6
  - https://git.kernel.org/stable/c/24ca648bf5f72ed8878cf09b5d4431935779681e
  - https://git.kernel.org/stable/c/2a4a62a14be1947fa945c5c11ebf67326381a568
  - https://git.kernel.org/stable/c/3549ab4b962cf619e8c55484a0d870a34b3f845f
  - https://git.kernel.org/stable/c/668ca34a428d6ffc0f99a1a6a9b661a288d4183b
  - https://git.kernel.org/stable/c/91e5ba2af2d729d5126aefd5aa3eadc69b8426e5
  - https://git.kernel.org/stable/c/9caad70819aef3431abaf73ba5163b55b161aba0
  - https://git.kernel.org/stable/c/cf0dabc37446c5ee538ae7b4c467ab0e53fa5463
  - https://git.kernel.org/stable/c/ef1dc929a1e5fa1b2d842256db9fb8710d3be910

------------------------------------------------------------

CVE ID: CVE-2022-49396
Description: In the Linux kernel, the following vulnerability has been resolved:

phy: qcom-qmp: fix reset-controller leak on probe errors

Make sure to release the lane reset controller in case of a late probe
error (e.g. probe deferral).

Note that due to the reset controller being defined in devicetree in
"lane" child nodes, devm_reset_control_get_exclusive() cannot be used
directly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2156dc390402043ba5982489c6625adcb0b0975c
  - https://git.kernel.org/stable/c/4d2900f20edfe541f75756a00deeb2ffe7c66bc1
  - https://git.kernel.org/stable/c/7ac21b24af859c097eb4034e93430056068f8f31
  - https://git.kernel.org/stable/c/8c03eb0c8982677b4e17174073a011788891304d
  - https://git.kernel.org/stable/c/a39d9eccb333b8c07c43ebea1c6dfda122378a0f
  - https://git.kernel.org/stable/c/b7b5fbcaac5355e2e695dc0c08a0fcf248250388
  - https://git.kernel.org/stable/c/ba173a6f8d8dffed64bb13ab23081bdddfb464f0
  - https://git.kernel.org/stable/c/feb05b10b3ed3ae21b851520a0d0b71685439517

------------------------------------------------------------

CVE ID: CVE-2022-49397
Description: In the Linux kernel, the following vulnerability has been resolved:

phy: qcom-qmp: fix struct clk leak on probe errors

Make sure to release the pipe clock reference in case of a late probe
error (e.g. probe deferral).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1668ad103679306ba2ef37f758d704e58a3ef1a0
  - https://git.kernel.org/stable/c/621a4bcfb7aa031e7760d7b156bad7a45df58387
  - https://git.kernel.org/stable/c/6f3673c8d8eff0c4ab5a5ee0d3ca9717d85419b4
  - https://git.kernel.org/stable/c/ad9b0fad02f9b3a06ad5ac7df11f244e316a6254
  - https://git.kernel.org/stable/c/b246695636a861a09f0e2cde92bb2dd8f114f024
  - https://git.kernel.org/stable/c/b999d48b0869b8599de532ff6081575a7ab5358a
  - https://git.kernel.org/stable/c/f0a4bc38a12f5a0cc5ad68670d9480e91e6a94df
  - https://git.kernel.org/stable/c/f8d23895a41243c6a8dbf392e531fff9497bb023

------------------------------------------------------------

CVE ID: CVE-2022-49398
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: dwc3: gadget: Replace list_for_each_entry_safe() if using giveback

The list_for_each_entry_safe() macro saves the current item (n) and
the item after (n+1), so that n can be safely removed without
corrupting the list.  However, when traversing the list and removing
items using gadget giveback, the DWC3 lock is briefly released,
allowing other routines to execute.  There is a situation where, while
items are being removed from the cancelled_list using
dwc3_gadget_ep_cleanup_cancelled_requests(), the pullup disable
routine is running in parallel (due to UDC unbind).  As the cleanup
routine removes n, and the pullup disable removes n+1, once the
cleanup retakes the DWC3 lock, it references a request who was already
removed/handled.  With list debug enabled, this leads to a panic.
Ensure all instances of the macro are replaced where gadget giveback
is used.

Example call stack:

Thread#1:
__dwc3_gadget_ep_set_halt() - CLEAR HALT
  -> dwc3_gadget_ep_cleanup_cancelled_requests()
    ->list_for_each_entry_safe()
    ->dwc3_gadget_giveback(n)
      ->dwc3_gadget_del_and_unmap_request()- n deleted[cancelled_list]
      ->spin_unlock
      ->Thread#2 executes
      ...
    ->dwc3_gadget_giveback(n+1)
      ->Already removed!

Thread#2:
dwc3_gadget_pullup()
  ->waiting for dwc3 spin_lock
  ...
  ->Thread#1 released lock
  ->dwc3_stop_active_transfers()
    ->dwc3_remove_requests()
      ->fetches n+1 item from cancelled_list (n removed by Thread#1)
      ->dwc3_gadget_giveback()
        ->dwc3_gadget_del_and_unmap_request()- n+1 deleted[cancelled_list]
        ->spin_unlock
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c6e5dc3b639c96e6839a8d1b8e951923fdfd34a
  - https://git.kernel.org/stable/c/2424307cdf421ac72075a1384eae4e4199ab6457
  - https://git.kernel.org/stable/c/26a7e6832afe9d9a991cfd9015177f083cf959cc
  - https://git.kernel.org/stable/c/bf594d1d0c1d7b895954018043536ffd327844f9

------------------------------------------------------------

CVE ID: CVE-2022-49399
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: goldfish: Use tty_port_destroy() to destroy port

In goldfish_tty_probe(), the port initialized through tty_port_init()
should be destroyed in error paths.In goldfish_tty_remove(), qtty->port
also should be destroyed or else might leak resources.

Fix the above by calling tty_port_destroy().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/241fcb79dd1df276d80b19f5f6acc9eaaaa63309
  - https://git.kernel.org/stable/c/326192b99c903a2193d820c30ed936cc2402382c
  - https://git.kernel.org/stable/c/45f6ce70abfb7ccf9d787781cbc4c03294a775a1
  - https://git.kernel.org/stable/c/4639d1b992de8f37d66f698056875c274efcd45f
  - https://git.kernel.org/stable/c/507b05063d1b7a1fcb9f7d7c47586fc4f3508f98
  - https://git.kernel.org/stable/c/9ae3d073f7db5578ae1907544f0c15947e9678e6
  - https://git.kernel.org/stable/c/da64f419d7f78272bfe40dde1262602d4ff6b32c
  - https://git.kernel.org/stable/c/ee6c33b29e624f515202a31bf6ef0437f26a1867

------------------------------------------------------------

CVE ID: CVE-2022-49400
Description: In the Linux kernel, the following vulnerability has been resolved:

md: Don't set mddev private to NULL in raid0 pers->free

In normal stop process, it does like this:
   do_md_stop
      |
   __md_stop (pers->free(); mddev->private=NULL)
      |
   md_free (free mddev)
__md_stop sets mddev->private to NULL after pers->free. The raid device
will be stopped and mddev memory is free. But in reshape, it doesn't
free the mddev and mddev will still be used in new raid.

In reshape, it first sets mddev->private to new_pers and then runs
old_pers->free(). Now raid0 sets mddev->private to NULL in raid0_free.
The new raid can't work anymore. It will panic when dereference
mddev->private because of NULL pointer dereference.

It can panic like this:
[63010.814972] kernel BUG at drivers/md/raid10.c:928!
[63010.819778] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
[63010.825011] CPU: 3 PID: 44437 Comm: md0_resync Kdump: loaded Not tainted 5.14.0-86.el9.x86_64 #1
[63010.833789] Hardware name: Dell Inc. PowerEdge R6415/07YXFK, BIOS 1.15.0 09/11/2020
[63010.841440] RIP: 0010:raise_barrier+0x161/0x170 [raid10]
[63010.865508] RSP: 0018:ffffc312408bbc10 EFLAGS: 00010246
[63010.870734] RAX: 0000000000000000 RBX: ffffa00bf7d39800 RCX: 0000000000000000
[63010.877866] RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffa00bf7d39800
[63010.884999] RBP: 0000000000000000 R08: fffffa4945e74400 R09: 0000000000000000
[63010.892132] R10: ffffa00eed02f798 R11: 0000000000000000 R12: ffffa00bbc435200
[63010.899266] R13: ffffa00bf7d39800 R14: 0000000000000400 R15: 0000000000000003
[63010.906399] FS:  0000000000000000(0000) GS:ffffa00eed000000(0000) knlGS:0000000000000000
[63010.914485] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[63010.920229] CR2: 00007f5cfbe99828 CR3: 0000000105efe000 CR4: 00000000003506e0
[63010.927363] Call Trace:
[63010.929822]  ? bio_reset+0xe/0x40
[63010.933144]  ? raid10_alloc_init_r10buf+0x60/0xa0 [raid10]
[63010.938629]  raid10_sync_request+0x756/0x1610 [raid10]
[63010.943770]  md_do_sync.cold+0x3e4/0x94c
[63010.947698]  md_thread+0xab/0x160
[63010.951024]  ? md_write_inc+0x50/0x50
[63010.954688]  kthread+0x149/0x170
[63010.957923]  ? set_kthread_struct+0x40/0x40
[63010.962107]  ret_from_fork+0x22/0x30

Removing the code that sets mddev->private to NULL in raid0 can fix
problem.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.17, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16.3, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0f2571ad7a30ff6b33cde142439f9378669f8b4f
  - https://git.kernel.org/stable/c/7da3454a65f8a56e65dfb44fa0ccac08cbc2f5a1
  - https://git.kernel.org/stable/c/b7a51df785031cc49caf1c59766ca89cfa97b54b
  - https://git.kernel.org/stable/c/f63fd1e0e0fc158023cc67ea6a07e278019061ba

------------------------------------------------------------

CVE ID: CVE-2022-49401
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/page_owner: use strscpy() instead of strlcpy()

current->comm[] is not a string (no guarantee for a zero byte in it).

strlcpy(s1, s2, l) is calling strlen(s2), potentially
causing out-of-bound access, as reported by syzbot:

detected buffer overflow in __fortify_strlen
------------[ cut here ]------------
kernel BUG at lib/string_helpers.c:980!
invalid opcode: 0000 [#1] PREEMPT SMP KASAN
CPU: 0 PID: 4087 Comm: dhcpcd-run-hooks Not tainted 5.18.0-rc3-syzkaller-01537-g20b87e7c29df #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:fortify_panic+0x18/0x1a lib/string_helpers.c:980
Code: 8c e8 c5 ba e1 fa e9 23 0f bf fa e8 0b 5d 8c f8 eb db 55 48 89 fd e8 e0 49 40 f8 48 89 ee 48 c7 c7 80 f5 26 8a e8 99 09 f1 ff <0f> 0b e8 ca 49 40 f8 48 8b 54 24 18 4c 89 f1 48 c7 c7 00 00 27 8a
RSP: 0018:ffffc900000074a8 EFLAGS: 00010286

RAX: 000000000000002c RBX: ffff88801226b728 RCX: 0000000000000000
RDX: ffff8880198e0000 RSI: ffffffff81600458 RDI: fffff52000000e87
RBP: ffffffff89da2aa0 R08: 000000000000002c R09: 0000000000000000
R10: ffffffff815fae2e R11: 0000000000000000 R12: ffff88801226b700
R13: ffff8880198e0830 R14: 0000000000000000 R15: 0000000000000000
FS:  0000000000000000(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f5876ad6ff8 CR3: 000000001a48c000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600
Call Trace:
 <IRQ>
 __fortify_strlen include/linux/fortify-string.h:128 [inline]
 strlcpy include/linux/fortify-string.h:143 [inline]
 __set_page_owner_handle+0x2b1/0x3e0 mm/page_owner.c:171
 __set_page_owner+0x3e/0x50 mm/page_owner.c:190
 prep_new_page mm/page_alloc.c:2441 [inline]
 get_page_from_freelist+0xba2/0x3e00 mm/page_alloc.c:4182
 __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5408
 alloc_pages+0x1aa/0x310 mm/mempolicy.c:2272
 alloc_slab_page mm/slub.c:1799 [inline]
 allocate_slab+0x26c/0x3c0 mm/slub.c:1944
 new_slab mm/slub.c:2004 [inline]
 ___slab_alloc+0x8df/0xf20 mm/slub.c:3005
 __slab_alloc.constprop.0+0x4d/0xa0 mm/slub.c:3092
 slab_alloc_node mm/slub.c:3183 [inline]
 slab_alloc mm/slub.c:3225 [inline]
 __kmem_cache_alloc_lru mm/slub.c:3232 [inline]
 kmem_cache_alloc+0x360/0x3b0 mm/slub.c:3242
 dst_alloc+0x146/0x1f0 net/core/dst.c:92
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5cd9900a1ac8b0a4ff3cd97d4d77b7711be435bf
  - https://git.kernel.org/stable/c/cd8c1fd8cdd14158f2d8bea2d1bfe8015dccfa3a

------------------------------------------------------------

CVE ID: CVE-2022-49402
Description: In the Linux kernel, the following vulnerability has been resolved:

ftrace: Clean up hash direct_functions on register failures

We see the following GPF when register_ftrace_direct fails:

[ ] general protection fault, probably for non-canonical address \
  0x200000000000010: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI
[...]
[ ] RIP: 0010:ftrace_find_rec_direct+0x53/0x70
[ ] Code: 48 c1 e0 03 48 03 42 08 48 8b 10 31 c0 48 85 d2 74 [...]
[ ] RSP: 0018:ffffc9000138bc10 EFLAGS: 00010206
[ ] RAX: 0000000000000000 RBX: ffffffff813e0df0 RCX: 000000000000003b
[ ] RDX: 0200000000000000 RSI: 000000000000000c RDI: ffffffff813e0df0
[ ] RBP: ffffffffa00a3000 R08: ffffffff81180ce0 R09: 0000000000000001
[ ] R10: ffffc9000138bc18 R11: 0000000000000001 R12: ffffffff813e0df0
[ ] R13: ffffffff813e0df0 R14: ffff888171b56400 R15: 0000000000000000
[ ] FS:  00007fa9420c7780(0000) GS:ffff888ff6a00000(0000) knlGS:000000000
[ ] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ ] CR2: 000000000770d000 CR3: 0000000107d50003 CR4: 0000000000370ee0
[ ] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[ ] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[ ] Call Trace:
[ ]  <TASK>
[ ]  register_ftrace_direct+0x54/0x290
[ ]  ? render_sigset_t+0xa0/0xa0
[ ]  bpf_trampoline_update+0x3f5/0x4a0
[ ]  ? 0xffffffffa00a3000
[ ]  bpf_trampoline_link_prog+0xa9/0x140
[ ]  bpf_tracing_prog_attach+0x1dc/0x450
[ ]  bpf_raw_tracepoint_open+0x9a/0x1e0
[ ]  ? find_held_lock+0x2d/0x90
[ ]  ? lock_release+0x150/0x430
[ ]  __sys_bpf+0xbd6/0x2700
[ ]  ? lock_is_held_type+0xd8/0x130
[ ]  __x64_sys_bpf+0x1c/0x20
[ ]  do_syscall_64+0x3a/0x80
[ ]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[ ] RIP: 0033:0x7fa9421defa9
[ ] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 9 f8 [...]
[ ] RSP: 002b:00007ffed743bd78 EFLAGS: 00000246 ORIG_RAX: 0000000000000141
[ ] RAX: ffffffffffffffda RBX: 00000000069d2480 RCX: 00007fa9421defa9
[ ] RDX: 0000000000000078 RSI: 00007ffed743bd80 RDI: 0000000000000011
[ ] RBP: 00007ffed743be00 R08: 0000000000bb7270 R09: 0000000000000000
[ ] R10: 00000000069da210 R11: 0000000000000246 R12: 0000000000000001
[ ] R13: 00007ffed743c4b0 R14: 00000000069d2480 R15: 0000000000000001
[ ]  </TASK>
[ ] Modules linked in: klp_vm(OK)
[ ] ---[ end trace 0000000000000000 ]---

One way to trigger this is:
  1. load a livepatch that patches kernel function xxx;
  2. run bpftrace -e 'kfunc:xxx {}', this will fail (expected for now);
  3. repeat #2 => gpf.

This is because the entry is added to direct_functions, but not removed.
Fix this by remove the entry from direct_functions when
register_ftrace_direct fails.

Also remove the last trailing space from ftrace.c, so we don't have to
worry about it anymore.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7d54c15cb89a29a5f59e5ffc9ee62e6591769ef1
  - https://git.kernel.org/stable/c/805e87af946d8d2954171361e64d143ff37a441b
  - https://git.kernel.org/stable/c/82c888e51c2176a06f8b4541cf748ee81aac6e7e
  - https://git.kernel.org/stable/c/a0392833a178cf109a57c2a9d4d531bdfc6cd98f
  - https://git.kernel.org/stable/c/cae2978d6907ef2c08b9b15f704e783f7c284713

------------------------------------------------------------

CVE ID: CVE-2022-49403
Description: In the Linux kernel, the following vulnerability has been resolved:

lib/string_helpers: fix not adding strarray to device's resource list

Add allocated strarray to device's resource list. This is a must to
automatically release strarray when the device disappears.

Without this fix we have a memory leak in the few drivers which use
devm_kasprintf_strarray().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/a152eb42fcecfe41239c3c6695342f3a128593e7
  - https://git.kernel.org/stable/c/bf29edab0c9ff3d2633b8306a67d04c357e2a385
  - https://git.kernel.org/stable/c/cd290a9839cee2f6641558877e707bd373c8f6f1

------------------------------------------------------------

CVE ID: CVE-2022-49404
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/hfi1: Fix potential integer multiplication overflow errors

When multiplying of different types, an overflow is possible even when
storing the result in a larger type. This is because the conversion is
done after the multiplication. So arithmetic overflow and thus in
incorrect value is possible.

Correct an instance of this in the inter packet delay calculation.  Fix by
ensuring one of the operands is u64 which will promote the other to u64 as
well ensuring no overflow.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.3, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/06039d8afefdbac05bcea5f397188407eba2996d
  - https://git.kernel.org/stable/c/252f4afd4557a2e7075f793a5c80fe6dd9e9ee4a
  - https://git.kernel.org/stable/c/31dca00d0cc9f4133320d72eb7e3720badc6d6e6
  - https://git.kernel.org/stable/c/3f09ec80f115d2875d747ed28adc1773037e0f8b
  - https://git.kernel.org/stable/c/79c164e61f818054cd6012e9035701840d895c51
  - https://git.kernel.org/stable/c/8858284dd74906fa00f04f0252c75df4893a7959
  - https://git.kernel.org/stable/c/a89cb7ddf6a89bab6012e19da38b7cdb26175c19
  - https://git.kernel.org/stable/c/ef5ab2e48a5f9960e2352332b7cdb7064bb49032
  - https://git.kernel.org/stable/c/f93e91a0372c922c20d5bee260b0f43b4b8a1bee

------------------------------------------------------------

CVE ID: CVE-2022-49405
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: r8188eu: prevent ->Ssid overflow in rtw_wx_set_scan()

This code has a check to prevent read overflow but it needs another
check to prevent writing beyond the end of the ->Ssid[] array.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/476bfda0be0f9669add92bff604ca78226cf53d1
  - https://git.kernel.org/stable/c/ac2eab7de458f5e1210ce1237afab40a307075c8
  - https://git.kernel.org/stable/c/bc10916e890948d8927a5c8c40fb5dc44be5e1b8
  - https://git.kernel.org/stable/c/c4bd6b72df4f01aa866ceb298466d6d07a6bd525

------------------------------------------------------------

CVE ID: CVE-2022-49406
Description: In the Linux kernel, the following vulnerability has been resolved:

block: Fix potential deadlock in blk_ia_range_sysfs_show()

When being read, a sysfs attribute is already protected against removal
with the kobject node active reference counter. As a result, in
blk_ia_range_sysfs_show(), there is no need to take the queue sysfs
lock when reading the value of a range attribute. Using the queue sysfs
lock in this function creates a potential deadlock situation with the
disk removal, something that a lockdep signals with a splat when the
device is removed:

[  760.703551]  Possible unsafe locking scenario:
[  760.703551]
[  760.703554]        CPU0                    CPU1
[  760.703556]        ----                    ----
[  760.703558]   lock(&q->sysfs_lock);
[  760.703565]                                lock(kn->active#385);
[  760.703573]                                lock(&q->sysfs_lock);
[  760.703579]   lock(kn->active#385);
[  760.703587]
[  760.703587]  *** DEADLOCK ***

Solve this by removing the mutex_lock()/mutex_unlock() calls from
blk_ia_range_sysfs_show().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/41e46b3c2aa24f755b2ae9ec4ce931ba5f0d8532
  - https://git.kernel.org/stable/c/717b078bc745ba9a262abebed9806a17e8bbb77b
  - https://git.kernel.org/stable/c/dc107c805cde709866b59867ef72b9390199205e

------------------------------------------------------------

CVE ID: CVE-2022-49407
Description: In the Linux kernel, the following vulnerability has been resolved:

dlm: fix plock invalid read

This patch fixes an invalid read showed by KASAN. A unlock will allocate a
"struct plock_op" and a followed send_op() will append it to a global
send_list data structure. In some cases a followed dev_read() moves it
to recv_list and dev_write() will cast it to "struct plock_xop" and access
fields which are only available in those structures. At this point an
invalid read happens by accessing those fields.

To fix this issue the "callback" field is moved to "struct plock_op" to
indicate that a cast to "plock_xop" is allowed and does the additional
"plock_xop" handling if set.

Example of the KASAN output which showed the invalid read:

[ 2064.296453] ==================================================================
[ 2064.304852] BUG: KASAN: slab-out-of-bounds in dev_write+0x52b/0x5a0 [dlm]
[ 2064.306491] Read of size 8 at addr ffff88800ef227d8 by task dlm_controld/7484
[ 2064.308168]
[ 2064.308575] CPU: 0 PID: 7484 Comm: dlm_controld Kdump: loaded Not tainted 5.14.0+ #9
[ 2064.310292] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011
[ 2064.311618] Call Trace:
[ 2064.312218]  dump_stack_lvl+0x56/0x7b
[ 2064.313150]  print_address_description.constprop.8+0x21/0x150
[ 2064.314578]  ? dev_write+0x52b/0x5a0 [dlm]
[ 2064.315610]  ? dev_write+0x52b/0x5a0 [dlm]
[ 2064.316595]  kasan_report.cold.14+0x7f/0x11b
[ 2064.317674]  ? dev_write+0x52b/0x5a0 [dlm]
[ 2064.318687]  dev_write+0x52b/0x5a0 [dlm]
[ 2064.319629]  ? dev_read+0x4a0/0x4a0 [dlm]
[ 2064.320713]  ? bpf_lsm_kernfs_init_security+0x10/0x10
[ 2064.321926]  vfs_write+0x17e/0x930
[ 2064.322769]  ? __fget_light+0x1aa/0x220
[ 2064.323753]  ksys_write+0xf1/0x1c0
[ 2064.324548]  ? __ia32_sys_read+0xb0/0xb0
[ 2064.325464]  do_syscall_64+0x3a/0x80
[ 2064.326387]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[ 2064.327606] RIP: 0033:0x7f807e4ba96f
[ 2064.328470] Code: 89 54 24 18 48 89 74 24 10 89 7c 24 08 e8 39 87 f8 ff 48 8b 54 24 18 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 31 44 89 c7 48 89 44 24 08 e8 7c 87 f8 ff 48
[ 2064.332902] RSP: 002b:00007ffd50cfe6e0 EFLAGS: 00000293 ORIG_RAX: 0000000000000001
[ 2064.334658] RAX: ffffffffffffffda RBX: 000055cc3886eb30 RCX: 00007f807e4ba96f
[ 2064.336275] RDX: 0000000000000040 RSI: 00007ffd50cfe7e0 RDI: 0000000000000010
[ 2064.337980] RBP: 00007ffd50cfe7e0 R08: 0000000000000000 R09: 0000000000000001
[ 2064.339560] R10: 000055cc3886eb30 R11: 0000000000000293 R12: 000055cc3886eb80
[ 2064.341237] R13: 000055cc3886eb00 R14: 000055cc3886f590 R15: 0000000000000001
[ 2064.342857]
[ 2064.343226] Allocated by task 12438:
[ 2064.344057]  kasan_save_stack+0x1c/0x40
[ 2064.345079]  __kasan_kmalloc+0x84/0xa0
[ 2064.345933]  kmem_cache_alloc_trace+0x13b/0x220
[ 2064.346953]  dlm_posix_unlock+0xec/0x720 [dlm]
[ 2064.348811]  do_lock_file_wait.part.32+0xca/0x1d0
[ 2064.351070]  fcntl_setlk+0x281/0xbc0
[ 2064.352879]  do_fcntl+0x5e4/0xfe0
[ 2064.354657]  __x64_sys_fcntl+0x11f/0x170
[ 2064.356550]  do_syscall_64+0x3a/0x80
[ 2064.358259]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[ 2064.360745]
[ 2064.361511] Last potentially related work creation:
[ 2064.363957]  kasan_save_stack+0x1c/0x40
[ 2064.365811]  __kasan_record_aux_stack+0xaf/0xc0
[ 2064.368100]  call_rcu+0x11b/0xf70
[ 2064.369785]  dlm_process_incoming_buffer+0x47d/0xfd0 [dlm]
[ 2064.372404]  receive_from_sock+0x290/0x770 [dlm]
[ 2064.374607]  process_recv_sockets+0x32/0x40 [dlm]
[ 2064.377290]  process_one_work+0x9a8/0x16e0
[ 2064.379357]  worker_thread+0x87/0xbf0
[ 2064.381188]  kthread+0x3ac/0x490
[ 2064.383460]  ret_from_fork+0x22/0x30
[ 2064.385588]
[ 2064.386518] Second to last potentially related work creation:
[ 2064.389219]  kasan_save_stack+0x1c/0x40
[ 2064.391043]  __kasan_record_aux_stack+0xaf/0xc0
[ 2064.393303]  call_rcu+0x11b/0xf70
[ 2064.394885]  dlm_process_incoming_buffer+0x47d/0xfd0 [dlm]
[ 2064.397694]  receive_from_sock+0x290/0x770 
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2c55155cc365861044d9e6e80e342693e8805e33
  - https://git.kernel.org/stable/c/42252d0d2aa9b94d168241710a761588b3959019
  - https://git.kernel.org/stable/c/49cd9eb7b9a7b88124b31e31f8e539acaf1b3a6d
  - https://git.kernel.org/stable/c/56aa8d1fbd02357f3bf81bdfba1cde87ce8402fc
  - https://git.kernel.org/stable/c/5a1765adf9855cf0f6d3f7e0eb4b78ca66f70dee
  - https://git.kernel.org/stable/c/72f2f68970f9bdc252d59e119b385a6441b0b155
  - https://git.kernel.org/stable/c/899bc4429174861122f0c236588700a4710c1fec
  - https://git.kernel.org/stable/c/acdad5bc9827922ec2f2e84fd198718aa8e8ab92
  - https://git.kernel.org/stable/c/e421872fa17542cf33747071fb141b0130ce9ef7

------------------------------------------------------------

CVE ID: CVE-2022-49408
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix memory leak in parse_apply_sb_mount_options()

If processing the on-disk mount options fails after any memory was
allocated in the ext4_fs_context, e.g. s_qf_names, then this memory is
leaked.  Fix this by calling ext4_fc_free() instead of kfree() directly.

Reproducer:

    mkfs.ext4 -F /dev/vdc
    tune2fs /dev/vdc -E mount_opts=usrjquota=file
    echo clear > /sys/kernel/debug/kmemleak
    mount /dev/vdc /vdc
    echo scan > /sys/kernel/debug/kmemleak
    sleep 5
    echo scan > /sys/kernel/debug/kmemleak
    cat /sys/kernel/debug/kmemleak
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/9ea3e6168948189cec31d0678d2b55b395f88491
  - https://git.kernel.org/stable/c/c069db76ed7b681c69159f44be96d2137e9ca989
  - https://git.kernel.org/stable/c/f92ded66e9d0aa20b883a2a5183973abc8f41815

------------------------------------------------------------

CVE ID: CVE-2022-49409
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix bug_on in __es_tree_search

Hulk Robot reported a BUG_ON:
==================================================================
kernel BUG at fs/ext4/extents_status.c:199!
[...]
RIP: 0010:ext4_es_end fs/ext4/extents_status.c:199 [inline]
RIP: 0010:__es_tree_search+0x1e0/0x260 fs/ext4/extents_status.c:217
[...]
Call Trace:
 ext4_es_cache_extent+0x109/0x340 fs/ext4/extents_status.c:766
 ext4_cache_extents+0x239/0x2e0 fs/ext4/extents.c:561
 ext4_find_extent+0x6b7/0xa20 fs/ext4/extents.c:964
 ext4_ext_map_blocks+0x16b/0x4b70 fs/ext4/extents.c:4384
 ext4_map_blocks+0xe26/0x19f0 fs/ext4/inode.c:567
 ext4_getblk+0x320/0x4c0 fs/ext4/inode.c:980
 ext4_bread+0x2d/0x170 fs/ext4/inode.c:1031
 ext4_quota_read+0x248/0x320 fs/ext4/super.c:6257
 v2_read_header+0x78/0x110 fs/quota/quota_v2.c:63
 v2_check_quota_file+0x76/0x230 fs/quota/quota_v2.c:82
 vfs_load_quota_inode+0x5d1/0x1530 fs/quota/dquot.c:2368
 dquot_enable+0x28a/0x330 fs/quota/dquot.c:2490
 ext4_quota_enable fs/ext4/super.c:6137 [inline]
 ext4_enable_quotas+0x5d7/0x960 fs/ext4/super.c:6163
 ext4_fill_super+0xa7c9/0xdc00 fs/ext4/super.c:4754
 mount_bdev+0x2e9/0x3b0 fs/super.c:1158
 mount_fs+0x4b/0x1e4 fs/super.c:1261
[...]
==================================================================

Above issue may happen as follows:
-------------------------------------
ext4_fill_super
 ext4_enable_quotas
  ext4_quota_enable
   ext4_iget
    __ext4_iget
     ext4_ext_check_inode
      ext4_ext_check
       __ext4_ext_check
        ext4_valid_extent_entries
         Check for overlapping extents does't take effect
   dquot_enable
    vfs_load_quota_inode
     v2_check_quota_file
      v2_read_header
       ext4_quota_read
        ext4_bread
         ext4_getblk
          ext4_map_blocks
           ext4_ext_map_blocks
            ext4_find_extent
             ext4_cache_extents
              ext4_es_cache_extent
               ext4_es_cache_extent
                __es_tree_search
                 ext4_es_end
                  BUG_ON(es->es_lblk + es->es_len < es->es_lblk)

The error ext4 extents is as follows:
0af3 0300 0400 0000 00000000    extent_header
00000000 0100 0000 12000000     extent1
00000000 0100 0000 18000000     extent2
02000000 0400 0000 14000000     extent3

In the ext4_valid_extent_entries function,
if prev is 0, no error is returned even if lblock<=prev.
This was intended to skip the check on the first extent, but
in the error image above, prev=0+1-1=0 when checking the second extent,
so even though lblock<=prev, the function does not return an error.
As a result, bug_ON occurs in __es_tree_search and the system panics.

To solve this problem, we only need to check that:
1. The lblock of the first extent is not less than 0.
2. The lblock of the next extent  is not less than
   the next block of the previous extent.
The same applies to extent_idx.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3c617827cd51018bc377bd2954e176920ddbcfad
  - https://git.kernel.org/stable/c/4fd58b5cf118d2d9038a0b8c9cc0e43096297686
  - https://git.kernel.org/stable/c/59cf2fabbfe76de29d88dd7ae69858a25735b59f
  - https://git.kernel.org/stable/c/d0083459e2b6b07ebd78bea2fe684a19cc0f3d0f
  - https://git.kernel.org/stable/c/d36f6ed761b53933b0b4126486c10d3da7751e7f
  - https://git.kernel.org/stable/c/ea6ea18b3ab0c0d7fefffb3c4d27df758b1c790a

------------------------------------------------------------

CVE ID: CVE-2022-49410
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix potential double free in create_var_ref()

In create_var_ref(), init_var_ref() is called to initialize the fields
of variable ref_field, which is allocated in the previous function call
to create_hist_field(). Function init_var_ref() allocates the
corresponding fields such as ref_field->system, but frees these fields
when the function encounters an error. The caller later calls
destroy_hist_field() to conduct error handling, which frees the fields
and the variable itself. This results in double free of the fields which
are already freed in the previous function.

Fix this by storing NULL to the corresponding fields when they are freed
in init_var_ref().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.17, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/058cb6d86b9789377216c936506b346aaa1eb581
  - https://git.kernel.org/stable/c/37443b3508b8cce6832f8d25cb4550b2f7801f50
  - https://git.kernel.org/stable/c/4fdfb15e08598711dbf50daf56a33965232daf0e
  - https://git.kernel.org/stable/c/99696a2592bca641eb88cc9a80c90e591afebd0f
  - https://git.kernel.org/stable/c/bd83ff3bbfb003832481c9bff999d12385f396ae
  - https://git.kernel.org/stable/c/c27f744ceefadc7bbeb14233b6abc150ced617d2
  - https://git.kernel.org/stable/c/f8b383f83cb573152c577eca1ef101e89995b72a

------------------------------------------------------------

CVE ID: CVE-2022-49411
Description: In the Linux kernel, the following vulnerability has been resolved:

bfq: Make sure bfqg for which we are queueing requests is online

Bios queued into BFQ IO scheduler can be associated with a cgroup that
was already offlined. This may then cause insertion of this bfq_group
into a service tree. But this bfq_group will get freed as soon as last
bio associated with it is completed leading to use after free issues for
service tree users. Fix the problem by making sure we always operate on
online bfq_group. If the bfq_group associated with the bio is not
online, we pick the first online parent.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/075a53b78b815301f8d3dd1ee2cd99554e34f0dd
  - https://git.kernel.org/stable/c/51f724bffa3403a5236597e6b75df7329c1ec6e9
  - https://git.kernel.org/stable/c/6ee0868b0c3ccead5907685fcdcdd0c08dfe4b0b
  - https://git.kernel.org/stable/c/7781c38552e6cc54ed8e9040279561340516b881
  - https://git.kernel.org/stable/c/97bd6c56bdcb41079e488e31df56809e3b2ce628
  - https://git.kernel.org/stable/c/ccddf8cd411c1800863ed357064e56ceffd356bb

------------------------------------------------------------

CVE ID: CVE-2022-49412
Description: In the Linux kernel, the following vulnerability has been resolved:

bfq: Avoid merging queues with different parents

It can happen that the parent of a bfqq changes between the moment we
decide two queues are worth to merge (and set bic->stable_merge_bfqq)
and the moment bfq_setup_merge() is called. This can happen e.g. because
the process submitted IO for a different cgroup and thus bfqq got
reparented. It can even happen that the bfqq we are merging with has
parent cgroup that is already offline and going to be destroyed in which
case the merge can lead to use-after-free issues such as:

BUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50
Read of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544

CPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014
Call Trace:
 <IRQ>
 dump_stack_lvl+0x46/0x5a
 print_address_description.constprop.0+0x1f/0x140
 ? __bfq_deactivate_entity+0x9cb/0xa50
 kasan_report.cold+0x7f/0x11b
 ? __bfq_deactivate_entity+0x9cb/0xa50
 __bfq_deactivate_entity+0x9cb/0xa50
 ? update_curr+0x32f/0x5d0
 bfq_deactivate_entity+0xa0/0x1d0
 bfq_del_bfqq_busy+0x28a/0x420
 ? resched_curr+0x116/0x1d0
 ? bfq_requeue_bfqq+0x70/0x70
 ? check_preempt_wakeup+0x52b/0xbc0
 __bfq_bfqq_expire+0x1a2/0x270
 bfq_bfqq_expire+0xd16/0x2160
 ? try_to_wake_up+0x4ee/0x1260
 ? bfq_end_wr_async_queues+0xe0/0xe0
 ? _raw_write_unlock_bh+0x60/0x60
 ? _raw_spin_lock_irq+0x81/0xe0
 bfq_idle_slice_timer+0x109/0x280
 ? bfq_dispatch_request+0x4870/0x4870
 __hrtimer_run_queues+0x37d/0x700
 ? enqueue_hrtimer+0x1b0/0x1b0
 ? kvm_clock_get_cycles+0xd/0x10
 ? ktime_get_update_offsets_now+0x6f/0x280
 hrtimer_interrupt+0x2c8/0x740

Fix the problem by checking that the parent of the two bfqqs we are
merging in bfq_setup_merge() is the same.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/5ee21edaed09e6b25f2c007b3f326752bc89bacf
  - https://git.kernel.org/stable/c/7d172b9dc913e161d8ff88770eea01701ff553de
  - https://git.kernel.org/stable/c/8abc8763b11c35e03cc91d59fd0cd28d39f88ca9
  - https://git.kernel.org/stable/c/97be7d13fbd4001eeab49b1be6399f23a8c66160
  - https://git.kernel.org/stable/c/a16c65cca7d2c7ff965fdd3adc8df2156529caf1
  - https://git.kernel.org/stable/c/c1cee4ab36acef271be9101590756ed0c0c374d9

------------------------------------------------------------

CVE ID: CVE-2022-49413
Description: In the Linux kernel, the following vulnerability has been resolved:

bfq: Update cgroup information before merging bio

When the process is migrated to a different cgroup (or in case of
writeback just starts submitting bios associated with a different
cgroup) bfq_merge_bio() can operate with stale cgroup information in
bic. Thus the bio can be merged to a request from a different cgroup or
it can result in merging of bfqqs for different cgroups or bfqqs of
already dead cgroups and causing possible use-after-free issues. Fix the
problem by updating cgroup information in bfq_merge_bio().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/2a1077f17169a6059992a0bbdb330e0abad1e6d9
  - https://git.kernel.org/stable/c/b06691af08b41dfd81052a3362514d9827b44bb1
  - https://git.kernel.org/stable/c/d9165200c5627a2cf4408eefabdf0058bdf95e1a
  - https://git.kernel.org/stable/c/da9f3025d595956410ceaab2bea01980d7775948
  - https://git.kernel.org/stable/c/e8821f45612f2e6d9adb9c6ba0fb4184f57692aa
  - https://git.kernel.org/stable/c/ea591cd4eb270393810e7be01feb8fde6a34fbbe

------------------------------------------------------------

CVE ID: CVE-2022-49414
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix race condition between ext4_write and ext4_convert_inline_data

Hulk Robot reported a BUG_ON:
 ==================================================================
 EXT4-fs error (device loop3): ext4_mb_generate_buddy:805: group 0,
 block bitmap and bg descriptor inconsistent: 25 vs 31513 free clusters
 kernel BUG at fs/ext4/ext4_jbd2.c:53!
 invalid opcode: 0000 [#1] SMP KASAN PTI
 CPU: 0 PID: 25371 Comm: syz-executor.3 Not tainted 5.10.0+ #1
 RIP: 0010:ext4_put_nojournal fs/ext4/ext4_jbd2.c:53 [inline]
 RIP: 0010:__ext4_journal_stop+0x10e/0x110 fs/ext4/ext4_jbd2.c:116
 [...]
 Call Trace:
  ext4_write_inline_data_end+0x59a/0x730 fs/ext4/inline.c:795
  generic_perform_write+0x279/0x3c0 mm/filemap.c:3344
  ext4_buffered_write_iter+0x2e3/0x3d0 fs/ext4/file.c:270
  ext4_file_write_iter+0x30a/0x11c0 fs/ext4/file.c:520
  do_iter_readv_writev+0x339/0x3c0 fs/read_write.c:732
  do_iter_write+0x107/0x430 fs/read_write.c:861
  vfs_writev fs/read_write.c:934 [inline]
  do_pwritev+0x1e5/0x380 fs/read_write.c:1031
 [...]
 ==================================================================

Above issue may happen as follows:
           cpu1                     cpu2
__________________________|__________________________
do_pwritev
 vfs_writev
  do_iter_write
   ext4_file_write_iter
    ext4_buffered_write_iter
     generic_perform_write
      ext4_da_write_begin
                           vfs_fallocate
                            ext4_fallocate
                             ext4_convert_inline_data
                              ext4_convert_inline_data_nolock
                               ext4_destroy_inline_data_nolock
                                clear EXT4_STATE_MAY_INLINE_DATA
                               ext4_map_blocks
                                ext4_ext_map_blocks
                                 ext4_mb_new_blocks
                                  ext4_mb_regular_allocator
                                   ext4_mb_good_group_nolock
                                    ext4_mb_init_group
                                     ext4_mb_init_cache
                                      ext4_mb_generate_buddy  --> error
       ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)
                                ext4_restore_inline_data
                                 set EXT4_STATE_MAY_INLINE_DATA
       ext4_block_write_begin
      ext4_da_write_end
       ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)
       ext4_write_inline_data_end
        handle=NULL
        ext4_journal_stop(handle)
         __ext4_journal_stop
          ext4_put_nojournal(handle)
           ref_cnt = (unsigned long)handle
           BUG_ON(ref_cnt == 0)  ---> BUG_ON

The lock held by ext4_convert_inline_data is xattr_sem, but the lock
held by generic_perform_write is i_rwsem. Therefore, the two locks can
be concurrent.

To solve above issue, we add inode_lock() for ext4_convert_inline_data().
At the same time, move ext4_convert_inline_data() in front of
ext4_punch_hole(), remove similar handling from ext4_punch_hole().
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.8, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/14602353b350950b551eccc6b46411aa3b12ffe2
  - https://git.kernel.org/stable/c/18881d7e517169193d9ef6c89c7f322e3e164277
  - https://git.kernel.org/stable/c/725e00cb7039eae291890f1bb19bc867176745f6
  - https://git.kernel.org/stable/c/91f90b571f1a23f5b8a9c2b68a9aa5d6981a3c3d
  - https://git.kernel.org/stable/c/ccc6639f831bee91aa8b41c8a1cdd020ecfb9f32
  - https://git.kernel.org/stable/c/f87c7a4b084afc13190cbb263538e444cb2b392a

------------------------------------------------------------

CVE ID: CVE-2022-49415
Description: In the Linux kernel, the following vulnerability has been resolved:

ipmi:ipmb: Fix refcount leak in ipmi_ipmb_probe

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a508e33956b538e034ed5df619a73ec7c15bda72
  - https://git.kernel.org/stable/c/f22068357acc268148bd55ce77f0a3e5c86701b4

------------------------------------------------------------

CVE ID: CVE-2022-49416
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: fix use-after-free in chanctx code

In ieee80211_vif_use_reserved_context(), when we have an
old context and the new context's replace_state is set to
IEEE80211_CHANCTX_REPLACE_NONE, we free the old context
in ieee80211_vif_use_reserved_reassign(). Therefore, we
cannot check the old_ctx anymore, so we should set it to
NULL after this point.

However, since the new_ctx replace state is clearly not
IEEE80211_CHANCTX_REPLACES_OTHER, we're not going to do
anything else in this function and can just return to
avoid accessing the freed old_ctx.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.17, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/265bec4779a38b65e86a25120370f200822dfa76
  - https://git.kernel.org/stable/c/2965c4cdf7ad9ce0796fac5e57debb9519ea721e
  - https://git.kernel.org/stable/c/4ba81e794f0fad6234f644c2da1ae14d5b95e1c4
  - https://git.kernel.org/stable/c/4f05a9e15edcdf5b97e0d86ab6ecd5f187289f6c
  - https://git.kernel.org/stable/c/6118bbdf69f4718b02d26bbcf2e497eb66004331
  - https://git.kernel.org/stable/c/82c8e7bbdd06c7ed58e22450cc5b37f33a25bb2c
  - https://git.kernel.org/stable/c/88cc8f963febe192d6ded9df7217f92f380b449a
  - https://git.kernel.org/stable/c/9f1e5cc85ad77e52f54049a94db0407445ae2a34
  - https://git.kernel.org/stable/c/b79110f2bf6022e60e590d2e094728a8eec3e79e

------------------------------------------------------------

CVE ID: CVE-2022-49417
Description: In the Linux kernel, the following vulnerability has been resolved:

iwlwifi: mei: fix potential NULL-ptr deref

If SKB allocation fails, continue rather than using the NULL
pointer.

Coverity CID: 1497650
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/29b81de94d62b5e2704bb5106b3e701ca8d7c7a4
  - https://git.kernel.org/stable/c/5d8d06fd3a02919100b28f927bcb76481ec0a0e3
  - https://git.kernel.org/stable/c/78488a64aea94a3336ee97f345c1496e9bc5ebdf

------------------------------------------------------------

CVE ID: CVE-2022-49418
Description: In the Linux kernel, the following vulnerability has been resolved:

NFSv4: Fix free of uninitialized nfs4_label on referral lookup.

Send along the already-allocated fattr along with nfs4_fs_locations, and
drop the memcpy of fattr.  We end up growing two more allocations, but this
fixes up a crash as:

PID: 790    TASK: ffff88811b43c000  CPU: 0   COMMAND: "ls"
 #0 [ffffc90000857920] panic at ffffffff81b9bfde
 #1 [ffffc900008579c0] do_trap at ffffffff81023a9b
 #2 [ffffc90000857a10] do_error_trap at ffffffff81023b78
 #3 [ffffc90000857a58] exc_stack_segment at ffffffff81be1f45
 #4 [ffffc90000857a80] asm_exc_stack_segment at ffffffff81c009de
 #5 [ffffc90000857b08] nfs_lookup at ffffffffa0302322 [nfs]
 #6 [ffffc90000857b70] __lookup_slow at ffffffff813a4a5f
 #7 [ffffc90000857c60] walk_component at ffffffff813a86c4
 #8 [ffffc90000857cb8] path_lookupat at ffffffff813a9553
 #9 [ffffc90000857cf0] filename_lookup at ffffffff813ab86b
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6015292653d95ba9f72906e2b65e536aa5807d64
  - https://git.kernel.org/stable/c/c3ed222745d9ad7b69299b349a64ba533c64a34f
  - https://git.kernel.org/stable/c/eb1fe9600b86c24a789046bfc5c6851dda119280

------------------------------------------------------------

CVE ID: CVE-2022-49419
Description: In the Linux kernel, the following vulnerability has been resolved:

video: fbdev: vesafb: Fix a use-after-free due early fb_info cleanup

Commit b3c9a924aab6 ("fbdev: vesafb: Cleanup fb_info in .fb_destroy rather
than .remove") fixed a use-after-free error due the vesafb driver freeing
the fb_info in the .remove handler instead of doing it in .fb_destroy.

This can happen if the .fb_destroy callback is executed after the .remove
callback, since the former tries to access a pointer freed by the latter.

But that change didn't take into account that another possible scenario is
that .fb_destroy is called before the .remove callback. For example, if no
process has the fbdev chardev opened by the time the driver is removed.

If that's the case, fb_info will be freed when unregister_framebuffer() is
called, making the fb_info pointer accessed in vesafb_remove() after that
to no longer be valid.

To prevent that, move the expression containing the info->par to happen
before the unregister_framebuffer() function call.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.41, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17.9, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0fac5f8fb1bc2fc4f8714bf5e743c9cc3f547c63
  - https://git.kernel.org/stable/c/acde4003efc16480375543638484d8f13f2e99a3
  - https://git.kernel.org/stable/c/d260cad015945d1f4bb9b028a096f648506106a2
  - https://git.kernel.org/stable/c/f605f5558ecc175ec70016a3c15f007cb6386531

------------------------------------------------------------

CVE ID: CVE-2022-49420
Description: In the Linux kernel, the following vulnerability has been resolved:

net: annotate races around sk->sk_bound_dev_if

UDP sendmsg() is lockless, and reads sk->sk_bound_dev_if while
this field can be changed by another thread.

Adds minimal annotations to avoid KCSAN splats for UDP.
Following patches will add more annotations to potential lockless readers.

BUG: KCSAN: data-race in __ip6_datagram_connect / udpv6_sendmsg

write to 0xffff888136d47a94 of 4 bytes by task 7681 on cpu 0:
 __ip6_datagram_connect+0x6e2/0x930 net/ipv6/datagram.c:221
 ip6_datagram_connect+0x2a/0x40 net/ipv6/datagram.c:272
 inet_dgram_connect+0x107/0x190 net/ipv4/af_inet.c:576
 __sys_connect_file net/socket.c:1900 [inline]
 __sys_connect+0x197/0x1b0 net/socket.c:1917
 __do_sys_connect net/socket.c:1927 [inline]
 __se_sys_connect net/socket.c:1924 [inline]
 __x64_sys_connect+0x3d/0x50 net/socket.c:1924
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x2b/0x50 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x44/0xae

read to 0xffff888136d47a94 of 4 bytes by task 7670 on cpu 1:
 udpv6_sendmsg+0xc60/0x16e0 net/ipv6/udp.c:1436
 inet6_sendmsg+0x5f/0x80 net/ipv6/af_inet6.c:652
 sock_sendmsg_nosec net/socket.c:705 [inline]
 sock_sendmsg net/socket.c:725 [inline]
 ____sys_sendmsg+0x39a/0x510 net/socket.c:2413
 ___sys_sendmsg net/socket.c:2467 [inline]
 __sys_sendmmsg+0x267/0x4c0 net/socket.c:2553
 __do_sys_sendmmsg net/socket.c:2582 [inline]
 __se_sys_sendmmsg net/socket.c:2579 [inline]
 __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2579
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x2b/0x50 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x44/0xae

value changed: 0x00000000 -> 0xffffff9b

Reported by Kernel Concurrency Sanitizer on:
CPU: 1 PID: 7670 Comm: syz-executor.3 Tainted: G        W         5.18.0-rc1-syzkaller-dirty #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011

I chose to not add Fixes: tag because race has minor consequences
and stable teams busy enough.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/20b2f61797873a2b18b5ff1a304ad2674fa1e0a5
  - https://git.kernel.org/stable/c/4c971d2f3548e4f11b1460ac048f5307e4b39fdb

------------------------------------------------------------

CVE ID: CVE-2022-49421
Description: In the Linux kernel, the following vulnerability has been resolved:

video: fbdev: clcdfb: Fix refcount leak in clcdfb_of_vram_setup

of_parse_phandle() returns a node pointer with refcount incremented, we should
use of_node_put() on it when not need anymore.  Add missing of_node_put() to
avoid refcount leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2e2e2c71b2642289438392edbf5d08cdbc0b138b
  - https://git.kernel.org/stable/c/38d245cebf545338a6bc1c7762023de3fbecd7b7
  - https://git.kernel.org/stable/c/51eb1bb6baeb478538dd4ec6459fd68c44a855b1
  - https://git.kernel.org/stable/c/6c92711db7c90f78e0b67ac2a8944d0fe7e12d83
  - https://git.kernel.org/stable/c/8db59df7f5826e104db82cfddbf22a33a151193e
  - https://git.kernel.org/stable/c/b23789a59fa6f00e98a319291819f91fbba0deb8
  - https://git.kernel.org/stable/c/bbb2a24e863b6a10129546a0a4ceea2f07deec39
  - https://git.kernel.org/stable/c/c1c4405222b6fc98c16e8c2aa679c14e41d81465
  - https://git.kernel.org/stable/c/f2dfb4ab887d67be7d0892ba041d3c8d738d3356

------------------------------------------------------------

CVE ID: CVE-2022-49422
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: idxd: Fix the error handling path in idxd_cdev_register()

If a call to alloc_chrdev_region() fails, the already allocated resources
are leaking.

Add the needed error handling path to fix the leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5e88561eceb34ae3f88451c2b8e30fe403484189
  - https://git.kernel.org/stable/c/6073af78156b8c3fc1198f8bcc190b7ac3ac0143
  - https://git.kernel.org/stable/c/aab08c1aac01097815fbcf10fce7021d2396a31f
  - https://git.kernel.org/stable/c/b3c7b5d08e9d5b2ff31c03078c00ecf11042419f
  - https://git.kernel.org/stable/c/c308a2e711a52a47f4b45e7add2b5200169e429a

------------------------------------------------------------

CVE ID: CVE-2022-49423
Description: In the Linux kernel, the following vulnerability has been resolved:

rtla: Avoid record NULL pointer dereference

Fix the following null/deref_null.cocci errors:
./tools/tracing/rtla/src/osnoise_hist.c:870:31-36: ERROR: record is NULL but dereferenced.
./tools/tracing/rtla/src/osnoise_top.c:650:31-36: ERROR: record is NULL but dereferenced.
./tools/tracing/rtla/src/timerlat_hist.c:905:31-36: ERROR: record is NULL but dereferenced.
./tools/tracing/rtla/src/timerlat_top.c:700:31-36: ERROR: record is NULL but dereferenced.

"record" is NULL before calling osnoise_init_trace_tool.
Add a tag "out_free" to avoid dereferring a NULL pointer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2a6b52ed72c822b5ee146a6a00ea66614fe02653
  - https://git.kernel.org/stable/c/b0f1c686baff74d5df10f2f46670ef4e24a75756

------------------------------------------------------------

CVE ID: CVE-2022-49424
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/mediatek: Fix NULL pointer dereference when printing dev_name

When larbdev is NULL (in the case I hit, the node is incorrectly set
iommus = <&iommu NUM>), it will cause device_link_add() fail and
kernel crashes when we try to print dev_name(larbdev).

Let's fail the probe if a larbdev is NULL to avoid invalid inputs from
dts.

It should work for normal correct setting and avoid the crash caused
by my incorrect setting.

Error log:
[   18.189042][  T301] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000050
...
[   18.344519][  T301] pstate: a0400005 (NzCv daif +PAN -UAO)
[   18.345213][  T301] pc : mtk_iommu_probe_device+0xf8/0x118 [mtk_iommu]
[   18.346050][  T301] lr : mtk_iommu_probe_device+0xd0/0x118 [mtk_iommu]
[   18.346884][  T301] sp : ffffffc00a5635e0
[   18.347392][  T301] x29: ffffffc00a5635e0 x28: ffffffd44a46c1d8
[   18.348156][  T301] x27: ffffff80c39a8000 x26: ffffffd44a80cc38
[   18.348917][  T301] x25: 0000000000000000 x24: ffffffd44a80cc38
[   18.349677][  T301] x23: ffffffd44e4da4c6 x22: ffffffd44a80cc38
[   18.350438][  T301] x21: ffffff80cecd1880 x20: 0000000000000000
[   18.351198][  T301] x19: ffffff80c439f010 x18: ffffffc00a50d0c0
[   18.351959][  T301] x17: ffffffffffffffff x16: 0000000000000004
[   18.352719][  T301] x15: 0000000000000004 x14: ffffffd44eb5d420
[   18.353480][  T301] x13: 0000000000000ad2 x12: 0000000000000003
[   18.354241][  T301] x11: 00000000fffffad2 x10: c0000000fffffad2
[   18.355003][  T301] x9 : a0d288d8d7142d00 x8 : a0d288d8d7142d00
[   18.355763][  T301] x7 : ffffffd44c2bc640 x6 : 0000000000000000
[   18.356524][  T301] x5 : 0000000000000080 x4 : 0000000000000001
[   18.357284][  T301] x3 : 0000000000000000 x2 : 0000000000000005
[   18.358045][  T301] x1 : 0000000000000000 x0 : 0000000000000000
[   18.360208][  T301] Hardware name: MT6873 (DT)
[   18.360771][  T301] Call trace:
[   18.361168][  T301]  dump_backtrace+0xf8/0x1f0
[   18.361737][  T301]  dump_stack_lvl+0xa8/0x11c
[   18.362305][  T301]  dump_stack+0x1c/0x2c
[   18.362816][  T301]  mrdump_common_die+0x184/0x40c [mrdump]
[   18.363575][  T301]  ipanic_die+0x24/0x38 [mrdump]
[   18.364230][  T301]  atomic_notifier_call_chain+0x128/0x2b8
[   18.364937][  T301]  die+0x16c/0x568
[   18.365394][  T301]  __do_kernel_fault+0x1e8/0x214
[   18.365402][  T301]  do_page_fault+0xb8/0x678
[   18.366934][  T301]  do_translation_fault+0x48/0x64
[   18.368645][  T301]  do_mem_abort+0x68/0x148
[   18.368652][  T301]  el1_abort+0x40/0x64
[   18.368660][  T301]  el1h_64_sync_handler+0x54/0x88
[   18.368668][  T301]  el1h_64_sync+0x68/0x6c
[   18.368673][  T301]  mtk_iommu_probe_device+0xf8/0x118 [mtk_iommu]
...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8837c2682b9b2eed83e6212bcf79850c593a6fee
  - https://git.kernel.org/stable/c/c3c2734e28d7fac50228c4d2b8896e8695adf304
  - https://git.kernel.org/stable/c/de78657e16f41417da9332f09c2d67d100096939
  - https://git.kernel.org/stable/c/e9c63c0f73a1bbfd02624f5eae7e881df8b6830f

------------------------------------------------------------

CVE ID: CVE-2022-49425
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix dereference of stale list iterator after loop body

The list iterator variable will be a bogus pointer if no break was hit.
Dereferencing it (cur->page in this case) could load an out-of-bounds/undefined
value making it unsafe to use that in the comparision to determine if the
specific element was found.

Since 'cur->page' *can* be out-ouf-bounds it cannot be guaranteed that
by chance (or intention of an attacker) it matches the value of 'page'
even though the correct element was not found.

This is fixed by using a separate list iterator variable for the loop
and only setting the original variable if a suitable element was found.
Then determing if the element was found is simply checking if the
variable is set.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2aaf51dd39afb6d01d13f1e6fe20b684733b37d5
  - https://git.kernel.org/stable/c/385edd3ce5b4b1e9d31f474a5e35a39779ec1110
  - https://git.kernel.org/stable/c/45b2b7d7108ae1e25a5036cab04ab9273e792332
  - https://git.kernel.org/stable/c/51d584704d18e60fa473823654f35611c777b291
  - https://git.kernel.org/stable/c/5e47a7add3dda7f236548c5ec3017776dc2a729f
  - https://git.kernel.org/stable/c/b26e1c777890e4b938136deb8ec07a29f33862e4
  - https://git.kernel.org/stable/c/ed7efc472c00986dcd6903ab6ed165c7fa167674

------------------------------------------------------------

CVE ID: CVE-2022-49426
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/arm-smmu-v3-sva: Fix mm use-after-free

We currently call arm64_mm_context_put() without holding a reference to
the mm, which can result in use-after-free. Call mmgrab()/mmdrop() to
ensure the mm only gets freed after we unpinned the ASID.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/9aa215450888cf29af0c479e14a712dc6b0c506c
  - https://git.kernel.org/stable/c/cbd23144f7662b00bcde32a938c4a4057e476d68
  - https://git.kernel.org/stable/c/e3cbbdbff8a4db5d053c53fd71be62ccccdb52b0
  - https://git.kernel.org/stable/c/fc90f13ea0dcd960e5002d204fa55cec4e0db2fa

------------------------------------------------------------

CVE ID: CVE-2022-49427
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/mediatek: Remove clk_disable in mtk_iommu_remove

After the commit b34ea31fe013 ("iommu/mediatek: Always enable the clk on
resume"), the iommu clock is controlled by the runtime callback.
thus remove the clk control in the mtk_iommu_remove.

Otherwise, it will warning like:

echo 14018000.iommu > /sys/bus/platform/drivers/mtk-iommu/unbind

[   51.413044] ------------[ cut here ]------------
[   51.413648] vpp0_smi_iommu already disabled
[   51.414233] WARNING: CPU: 2 PID: 157 at */v5.15-rc1/kernel/mediatek/
                          drivers/clk/clk.c:952 clk_core_disable+0xb0/0xb8
[   51.417174] Hardware name: MT8195V/C(ENG) (DT)
[   51.418635] pc : clk_core_disable+0xb0/0xb8
[   51.419177] lr : clk_core_disable+0xb0/0xb8
...
[   51.429375] Call trace:
[   51.429694]  clk_core_disable+0xb0/0xb8
[   51.430193]  clk_core_disable_lock+0x24/0x40
[   51.430745]  clk_disable+0x20/0x30
[   51.431189]  mtk_iommu_remove+0x58/0x118
[   51.431705]  platform_remove+0x28/0x60
[   51.432197]  device_release_driver_internal+0x110/0x1f0
[   51.432873]  device_driver_detach+0x18/0x28
[   51.433418]  unbind_store+0xd4/0x108
[   51.433886]  drv_attr_store+0x24/0x38
[   51.434363]  sysfs_kf_write+0x40/0x58
[   51.434843]  kernfs_fop_write_iter+0x164/0x1e0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/053465ab20dcd324a43a1811ee98e5721e6a3e65
  - https://git.kernel.org/stable/c/6eaa046c696c83542c56765cdde564d9818ff1fb
  - https://git.kernel.org/stable/c/98df772bdd1c4ce717a26289efea15cbbe4b64ed
  - https://git.kernel.org/stable/c/9b3bd97acb4f8954b8a43a5d63ed9050d463b4e1

------------------------------------------------------------

CVE ID: CVE-2022-49428
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check on inline_dots inode

As Wenqing reported in bugzilla:

https://bugzilla.kernel.org/show_bug.cgi?id=215765

It will cause a kernel panic with steps:
- mkdir mnt
- mount tmp40.img mnt
- ls mnt

folio_mark_dirty+0x33/0x50
f2fs_add_regular_entry+0x541/0xad0 [f2fs]
f2fs_add_dentry+0x6c/0xb0 [f2fs]
f2fs_do_add_link+0x182/0x230 [f2fs]
__recover_dot_dentries+0x2d6/0x470 [f2fs]
f2fs_lookup+0x5af/0x6a0 [f2fs]
__lookup_slow+0xac/0x200
lookup_slow+0x45/0x70
walk_component+0x16c/0x250
path_lookupat+0x8b/0x1f0
filename_lookup+0xef/0x250
user_path_at_empty+0x46/0x70
vfs_statx+0x98/0x190
__do_sys_newlstat+0x41/0x90
__x64_sys_newlstat+0x1a/0x30
do_syscall_64+0x37/0xb0
entry_SYSCALL_64_after_hwframe+0x44/0xae

The root cause is for special file: e.g. character, block, fifo or
socket file, f2fs doesn't assign address space operations pointer array
for mapping->a_ops field, so, in a fuzzed image, if inline_dots flag was
tagged in special file, during lookup(), when f2fs runs into
__recover_dot_dentries(), it will cause NULL pointer access once
f2fs_add_regular_entry() calls a_ops->set_dirty_page().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/12662d19467b391b5b509ac5e9ab4f583c6dde16
  - https://git.kernel.org/stable/c/250e5a6be52a6b9d82fe91976c83cc158868b4e9
  - https://git.kernel.org/stable/c/2f46160d0a19b13bfe96c0dd50eed5c5d253ab7a
  - https://git.kernel.org/stable/c/34f48ce5d5936eea33e3b6415403e57eb84aff97

------------------------------------------------------------

CVE ID: CVE-2022-49429
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/hfi1: Prevent panic when SDMA is disabled

If the hfi1 module is loaded with HFI1_CAP_SDMA off, a call to
hfi1_write_iter() will dereference a NULL pointer and panic. A typical
stack frame is:

  sdma_select_user_engine [hfi1]
  hfi1_user_sdma_process_request [hfi1]
  hfi1_write_iter [hfi1]
  do_iter_readv_writev
  do_iter_write
  vfs_writev
  do_writev
  do_syscall_64

The fix is to test for SDMA in hfi1_write_iter() and fail the I/O with
EINVAL.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e4dda8b3f4c07ee9ea670a10ea3171a5e63a86f
  - https://git.kernel.org/stable/c/22e7e400fd1a890db2ea13686324aff50e972f4f
  - https://git.kernel.org/stable/c/29952ab85d6c3fe0b7909d9a737f10c58bf6824d
  - https://git.kernel.org/stable/c/32e6aea33944f364d51cd263e4cd236393a188b6
  - https://git.kernel.org/stable/c/33794e8e9bcb4affc0ebff9cdec85acc8b8a1762
  - https://git.kernel.org/stable/c/629e052d0c98e46dde9f0824f0aa437f678d9b8f
  - https://git.kernel.org/stable/c/cc80d3c37cec9d6ddb140483647901bc7cc6c31d
  - https://git.kernel.org/stable/c/e60ad83f645ee6fadd5a8057ba267aeec54f08fe

------------------------------------------------------------

CVE ID: CVE-2022-49430
Description: In the Linux kernel, the following vulnerability has been resolved:

Input: gpio-keys - cancel delayed work only in case of GPIO

gpio_keys module can either accept gpios or interrupts. The module
initializes delayed work in case of gpios only and is only used if
debounce timer is not used, so make sure cancel_delayed_work_sync()
is called only when its gpio-backed and debounce_use_hrtimer is false.

This fixes the issue seen below when the gpio_keys module is unloaded and
an interrupt pin is used instead of GPIO:

[  360.297569] ------------[ cut here ]------------
[  360.302303] WARNING: CPU: 0 PID: 237 at kernel/workqueue.c:3066 __flush_work+0x414/0x470
[  360.310531] Modules linked in: gpio_keys(-)
[  360.314797] CPU: 0 PID: 237 Comm: rmmod Not tainted 5.18.0-rc5-arm64-renesas-00116-g73636105874d-dirty #166
[  360.324662] Hardware name: Renesas SMARC EVK based on r9a07g054l2 (DT)
[  360.331270] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[  360.338318] pc : __flush_work+0x414/0x470
[  360.342385] lr : __cancel_work_timer+0x140/0x1b0
[  360.347065] sp : ffff80000a7fba00
[  360.350423] x29: ffff80000a7fba00 x28: ffff000012b9c5c0 x27: 0000000000000000
[  360.357664] x26: ffff80000a7fbb80 x25: ffff80000954d0a8 x24: 0000000000000001
[  360.364904] x23: ffff800009757000 x22: 0000000000000000 x21: ffff80000919b000
[  360.372143] x20: ffff00000f5974e0 x19: ffff00000f5974e0 x18: ffff8000097fcf48
[  360.379382] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000053f40
[  360.386622] x14: ffff800009850e88 x13: 0000000000000002 x12: 000000000000a60c
[  360.393861] x11: 000000000000a610 x10: 0000000000000000 x9 : 0000000000000008
[  360.401100] x8 : 0101010101010101 x7 : 00000000a473c394 x6 : 0080808080808080
[  360.408339] x5 : 0000000000000001 x4 : 0000000000000000 x3 : ffff80000919b458
[  360.415578] x2 : ffff8000097577f0 x1 : 0000000000000001 x0 : 0000000000000000
[  360.422818] Call trace:
[  360.425299]  __flush_work+0x414/0x470
[  360.429012]  __cancel_work_timer+0x140/0x1b0
[  360.433340]  cancel_delayed_work_sync+0x10/0x18
[  360.437931]  gpio_keys_quiesce_key+0x28/0x58 [gpio_keys]
[  360.443327]  devm_action_release+0x10/0x18
[  360.447481]  release_nodes+0x8c/0x1a0
[  360.451194]  devres_release_all+0x90/0x100
[  360.455346]  device_unbind_cleanup+0x14/0x60
[  360.459677]  device_release_driver_internal+0xe8/0x168
[  360.464883]  driver_detach+0x4c/0x90
[  360.468509]  bus_remove_driver+0x54/0xb0
[  360.472485]  driver_unregister+0x2c/0x58
[  360.476462]  platform_driver_unregister+0x10/0x18
[  360.481230]  gpio_keys_exit+0x14/0x828 [gpio_keys]
[  360.486088]  __arm64_sys_delete_module+0x1e0/0x270
[  360.490945]  invoke_syscall+0x40/0xf8
[  360.494661]  el0_svc_common.constprop.3+0xf0/0x110
[  360.499515]  do_el0_svc+0x20/0x78
[  360.502877]  el0_svc+0x48/0xf8
[  360.505977]  el0t_64_sync_handler+0x88/0xb0
[  360.510216]  el0t_64_sync+0x148/0x14c
[  360.513930] irq event stamp: 4306
[  360.517288] hardirqs last  enabled at (4305): [<ffff8000080b0300>] __cancel_work_timer+0x130/0x1b0
[  360.526359] hardirqs last disabled at (4306): [<ffff800008d194fc>] el1_dbg+0x24/0x88
[  360.534204] softirqs last  enabled at (4278): [<ffff8000080104a0>] _stext+0x4a0/0x5e0
[  360.542133] softirqs last disabled at (4267): [<ffff8000080932ac>] irq_exit_rcu+0x18c/0x1b0
[  360.550591] ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4160e09619086fc155b51ccdb3462a3f233a5f4b
  - https://git.kernel.org/stable/c/8b1ae300c2953257c146b5f0757537935c0b6027
  - https://git.kernel.org/stable/c/96c460687813915dedca9dd7d04ae0e90607fd79
  - https://git.kernel.org/stable/c/cee409bbba0d1bd3fb73064fb480ff365f453b5d

------------------------------------------------------------

CVE ID: CVE-2022-49431
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/iommu: Add missing of_node_put in iommu_init_early_dart

The device_node pointer is returned by of_find_compatible_node
with refcount incremented. We should use of_node_put() to avoid
the refcount leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/57b742a5b8945118022973e6416b71351df512fb
  - https://git.kernel.org/stable/c/7e3f1dfb9e21733d7276bc9ccea4daada163f2ba
  - https://git.kernel.org/stable/c/8657e8ea23325949091da72453ba84fb73cc2bd9
  - https://git.kernel.org/stable/c/cb4f2dc513e99c5d0485661f114e4dda73612d10
  - https://git.kernel.org/stable/c/df6d8b689252c0acc0448d4ae3d33f2d6db048ab
  - https://git.kernel.org/stable/c/dfc308d6f29aa28463deb9a12278a85a382385ca

------------------------------------------------------------

CVE ID: CVE-2022-49432
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/xics: fix refcount leak in icp_opal_init()

The of_find_compatible_node() function returns a node pointer with
refcount incremented, use of_node_put() on it when done.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d5c8cea85fb1680eae8d645b96b92146cb4633c
  - https://git.kernel.org/stable/c/2357bd7499a81c70b460e2191852bbfc7b63c354
  - https://git.kernel.org/stable/c/537a317e5ff45d1f5a0ecaf6a0d7c8043c878cb1
  - https://git.kernel.org/stable/c/53f3f7f73e609b934083f896cb7ca2c2cb009b9f
  - https://git.kernel.org/stable/c/5dd9e27ea4a39f7edd4bf81e9e70208e7ac0b7c9
  - https://git.kernel.org/stable/c/6a61a97106279c2aa16fbbb2a171fd5dde127d23
  - https://git.kernel.org/stable/c/977dbc81d0f866ef63b93c127b7404f07734b3cc
  - https://git.kernel.org/stable/c/9a42bc2494fadb453de00ce61042e588563ddc6d
  - https://git.kernel.org/stable/c/df802880a7f9cd96b921b00639b00871f18a9a57

------------------------------------------------------------

CVE ID: CVE-2022-49433
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/hfi1: Prevent use of lock before it is initialized

If there is a failure during probe of hfi1 before the sdma_map_lock is
initialized, the call to hfi1_free_devdata() will attempt to use a lock
that has not been initialized. If the locking correctness validator is on
then an INFO message and stack trace resembling the following may be seen:

  INFO: trying to register non-static key.
  The code is fine but needs lockdep annotation, or maybe
  you didn't initialize this object before use?
  turning off the locking correctness validator.
  Call Trace:
  register_lock_class+0x11b/0x880
  __lock_acquire+0xf3/0x7930
  lock_acquire+0xff/0x2d0
  _raw_spin_lock_irq+0x46/0x60
  sdma_clean+0x42a/0x660 [hfi1]
  hfi1_free_devdata+0x3a7/0x420 [hfi1]
  init_one+0x867/0x11a0 [hfi1]
  pci_device_probe+0x40e/0x8d0

The use of sdma_map_lock in sdma_clean() is for freeing the sdma_map
memory, and sdma_map is not allocated/initialized until after
sdma_map_lock has been initialized. This code only needs to be run if
sdma_map is not NULL, and so checking for that condition will avoid trying
to use the lock before it is initialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/05c03dfd09c069c4ffd783b47b2da5dcc9421f2c
  - https://git.kernel.org/stable/c/288d198f50434f29b4a26a9de4394ae2305ad8af
  - https://git.kernel.org/stable/c/30eb275e7ed588270ae159cc590a96658e0cfd8f
  - https://git.kernel.org/stable/c/66090815a24ce14cf51ef5453fc0218fe8a39bc2
  - https://git.kernel.org/stable/c/addb192000d8819c0b1553453994df9bb54c28db
  - https://git.kernel.org/stable/c/ca55150bff5817af4f857a746ecab9862c23e12a
  - https://git.kernel.org/stable/c/fc0750e659db7b315bf6348902cc8ca3cdd4b8d8

------------------------------------------------------------

CVE ID: CVE-2022-49434
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: Avoid pci_dev_lock() AB/BA deadlock with sriov_numvfs_store()

The sysfs sriov_numvfs_store() path acquires the device lock before the
config space access lock:

  sriov_numvfs_store
    device_lock                 # A (1) acquire device lock
    sriov_configure
      vfio_pci_sriov_configure  # (for example)
        vfio_pci_core_sriov_configure
          pci_disable_sriov
            sriov_disable
              pci_cfg_access_lock
                pci_wait_cfg    # B (4) wait for dev->block_cfg_access == 0

Previously, pci_dev_lock() acquired the config space access lock before the
device lock:

  pci_dev_lock
    pci_cfg_access_lock
      dev->block_cfg_access = 1 # B (2) set dev->block_cfg_access = 1
    device_lock                 # A (3) wait for device lock

Any path that uses pci_dev_lock(), e.g., pci_reset_function(), may
deadlock with sriov_numvfs_store() if the operations occur in the sequence
(1) (2) (3) (4).

Avoid the deadlock by reversing the order in pci_dev_lock() so it acquires
the device lock before the config space access lock, the same as the
sriov_numvfs_store() path.

[bhelgaas: combined and adapted commit log from Jay Zhou's independent
subsequent posting:
https://lore.kernel.org/r/20220404062539.1710-1-jianjay.zhou@huawei.com]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2cdd5284035322795b0964f899eefba254cfe483
  - https://git.kernel.org/stable/c/59ea6b3ae51df7cd6bfd84c9c0030609b9315622
  - https://git.kernel.org/stable/c/a91ee0e9fca9d7501286cfbced9b30a33e52740a
  - https://git.kernel.org/stable/c/aed6d4d519210c28817948f34c53b6e058e0456c
  - https://git.kernel.org/stable/c/c3c6dc1853b8bf3c718f96fd8480a6eb09ba4831
  - https://git.kernel.org/stable/c/c9a81f9ed6ae3554621d6a50220b1bc74b67d81e
  - https://git.kernel.org/stable/c/da9792920ab525b8a932aa9aeee34529ad7b83f7
  - https://git.kernel.org/stable/c/ea047f51172aa68841adef7f52d375002438b8f0
  - https://git.kernel.org/stable/c/eff3587b9c01439b738298475e555c028ac9f55e

------------------------------------------------------------

CVE ID: CVE-2022-49435
Description: In the Linux kernel, the following vulnerability has been resolved:

mfd: davinci_voicecodec: Fix possible null-ptr-deref davinci_vc_probe()

It will cause null-ptr-deref when using 'res', if platform_get_resource()
returns NULL, so move using 'res' after devm_ioremap_resource() that
will check it to avoid null-ptr-deref.
And use devm_platform_get_and_ioremap_resource() to simplify code.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d00158a06efe6bbcd020108634ea0f2ed8b32f7
  - https://git.kernel.org/stable/c/311242c7703df0da14c206260b7e855f69cb0264
  - https://git.kernel.org/stable/c/49c1e32e7b3f301642a60448700ec531df981269
  - https://git.kernel.org/stable/c/5289795824b77489803b0802cd9edc13824a2d0b
  - https://git.kernel.org/stable/c/579944b9f38727d9ff570b58f83bc424e8af8398
  - https://git.kernel.org/stable/c/a1d4941d9a24999f680799f9bbde7f57351ca637

------------------------------------------------------------

CVE ID: CVE-2022-49436
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/papr_scm: Fix leaking nvdimm_events_map elements

Right now 'char *' elements allocated for individual 'stat_id' in
'papr_scm_priv.nvdimm_events_map[]' during papr_scm_pmu_check_events(), get
leaked in papr_scm_remove() and papr_scm_pmu_register(),
papr_scm_pmu_check_events() error paths.

Also individual 'stat_id' arent NULL terminated 'char *' instead they are fixed
8-byte sized identifiers. However papr_scm_pmu_register() assumes it to be a
NULL terminated 'char *' and at other places it assumes it to be a
'papr_scm_perf_stat.stat_id' sized string which is 8-byes in size.

Fix this by allocating the memory for papr_scm_priv.nvdimm_events_map to also
include space for 'stat_id' entries. This is possible since number of available
events/stat_ids are known upfront. This saves some memory and one extra level of
indirection from 'nvdimm_events_map' to 'stat_id'. Also rest of the code
can continue to call 'kfree(papr_scm_priv.nvdimm_events_map)' without needing to
iterate over the array and free up individual elements.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e0946e22f3665d27325d389ff45ade6e93f3678
  - https://git.kernel.org/stable/c/b073096df4dec70d0436321b7093bad27ae91f9e

------------------------------------------------------------

CVE ID: CVE-2022-49437
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/xive: Fix refcount leak in xive_spapr_init

of_find_compatible_node() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1d1fb9618bdd5a5fbf9a9eb75133da301d33721c
  - https://git.kernel.org/stable/c/65f11ccdd746e0e7f0b469cc989ba43d4f30ecfe
  - https://git.kernel.org/stable/c/6e806485d851986a2445267608f27cb4ba2ed774
  - https://git.kernel.org/stable/c/cc62dde2a5f4ba14016fd9caec76f08d388f4b9c

------------------------------------------------------------

CVE ID: CVE-2022-49438
Description: In the Linux kernel, the following vulnerability has been resolved:

Input: sparcspkr - fix refcount leak in bbc_beep_probe

of_find_node_by_path() calls of_find_node_opts_by_path(),
which returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.26, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1124e39fea0e2fdb4202f95b716cb97cc7de7cc7
  - https://git.kernel.org/stable/c/2f51db16cb740ff90086189a1ef2581eab665591
  - https://git.kernel.org/stable/c/353bc58ac6c782d4dcde9136a91d1f90867938fe
  - https://git.kernel.org/stable/c/418b6a3e12f75638abc5673eb76cb32127d0ab13
  - https://git.kernel.org/stable/c/6e07ccc7d56130f760d23f67a70c45366c07debc
  - https://git.kernel.org/stable/c/73d6f42d8d86648bec2e73d34fe1648cb6d23e08
  - https://git.kernel.org/stable/c/bbc2b0ce6042dd3117827f10ea8cb67e0ab786da
  - https://git.kernel.org/stable/c/c8994b30d71d64d5dcc9bc0edbfdf367171aa96f
  - https://git.kernel.org/stable/c/f13064b0f2c651a3fbb0749932795c6fd21556a8

------------------------------------------------------------

CVE ID: CVE-2022-49439
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/fsl_rio: Fix refcount leak in fsl_rio_setup

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.3, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/46fd994763cf6884b88a2da712af918f3ed54d7b
  - https://git.kernel.org/stable/c/51e25fbf20c9152d84a34b7afac15a41fe5c9116
  - https://git.kernel.org/stable/c/5607a77a365df8c0fd5ff43ac424812b95775527
  - https://git.kernel.org/stable/c/5b8aa2ba38c010f47c965dd9bb5a8561813ed649
  - https://git.kernel.org/stable/c/7b668a59ddfb32727e39b06fdf52b28e58c684e0
  - https://git.kernel.org/stable/c/bcb6c4c5eb4836a21411dfe8247bf9951eb6e7c3
  - https://git.kernel.org/stable/c/c70dd353d37158e06bf8d450d4b31a7091609924
  - https://git.kernel.org/stable/c/fcee96924ba1596ca80a6770b2567ca546f9a482

------------------------------------------------------------

CVE ID: CVE-2022-49440
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/rtas: Keep MSR[RI] set when calling RTAS

RTAS runs in real mode (MSR[DR] and MSR[IR] unset) and in 32-bit big
endian mode (MSR[SF,LE] unset).

The change in MSR is done in enter_rtas() in a relatively complex way,
since the MSR value could be hardcoded.

Furthermore, a panic has been reported when hitting the watchdog interrupt
while running in RTAS, this leads to the following stack trace:

  watchdog: CPU 24 Hard LOCKUP
  watchdog: CPU 24 TB:997512652051031, last heartbeat TB:997504470175378 (15980ms ago)
  ...
  Supported: No, Unreleased kernel
  CPU: 24 PID: 87504 Comm: drmgr Kdump: loaded Tainted: G            E  X    5.14.21-150400.71.1.bz196362_2-default #1 SLE15-SP4 (unreleased) 0d821077ef4faa8dfaf370efb5fdca1fa35f4e2c
  NIP:  000000001fb41050 LR: 000000001fb4104c CTR: 0000000000000000
  REGS: c00000000fc33d60 TRAP: 0100   Tainted: G            E  X     (5.14.21-150400.71.1.bz196362_2-default)
  MSR:  8000000002981000 <SF,VEC,VSX,ME>  CR: 48800002  XER: 20040020
  CFAR: 000000000000011c IRQMASK: 1
  GPR00: 0000000000000003 ffffffffffffffff 0000000000000001 00000000000050dc
  GPR04: 000000001ffb6100 0000000000000020 0000000000000001 000000001fb09010
  GPR08: 0000000020000000 0000000000000000 0000000000000000 0000000000000000
  GPR12: 80040000072a40a8 c00000000ff8b680 0000000000000007 0000000000000034
  GPR16: 000000001fbf6e94 000000001fbf6d84 000000001fbd1db0 000000001fb3f008
  GPR20: 000000001fb41018 ffffffffffffffff 000000000000017f fffffffffffff68f
  GPR24: 000000001fb18fe8 000000001fb3e000 000000001fb1adc0 000000001fb1cf40
  GPR28: 000000001fb26000 000000001fb460f0 000000001fb17f18 000000001fb17000
  NIP [000000001fb41050] 0x1fb41050
  LR [000000001fb4104c] 0x1fb4104c
  Call Trace:
  Instruction dump:
  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
  Oops: Unrecoverable System Reset, sig: 6 [#1]
  LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries
  ...
  Supported: No, Unreleased kernel
  CPU: 24 PID: 87504 Comm: drmgr Kdump: loaded Tainted: G            E  X    5.14.21-150400.71.1.bz196362_2-default #1 SLE15-SP4 (unreleased) 0d821077ef4faa8dfaf370efb5fdca1fa35f4e2c
  NIP:  000000001fb41050 LR: 000000001fb4104c CTR: 0000000000000000
  REGS: c00000000fc33d60 TRAP: 0100   Tainted: G            E  X     (5.14.21-150400.71.1.bz196362_2-default)
  MSR:  8000000002981000 <SF,VEC,VSX,ME>  CR: 48800002  XER: 20040020
  CFAR: 000000000000011c IRQMASK: 1
  GPR00: 0000000000000003 ffffffffffffffff 0000000000000001 00000000000050dc
  GPR04: 000000001ffb6100 0000000000000020 0000000000000001 000000001fb09010
  GPR08: 0000000020000000 0000000000000000 0000000000000000 0000000000000000
  GPR12: 80040000072a40a8 c00000000ff8b680 0000000000000007 0000000000000034
  GPR16: 000000001fbf6e94 000000001fbf6d84 000000001fbd1db0 000000001fb3f008
  GPR20: 000000001fb41018 ffffffffffffffff 000000000000017f fffffffffffff68f
  GPR24: 000000001fb18fe8 000000001fb3e000 000000001fb1adc0 000000001fb1cf40
  GPR28: 000000001fb26000 000000001fb460f0 000000001fb17f18 000000001fb17000
  NIP [000000001fb41050] 0x1fb41050
  LR [000000001fb4104c] 0x1fb4104c
  Call Trace:
  Instruction dump:
  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
  ---[ end trace 3ddec07f638c34a2 ]---

This happens because MSR[RI] is unset when entering RTAS but there is no
valid reason to not set it here.

RTAS is expected to be called with MSR[RI] as specified in PAPR+ section
"7.2.1 Machine State":

  R1–7.2.1–9. If called with MSR[RI] equal to 1, then RTAS must protect
  its own critical regions from recursion by setting the MSR[RI] bit to
  0 when in the critical regions.

Fixing this by reviewing the way MSR is compute before calling RTAS. Now a
hardcoded value meaning real 
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5ca40fcf0da0ce2b5bc44e7d8b036535955f2e3d
  - https://git.kernel.org/stable/c/5f4367448f6817c8a0e94dc9736ed84fa8eee4a3
  - https://git.kernel.org/stable/c/b6b1c3ce06ca438eb24e0f45bf0e63ecad0369f5
  - https://git.kernel.org/stable/c/c9c41f0273826a13ac93124e66a4ff45df281ba0

------------------------------------------------------------

CVE ID: CVE-2022-49441
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: fix deadlock caused by calling printk() under tty_port->lock

pty_write() invokes kmalloc() which may invoke a normal printk() to print
failure message.  This can cause a deadlock in the scenario reported by
syz-bot below:

       CPU0              CPU1                    CPU2
       ----              ----                    ----
                         lock(console_owner);
                                                 lock(&port_lock_key);
  lock(&port->lock);
                         lock(&port_lock_key);
                                                 lock(&port->lock);
  lock(console_owner);

As commit dbdda842fe96 ("printk: Add console owner and waiter logic to
load balance console writes") said, such deadlock can be prevented by
using printk_deferred() in kmalloc() (which is invoked in the section
guarded by the port->lock).  But there are too many printk() on the
kmalloc() path, and kmalloc() can be called from anywhere, so changing
printk() to printk_deferred() is too complicated and inelegant.

Therefore, this patch chooses to specify __GFP_NOWARN to kmalloc(), so
that printk() will not be called, and this deadlock problem can be
avoided.

Syzbot reported the following lockdep error:

======================================================
WARNING: possible circular locking dependency detected
5.4.143-00237-g08ccc19a-dirty #10 Not tainted
------------------------------------------------------
syz-executor.4/29420 is trying to acquire lock:
ffffffff8aedb2a0 (console_owner){....}-{0:0}, at: console_trylock_spinning kernel/printk/printk.c:1752 [inline]
ffffffff8aedb2a0 (console_owner){....}-{0:0}, at: vprintk_emit+0x2ca/0x470 kernel/printk/printk.c:2023

but task is already holding lock:
ffff8880119c9158 (&port->lock){-.-.}-{2:2}, at: pty_write+0xf4/0x1f0 drivers/tty/pty.c:120

which lock already depends on the new lock.

the existing dependency chain (in reverse order) is:

-> #2 (&port->lock){-.-.}-{2:2}:
       __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
       _raw_spin_lock_irqsave+0x35/0x50 kernel/locking/spinlock.c:159
       tty_port_tty_get drivers/tty/tty_port.c:288 [inline]          		<-- lock(&port->lock);
       tty_port_default_wakeup+0x1d/0xb0 drivers/tty/tty_port.c:47
       serial8250_tx_chars+0x530/0xa80 drivers/tty/serial/8250/8250_port.c:1767
       serial8250_handle_irq.part.0+0x31f/0x3d0 drivers/tty/serial/8250/8250_port.c:1854
       serial8250_handle_irq drivers/tty/serial/8250/8250_port.c:1827 [inline] 	<-- lock(&port_lock_key);
       serial8250_default_handle_irq+0xb2/0x220 drivers/tty/serial/8250/8250_port.c:1870
       serial8250_interrupt+0xfd/0x200 drivers/tty/serial/8250/8250_core.c:126
       __handle_irq_event_percpu+0x109/0xa50 kernel/irq/handle.c:156
       [...]

-> #1 (&port_lock_key){-.-.}-{2:2}:
       __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
       _raw_spin_lock_irqsave+0x35/0x50 kernel/locking/spinlock.c:159
       serial8250_console_write+0x184/0xa40 drivers/tty/serial/8250/8250_port.c:3198
										<-- lock(&port_lock_key);
       call_console_drivers kernel/printk/printk.c:1819 [inline]
       console_unlock+0x8cb/0xd00 kernel/printk/printk.c:2504
       vprintk_emit+0x1b5/0x470 kernel/printk/printk.c:2024			<-- lock(console_owner);
       vprintk_func+0x8d/0x250 kernel/printk/printk_safe.c:394
       printk+0xba/0xed kernel/printk/printk.c:2084
       register_console+0x8b3/0xc10 kernel/printk/printk.c:2829
       univ8250_console_init+0x3a/0x46 drivers/tty/serial/8250/8250_core.c:681
       console_init+0x49d/0x6d3 kernel/printk/printk.c:2915
       start_kernel+0x5e9/0x879 init/main.c:713
       secondary_startup_64+0xa4/0xb0 arch/x86/kernel/head_64.S:241

-> #0 (console_owner){....}-{0:0}:
       [...]
       lock_acquire+0x127/0x340 kernel/locking/lockdep.c:4734
       console_trylock_spinning kernel/printk/printk.c:1773 
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18.118, Last Version (Excluding): 3.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.146, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.117, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.60, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.17.12, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/04ee31678c128a6cc7bb057ea189a8624ba5a314
  - https://git.kernel.org/stable/c/0bcf44903ef4df742dcada86ccaedd25374ffb50
  - https://git.kernel.org/stable/c/18ca0d55e8639b911df8aae1b47598b13f9acded
  - https://git.kernel.org/stable/c/3219ac364ac3d8d30771612a6010f1e0b7fa0a28
  - https://git.kernel.org/stable/c/4af21b12a60ed2d3642284f4f85b42d7dc6ac246
  - https://git.kernel.org/stable/c/4c253caf9264d2aa47ee806a87986dd8eb91a5d9
  - https://git.kernel.org/stable/c/6b9dbedbe3499fef862c4dff5217cf91f34e43b3
  - https://git.kernel.org/stable/c/9834b13e8b962caa28fbcf1f422dd82413da4ede
  - https://git.kernel.org/stable/c/b3c974501d0c32258ae0e04e5cc3fb92383b40f6

------------------------------------------------------------

CVE ID: CVE-2022-49442
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers/base/node.c: fix compaction sysfs file leak

Compaction sysfs file is created via compaction_register_node in
register_node.  But we forgot to remove it in unregister_node.  Thus
compaction sysfs file is leaked.  Using compaction_unregister_node to fix
this issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/386e69e068177ee91cac27f2f0e6ebda1515f5ca
  - https://git.kernel.org/stable/c/39642b0feddb9c39faa6de469a94bfeb4dc0d3a9
  - https://git.kernel.org/stable/c/466134df7561aeb801baddf6666b512e0e1a1707
  - https://git.kernel.org/stable/c/606732650a2c88e66c59c22dd5464ea0d820250e
  - https://git.kernel.org/stable/c/6905be93d1ab54f73718047536fec0ca488d5315
  - https://git.kernel.org/stable/c/b3fcf1f583b1a0946d9d9bfb7362c9c186801775
  - https://git.kernel.org/stable/c/d8a5bdc767f17281da648555cdbd286f98fd98ee
  - https://git.kernel.org/stable/c/da63dc84befaa9e6079a0bc363ff0eaa975f9073
  - https://git.kernel.org/stable/c/f76ddc8fcf6d81fe89bfa4d3efcbc4fe69a91d48

------------------------------------------------------------

CVE ID: CVE-2022-49443
Description: In the Linux kernel, the following vulnerability has been resolved:

list: fix a data-race around ep->rdllist

ep_poll() first calls ep_events_available() with no lock held and checks
if ep->rdllist is empty by list_empty_careful(), which reads
rdllist->prev.  Thus all accesses to it need some protection to avoid
store/load-tearing.

Note INIT_LIST_HEAD_RCU() already has the annotation for both prev
and next.

Commit bf3b9f6372c4 ("epoll: Add busy poll support to epoll with socket
fds.") added the first lockless ep_events_available(), and commit
c5a282e9635e ("fs/epoll: reduce the scope of wq lock in epoll_wait()")
made some ep_events_available() calls lockless and added single call under
a lock, finally commit e59d3c64cba6 ("epoll: eliminate unnecessary lock
for zero timeout") made the last ep_events_available() lockless.

BUG: KCSAN: data-race in do_epoll_wait / do_epoll_wait

write to 0xffff88810480c7d8 of 8 bytes by task 1802 on cpu 0:
 INIT_LIST_HEAD include/linux/list.h:38 [inline]
 list_splice_init include/linux/list.h:492 [inline]
 ep_start_scan fs/eventpoll.c:622 [inline]
 ep_send_events fs/eventpoll.c:1656 [inline]
 ep_poll fs/eventpoll.c:1806 [inline]
 do_epoll_wait+0x4eb/0xf40 fs/eventpoll.c:2234
 do_epoll_pwait fs/eventpoll.c:2268 [inline]
 __do_sys_epoll_pwait fs/eventpoll.c:2281 [inline]
 __se_sys_epoll_pwait+0x12b/0x240 fs/eventpoll.c:2275
 __x64_sys_epoll_pwait+0x74/0x80 fs/eventpoll.c:2275
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x44/0xae

read to 0xffff88810480c7d8 of 8 bytes by task 1799 on cpu 1:
 list_empty_careful include/linux/list.h:329 [inline]
 ep_events_available fs/eventpoll.c:381 [inline]
 ep_poll fs/eventpoll.c:1797 [inline]
 do_epoll_wait+0x279/0xf40 fs/eventpoll.c:2234
 do_epoll_pwait fs/eventpoll.c:2268 [inline]
 __do_sys_epoll_pwait fs/eventpoll.c:2281 [inline]
 __se_sys_epoll_pwait+0x12b/0x240 fs/eventpoll.c:2275
 __x64_sys_epoll_pwait+0x74/0x80 fs/eventpoll.c:2275
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x44/0xae

value changed: 0xffff88810480c7d0 -> 0xffff888103c15098

Reported by Kernel Concurrency Sanitizer on:
CPU: 1 PID: 1799 Comm: syz-fuzzer Tainted: G        W         5.17.0-rc7-syzkaller-dirty #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/5d5d993f16be15d124be7b8ec71b28ef7b7dc3af
  - https://git.kernel.org/stable/c/cb3e48f7a35033deb9455abe3932e63cb500b9eb
  - https://git.kernel.org/stable/c/d679ae94fdd5d3ab00c35078f5af5f37e068b03d
  - https://git.kernel.org/stable/c/e039c0b5985999b150594126225e1ee51df7b4c9

------------------------------------------------------------

CVE ID: CVE-2022-49444
Description: In the Linux kernel, the following vulnerability has been resolved:

module: fix [e_shstrndx].sh_size=0 OOB access

It is trivial to craft a module to trigger OOB access in this line:

	if (info->secstrings[strhdr->sh_size - 1] != '\0') {

BUG: unable to handle page fault for address: ffffc90000aa0fff
PGD 100000067 P4D 100000067 PUD 100066067 PMD 10436f067 PTE 0
Oops: 0000 [#1] PREEMPT SMP PTI
CPU: 7 PID: 1215 Comm: insmod Not tainted 5.18.0-rc5-00007-g9bf578647087-dirty #10
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04/01/2014
RIP: 0010:load_module+0x19b/0x2391

[rebased patch onto modules-next]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09cb6663618a74fe5572a4931ecbf098832e79ec
  - https://git.kernel.org/stable/c/391e982bfa632b8315235d8be9c0a81374c6a19c
  - https://git.kernel.org/stable/c/45a76414b6d8b8b39c23fea53b9d20e831ae72a0
  - https://git.kernel.org/stable/c/921630e2e5124a04158129a8f22f4b425e61a858

------------------------------------------------------------

CVE ID: CVE-2022-49445
Description: In the Linux kernel, the following vulnerability has been resolved:

pinctrl: renesas: core: Fix possible null-ptr-deref in sh_pfc_map_resources()

It will cause null-ptr-deref when using 'res', if platform_get_resource()
returns NULL, so move using 'res' after devm_ioremap_resource() that
will check it to avoid null-ptr-deref.
And use devm_platform_get_and_ioremap_resource() to simplify code.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.3, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/5376e3d904532e657fd7ca1a9b1ff3d351527b90
  - https://git.kernel.org/stable/c/5ed0519d425619b435150372cce2ffeec71581fa
  - https://git.kernel.org/stable/c/e3a1ad8fd0ac11f4fa1260c23b5db71a25473254
  - https://git.kernel.org/stable/c/f991879762392c19661af5b722578089a12b305f
  - https://git.kernel.org/stable/c/fb4f022b3ad1f3ff3cafdbc7d51896090ae17701

------------------------------------------------------------

CVE ID: CVE-2022-49446
Description: In the Linux kernel, the following vulnerability has been resolved:

nvdimm: Fix firmware activation deadlock scenarios

Lockdep reports the following deadlock scenarios for CXL root device
power-management, device_prepare(), operations, and device_shutdown()
operations for 'nd_region' devices:

 Chain exists of:
   &nvdimm_region_key --> &nvdimm_bus->reconfig_mutex --> system_transition_mutex

  Possible unsafe locking scenario:

        CPU0                    CPU1
        ----                    ----
   lock(system_transition_mutex);
                                lock(&nvdimm_bus->reconfig_mutex);
                                lock(system_transition_mutex);
   lock(&nvdimm_region_key);

 Chain exists of:
   &cxl_nvdimm_bridge_key --> acpi_scan_lock --> &cxl_root_key

  Possible unsafe locking scenario:

        CPU0                    CPU1
        ----                    ----
   lock(&cxl_root_key);
                                lock(acpi_scan_lock);
                                lock(&cxl_root_key);
   lock(&cxl_nvdimm_bridge_key);

These stem from holding nvdimm_bus_lock() over hibernate_quiet_exec()
which walks the entire system device topology taking device_lock() along
the way. The nvdimm_bus_lock() is protecting against unregistration,
multiple simultaneous ops callers, and preventing activate_show() from
racing activate_store(). For the first 2, the lock is redundant.
Unregistration already flushes all ops users, and sysfs already prevents
multiple threads to be active in an ops handler at the same time. For
the last userspace should already be waiting for its last
activate_store() to complete, and does not need activate_show() to flush
the write side, so this lock usage can be deleted in these attributes.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.9, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/2f97ebc58d5fc83ca1528cd553fa725472ab3ca8
  - https://git.kernel.org/stable/c/2fd853fdb40afc052de338693df1372f2ead7be7
  - https://git.kernel.org/stable/c/641649f31e20df630310f5c22f26c071acc676d4
  - https://git.kernel.org/stable/c/ceb924ee16b2c8e48dcac3d9ad6be01c40b5a228
  - https://git.kernel.org/stable/c/e6829d1bd3c4b58296ee9e412f7ed4d6cb390192

------------------------------------------------------------

CVE ID: CVE-2022-49447
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: hisi: Add missing of_node_put after of_find_compatible_node

of_find_compatible_node  will increment the refcount of the returned
device_node. Calling of_node_put() to avoid the refcount leak
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/21a3effe446dd6dc5eed7fe897c2f9b88c9a5d6d
  - https://git.kernel.org/stable/c/45d211668d33c49d73f5213e8c2b58468108647c
  - https://git.kernel.org/stable/c/46cb7868811d025c3d29c10d18b3422db1cf20d5
  - https://git.kernel.org/stable/c/9bc72e47d4630d58a840a66a869c56b29554cfe4
  - https://git.kernel.org/stable/c/a3265a9440030068547a20dfee646666f3ca5278
  - https://git.kernel.org/stable/c/cafaaae4bb9ce84a2791fa29bf6907a9466c3883
  - https://git.kernel.org/stable/c/dd4be8ecfb41a29e7c4e551b4e866157ce4a3429
  - https://git.kernel.org/stable/c/e109058165137ef42841abd989f080adfefa14fa
  - https://git.kernel.org/stable/c/f8da78b2bae1f54746647a2bb44f8bd6025c57af

------------------------------------------------------------

CVE ID: CVE-2022-49448
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: bcm: Check for NULL return of devm_kzalloc()

As the potential failure of allocation, devm_kzalloc() may return NULL.  Then
the 'pd->pmb' and the follow lines of code may bring null pointer dereference.

Therefore, it is better to check the return value of devm_kzalloc() to avoid
this confusion.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/36339ea7bae4943be01c8e9545e46e334591fecd
  - https://git.kernel.org/stable/c/5650e103bfc70156001615861fb8aafb3947da6e
  - https://git.kernel.org/stable/c/b48b98743b568bb219152ba2e15af6ef0d3d8a9b
  - https://git.kernel.org/stable/c/b4bd2aafacce48db26b0a213d849818d940556dd

------------------------------------------------------------

CVE ID: CVE-2022-49449
Description: In the Linux kernel, the following vulnerability has been resolved:

pinctrl: renesas: rzn1: Fix possible null-ptr-deref in sh_pfc_map_resources()

It will cause null-ptr-deref when using 'res', if platform_get_resource()
returns NULL, so move using 'res' after devm_ioremap_resource() that
will check it to avoid null-ptr-deref.
And use devm_platform_get_and_ioremap_resource() to simplify code.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/01f9e02e0f13df3fd291676dc80054e977be1601
  - https://git.kernel.org/stable/c/2f661477c2bb8068194dbba9738d05219f111c6e
  - https://git.kernel.org/stable/c/34c719b8fdfbd0c7c54cae56e6b0f16e9f8bf03e
  - https://git.kernel.org/stable/c/b646e0cfeb38bf5f1944fd548f1dfa9b129fa00c
  - https://git.kernel.org/stable/c/c16b59d445135c8026a04e388d8b2762feaa3b3b

------------------------------------------------------------

CVE ID: CVE-2022-49450
Description: In the Linux kernel, the following vulnerability has been resolved:

rxrpc: Fix listen() setting the bar too high for the prealloc rings

AF_RXRPC's listen() handler lets you set the backlog up to 32 (if you bump
up the sysctl), but whilst the preallocation circular buffers have 32 slots
in them, one of them has to be a dead slot because we're using CIRC_CNT().

This means that listen(rxrpc_sock, 32) will cause an oops when the socket
is closed because rxrpc_service_prealloc_one() allocated one too many calls
and rxrpc_discard_prealloc() won't then be able to get rid of them because
it'll think the ring is empty.  rxrpc_release_calls_on_socket() then tries
to abort them, but oopses because call->peer isn't yet set.

Fix this by setting the maximum backlog to RXRPC_BACKLOG_MAX - 1 to match
the ring capacity.

 BUG: kernel NULL pointer dereference, address: 0000000000000086
 ...
 RIP: 0010:rxrpc_send_abort_packet+0x73/0x240 [rxrpc]
 Call Trace:
  <TASK>
  ? __wake_up_common_lock+0x7a/0x90
  ? rxrpc_notify_socket+0x8e/0x140 [rxrpc]
  ? rxrpc_abort_call+0x4c/0x60 [rxrpc]
  rxrpc_release_calls_on_socket+0x107/0x1a0 [rxrpc]
  rxrpc_release+0xc9/0x1c0 [rxrpc]
  __sock_release+0x37/0xa0
  sock_close+0x11/0x20
  __fput+0x89/0x240
  task_work_run+0x59/0x90
  do_exit+0x319/0xaa0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/369de57492c4f1a42563c5a3bd365822ca3bfc79
  - https://git.kernel.org/stable/c/4a3a78b7918bdd723d8c7c9786522ca969bffcc4
  - https://git.kernel.org/stable/c/5b4826657d36c218e9f08e8d3223b0edce3de88f
  - https://git.kernel.org/stable/c/616f76498d5ddf26b997caf64a95cda3c8a55533
  - https://git.kernel.org/stable/c/61fb38cfbb1d54d3dafd0c25752f684b3cd00b32
  - https://git.kernel.org/stable/c/88e22159750b0d55793302eeed8ee603f5c1a95c
  - https://git.kernel.org/stable/c/91b34bf0409f43bb60453bab23c5beadd726d022
  - https://git.kernel.org/stable/c/b3a9b227d5e7467b8518160ff034ea22bb9de573
  - https://git.kernel.org/stable/c/e198f1930050e3115c80b67d9249f80f98a27c67

------------------------------------------------------------

CVE ID: CVE-2022-49451
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: arm_scmi: Fix list protocols enumeration in the base protocol

While enumerating protocols implemented by the SCMI platform using
BASE_DISCOVER_LIST_PROTOCOLS, the number of returned protocols is
currently validated in an improper way since the check employs a sum
between unsigned integers that could overflow and cause the check itself
to be silently bypassed if the returned value 'loop_num_ret' is big
enough.

Fix the validation avoiding the addition.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.17, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1052f22e127d0c34c3387bb389424ba1c61491ff
  - https://git.kernel.org/stable/c/2ccfcd7a09c826516edcfe464b05071961aada3f
  - https://git.kernel.org/stable/c/444a2d27fe9867d0da4b28fc45b793f32e099ab8
  - https://git.kernel.org/stable/c/6e7978695f4a6cbd83616b5a702b77fa2087b247
  - https://git.kernel.org/stable/c/8009120e0354a67068e920eb10dce532391361d0
  - https://git.kernel.org/stable/c/98342148a8cd242855d7e257f298c966c96dba9f
  - https://git.kernel.org/stable/c/b0e4bafac8963c2d85ee18d3d01f393735acceec

------------------------------------------------------------

CVE ID: CVE-2022-49452
Description: In the Linux kernel, the following vulnerability has been resolved:

dpaa2-eth: retrieve the virtual address before dma_unmap

The TSO header was DMA unmapped before the virtual address was retrieved
and then used to free the buffer. This meant that we were actually
removing the DMA map and then trying to search for it to help in
retrieving the virtual address. This lead to a invalid virtual address
being used in the kfree call.

Fix this by calling dpaa2_iova_to_virt() prior to the dma_unmap call.

[  487.231819] Unable to handle kernel paging request at virtual address fffffd9807000008

(...)

[  487.354061] Hardware name: SolidRun LX2160A Honeycomb (DT)
[  487.359535] pstate: a0400005 (NzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[  487.366485] pc : kfree+0xac/0x304
[  487.369799] lr : kfree+0x204/0x304
[  487.373191] sp : ffff80000c4eb120
[  487.376493] x29: ffff80000c4eb120 x28: ffff662240c46400 x27: 0000000000000001
[  487.383621] x26: 0000000000000001 x25: ffff662246da0cc0 x24: ffff66224af78000
[  487.390748] x23: ffffad184f4ce008 x22: ffffad1850185000 x21: ffffad1838d13cec
[  487.397874] x20: ffff6601c0000000 x19: fffffd9807000000 x18: 0000000000000000
[  487.405000] x17: ffffb910cdc49000 x16: ffffad184d7d9080 x15: 0000000000004000
[  487.412126] x14: 0000000000000008 x13: 000000000000ffff x12: 0000000000000000
[  487.419252] x11: 0000000000000004 x10: 0000000000000001 x9 : ffffad184d7d927c
[  487.426379] x8 : 0000000000000000 x7 : 0000000ffffffd1d x6 : ffff662240a94900
[  487.433505] x5 : 0000000000000003 x4 : 0000000000000009 x3 : ffffad184f4ce008
[  487.440632] x2 : ffff662243eec000 x1 : 0000000100000100 x0 : fffffc0000000000
[  487.447758] Call trace:
[  487.450194]  kfree+0xac/0x304
[  487.453151]  dpaa2_eth_free_tx_fd.isra.0+0x33c/0x3e0 [fsl_dpaa2_eth]
[  487.459507]  dpaa2_eth_tx_conf+0x100/0x2e0 [fsl_dpaa2_eth]
[  487.464989]  dpaa2_eth_poll+0xdc/0x380 [fsl_dpaa2_eth]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/06d129946a71f3159b3b40ee95549183edf2c79d
  - https://git.kernel.org/stable/c/ba5fe3dd4833bbc03609c5c0c2dd2cea5fa5addf

------------------------------------------------------------

CVE ID: CVE-2022-49453
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: ti: ti_sci_pm_domains: Check for null return of devm_kcalloc

The allocation funciton devm_kcalloc may fail and return a null pointer,
which would cause a null-pointer dereference later.
It might be better to check it and directly return -ENOMEM just like the
usage of devm_kcalloc in previous code.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/01ba41a359622ab256ce4d4f8b94c67165ae3daf
  - https://git.kernel.org/stable/c/05efc4591f80582b6fe53366b70b6a35a42fd255
  - https://git.kernel.org/stable/c/7cef9274fa1b8506949d74bc45aef072b890824a
  - https://git.kernel.org/stable/c/ba56291e297d28aa6eb82c5c1964fae2d7594746
  - https://git.kernel.org/stable/c/c4e188869406b47ac3350920bf165be303cb1c96

------------------------------------------------------------

CVE ID: CVE-2022-49454
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: mediatek: Fix refcount leak in mtk_pcie_subsys_powerup()

The of_find_compatible_node() function returns a node pointer with
refcount incremented, We should use of_node_put() on it when done
Add the missing of_node_put() to release the refcount.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/09b2d906d78ddf5042b1f3e0091835fc6997e8a4
  - https://git.kernel.org/stable/c/214e0d8fe4a813ae6ffd62bc2dfe7544c20914f4
  - https://git.kernel.org/stable/c/4cef4237d6c37257cb6ddc397723e9c0dded0efe
  - https://git.kernel.org/stable/c/ad1c9d13e04509ae24fae8dd2897148657323519

------------------------------------------------------------

CVE ID: CVE-2022-49455
Description: In the Linux kernel, the following vulnerability has been resolved:

misc: ocxl: fix possible double free in ocxl_file_register_afu

info_release() will be called in device_unregister() when info->dev's
reference count is 0. So there is no need to call ocxl_afu_put() and
kfree() again.

Fix this by adding free_minor() and return to err_unregister error path.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/252768d32e92c1214aeebb5fec0844ca479bcf5c
  - https://git.kernel.org/stable/c/8fb674216835e1f0c143762696d645facebb4685
  - https://git.kernel.org/stable/c/950cf957fe34d40d63dfa3bf3968210430b6491e
  - https://git.kernel.org/stable/c/9e9087cf34ee69f4e95d146ac29385d6e367a97b
  - https://git.kernel.org/stable/c/de65c32ace9aa70d51facc61ba986607075e3a25
  - https://git.kernel.org/stable/c/ee89d8dee55ab4b3b8ad8b70866b2841ba334767

------------------------------------------------------------

CVE ID: CVE-2022-49456
Description: In the Linux kernel, the following vulnerability has been resolved:

bonding: fix missed rcu protection

When removing the rcu_read_lock in bond_ethtool_get_ts_info() as
discussed [1], I didn't notice it could be called via setsockopt,
which doesn't hold rcu lock, as syzbot pointed:

  stack backtrace:
  CPU: 0 PID: 3599 Comm: syz-executor317 Not tainted 5.18.0-rc5-syzkaller-01392-g01f4685797a5 #0
  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
  Call Trace:
   <TASK>
   __dump_stack lib/dump_stack.c:88 [inline]
   dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
   bond_option_active_slave_get_rcu include/net/bonding.h:353 [inline]
   bond_ethtool_get_ts_info+0x32c/0x3a0 drivers/net/bonding/bond_main.c:5595
   __ethtool_get_ts_info+0x173/0x240 net/ethtool/common.c:554
   ethtool_get_phc_vclocks+0x99/0x110 net/ethtool/common.c:568
   sock_timestamping_bind_phc net/core/sock.c:869 [inline]
   sock_set_timestamping+0x3a3/0x7e0 net/core/sock.c:916
   sock_setsockopt+0x543/0x2ec0 net/core/sock.c:1221
   __sys_setsockopt+0x55e/0x6a0 net/socket.c:2223
   __do_sys_setsockopt net/socket.c:2238 [inline]
   __se_sys_setsockopt net/socket.c:2235 [inline]
   __x64_sys_setsockopt+0xba/0x150 net/socket.c:2235
   do_syscall_x64 arch/x86/entry/common.c:50 [inline]
   do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
   entry_SYSCALL_64_after_hwframe+0x44/0xae
  RIP: 0033:0x7f8902c8eb39

Fix it by adding rcu_read_lock and take a ref on the real_dev.
Since dev_hold() and dev_put() can take NULL these days, we can
skip checking if real_dev exist.

[1] https://lore.kernel.org/netdev/27565.1642742439@famine/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b66a533c47d29b38af8e05fbb53b609a5ba3a4e
  - https://git.kernel.org/stable/c/85eed460681da71b359ed906bce4d800081db854
  - https://git.kernel.org/stable/c/9b80ccda233fa6c59de411bf889cc4d0e028f2c7

------------------------------------------------------------

CVE ID: CVE-2022-49457
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: versatile: Add missing of_node_put in dcscb_init

The device_node pointer is returned by of_find_compatible_node
with refcount incremented. We should use of_node_put() to avoid
the refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/23b44f9c649bbef10b45fa33080cd8b4166800ae
  - https://git.kernel.org/stable/c/2d7b23db35254b7d46e852967090c64cdccf24da
  - https://git.kernel.org/stable/c/3c6006faed9aba5144b33176d061031a9be66954
  - https://git.kernel.org/stable/c/83c329b980bddbc8c6a3d287d91f2103a4d4a860
  - https://git.kernel.org/stable/c/a0fc05cd17617e63fc13ad0c01f3f0afd890d8ec
  - https://git.kernel.org/stable/c/bbdfb7d4f036118d36415a2575efa6f5246505ae
  - https://git.kernel.org/stable/c/d146e2a9864ade19914494de3fb520390b415d58
  - https://git.kernel.org/stable/c/d6de7b181c29cd4578ec139aafb5eac062abbe1b
  - https://git.kernel.org/stable/c/fcd1999ba97445a12cc394f5f42ffd9116bf0185

------------------------------------------------------------

CVE ID: CVE-2022-49458
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm: don't free the IRQ if it was not requested

As msm_drm_uninit() is called from the msm_drm_init() error path,
additional care should be necessary as not to call the free_irq() for
the IRQ that was not requested before (because an error occured earlier
than the request_irq() call).

This fixed the issue reported with the following backtrace:

[    8.571329] Trying to free already-free IRQ 187
[    8.571339] WARNING: CPU: 0 PID: 76 at kernel/irq/manage.c:1895 free_irq+0x1e0/0x35c
[    8.588746] Modules linked in: pmic_glink pdr_interface fastrpc qrtr_smd snd_soc_hdmi_codec msm fsa4480 gpu_sched drm_dp_aux_bus qrtr i2c_qcom_geni crct10dif_ce qcom_stats qcom_q6v5_pas drm_display_helper gpi qcom_pil_info drm_kms_helper qcom_q6v5 qcom_sysmon qcom_common qcom_glink_smem qcom_rng mdt_loader qmi_helpers phy_qcom_qmp ufs_qcom typec qnoc_sm8350 socinfo rmtfs_mem fuse drm ipv6
[    8.624154] CPU: 0 PID: 76 Comm: kworker/u16:2 Not tainted 5.18.0-rc5-next-20220506-00033-g6cee8cab6089-dirty #419
[    8.624161] Hardware name: Qualcomm Technologies, Inc. SM8350 HDK (DT)
[    8.641496] Workqueue: events_unbound deferred_probe_work_func
[    8.647510] pstate: 604000c5 (nZCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[    8.654681] pc : free_irq+0x1e0/0x35c
[    8.658454] lr : free_irq+0x1e0/0x35c
[    8.662228] sp : ffff800008ab3950
[    8.665642] x29: ffff800008ab3950 x28: 0000000000000000 x27: ffff16350f56a700
[    8.672994] x26: ffff1635025df080 x25: ffff16350251badc x24: ffff16350251bb90
[    8.680343] x23: 0000000000000000 x22: 00000000000000bb x21: ffff16350e8f9800
[    8.687690] x20: ffff16350251ba00 x19: ffff16350cbd5880 x18: ffffffffffffffff
[    8.695039] x17: 0000000000000000 x16: ffffa2dd12179434 x15: ffffa2dd1431d02d
[    8.702391] x14: 0000000000000000 x13: ffffa2dd1431d028 x12: 662d79646165726c
[    8.709740] x11: ffffa2dd13fd2438 x10: 000000000000000a x9 : 00000000000000bb
[    8.717111] x8 : ffffa2dd13fd23f0 x7 : ffff800008ab3750 x6 : 00000000fffff202
[    8.724487] x5 : ffff16377e870a18 x4 : 00000000fffff202 x3 : ffff735a6ae1b000
[    8.731851] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff1635015f8000
[    8.739217] Call trace:
[    8.741755]  free_irq+0x1e0/0x35c
[    8.745198]  msm_drm_uninit.isra.0+0x14c/0x294 [msm]
[    8.750548]  msm_drm_bind+0x28c/0x5d0 [msm]
[    8.755081]  try_to_bring_up_aggregate_device+0x164/0x1d0
[    8.760657]  __component_add+0xa0/0x170
[    8.764626]  component_add+0x14/0x20
[    8.768337]  dp_display_probe+0x2a4/0x464 [msm]
[    8.773242]  platform_probe+0x68/0xe0
[    8.777043]  really_probe.part.0+0x9c/0x28c
[    8.781368]  __driver_probe_device+0x98/0x144
[    8.785871]  driver_probe_device+0x40/0x140
[    8.790191]  __device_attach_driver+0xb4/0x120
[    8.794788]  bus_for_each_drv+0x78/0xd0
[    8.798751]  __device_attach+0xdc/0x184
[    8.802713]  device_initial_probe+0x14/0x20
[    8.807031]  bus_probe_device+0x9c/0xa4
[    8.810991]  deferred_probe_work_func+0x88/0xc0
[    8.815667]  process_one_work+0x1d0/0x320
[    8.819809]  worker_thread+0x14c/0x444
[    8.823688]  kthread+0x10c/0x110
[    8.827036]  ret_from_fork+0x10/0x20

Patchwork: https://patchwork.freedesktop.org/patch/485422/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/577e2a9dfc8fba7938aaf75db63fae7e328cc3cb
  - https://git.kernel.org/stable/c/59023c4fb1ab3de0fa001681650f662c253c7fd7
  - https://git.kernel.org/stable/c/b288ec4439c1dad304c1862bf6b0be78d9b1b2b2
  - https://git.kernel.org/stable/c/beb81c13d020ceb7f8693e65464162e5f249218e

------------------------------------------------------------

CVE ID: CVE-2022-49459
Description: In the Linux kernel, the following vulnerability has been resolved:

thermal/drivers/broadcom: Fix potential NULL dereference in sr_thermal_probe

platform_get_resource() may return NULL, add proper check to
avoid potential NULL dereferencing.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.1, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/61621e042c22b47d1eadee617bdd26835294b425
  - https://git.kernel.org/stable/c/79098339ac2065f4b4352ef5921628970b6f47e6
  - https://git.kernel.org/stable/c/b3461ccaa5d2588568d865faee285512ad448049
  - https://git.kernel.org/stable/c/e20d136ec7d6f309989c447638365840d3424c8e
  - https://git.kernel.org/stable/c/ee9b6b02e8c140323ed46d6602d805ea735c7719
  - https://git.kernel.org/stable/c/ef1235c6514a58f274246cf4a2d5f4e40af539ce

------------------------------------------------------------

CVE ID: CVE-2022-49460
Description: In the Linux kernel, the following vulnerability has been resolved:

PM / devfreq: rk3399_dmc: Disable edev on remove()

Otherwise we hit an unablanced enable-count when unbinding the DFI
device:

[ 1279.659119] ------------[ cut here ]------------
[ 1279.659179] WARNING: CPU: 2 PID: 5638 at drivers/devfreq/devfreq-event.c:360 devfreq_event_remove_edev+0x84/0x8c
...
[ 1279.659352] Hardware name: Google Kevin (DT)
[ 1279.659363] pstate: 80400005 (Nzcv daif +PAN -UAO -TCO BTYPE=--)
[ 1279.659371] pc : devfreq_event_remove_edev+0x84/0x8c
[ 1279.659380] lr : devm_devfreq_event_release+0x1c/0x28
...
[ 1279.659571] Call trace:
[ 1279.659582]  devfreq_event_remove_edev+0x84/0x8c
[ 1279.659590]  devm_devfreq_event_release+0x1c/0x28
[ 1279.659602]  release_nodes+0x1cc/0x244
[ 1279.659611]  devres_release_all+0x44/0x60
[ 1279.659621]  device_release_driver_internal+0x11c/0x1ac
[ 1279.659629]  device_driver_detach+0x20/0x2c
[ 1279.659641]  unbind_store+0x7c/0xb0
[ 1279.659650]  drv_attr_store+0x2c/0x40
[ 1279.659663]  sysfs_kf_write+0x44/0x58
[ 1279.659672]  kernfs_fop_write_iter+0xf4/0x190
[ 1279.659684]  vfs_write+0x2b0/0x2e4
[ 1279.659693]  ksys_write+0x80/0xec
[ 1279.659701]  __arm64_sys_write+0x24/0x30
[ 1279.659714]  el0_svc_common+0xf0/0x1d8
[ 1279.659724]  do_el0_svc_compat+0x28/0x3c
[ 1279.659738]  el0_svc_compat+0x10/0x1c
[ 1279.659746]  el0_sync_compat_handler+0xa8/0xcc
[ 1279.659758]  el0_sync_compat+0x188/0x1c0
[ 1279.659768] ---[ end trace cec200e5094155b4 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2fccf9e6050e0e3b8b4cd275d41daf7f7fa22804
  - https://git.kernel.org/stable/c/664736e2cc09e504ce58ec61164d029d1f2651bb
  - https://git.kernel.org/stable/c/86b091b6894c449d2734de7aa7d79ccb33ffd97d
  - https://git.kernel.org/stable/c/a0180e324a9a63de8f770da300477b48cb4a53f1
  - https://git.kernel.org/stable/c/a9c2b23a7ac6ab19214cad8cac8af8608a4d9cef
  - https://git.kernel.org/stable/c/cb1be1d4be18fe286ba5a67d928598378fd7fbe5
  - https://git.kernel.org/stable/c/fb089b6f21de03a685dd31df3789bbb01c59f8e3

------------------------------------------------------------

CVE ID: CVE-2022-49461
Description: In the Linux kernel, the following vulnerability has been resolved:

amt: fix memory leak for advertisement message

When a gateway receives an advertisement message, it extracts relay
information and then it should be freed.
But the advertisement handler doesn't free it.
So, memory leak would occur.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/19bb2d57eac86a368839a92117d8a10ab7183623
  - https://git.kernel.org/stable/c/e7322da399fb86a2072f008b56f7160afa1b2051
  - https://git.kernel.org/stable/c/fe29794c3585d039fefebaa2b5a4932a627ad4fd

------------------------------------------------------------

CVE ID: CVE-2022-49462
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/a6xx: Fix refcount leak in a6xx_gpu_init

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.

a6xx_gmu_init() passes the node to of_find_device_by_node()
and of_dma_configure(), of_find_device_by_node() will takes its
reference, of_dma_configure() doesn't need the node after usage.

Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/06907a374f1b74f8f2fb30720dc6df81331e4fb5
  - https://git.kernel.org/stable/c/48e82ce8cdb19c20a5020fa446b286d6a147450c
  - https://git.kernel.org/stable/c/65ddbc0d26824e2a5d6154d01d8cf39344900213
  - https://git.kernel.org/stable/c/6832e36f156ea35a6ed74bca72727806116effdd
  - https://git.kernel.org/stable/c/c56de483093d7ad0782327f95dda7da97bc4c315
  - https://git.kernel.org/stable/c/edff4c1af831d0c02e654eed9da7d74174de49d5

------------------------------------------------------------

CVE ID: CVE-2022-49463
Description: In the Linux kernel, the following vulnerability has been resolved:

thermal/drivers/imx_sc_thermal: Fix refcount leak in imx_sc_thermal_probe

of_find_node_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/09700c504d8e63faffd2a2235074e8c5d130cb8f
  - https://git.kernel.org/stable/c/0ec10303c10833c1bcba7a1bde2f297e494d5464
  - https://git.kernel.org/stable/c/3ade442ea5d3512a3c67984489ab4d8a6fb3b29f
  - https://git.kernel.org/stable/c/8bbf522a2c51ef939d0e8835e236bfcd252193af
  - https://git.kernel.org/stable/c/ec0925b731697db7cab5944a3e55d2d58bb3d075

------------------------------------------------------------

CVE ID: CVE-2022-49464
Description: In the Linux kernel, the following vulnerability has been resolved:

erofs: fix buffer copy overflow of ztailpacking feature

I got some KASAN report as below:

[   46.959738] ==================================================================
[   46.960430] BUG: KASAN: use-after-free in z_erofs_shifted_transform+0x2bd/0x370
[   46.960430] Read of size 4074 at addr ffff8880300c2f8e by task fssum/188
...
[   46.960430] Call Trace:
[   46.960430]  <TASK>
[   46.960430]  dump_stack_lvl+0x41/0x5e
[   46.960430]  print_report.cold+0xb2/0x6b7
[   46.960430]  ? z_erofs_shifted_transform+0x2bd/0x370
[   46.960430]  kasan_report+0x8a/0x140
[   46.960430]  ? z_erofs_shifted_transform+0x2bd/0x370
[   46.960430]  kasan_check_range+0x14d/0x1d0
[   46.960430]  memcpy+0x20/0x60
[   46.960430]  z_erofs_shifted_transform+0x2bd/0x370
[   46.960430]  z_erofs_decompress_pcluster+0xaae/0x1080

The root cause is that the tail pcluster won't be a complete filesystem
block anymore. So if ztailpacking is used, the second part of an
uncompressed tail pcluster may not be ``rq->pageofs_out``.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/4d53a625f29074e7b8236c2c0e0922edb7608df9
  - https://git.kernel.org/stable/c/6b59e1907f58cf877c563dcf013159eb9f994b64
  - https://git.kernel.org/stable/c/dcbe6803fffd387f72b48c2373b5f5ed12a5804b

------------------------------------------------------------

CVE ID: CVE-2022-49465
Description: In the Linux kernel, the following vulnerability has been resolved:

blk-throttle: Set BIO_THROTTLED when bio has been throttled

1.In current process, all bio will set the BIO_THROTTLED flag
after __blk_throtl_bio().

2.If bio needs to be throttled, it will start the timer and
stop submit bio directly. Bio will submit in
blk_throtl_dispatch_work_fn() when the timer expires.But in
the current process, if bio is throttled. The BIO_THROTTLED
will be set to bio after timer start. If the bio has been
completed, it may cause use-after-free blow.

BUG: KASAN: use-after-free in blk_throtl_bio+0x12f0/0x2c70
Read of size 2 at addr ffff88801b8902d4 by task fio/26380

 dump_stack+0x9b/0xce
 print_address_description.constprop.6+0x3e/0x60
 kasan_report.cold.9+0x22/0x3a
 blk_throtl_bio+0x12f0/0x2c70
 submit_bio_checks+0x701/0x1550
 submit_bio_noacct+0x83/0xc80
 submit_bio+0xa7/0x330
 mpage_readahead+0x380/0x500
 read_pages+0x1c1/0xbf0
 page_cache_ra_unbounded+0x471/0x6f0
 do_page_cache_ra+0xda/0x110
 ondemand_readahead+0x442/0xae0
 page_cache_async_ra+0x210/0x300
 generic_file_buffered_read+0x4d9/0x2130
 generic_file_read_iter+0x315/0x490
 blkdev_read_iter+0x113/0x1b0
 aio_read+0x2ad/0x450
 io_submit_one+0xc8e/0x1d60
 __se_sys_io_submit+0x125/0x350
 do_syscall_64+0x2d/0x40
 entry_SYSCALL_64_after_hwframe+0x44/0xa9

Allocated by task 26380:
 kasan_save_stack+0x19/0x40
 __kasan_kmalloc.constprop.2+0xc1/0xd0
 kmem_cache_alloc+0x146/0x440
 mempool_alloc+0x125/0x2f0
 bio_alloc_bioset+0x353/0x590
 mpage_alloc+0x3b/0x240
 do_mpage_readpage+0xddf/0x1ef0
 mpage_readahead+0x264/0x500
 read_pages+0x1c1/0xbf0
 page_cache_ra_unbounded+0x471/0x6f0
 do_page_cache_ra+0xda/0x110
 ondemand_readahead+0x442/0xae0
 page_cache_async_ra+0x210/0x300
 generic_file_buffered_read+0x4d9/0x2130
 generic_file_read_iter+0x315/0x490
 blkdev_read_iter+0x113/0x1b0
 aio_read+0x2ad/0x450
 io_submit_one+0xc8e/0x1d60
 __se_sys_io_submit+0x125/0x350
 do_syscall_64+0x2d/0x40
 entry_SYSCALL_64_after_hwframe+0x44/0xa9

Freed by task 0:
 kasan_save_stack+0x19/0x40
 kasan_set_track+0x1c/0x30
 kasan_set_free_info+0x1b/0x30
 __kasan_slab_free+0x111/0x160
 kmem_cache_free+0x94/0x460
 mempool_free+0xd6/0x320
 bio_free+0xe0/0x130
 bio_put+0xab/0xe0
 bio_endio+0x3a6/0x5d0
 blk_update_request+0x590/0x1370
 scsi_end_request+0x7d/0x400
 scsi_io_completion+0x1aa/0xe50
 scsi_softirq_done+0x11b/0x240
 blk_mq_complete_request+0xd4/0x120
 scsi_mq_done+0xf0/0x200
 virtscsi_vq_done+0xbc/0x150
 vring_interrupt+0x179/0x390
 __handle_irq_event_percpu+0xf7/0x490
 handle_irq_event_percpu+0x7b/0x160
 handle_irq_event+0xcc/0x170
 handle_edge_irq+0x215/0xb20
 common_interrupt+0x60/0x120
 asm_common_interrupt+0x1e/0x40

Fix this by move BIO_THROTTLED set into the queue_lock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0cfc8a0fb07cde61915e4a77c4794c47de3114a4
  - https://git.kernel.org/stable/c/5a011f889b4832aa80c2a872a5aade5c48d2756f
  - https://git.kernel.org/stable/c/935fa666534d7b7185e8c6b0191cd06281be4290

------------------------------------------------------------

CVE ID: CVE-2022-49466
Description: In the Linux kernel, the following vulnerability has been resolved:

regulator: scmi: Fix refcount leak in scmi_regulator_probe

of_find_node_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/299a002161c7bfb72e99ba45e5b660aecc344ea0
  - https://git.kernel.org/stable/c/4a59c763ef9b68c711dc2fd2ef4a6648da5480ee
  - https://git.kernel.org/stable/c/68d6c8476fd4f448e70e0ab31ff972838ac41dae
  - https://git.kernel.org/stable/c/9ebbfa73d69909b7c737f599fd4ebd42318fc881

------------------------------------------------------------

CVE ID: CVE-2022-49467
Description: In the Linux kernel, the following vulnerability has been resolved:

drm: msm: fix possible memory leak in mdp5_crtc_cursor_set()

drm_gem_object_lookup will call drm_gem_object_get inside. So cursor_bo
needs to be put when msm_gem_get_and_pin_iova fails.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/33546183c16c7b9650682dc610bedd732d9c6919
  - https://git.kernel.org/stable/c/449374565f349d4233beec811d4286fdfe5de44b
  - https://git.kernel.org/stable/c/656aa3c51fc662064f17179b38ec3ce43af53bca
  - https://git.kernel.org/stable/c/947a844bb3ebff0f4736d244d792ce129f6700d7
  - https://git.kernel.org/stable/c/d544880482a5558ec06393b1b3d5dc9275b7a32b
  - https://git.kernel.org/stable/c/d63ffe3fb3f8327ca21cf91b6a14a2961bc629b4
  - https://git.kernel.org/stable/c/f8cd192752a1f613b14eee77783c6f0aebb49691

------------------------------------------------------------

CVE ID: CVE-2022-49468
Description: In the Linux kernel, the following vulnerability has been resolved:

thermal/core: Fix memory leak in __thermal_cooling_device_register()

I got memory leak as follows when doing fault injection test:

unreferenced object 0xffff888010080000 (size 264312):
  comm "182", pid 102533, jiffies 4296434960 (age 10.100s)
  hex dump (first 32 bytes):
    00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N..........
    ff ff ff ff ff ff ff ff 40 7f 1f b9 ff ff ff ff  ........@.......
  backtrace:
    [<0000000038b2f4fc>] kmalloc_order_trace+0x1d/0x110 mm/slab_common.c:969
    [<00000000ebcb8da5>] __kmalloc+0x373/0x420 include/linux/slab.h:510
    [<0000000084137f13>] thermal_cooling_device_setup_sysfs+0x15d/0x2d0 include/linux/slab.h:586
    [<00000000352b8755>] __thermal_cooling_device_register+0x332/0xa60 drivers/thermal/thermal_core.c:927
    [<00000000fb9f331b>] devm_thermal_of_cooling_device_register+0x6b/0xf0 drivers/thermal/thermal_core.c:1041
    [<000000009b8012d2>] max6650_probe.cold+0x557/0x6aa drivers/hwmon/max6650.c:211
    [<00000000da0b7e04>] i2c_device_probe+0x472/0xac0 drivers/i2c/i2c-core-base.c:561

If device_register() fails, thermal_cooling_device_destroy_sysfs() need be called
to free the memory allocated in thermal_cooling_device_setup_sysfs().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/18530bedd221160823f63ccc20dd55c7a03edbcf
  - https://git.kernel.org/stable/c/21ccc58b671aea924f2481cf5c1cf0ebbfd3552d
  - https://git.kernel.org/stable/c/3802171f0b5b8b831f4ade5c827547cb323a5bb2
  - https://git.kernel.org/stable/c/98a160e898c0f4a979af9de3ab48b4b1d42d1dbb
  - https://git.kernel.org/stable/c/9abdf0c0184230f0cb5c6685aabf33dda89aa9fb

------------------------------------------------------------

CVE ID: CVE-2022-49469
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix anon_dev leak in create_subvol()

When btrfs_qgroup_inherit(), btrfs_alloc_tree_block, or
btrfs_insert_root() fail in create_subvol(), we return without freeing
anon_dev. Reorganize the error handling in create_subvol() to fix this.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2256e901f5bddc56e24089c96f27b77da932dfcc
  - https://git.kernel.org/stable/c/7a875ad8706f0903a0e812e0dd701956ee9826ff
  - https://git.kernel.org/stable/c/d887b3de318834f9aa637ecf79c6bc66cba7c69a

------------------------------------------------------------

CVE ID: CVE-2022-49470
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btmtksdio: fix use-after-free at btmtksdio_recv_event

We should not access skb buffer data anymore after hci_recv_frame was
called.

[   39.634809] BUG: KASAN: use-after-free in btmtksdio_recv_event+0x1b0
[   39.634855] Read of size 1 at addr ffffff80cf28a60d by task kworker
[   39.634962] Call trace:
[   39.634974]  dump_backtrace+0x0/0x3b8
[   39.634999]  show_stack+0x20/0x2c
[   39.635016]  dump_stack_lvl+0x60/0x78
[   39.635040]  print_address_description+0x70/0x2f0
[   39.635062]  kasan_report+0x154/0x194
[   39.635079]  __asan_report_load1_noabort+0x44/0x50
[   39.635099]  btmtksdio_recv_event+0x1b0/0x1c4
[   39.635129]  btmtksdio_txrx_work+0x6cc/0xac4
[   39.635157]  process_one_work+0x560/0xc5c
[   39.635177]  worker_thread+0x7ec/0xcc0
[   39.635195]  kthread+0x2d0/0x3d0
[   39.635215]  ret_from_fork+0x10/0x20
[   39.635247] Allocated by task 0:
[   39.635260] (stack is not available)
[   39.635281] Freed by task 2392:
[   39.635295]  kasan_save_stack+0x38/0x68
[   39.635319]  kasan_set_track+0x28/0x3c
[   39.635338]  kasan_set_free_info+0x28/0x4c
[   39.635357]  ____kasan_slab_free+0x104/0x150
[   39.635374]  __kasan_slab_free+0x18/0x28
[   39.635391]  slab_free_freelist_hook+0x114/0x248
[   39.635410]  kfree+0xf8/0x2b4
[   39.635427]  skb_free_head+0x58/0x98
[   39.635447]  skb_release_data+0x2f4/0x410
[   39.635464]  skb_release_all+0x50/0x60
[   39.635481]  kfree_skb+0xc8/0x25c
[   39.635498]  hci_event_packet+0x894/0xca4 [bluetooth]
[   39.635721]  hci_rx_work+0x1c8/0x68c [bluetooth]
[   39.635925]  process_one_work+0x560/0xc5c
[   39.635951]  worker_thread+0x7ec/0xcc0
[   39.635970]  kthread+0x2d0/0x3d0
[   39.635990]  ret_from_fork+0x10/0x20
[   39.636021] The buggy address belongs to the object at ffffff80cf28a600
                which belongs to the cache kmalloc-512 of size 512
[   39.636039] The buggy address is located 13 bytes inside of
                512-byte region [ffffff80cf28a600, ffffff80cf28a800)
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 5.15.54
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/01c6a899fa6be4f4cbf60c4f44f0f6691155415f
  - https://git.kernel.org/stable/c/02ba31e09a26e8cd4582ac8e6163d80284997727
  - https://git.kernel.org/stable/c/0fab6361c4ba17d1b43a991bef4238a3c1754d35
  - https://git.kernel.org/stable/c/b3cec8a42fcd11d05313c724f27e01b1db77522c

------------------------------------------------------------

CVE ID: CVE-2022-49471
Description: In the Linux kernel, the following vulnerability has been resolved:

rtw89: cfo: check mac_id to avoid out-of-bounds

Somehow, hardware reports incorrect mac_id and pollute memory. Check index
before we access the array.

  UBSAN: array-index-out-of-bounds in rtw89/phy.c:2517:23
  index 188 is out of range for type 's32 [64]'
  CPU: 1 PID: 51550 Comm: irq/35-rtw89_pc Tainted: G           OE
  Call Trace:
   <IRQ>
   show_stack+0x52/0x58
   dump_stack_lvl+0x4c/0x63
   dump_stack+0x10/0x12
   ubsan_epilogue+0x9/0x45
   __ubsan_handle_out_of_bounds.cold+0x44/0x49
   ? __alloc_skb+0x92/0x1d0
   rtw89_phy_cfo_parse+0x44/0x7f [rtw89_core]
   rtw89_core_rx+0x261/0x871 [rtw89_core]
   ? __alloc_skb+0xee/0x1d0
   rtw89_pci_napi_poll+0x3fa/0x4ea [rtw89_pci]
   __napi_poll+0x33/0x1a0
   net_rx_action+0x126/0x260
   ? __queue_work+0x217/0x4c0
   __do_softirq+0xd9/0x315
   ? disable_irq_nosync+0x10/0x10
   do_softirq.part.0+0x6d/0x90
   </IRQ>
   <TASK>
   __local_bh_enable_ip+0x62/0x70
   rtw89_pci_interrupt_threadfn+0x182/0x1a6 [rtw89_pci]
   irq_thread_fn+0x28/0x60
   irq_thread+0xc8/0x190
   ? irq_thread_fn+0x60/0x60
   kthread+0x16b/0x190
   ? irq_thread_check_affinity+0xe0/0xe0
   ? set_kthread_struct+0x50/0x50
   ret_from_fork+0x22/0x30
   </TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/03ed236480aeec8c2fd327a1ea6d711364c495e3
  - https://git.kernel.org/stable/c/97df85871a5b187609d30fca6d85b912d9e02f29
  - https://git.kernel.org/stable/c/c32fafe68298bb599e825c298e1d0ba30186f0a5

------------------------------------------------------------

CVE ID: CVE-2022-49472
Description: In the Linux kernel, the following vulnerability has been resolved:

net: phy: micrel: Allow probing without .driver_data

Currently, if the .probe element is present in the phy_driver structure
and the .driver_data is not, a NULL pointer dereference happens.

Allow passing .probe without .driver_data by inserting NULL checks
for priv->type.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/143878e18001c5a61fcc7ae5c5240323753bb641
  - https://git.kernel.org/stable/c/1e5fbfc2a6f384e3195446c14bbd3bc298eb88c2
  - https://git.kernel.org/stable/c/660dfa033ccc9afb032015b6dc76e846bba42cfb
  - https://git.kernel.org/stable/c/7dcb404662839a4ed1a9703658fee979eb894ca4
  - https://git.kernel.org/stable/c/91e720b32cba25fa58eaa4c88fe957009cffe9f3
  - https://git.kernel.org/stable/c/abb5594ae2ba7b82cce85917cc6337ec5d774837
  - https://git.kernel.org/stable/c/bd219273b4e004a3f853da72e111fc8f81357501
  - https://git.kernel.org/stable/c/f2ef6f7539c68c6bd6c32323d8845ee102b7c450

------------------------------------------------------------

CVE ID: CVE-2022-49473
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: ti: j721e-evm: Fix refcount leak in j721e_soc_probe_*

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not needed anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.9, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/2a3966b950b37a6f10c5f9caee15b4cdcf5a7413
  - https://git.kernel.org/stable/c/510e879420b410d88c612aecc6ca15dc6fe77473
  - https://git.kernel.org/stable/c/554df0f70bff1ace6d2df2fcaddbc9b7bd509de2
  - https://git.kernel.org/stable/c/a34840c4eb3278a7c29c9c57a65ce7541c66f9f2
  - https://git.kernel.org/stable/c/d748ff8fbb3a5296bddd586445dc692b079cbe3d

------------------------------------------------------------

CVE ID: CVE-2022-49474
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: fix dangling sco_conn and use-after-free in sco_sock_timeout

Connecting the same socket twice consecutively in sco_sock_connect()
could lead to a race condition where two sco_conn objects are created
but only one is associated with the socket. If the socket is closed
before the SCO connection is established, the timer associated with the
dangling sco_conn object won't be canceled. As the sock object is being
freed, the use-after-free problem happens when the timer callback
function sco_sock_timeout() accesses the socket. Here's the call trace:

dump_stack+0x107/0x163
? refcount_inc+0x1c/
print_address_description.constprop.0+0x1c/0x47e
? refcount_inc+0x1c/0x7b
kasan_report+0x13a/0x173
? refcount_inc+0x1c/0x7b
check_memory_region+0x132/0x139
refcount_inc+0x1c/0x7b
sco_sock_timeout+0xb2/0x1ba
process_one_work+0x739/0xbd1
? cancel_delayed_work+0x13f/0x13f
? __raw_spin_lock_init+0xf0/0xf0
? to_kthread+0x59/0x85
worker_thread+0x593/0x70e
kthread+0x346/0x35a
? drain_workqueue+0x31a/0x31a
? kthread_bind+0x4b/0x4b
ret_from_fork+0x1f/0x30
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.284, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.238, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.247, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.207, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.146, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.65, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13.17, Last Version (Excluding): 5.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14.4, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/36c644c63bfcaee2d3a426f45e89a9cd09799318
  - https://git.kernel.org/stable/c/390d82733a953c1fabf3de9c9618091a7a9c90a6
  - https://git.kernel.org/stable/c/537f619dea4e3fa8ed1f8f938abffe3615794bcc
  - https://git.kernel.org/stable/c/65d347cb39e2e6bd0c2a745ad7c928998ebb0162
  - https://git.kernel.org/stable/c/6f55fac0af3531cf60d11369454c41f5fc81ab3f
  - https://git.kernel.org/stable/c/7aa1e7d15f8a5b65f67bacb100d8fc033b21efa2
  - https://git.kernel.org/stable/c/7d61dbd7311ab978d8ddac1749a758de4de00374
  - https://git.kernel.org/stable/c/99df16007f4bbf9abfc3478cb17d10f0d7f8906e
  - https://git.kernel.org/stable/c/9de3dc09e56f8deacd2bdbf4cecb71e11a312405

------------------------------------------------------------

CVE ID: CVE-2022-49475
Description: In the Linux kernel, the following vulnerability has been resolved:

spi: spi-fsl-qspi: check return value after calling platform_get_resource_byname()

It will cause null-ptr-deref if platform_get_resource_byname() returns NULL,
we need check the return value.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/10f537219629769498ecb8515e096be213224c24
  - https://git.kernel.org/stable/c/33dda87d04598ac5d9a849218a373443f7d3de66
  - https://git.kernel.org/stable/c/560dcbe1c7a78f597f2167371ebdbe2bca3d0735
  - https://git.kernel.org/stable/c/9d9c84825c3ec359b165c762a424cfdefe87fdd7
  - https://git.kernel.org/stable/c/a2b331ac11e1cac56f5b7d367e9f3c5796deaaed

------------------------------------------------------------

CVE ID: CVE-2022-49476
Description: In the Linux kernel, the following vulnerability has been resolved:

mt76: mt7921: fix kernel crash at mt7921_pci_remove

The crash log shown it is possible that mt7921_irq_handler is called while
devm_free_irq is being handled so mt76_free_device need to be postponed
until devm_free_irq is completed to solve the crash we free the mt76 device
too early.

[ 9299.339655] BUG: kernel NULL pointer dereference, address: 0000000000000008
[ 9299.339705] #PF: supervisor read access in kernel mode
[ 9299.339735] #PF: error_code(0x0000) - not-present page
[ 9299.339768] PGD 0 P4D 0
[ 9299.339786] Oops: 0000 [#1] SMP PTI
[ 9299.339812] CPU: 1 PID: 1624 Comm: prepare-suspend Not tainted 5.15.14-1.fc32.qubes.x86_64 #1
[ 9299.339863] Hardware name: Xen HVM domU, BIOS 4.14.3 01/20/2022
[ 9299.339901] RIP: 0010:mt7921_irq_handler+0x1e/0x70 [mt7921e]
[ 9299.340048] RSP: 0018:ffffa81b80c27cb0 EFLAGS: 00010082
[ 9299.340081] RAX: 0000000000000000 RBX: ffff98a4cb752020 RCX: ffffffffa96211c5
[ 9299.340123] RDX: 0000000000000000 RSI: 00000000000d4204 RDI: ffff98a4cb752020
[ 9299.340165] RBP: ffff98a4c28a62a4 R08: ffff98a4c37a96c0 R09: 0000000080150011
[ 9299.340207] R10: 0000000040000000 R11: 0000000000000000 R12: ffff98a4c4eaa080
[ 9299.340249] R13: ffff98a4c28a6360 R14: ffff98a4cb752020 R15: ffff98a4c28a6228
[ 9299.340297] FS: 00007260840d3740(0000) GS:ffff98a4ef700000(0000) knlGS:0000000000000000
[ 9299.340345] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 9299.340383] CR2: 0000000000000008 CR3: 0000000004c56001 CR4: 0000000000770ee0
[ 9299.340432] PKRU: 55555554
[ 9299.340449] Call Trace:
[ 9299.340467] <TASK>
[ 9299.340485] __free_irq+0x221/0x350
[ 9299.340527] free_irq+0x30/0x70
[ 9299.340553] devm_free_irq+0x55/0x80
[ 9299.340579] mt7921_pci_remove+0x2f/0x40 [mt7921e]
[ 9299.340616] pci_device_remove+0x3b/0xa0
[ 9299.340651] __device_release_driver+0x17a/0x240
[ 9299.340686] device_driver_detach+0x3c/0xa0
[ 9299.340714] unbind_store+0x113/0x130
[ 9299.340740] kernfs_fop_write_iter+0x124/0x1b0
[ 9299.340775] new_sync_write+0x15c/0x1f0
[ 9299.340806] vfs_write+0x1d2/0x270
[ 9299.340831] ksys_write+0x67/0xe0
[ 9299.340857] do_syscall_64+0x3b/0x90
[ 9299.340887] entry_SYSCALL_64_after_hwframe+0x44/0xae
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/09693f5b636fb3f6dd56fd943226fc1bbc600b51
  - https://git.kernel.org/stable/c/677e669973bf5460705bc65033445ea9f6615999
  - https://git.kernel.org/stable/c/ad483ed9dd5193a54293269c852a29051813b7bd

------------------------------------------------------------

CVE ID: CVE-2022-49477
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: samsung: Fix refcount leak in aries_audio_probe

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
If extcon_find_edev_by_node() fails, it doesn't call of_node_put()
Calling of_node_put() after extcon_find_edev_by_node() to fix this.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.9, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/46d1b310a2d571811c4e08041ce287babb60b86a
  - https://git.kernel.org/stable/c/70130bde3457d28c02c76b6cacc5d40a72dd6e17
  - https://git.kernel.org/stable/c/85d899f396622d3034643bf89615a78f9be7c91a
  - https://git.kernel.org/stable/c/bf4a9b2467b775717d0e9034ad916888e19713a3
  - https://git.kernel.org/stable/c/cacea459f95be22b3750f3b25b7a1c5897a68206

------------------------------------------------------------

CVE ID: CVE-2022-49478
Description: In the Linux kernel, the following vulnerability has been resolved:

media: pvrusb2: fix array-index-out-of-bounds in pvr2_i2c_core_init

Syzbot reported that -1 is used as array index. The problem was in
missing validation check.

hdw->unit_number is initialized with -1 and then if init table walk fails
this value remains unchanged. Since code blindly uses this member for
array indexing adding sanity check is the easiest fix for that.

hdw->workpoll initialization moved upper to prevent warning in
__flush_work.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.18, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1310fc3538dcc375a2f46ef0a438512c2ca32827
  - https://git.kernel.org/stable/c/24e807541e4a9263ed928e6ae3498de3ad43bd1e
  - https://git.kernel.org/stable/c/2e004fe914b243db41fa96f9e583385f360ea58e
  - https://git.kernel.org/stable/c/3309c2c574e13b21b44729f5bdbf21f60189b79a
  - https://git.kernel.org/stable/c/4351bfe36aba9fa7dc9d68d498d25d41a0f45e67
  - https://git.kernel.org/stable/c/471bec68457aaf981add77b4f590d65dd7da1059
  - https://git.kernel.org/stable/c/a3304766d9384886e6d3092c776273526947a2e9
  - https://git.kernel.org/stable/c/a3660e06675bccec4bf149c7229ea1d491ba10d7
  - https://git.kernel.org/stable/c/f99a8b1ec0eddc2931aeaa4f490277a15b39f511

------------------------------------------------------------

CVE ID: CVE-2022-49479
Description: In the Linux kernel, the following vulnerability has been resolved:

mt76: fix tx status related use-after-free race on station removal

There is a small race window where ongoing tx activity can lead to a skb
getting added to the status tracking idr after that idr has already been
cleaned up, which will keep the wcid linked in the status poll list.
Fix this by only adding status skbs if the wcid pointer is still assigned
in dev->wcid, which gets cleared early by mt76_sta_pre_rcu_remove
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/ddd426d72aca4054045a9bd3b80a4ce1d398f11f
  - https://git.kernel.org/stable/c/ef7f9f894cfd0b2e471206409a529af4a26ddd55
  - https://git.kernel.org/stable/c/fcfe1b5e162bf473c1d47760962cec8523c00466

------------------------------------------------------------

CVE ID: CVE-2022-49480
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: imx-hdmi: Fix refcount leak in imx_hdmi_probe

of_find_device_by_node() takes reference, we should use put_device()
to release it. when devm_kzalloc() fails, it doesn't have a
put_device(), it will cause refcount leak.
Add missing put_device() to fix this.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/81b7edaabd44ba133006ad72056914eb36828d60
  - https://git.kernel.org/stable/c/8205a0114db10ec41bd2b748cdd7528632082eca
  - https://git.kernel.org/stable/c/cf760e494ee5fa6bc2dc222f0098c741ad460801
  - https://git.kernel.org/stable/c/ed46731d8e86c8d65f5fc717671e1f1f6c3146d2

------------------------------------------------------------

CVE ID: CVE-2022-49481
Description: In the Linux kernel, the following vulnerability has been resolved:

regulator: pfuze100: Fix refcount leak in pfuze_parse_regulators_dt

of_node_get() returns a node with refcount incremented.
Calling of_node_put() to drop the reference when not needed anymore.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.12, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0be5d9da5743b9825a95baec85a67500b2c1d362
  - https://git.kernel.org/stable/c/49d785baeb91568332197be356d138e5e59c7ddb
  - https://git.kernel.org/stable/c/56ab0c01027492cd161c64148e1dc892c56887ad
  - https://git.kernel.org/stable/c/671be14fc31374b1a10a3abd93db6a8480838fc9
  - https://git.kernel.org/stable/c/6ca675f4abbc74bc991d154a1ecc8b384dc2aae4
  - https://git.kernel.org/stable/c/984cfef0675ed7398814e14af2c5323911723e1c
  - https://git.kernel.org/stable/c/9f564e29a51210a49df3d925117777c157a17d6d
  - https://git.kernel.org/stable/c/afaa7b933ef00a2d3262f4d1252087613fb5c06d
  - https://git.kernel.org/stable/c/b74c0dd9179d21b7260260e075d597b23970100c

------------------------------------------------------------

CVE ID: CVE-2022-49482
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: mxs-saif: Fix refcount leak in mxs_saif_probe

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.5, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/18b907ff0ae4bf20120aae1538f7156b9d08e3a7
  - https://git.kernel.org/stable/c/24491124406666bf0dcb9ee10c5575c6ce6a1730
  - https://git.kernel.org/stable/c/2a0da7641e1f17a744ac7b3f76471388c97b63dc
  - https://git.kernel.org/stable/c/2be84f73785fa9ed6443e3c5b158730266f1c2ee
  - https://git.kernel.org/stable/c/30d110ca703ce60162ec337aa564a3e4da30715f
  - https://git.kernel.org/stable/c/4e2a1bcc51bdebed48176f6e88c150f175983f9c
  - https://git.kernel.org/stable/c/c933829cbf3338b684869e6c4c8931abf5d68fbd
  - https://git.kernel.org/stable/c/d42601e93fce7802bb8d70dd59b60cfeefa20469
  - https://git.kernel.org/stable/c/d855505851ee8ba666eb204149b49f906130dc17

------------------------------------------------------------

CVE ID: CVE-2022-49483
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/disp/dpu1: avoid clearing hw interrupts if hw_intr is null during drm uninit

If edp modeset init is failed due to panel being not ready and
probe defers during drm bind, avoid clearing irqs and dereference
hw_intr when hw_intr is null.

BUG: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000

Call trace:
 dpu_core_irq_uninstall+0x50/0xb0
 dpu_irq_uninstall+0x18/0x24
 msm_drm_uninit+0xd8/0x16c
 msm_drm_bind+0x580/0x5fc
 try_to_bring_up_master+0x168/0x1c0
 __component_add+0xb4/0x178
 component_add+0x1c/0x28
 dp_display_probe+0x38c/0x400
 platform_probe+0xb0/0xd0
 really_probe+0xcc/0x2c8
 __driver_probe_device+0xbc/0xe8
 driver_probe_device+0x48/0xf0
 __device_attach_driver+0xa0/0xc8
 bus_for_each_drv+0x8c/0xd8
 __device_attach+0xc4/0x150
 device_initial_probe+0x1c/0x28

Changes in V2:
- Update commit message and coreect fixes tag.

Patchwork: https://patchwork.freedesktop.org/patch/484430/
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/01013ba9bbddc62f7d011163cebfd7ed06bb698b
  - https://git.kernel.org/stable/c/a7ca30c3a8b2e8bda65f2b922d382ac056be8aa4
  - https://git.kernel.org/stable/c/a800701429313149afde18d98821554fbfcb3164

------------------------------------------------------------

CVE ID: CVE-2022-49484
Description: In the Linux kernel, the following vulnerability has been resolved:

mt76: mt7915: fix possible NULL pointer dereference in mt7915_mac_fill_rx_vector

Fix possible NULL pointer dereference in mt7915_mac_fill_rx_vector
routine if the chip does not support dbdc and the hw reports band_idx
set to 1.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/268e8ef187eb8780d021b0e4f5ffa92dee5c4983
  - https://git.kernel.org/stable/c/62fdc974894eec80d678523458cf99bbdb887e22

------------------------------------------------------------

CVE ID: CVE-2022-49485
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/v3d: Fix null pointer dereference of pointer perfmon

In the unlikely event that pointer perfmon is null the WARN_ON return path
occurs after the pointer has already been deferenced. Fix this by only
dereferencing perfmon after it has been null checked.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1df8f8901babcc8c8eea2c067179e455b5c828fd
  - https://git.kernel.org/stable/c/3b72deb784a7d4ae8519a5c584cd87c4b57aa6c8
  - https://git.kernel.org/stable/c/4be045434923e549a50846a066a04b7b6c1d6d33
  - https://git.kernel.org/stable/c/ce7a1ecf3f9f1fccaf67295307614511d8e11b13

------------------------------------------------------------

CVE ID: CVE-2022-49486
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: fsl: Fix refcount leak in imx_sgtl5000_probe

of_find_i2c_device_by_node() takes a reference,
In error paths, we should call put_device() to drop
the reference to aviod refount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.5, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/41cd312dfe980af869c3503b4d38e62ed20dd3b7
  - https://git.kernel.org/stable/c/4bfbbfdb3d761323127a67d7d765abe2f77d7b21
  - https://git.kernel.org/stable/c/7f75e9f629ef54a0845b43889d8ab9dd6e280dd5
  - https://git.kernel.org/stable/c/922bccdb1796a9e7b989f2bc6d9ada7b499a4329
  - https://git.kernel.org/stable/c/96fc3da6184af5687e153d420cd7dcdeefdd2f9a
  - https://git.kernel.org/stable/c/e84aaf23ca82753d765bf84d05295d9d9c5fed29

------------------------------------------------------------

CVE ID: CVE-2022-49487
Description: In the Linux kernel, the following vulnerability has been resolved:

mtd: rawnand: intel: fix possible null-ptr-deref in ebu_nand_probe()

It will cause null-ptr-deref when using 'res', if platform_get_resource()
returns NULL, so move using 'res' after devm_ioremap_resource() that
will check it to avoid null-ptr-deref.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/daa5166450b447415aeeaac0199e445bae7bd0f2
  - https://git.kernel.org/stable/c/ddf66aefd685fd46500b9917333e1b1e118276dc
  - https://git.kernel.org/stable/c/e5b1e419cdb6dd8709eb05ed34039a3ded8e6003
  - https://git.kernel.org/stable/c/f8e262eb7575a4a2412f30f7a1b293875aceba80

------------------------------------------------------------

CVE ID: CVE-2022-49488
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/mdp5: Return error code in mdp5_mixer_release when deadlock is detected

There is a possibility for mdp5_get_global_state to return
-EDEADLK when acquiring the modeset lock, but currently global_state in
mdp5_mixer_release doesn't check for if an error is returned.

To avoid a NULL dereference error, let's have mdp5_mixer_release
check if an error is returned and propagate that error.

Patchwork: https://patchwork.freedesktop.org/patch/485181/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09bdeedc1fc53e64b8282e1de67752c69e43bdba
  - https://git.kernel.org/stable/c/1a5d1474026ea4f1a6f931075ca2adb884af39cf
  - https://git.kernel.org/stable/c/22d8424913b1348c6324916745fadaeea5273f0e
  - https://git.kernel.org/stable/c/46e5ce63924a96af452c4fc5ee0bb3b241e1b9f4
  - https://git.kernel.org/stable/c/47e393061049aff6818d1b9fdca7351411a23fc2
  - https://git.kernel.org/stable/c/883f1d52a57bf51e1d7a80c432345e2c6222477e
  - https://git.kernel.org/stable/c/ca75f6f7c6f89365e40f10f641b15981b1f07c31

------------------------------------------------------------

CVE ID: CVE-2022-49489
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/disp/dpu1: set vbif hw config to NULL to avoid use after memory free during pm runtime resume

BUG: Unable to handle kernel paging request at virtual address 006b6b6b6b6b6be3

Call trace:
  dpu_vbif_init_memtypes+0x40/0xb8
  dpu_runtime_resume+0xcc/0x1c0
  pm_generic_runtime_resume+0x30/0x44
  __genpd_runtime_resume+0x68/0x7c
  genpd_runtime_resume+0x134/0x258
  __rpm_callback+0x98/0x138
  rpm_callback+0x30/0x88
  rpm_resume+0x36c/0x49c
  __pm_runtime_resume+0x80/0xb0
  dpu_core_irq_uninstall+0x30/0xb0
  dpu_irq_uninstall+0x18/0x24
  msm_drm_uninit+0xd8/0x16c

Patchwork: https://patchwork.freedesktop.org/patch/483255/
[DB: fixed Fixes tag]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/134760263f6441741db0b2970e7face6b34b6d1c
  - https://git.kernel.org/stable/c/5b0adf5cbf3b74721e4e4c4e0cadc91b8df8bcc2
  - https://git.kernel.org/stable/c/97ac682b6f7d36be5d934f86c9911066540a68f1
  - https://git.kernel.org/stable/c/aa4cb188988dc6f1b3f4917d4dbc452150a5d871
  - https://git.kernel.org/stable/c/ef10d0c68e8608848cd58fca2589685718426607
  - https://git.kernel.org/stable/c/ef4bdaac7cb5416f236613ed9337ff0ea8ee329b
  - https://git.kernel.org/stable/c/fa5186b279ecf44b14fb435540d2065be91cb1ed

------------------------------------------------------------

CVE ID: CVE-2022-49490
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/mdp5: Return error code in mdp5_pipe_release when deadlock is detected

mdp5_get_global_state runs the risk of hitting a -EDEADLK when acquiring
the modeset lock, but currently mdp5_pipe_release doesn't check for if
an error is returned. Because of this, there is a possibility of
mdp5_pipe_release hitting a NULL dereference error.

To avoid this, let's have mdp5_pipe_release check if
mdp5_get_global_state returns an error and propogate that error.

Changes since v1:
- Separated declaration and initialization of *new_state to avoid
  compiler warning
- Fixed some spelling mistakes in commit message

Changes since v2:
- Return 0 in case where hwpipe is NULL as this is considered normal
  behavior
- Added 2nd patch in series to fix a similar NULL dereference issue in
  mdp5_mixer_release

Patchwork: https://patchwork.freedesktop.org/patch/485179/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/04bef5f1ba8ea6d7c1c8f5f65e0395c62db59cb8
  - https://git.kernel.org/stable/c/19964dfb39bda4d7716a71009488f0668ecbcf52
  - https://git.kernel.org/stable/c/33dc5aac46e0fad8f5eb193e5906ed0eb6b66ceb
  - https://git.kernel.org/stable/c/49dc28b4b2e28ef7564e355c91487996c1cbebd7
  - https://git.kernel.org/stable/c/776f5c58bfe16cf322d71eeed3c5dda1eeac7e6b
  - https://git.kernel.org/stable/c/b2aa2c4efe93e2580d6a8774b04fe2b99756a322
  - https://git.kernel.org/stable/c/d59be579fa932c46b908f37509f319cbd4ca9a68

------------------------------------------------------------

CVE ID: CVE-2022-49491
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/rockchip: vop: fix possible null-ptr-deref in vop_bind()

It will cause null-ptr-deref in resource_size(), if platform_get_resource()
returns NULL, move calling resource_size() after devm_ioremap_resource() that
will check 'res' to avoid null-ptr-deref.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.19, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/3451852312303d54a003c73bd0ae39cebb960bd5
  - https://git.kernel.org/stable/c/452922955df215a417c80d09dab72bbc667a1861
  - https://git.kernel.org/stable/c/6ff986e057bf28e2f7690dad410768b2270f9453
  - https://git.kernel.org/stable/c/769c53bb6116d0eaec0f1fe4ec4b27a74465cad1
  - https://git.kernel.org/stable/c/a9b4599665e437de8a1152799c34841b799a2e1c
  - https://git.kernel.org/stable/c/b54926bd558d97c888c3d2d87886f3c159d3254a
  - https://git.kernel.org/stable/c/ecfa52654d0c9c333c1fe1611f47105f6bce9591
  - https://git.kernel.org/stable/c/f8c242908ad15bbd604d3bcb54961b7d454c43f8
  - https://git.kernel.org/stable/c/fcd6a886443730c39170b8383411e52118aec0a3

------------------------------------------------------------

CVE ID: CVE-2022-49492
Description: In the Linux kernel, the following vulnerability has been resolved:

nvme-pci: fix a NULL pointer dereference in nvme_alloc_admin_tags

In nvme_alloc_admin_tags, the admin_q can be set to an error (typically
-ENOMEM) if the blk_mq_init_queue call fails to set up the queue, which
is checked immediately after the call. However, when we return the error
message up the stack, to nvme_reset_work the error takes us to
nvme_remove_dead_ctrl()
  nvme_dev_disable()
   nvme_suspend_queue(&dev->queues[0]).

Here, we only check that the admin_q is non-NULL, rather than not
an error or NULL, and begin quiescing a queue that never existed, leading
to bad / NULL pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/54a4c1e47d1b2585e74920399455bd9abbfb2bd7
  - https://git.kernel.org/stable/c/7a28556082d1fbcbc599baf1c24252dfc73efefc
  - https://git.kernel.org/stable/c/8321b17789f614414206af07e17ce4751c95dc76
  - https://git.kernel.org/stable/c/8da2b7bdb47e94bbc4062a3978c708926bcb022c
  - https://git.kernel.org/stable/c/906c81dba8ee8057523859b5e1a2479e9fd34860
  - https://git.kernel.org/stable/c/9e649471b396fa0139d53919354ce1eace9b9a24
  - https://git.kernel.org/stable/c/af98940dd33c9f9e1beb4f71c0a39260100e2a65
  - https://git.kernel.org/stable/c/da42761181627e9bdc37d18368b827948a583929
  - https://git.kernel.org/stable/c/f76729662650cd7bc8f8194e057af381370349a7

------------------------------------------------------------

CVE ID: CVE-2022-49493
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: rt5645: Fix errorenous cleanup order

There is a logic error when removing rt5645 device as the function
rt5645_i2c_remove() first cancel the &rt5645->jack_detect_work and
delete the &rt5645->btn_check_timer latter. However, since the timer
handler rt5645_btn_check_callback() will re-queue the jack_detect_work,
this cleanup order is buggy.

That is, once the del_timer_sync in rt5645_i2c_remove is concurrently
run with the rt5645_btn_check_callback, the canceled jack_detect_work
will be rescheduled again, leading to possible use-after-free.

This patch fix the issue by placing the del_timer_sync function before
the cancel_delayed_work_sync.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/061a6159cea583f1155f67d1915917a6b9282662
  - https://git.kernel.org/stable/c/0941150100173d4eaf3fe08ff4b16740e7c3026f
  - https://git.kernel.org/stable/c/1a5a3dfd9f172dcb115072f0aea5e27d3083c20e
  - https://git.kernel.org/stable/c/236d29c5857f02e0a53fdf15d3dce1536c4322ce
  - https://git.kernel.org/stable/c/2def44d3aec59e38d2701c568d65540783f90f2f
  - https://git.kernel.org/stable/c/453f0920ffc1a28e28ddb9c3cd5562472b2895b0
  - https://git.kernel.org/stable/c/7d801e807536a9a9c2146c5f4a5836f154517ed3
  - https://git.kernel.org/stable/c/88c09e4812d72c3153afc8e5a45ecac2d0eae3ff
  - https://git.kernel.org/stable/c/abe7554da62cb489712a54de69ef5665c250e564

------------------------------------------------------------

CVE ID: CVE-2022-49494
Description: In the Linux kernel, the following vulnerability has been resolved:

mtd: rawnand: cadence: fix possible null-ptr-deref in cadence_nand_dt_probe()

It will cause null-ptr-deref when using 'res', if platform_get_resource()
returns NULL, so move using 'res' after devm_ioremap_resource() that
will check it to avoid null-ptr-deref.
And use devm_platform_get_and_ioremap_resource() to simplify code.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/069af5e27c1b0f7677ef76d8d3102e503ca4f80b
  - https://git.kernel.org/stable/c/0cfee868b89ffa945f3d535ee5c985cb40c5a0f8
  - https://git.kernel.org/stable/c/13b60d3dc84b47307669edb66b633b18466014b4
  - https://git.kernel.org/stable/c/81f1ddffdc22ca5789e33b9d4712914e302090c1
  - https://git.kernel.org/stable/c/a28ed09dafee20da51eb26452950839633afd824

------------------------------------------------------------

CVE ID: CVE-2022-49495
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/hdmi: check return value after calling platform_get_resource_byname()

It will cause null-ptr-deref if platform_get_resource_byname() returns NULL,
we need check the return value.

Patchwork: https://patchwork.freedesktop.org/patch/482992/
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.3, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0978fcce91b90b561b8c82e7c492ba9fc8440eef
  - https://git.kernel.org/stable/c/2b3ed7547b1a052209da6c4ab886ffe0eed88c42
  - https://git.kernel.org/stable/c/4cd66a8016b872a153bf892fe4258cbc0dacf5b1
  - https://git.kernel.org/stable/c/6369dda4a2209142ab819f01d3d2076d81e3ebdd
  - https://git.kernel.org/stable/c/9cb1ee33efccb8b107ee04b7b3441820de3fd2da
  - https://git.kernel.org/stable/c/9f5495a5c51c1d11c6ffc13aa2befffec0c2651a
  - https://git.kernel.org/stable/c/a36e506711548df923ceb7ec9f6001375be799a5
  - https://git.kernel.org/stable/c/c1bfacf0daf25a5fc7d667399d6ff2dffda84cd8
  - https://git.kernel.org/stable/c/d9cb951d11a4ace4de5c50b1178ad211de17079e

------------------------------------------------------------

CVE ID: CVE-2022-49496
Description: In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: prevent kernel crash when rmmod mtk-vcodec-dec.ko

If the driver support subdev mode, the parameter "dev->pm.dev" will be
NULL in mtk_vcodec_dec_remove. Kernel will crash when try to rmmod
mtk-vcodec-dec.ko.

[ 4380.702726] pc : do_raw_spin_trylock+0x4/0x80
[ 4380.707075] lr : _raw_spin_lock_irq+0x90/0x14c
[ 4380.711509] sp : ffff80000819bc10
[ 4380.714811] x29: ffff80000819bc10 x28: ffff3600c03e4000 x27: 0000000000000000
[ 4380.721934] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
[ 4380.729057] x23: ffff3600c0f34930 x22: ffffd5e923549000 x21: 0000000000000220
[ 4380.736179] x20: 0000000000000208 x19: ffffd5e9213e8ebc x18: 0000000000000020
[ 4380.743298] x17: 0000002000000000 x16: ffffd5e9213e8e90 x15: 696c346f65646976
[ 4380.750420] x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000040
[ 4380.757542] x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
[ 4380.764664] x8 : 0000000000000000 x7 : ffff3600c7273ae8 x6 : ffffd5e9213e8ebc
[ 4380.771786] x5 : 0000000000000000 x4 : 0000000000000001 x3 : 0000000000000000
[ 4380.778908] x2 : 0000000000000000 x1 : ffff3600c03e4000 x0 : 0000000000000208
[ 4380.786031] Call trace:
[ 4380.788465]  do_raw_spin_trylock+0x4/0x80
[ 4380.792462]  __pm_runtime_disable+0x2c/0x1b0
[ 4380.796723]  mtk_vcodec_dec_remove+0x5c/0xa0 [mtk_vcodec_dec]
[ 4380.802466]  platform_remove+0x2c/0x60
[ 4380.806204]  __device_release_driver+0x194/0x250
[ 4380.810810]  driver_detach+0xc8/0x15c
[ 4380.814462]  bus_remove_driver+0x5c/0xb0
[ 4380.818375]  driver_unregister+0x34/0x64
[ 4380.822288]  platform_driver_unregister+0x18/0x24
[ 4380.826979]  mtk_vcodec_dec_driver_exit+0x1c/0x888 [mtk_vcodec_dec]
[ 4380.833240]  __arm64_sys_delete_module+0x190/0x224
[ 4380.838020]  invoke_syscall+0x48/0x114
[ 4380.841760]  el0_svc_common.constprop.0+0x60/0x11c
[ 4380.846540]  do_el0_svc+0x28/0x90
[ 4380.849844]  el0_svc+0x4c/0x100
[ 4380.852975]  el0t_64_sync_handler+0xec/0xf0
[ 4380.857148]  el0t_64_sync+0x190/0x194
[ 4380.860801] Code: 94431515 17ffffca d503201f d503245f (b9400004)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1fa37b00dc55a061a3eb82e378849862b4aeca9d
  - https://git.kernel.org/stable/c/c10c0086db688c95bb4e0e378e523818dff1551d

------------------------------------------------------------

CVE ID: CVE-2022-49497
Description: In the Linux kernel, the following vulnerability has been resolved:

net: remove two BUG() from skb_checksum_help()

I have a syzbot report that managed to get a crash in skb_checksum_help()

If syzbot can trigger these BUG(), it makes sense to replace
them with more friendly WARN_ON_ONCE() since skb_checksum_help()
can instead return an error code.

Note that syzbot will still crash there, until real bug is fixed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/312c43e98ed190bd8fd7a71a0addf9539d5b8ab1
  - https://git.kernel.org/stable/c/6320ae1b5876c30bf98203b6a5abe8b5c45e6a04
  - https://git.kernel.org/stable/c/b1320c9a4d30ff54b824a8ad6036e0b5fb4c5e73
  - https://git.kernel.org/stable/c/d5281245f3502e960cb6b89348767b935379cee3
  - https://git.kernel.org/stable/c/d7ea0d9df2a6265b2b180d17ebc64b38105968fc

------------------------------------------------------------

CVE ID: CVE-2022-49498
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: pcm: Check for null pointer of pointer substream before dereferencing it

Pointer substream is being dereferenced on the assignment of pointer card
before substream is being null checked with the macro PCM_RUNTIME_CHECK.
Although PCM_RUNTIME_CHECK calls BUG_ON, it still is useful to perform the
the pointer check before card is assigned.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.6, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/011b559be832194f992f73d6c0d5485f5925a10b
  - https://git.kernel.org/stable/c/1f2e28857be1e5c7db39bbc221332215fc5467e3
  - https://git.kernel.org/stable/c/7784d22f81a29df2ec57ca90d54f93a35cbcd1a2
  - https://git.kernel.org/stable/c/b2421a196cb0911ea95aec1050a0b830464c8fa6
  - https://git.kernel.org/stable/c/b41ef7ad9238c22aa2e142f5ce4ce1a1a0d48123
  - https://git.kernel.org/stable/c/f2c68c52898f623fe84518da4606538d193b0cca

------------------------------------------------------------

CVE ID: CVE-2022-49499
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm: Fix null pointer dereferences without iommu

Check if 'aspace' is set before using it as it will stay null without
IOMMU, such as on msm8974.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/36a1d1bda77e1851bddfa9cf4e8ada94476dbaff
  - https://git.kernel.org/stable/c/f09937e80f9bc792965476c9a528f26c8fdc9179

------------------------------------------------------------

CVE ID: CVE-2022-49500
Description: In the Linux kernel, the following vulnerability has been resolved:

wl1251: dynamically allocate memory used for DMA

With introduction of vmap'ed stacks, stack parameters can no
longer be used for DMA and now leads to kernel panic.

It happens at several places for the wl1251 (e.g. when
accessed through SDIO) making it unuseable on e.g. the
OpenPandora.

We solve this by allocating temporary buffers or use wl1251_read32().

Tested on v5.18-rc5 with OpenPandora.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/454744754cbf2c21b3fc7344e46e10bee2768094
  - https://git.kernel.org/stable/c/da03bbfbf5acd1ab0b074617e865ad1e8a5779ef

------------------------------------------------------------

CVE ID: CVE-2022-49501
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet: Run unregister_netdev() before unbind() again

Commit 2c9d6c2b871d ("usbnet: run unbind() before unregister_netdev()")
sought to fix a use-after-free on disconnect of USB Ethernet adapters.

It turns out that a different fix is necessary to address the issue:
https://lore.kernel.org/netdev/18b3541e5372bc9b9fc733d422f4e698c089077c.1650177997.git.lukas@wunner.de/

So the commit was not necessary.

The commit made binding and unbinding of USB Ethernet asymmetrical:
Before, usbnet_probe() first invoked the ->bind() callback and then
register_netdev().  usbnet_disconnect() mirrored that by first invoking
unregister_netdev() and then ->unbind().

Since the commit, the order in usbnet_disconnect() is reversed and no
longer mirrors usbnet_probe().

One consequence is that a PHY disconnected (and stopped) in ->unbind()
is afterwards stopped once more by unregister_netdev() as it closes the
netdev before unregistering.  That necessitates a contortion in ->stop()
because the PHY may only be stopped if it hasn't already been
disconnected.

Reverting the commit allows making the call to phy_stop() unconditional
in ->stop().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/6d5deb242874d924beccf7eb3cef04c1c3b0da79
  - https://git.kernel.org/stable/c/969a1b3ea3cb7d58a16fe12fd1b04bfc0ea40509
  - https://git.kernel.org/stable/c/d1408f6b4dd78fb1b9e26bcf64477984e5f85409
  - https://git.kernel.org/stable/c/fbda837107f9bd4ec658d2aa88c6856dba606f06

------------------------------------------------------------

CVE ID: CVE-2022-49502
Description: In the Linux kernel, the following vulnerability has been resolved:

media: rga: fix possible memory leak in rga_probe

rga->m2m_dev needs to be freed when rga_probe fails.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1cdc768468c25d6b10ab83ec1efd4a8554532d69
  - https://git.kernel.org/stable/c/8ddc89437ccefa18279918c19a61fd81527f40b9
  - https://git.kernel.org/stable/c/a71eb6025305192e646040cd76ccacb5bd48a1b5
  - https://git.kernel.org/stable/c/b7bbca4d08471bc8404a946bab1aa017dd05199b
  - https://git.kernel.org/stable/c/eeb4819e94aa69767b9e5591e70c63e8b7c5786a

------------------------------------------------------------

CVE ID: CVE-2022-49503
Description: In the Linux kernel, the following vulnerability has been resolved:

ath9k_htc: fix potential out of bounds access with invalid rxstatus->rs_keyix

The "rxstatus->rs_keyix" eventually gets passed to test_bit() so we need to
ensure that it is within the bitmap.

drivers/net/wireless/ath/ath9k/common.c:46 ath9k_cmn_rx_accept()
error: passing untrusted data 'rx_stats->rs_keyix' to 'test_bit()'
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0bcb528402cd5e1a6e1833e956fd58a12d509e8e
  - https://git.kernel.org/stable/c/2326d398ccd41ba6d93b8346532dfa432ab00fee
  - https://git.kernel.org/stable/c/2dc509305cf956381532792cb8dceef2b1504765
  - https://git.kernel.org/stable/c/3dad3fed5672828c7fb0465cb66a3d9a70952fa6
  - https://git.kernel.org/stable/c/461e4c1f199076275f16bf6f3d3e42c6b6c79f33
  - https://git.kernel.org/stable/c/4bdcf32c965c27f55ccc4ee71c1927131115b0bb
  - https://git.kernel.org/stable/c/7f6defe0fabc79f29603c6fa3c80e4fe0456a3e9
  - https://git.kernel.org/stable/c/a048e0c3caa852397b7b50d4c82a0415c05f7ac3
  - https://git.kernel.org/stable/c/eda518db7db16c360bc84379d90675650daa3048

------------------------------------------------------------

CVE ID: CVE-2022-49504
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Inhibit aborts if external loopback plug is inserted

After running a short external loopback test, when the external loopback is
removed and a normal cable inserted that is directly connected to a target
device, the system oops in the llpfc_set_rrq_active() routine.

When the loopback was inserted an FLOGI was transmit. As we're looped back,
we receive the FLOGI request. The FLOGI is ABTS'd as we recognize the same
wppn thus understand it's a loopback. However, as the ABTS sends address
information the port is not set to (fffffe), the ABTS is dropped on the
wire. A short 1 frame loopback test is run and completes before the ABTS
times out. The looback is unplugged and the new cable plugged in, and the
an FLOGI to the new device occurs and completes. Due to a mixup in ref
counting the completion of the new FLOGI releases the fabric ndlp. Then the
original ABTS completes and references the released ndlp generating the
oops.

Correct by no-op'ing the ABTS when in loopback mode (it will be dropped
anyway). Added a flag to track the mode to recognize when it should be
no-op'd.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a1516930cb605caee3bc7b4f3b7994b88c0b8505
  - https://git.kernel.org/stable/c/ead76d4c09b89f4c8d632648026a476a5a34fde8

------------------------------------------------------------

CVE ID: CVE-2022-49505
Description: In the Linux kernel, the following vulnerability has been resolved:

NFC: NULL out the dev->rfkill to prevent UAF

Commit 3e3b5dfcd16a ("NFC: reorder the logic in nfc_{un,}register_device")
assumes the device_is_registered() in function nfc_dev_up() will help
to check when the rfkill is unregistered. However, this check only
take effect when device_del(&dev->dev) is done in nfc_unregister_device().
Hence, the rfkill object is still possible be dereferenced.

The crash trace in latest kernel (5.18-rc2):

[   68.760105] ==================================================================
[   68.760330] BUG: KASAN: use-after-free in __lock_acquire+0x3ec1/0x6750
[   68.760756] Read of size 8 at addr ffff888009c93018 by task fuzz/313
[   68.760756]
[   68.760756] CPU: 0 PID: 313 Comm: fuzz Not tainted 5.18.0-rc2 #4
[   68.760756] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[   68.760756] Call Trace:
[   68.760756]  <TASK>
[   68.760756]  dump_stack_lvl+0x57/0x7d
[   68.760756]  print_report.cold+0x5e/0x5db
[   68.760756]  ? __lock_acquire+0x3ec1/0x6750
[   68.760756]  kasan_report+0xbe/0x1c0
[   68.760756]  ? __lock_acquire+0x3ec1/0x6750
[   68.760756]  __lock_acquire+0x3ec1/0x6750
[   68.760756]  ? lockdep_hardirqs_on_prepare+0x410/0x410
[   68.760756]  ? register_lock_class+0x18d0/0x18d0
[   68.760756]  lock_acquire+0x1ac/0x4f0
[   68.760756]  ? rfkill_blocked+0xe/0x60
[   68.760756]  ? lockdep_hardirqs_on_prepare+0x410/0x410
[   68.760756]  ? mutex_lock_io_nested+0x12c0/0x12c0
[   68.760756]  ? nla_get_range_signed+0x540/0x540
[   68.760756]  ? _raw_spin_lock_irqsave+0x4e/0x50
[   68.760756]  _raw_spin_lock_irqsave+0x39/0x50
[   68.760756]  ? rfkill_blocked+0xe/0x60
[   68.760756]  rfkill_blocked+0xe/0x60
[   68.760756]  nfc_dev_up+0x84/0x260
[   68.760756]  nfc_genl_dev_up+0x90/0xe0
[   68.760756]  genl_family_rcv_msg_doit+0x1f4/0x2f0
[   68.760756]  ? genl_family_rcv_msg_attrs_parse.constprop.0+0x230/0x230
[   68.760756]  ? security_capable+0x51/0x90
[   68.760756]  genl_rcv_msg+0x280/0x500
[   68.760756]  ? genl_get_cmd+0x3c0/0x3c0
[   68.760756]  ? lock_acquire+0x1ac/0x4f0
[   68.760756]  ? nfc_genl_dev_down+0xe0/0xe0
[   68.760756]  ? lockdep_hardirqs_on_prepare+0x410/0x410
[   68.760756]  netlink_rcv_skb+0x11b/0x340
[   68.760756]  ? genl_get_cmd+0x3c0/0x3c0
[   68.760756]  ? netlink_ack+0x9c0/0x9c0
[   68.760756]  ? netlink_deliver_tap+0x136/0xb00
[   68.760756]  genl_rcv+0x1f/0x30
[   68.760756]  netlink_unicast+0x430/0x710
[   68.760756]  ? memset+0x20/0x40
[   68.760756]  ? netlink_attachskb+0x740/0x740
[   68.760756]  ? __build_skb_around+0x1f4/0x2a0
[   68.760756]  netlink_sendmsg+0x75d/0xc00
[   68.760756]  ? netlink_unicast+0x710/0x710
[   68.760756]  ? netlink_unicast+0x710/0x710
[   68.760756]  sock_sendmsg+0xdf/0x110
[   68.760756]  __sys_sendto+0x19e/0x270
[   68.760756]  ? __ia32_sys_getpeername+0xa0/0xa0
[   68.760756]  ? fd_install+0x178/0x4c0
[   68.760756]  ? fd_install+0x195/0x4c0
[   68.760756]  ? kernel_fpu_begin_mask+0x1c0/0x1c0
[   68.760756]  __x64_sys_sendto+0xd8/0x1b0
[   68.760756]  ? lockdep_hardirqs_on+0xbf/0x130
[   68.760756]  ? syscall_enter_from_user_mode+0x1d/0x50
[   68.760756]  do_syscall_64+0x3b/0x90
[   68.760756]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   68.760756] RIP: 0033:0x7f67fb50e6b3
...
[   68.760756] RSP: 002b:00007f67fa91fe90 EFLAGS: 00000293 ORIG_RAX: 000000000000002c
[   68.760756] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f67fb50e6b3
[   68.760756] RDX: 000000000000001c RSI: 0000559354603090 RDI: 0000000000000003
[   68.760756] RBP: 00007f67fa91ff00 R08: 00007f67fa91fedc R09: 000000000000000c
[   68.760756] R10: 0000000000000000 R11: 0000000000000293 R12: 00007ffe824d496e
[   68.760756] R13: 00007ffe824d496f R14: 00007f67fa120000 R15: 0000000000000003

[   68.760756]  </TASK>
[   68.760756]
[   68.760756] Allocated by task 279:
[   68.760756]  kasan_save_stack+0x1e/0x40
[
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.293, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.291, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.256, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.218, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.162, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.82, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.5, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1632be63862f183cd5cf1cc094e698e6ec005dfd
  - https://git.kernel.org/stable/c/1b0e81416a24d6e9b8c2341e22e8bf48f8b8bfc9
  - https://git.kernel.org/stable/c/2a1b5110c95e4d49c8c3906270dfcde680a5a7be
  - https://git.kernel.org/stable/c/4a68938f43b7c2663e4c90bb9bbe29ac8b9a42a0
  - https://git.kernel.org/stable/c/4f5d71930f41be78557f9714393179025baacd65
  - https://git.kernel.org/stable/c/6abfaca8711803d0d7cc8c0fac1070a88509d463
  - https://git.kernel.org/stable/c/a8e03bcad52dc9afabf650fdbad84f739cec9efa
  - https://git.kernel.org/stable/c/f81270125b50532624400063281e6611ecd61ddf
  - https://git.kernel.org/stable/c/fbf9c4c714d3cdeb98b6a18e4d057f931cad1d81

------------------------------------------------------------

CVE ID: CVE-2022-49506
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/mediatek: Add vblank register/unregister callback functions

We encountered a kernel panic issue that callback data will be NULL when
it's using in ovl irq handler. There is a timing issue between
mtk_disp_ovl_irq_handler() and mtk_ovl_disable_vblank().

To resolve this issue, we use the flow to register/unregister vblank cb:
- Register callback function and callback data when crtc creates.
- Unregister callback function and callback data when crtc destroies.

With this solution, we can assure callback data will not be NULL when
vblank is disable.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a4027b5971fe2a94e32754f007d9d3c12c68ad1
  - https://git.kernel.org/stable/c/8a265d9838bc3c63579002d55c2b2c655c4f8f26
  - https://git.kernel.org/stable/c/8a2dbdeccef6de47565638abdf3c25f41cdffc37
  - https://git.kernel.org/stable/c/b74d921b900b6ce38c6247c0a1c86be9f3746493

------------------------------------------------------------

CVE ID: CVE-2022-49507
Description: In the Linux kernel, the following vulnerability has been resolved:

regulator: da9121: Fix uninit-value in da9121_assign_chip_model()

KASAN report slab-out-of-bounds in __regmap_init as follows:

BUG: KASAN: slab-out-of-bounds in __regmap_init drivers/base/regmap/regmap.c:841
Read of size 1 at addr ffff88803678cdf1 by task xrun/9137

CPU: 0 PID: 9137 Comm: xrun Tainted: G        W         5.18.0-rc2
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
Call Trace:
 <TASK>
 dump_stack_lvl+0xe8/0x15a lib/dump_stack.c:88
 print_report.cold+0xcd/0x69b mm/kasan/report.c:313
 kasan_report+0x8e/0xc0 mm/kasan/report.c:491
 __regmap_init+0x4540/0x4ba0 drivers/base/regmap/regmap.c:841
 __devm_regmap_init+0x7a/0x100 drivers/base/regmap/regmap.c:1266
 __devm_regmap_init_i2c+0x65/0x80 drivers/base/regmap/regmap-i2c.c:394
 da9121_i2c_probe+0x386/0x6d1 drivers/regulator/da9121-regulator.c:1039
 i2c_device_probe+0x959/0xac0 drivers/i2c/i2c-core-base.c:563

This happend when da9121 device is probe by da9121_i2c_id, but with
invalid dts. Thus, chip->subvariant_id is set to -EINVAL, and later
da9121_assign_chip_model() will access 'regmap' without init it.

Fix it by return -EINVAL from da9121_assign_chip_model() if
'chip->subvariant_id' is invalid.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/60f21eda69f1b5727a97d2077da766eb27fcc21f
  - https://git.kernel.org/stable/c/7da64c7c82c9b29b628a62c88a8c2fb06990563d
  - https://git.kernel.org/stable/c/bab76514aca36bc513224525d5598da676938218
  - https://git.kernel.org/stable/c/be96baa0c79588084e0d7a4fa21c574cec9a57f4

------------------------------------------------------------

CVE ID: CVE-2022-49508
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: elan: Fix potential double free in elan_input_configured

'input' is a managed resource allocated with devm_input_allocate_device(),
so there is no need to call input_free_device() explicitly or
there will be a double free.

According to the doc of devm_input_allocate_device():
 * Managed input devices do not need to be explicitly unregistered or
 * freed as it will be done automatically when owner device unbinds from
 * its driver (or binding fails).
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.17, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1af20714fedad238362571620be0bd690ded05b6
  - https://git.kernel.org/stable/c/24f9dfdaece9bd75bb8dbfdba83eddeefdf7dc47
  - https://git.kernel.org/stable/c/5291451851feeb66fd4bf0826710f482f3b1ab38
  - https://git.kernel.org/stable/c/6d0726725c7c560495f5ff364862a2cefea542e3
  - https://git.kernel.org/stable/c/8bb1716507ebf12d50bbf181764481de3b6bc7fd
  - https://git.kernel.org/stable/c/c92ec22a991778a096342cf1a917ae36c5c86a90
  - https://git.kernel.org/stable/c/f1d4f19a796551edc6679a681ea1756b8c578c08

------------------------------------------------------------

CVE ID: CVE-2022-49509
Description: In the Linux kernel, the following vulnerability has been resolved:

media: i2c: max9286: fix kernel oops when removing module

When removing the max9286 module we get a kernel oops:

Unable to handle kernel paging request at virtual address 000000aa00000094
Mem abort info:
  ESR = 0x96000004
  EC = 0x25: DABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
  FSC = 0x04: level 0 translation fault
Data abort info:
  ISV = 0, ISS = 0x00000004
  CM = 0, WnR = 0
user pgtable: 4k pages, 48-bit VAs, pgdp=0000000880d85000
[000000aa00000094] pgd=0000000000000000, p4d=0000000000000000
Internal error: Oops: 96000004 [#1] PREEMPT SMP
Modules linked in: fsl_jr_uio caam_jr rng_core libdes caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine max9271 authenc crct10dif_ce mxc_jpeg_encdec
CPU: 2 PID: 713 Comm: rmmod Tainted: G         C        5.15.5-00057-gaebcd29c8ed7-dirty #5
Hardware name: Freescale i.MX8QXP MEK (DT)
pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : i2c_mux_del_adapters+0x24/0xf0
lr : max9286_remove+0x28/0xd0 [max9286]
sp : ffff800013a9bbf0
x29: ffff800013a9bbf0 x28: ffff00080b6da940 x27: 0000000000000000
x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
x23: ffff000801a5b970 x22: ffff0008048b0890 x21: ffff800009297000
x20: ffff0008048b0f70 x19: 000000aa00000064 x18: 0000000000000000
x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
x14: 0000000000000014 x13: 0000000000000000 x12: ffff000802da49e8
x11: ffff000802051918 x10: ffff000802da4920 x9 : ffff000800030098
x8 : 0101010101010101 x7 : 7f7f7f7f7f7f7f7f x6 : fefefeff6364626d
x5 : 8080808000000000 x4 : 0000000000000000 x3 : 0000000000000000
x2 : ffffffffffffffff x1 : ffff00080b6da940 x0 : 0000000000000000
Call trace:
 i2c_mux_del_adapters+0x24/0xf0
 max9286_remove+0x28/0xd0 [max9286]
 i2c_device_remove+0x40/0x110
 __device_release_driver+0x188/0x234
 driver_detach+0xc4/0x150
 bus_remove_driver+0x60/0xe0
 driver_unregister+0x34/0x64
 i2c_del_driver+0x58/0xa0
 max9286_i2c_driver_exit+0x1c/0x490 [max9286]
 __arm64_sys_delete_module+0x194/0x260
 invoke_syscall+0x48/0x114
 el0_svc_common.constprop.0+0xd4/0xfc
 do_el0_svc+0x2c/0x94
 el0_svc+0x28/0x80
 el0t_64_sync_handler+0xa8/0x130
 el0t_64_sync+0x1a0/0x1a4

The Oops happens because the I2C client data does not point to
max9286_priv anymore but to v4l2_subdev. The change happened in
max9286_init() which calls v4l2_i2c_subdev_init() later on...

Besides fixing the max9286_remove() function, remove the call to
i2c_set_clientdata() in max9286_probe(), to avoid confusion, and make
the necessary changes to max9286_init() so that it doesn't have to use
i2c_get_clientdata() in order to fetch the pointer to priv.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/365ab7ebc24eebb42b9e020aeb440d51af8960cd
  - https://git.kernel.org/stable/c/579c77595dbbdfe4f2edf335899f86ac51eca4e9
  - https://git.kernel.org/stable/c/9dd783274c89c21a038d967b52a858a297e767f8
  - https://git.kernel.org/stable/c/a4ec75df70575cdf33d9638c7844e729bfe6ce24

------------------------------------------------------------

CVE ID: CVE-2022-49510
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/omap: fix NULL but dereferenced coccicheck error

Fix the following coccicheck warning:
./drivers/gpu/drm/omapdrm/omap_overlay.c:89:22-25: ERROR: r_ovl is NULL
but dereferenced.

Here should be ovl->idx rather than r_ovl->idx.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/08d9a75eab594ca508a440db7c73064498d26687
  - https://git.kernel.org/stable/c/8f2a3970c969d0d8d7289a4c65edcedafc16fd92
  - https://git.kernel.org/stable/c/d2507be660310bb9bcca918f81f49b8bba07e462

------------------------------------------------------------

CVE ID: CVE-2022-49511
Description: In the Linux kernel, the following vulnerability has been resolved:

fbdev: defio: fix the pagelist corruption

Easily hit the below list corruption:
==
list_add corruption. prev->next should be next (ffffffffc0ceb090), but
was ffffec604507edc8. (prev=ffffec604507edc8).
WARNING: CPU: 65 PID: 3959 at lib/list_debug.c:26
__list_add_valid+0x53/0x80
CPU: 65 PID: 3959 Comm: fbdev Tainted: G     U
RIP: 0010:__list_add_valid+0x53/0x80
Call Trace:
 <TASK>
 fb_deferred_io_mkwrite+0xea/0x150
 do_page_mkwrite+0x57/0xc0
 do_wp_page+0x278/0x2f0
 __handle_mm_fault+0xdc2/0x1590
 handle_mm_fault+0xdd/0x2c0
 do_user_addr_fault+0x1d3/0x650
 exc_page_fault+0x77/0x180
 ? asm_exc_page_fault+0x8/0x30
 asm_exc_page_fault+0x1e/0x30
RIP: 0033:0x7fd98fc8fad1
==

Figure out the race happens when one process is adding &page->lru into
the pagelist tail in fb_deferred_io_mkwrite(), another process is
re-initializing the same &page->lru in fb_deferred_io_fault(), which is
not protected by the lock.

This fix is to init all the page lists one time during initialization,
it not only fixes the list corruption, but also avoids INIT_LIST_HEAD()
redundantly.

V2: change "int i" to "unsigned int i" (Geert Uytterhoeven)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6a9ae2fe887042f76fd3d334349e64e8ab3c55a2
  - https://git.kernel.org/stable/c/856082f021a28221db2c32bd0531614a8382be67
  - https://git.kernel.org/stable/c/e79b2b2aadeffe1db54a6b569b9b621575c3eb07

------------------------------------------------------------

CVE ID: CVE-2022-49512
Description: In the Linux kernel, the following vulnerability has been resolved:

mtd: rawnand: denali: Use managed device resources

All of the resources used by this driver has managed interfaces, so use
them. Otherwise we will get the following splat:

[    4.472703] denali-nand-pci 0000:00:05.0: timeout while waiting for irq 0x1000
[    4.474071] denali-nand-pci: probe of 0000:00:05.0 failed with error -5
[    4.473538] nand: No NAND device found
[    4.474068] BUG: unable to handle page fault for address: ffffc90005000410
[    4.475169] #PF: supervisor write access in kernel mode
[    4.475579] #PF: error_code(0x0002) - not-present page
[    4.478362] RIP: 0010:iowrite32+0x9/0x50
[    4.486068] Call Trace:
[    4.486269]  <IRQ>
[    4.486443]  denali_isr+0x15b/0x300 [denali]
[    4.486788]  ? denali_direct_write+0x50/0x50 [denali]
[    4.487189]  __handle_irq_event_percpu+0x161/0x3b0
[    4.487571]  handle_irq_event+0x7d/0x1b0
[    4.487884]  handle_fasteoi_irq+0x2b0/0x770
[    4.488219]  __common_interrupt+0xc8/0x1b0
[    4.488549]  common_interrupt+0x9a/0xc0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3830dbdfb9a4aec680e43ed80b9f23db7a88eac9
  - https://git.kernel.org/stable/c/3a745b51cddafade99aaea1b93aad31e9614e230
  - https://git.kernel.org/stable/c/3c68daf4a368cd9e63ae5a2145c9e4a6f838c166
  - https://git.kernel.org/stable/c/87149cf9186201a63f0e0b93d9fa93d480bcb771
  - https://git.kernel.org/stable/c/efea1dd176edd17c8252051b7de6957f06efc394

------------------------------------------------------------

CVE ID: CVE-2022-49513
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: governor: Use kobject release() method to free dbs_data

The struct dbs_data embeds a struct gov_attr_set and
the struct gov_attr_set embeds a kobject. Since every kobject must have
a release() method and we can't use kfree() to free it directly,
so introduce cpufreq_dbs_data_release() to release the dbs_data via
the kobject::release() method. This fixes the calltrace like below:

  ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x34
  WARNING: CPU: 12 PID: 810 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100
  Modules linked in:
  CPU: 12 PID: 810 Comm: sh Not tainted 5.16.0-next-20220120-yocto-standard+ #536
  Hardware name: Marvell OcteonTX CN96XX board (DT)
  pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : debug_print_object+0xb8/0x100
  lr : debug_print_object+0xb8/0x100
  sp : ffff80001dfcf9a0
  x29: ffff80001dfcf9a0 x28: 0000000000000001 x27: ffff0001464f0000
  x26: 0000000000000000 x25: ffff8000090e3f00 x24: ffff80000af60210
  x23: ffff8000094dfb78 x22: ffff8000090e3f00 x21: ffff0001080b7118
  x20: ffff80000aeb2430 x19: ffff800009e8f5e0 x18: 0000000000000000
  x17: 0000000000000002 x16: 00004d62e58be040 x15: 013590470523aff8
  x14: ffff8000090e1828 x13: 0000000001359047 x12: 00000000f5257d14
  x11: 0000000000040591 x10: 0000000066c1ffea x9 : ffff8000080d15e0
  x8 : ffff80000a1765a8 x7 : 0000000000000000 x6 : 0000000000000001
  x5 : ffff800009e8c000 x4 : ffff800009e8c760 x3 : 0000000000000000
  x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0001474ed040
  Call trace:
   debug_print_object+0xb8/0x100
   __debug_check_no_obj_freed+0x1d0/0x25c
   debug_check_no_obj_freed+0x24/0xa0
   kfree+0x11c/0x440
   cpufreq_dbs_governor_exit+0xa8/0xac
   cpufreq_exit_governor+0x44/0x90
   cpufreq_set_policy+0x29c/0x570
   store_scaling_governor+0x110/0x154
   store+0xb0/0xe0
   sysfs_kf_write+0x58/0x84
   kernfs_fop_write_iter+0x12c/0x1c0
   new_sync_write+0xf0/0x18c
   vfs_write+0x1cc/0x220
   ksys_write+0x74/0x100
   __arm64_sys_write+0x28/0x3c
   invoke_syscall.constprop.0+0x58/0xf0
   do_el0_svc+0x70/0x170
   el0_svc+0x54/0x190
   el0t_64_sync_handler+0xa4/0x130
   el0t_64_sync+0x1a0/0x1a4
  irq event stamp: 189006
  hardirqs last  enabled at (189005): [<ffff8000080849d0>] finish_task_switch.isra.0+0xe0/0x2c0
  hardirqs last disabled at (189006): [<ffff8000090667a4>] el1_dbg+0x24/0xa0
  softirqs last  enabled at (188966): [<ffff8000080106d0>] __do_softirq+0x4b0/0x6a0
  softirqs last disabled at (188957): [<ffff80000804a618>] __irq_exit_rcu+0x108/0x1a4

[ rjw: Because can be freed by the gov_attr_set_put() in
  cpufreq_dbs_governor_exit() now, it is also necessary to put the
  invocation of the governor ->exit() callback into the new
  cpufreq_dbs_data_release() function. ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1e32083f327184b6226ce320ef30085ce785ea4e
  - https://git.kernel.org/stable/c/a1964688582d26af1328e19b658933659fb54337
  - https://git.kernel.org/stable/c/a85ee6401a47ae3fc64ba506cacb3e7873823c65

------------------------------------------------------------

CVE ID: CVE-2022-49514
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: mediatek: Fix error handling in mt8173_max98090_dev_probe

Call of_node_put(platform_node) to avoid refcount leak in
the error path.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0a1901f34f775b83ea4b8dbb5ed992147b9b8531
  - https://git.kernel.org/stable/c/1e932aba3c7628c9f880ee9c2cfcc2ae3ba0c01e
  - https://git.kernel.org/stable/c/23f340ed906c758cec6527376768e3bc1474ac30
  - https://git.kernel.org/stable/c/48889eb3cce91d7f58e02bc07277b7f724b7a54a
  - https://git.kernel.org/stable/c/4f4e0454e226de3bf4efd7e7924d1edc571c52d5
  - https://git.kernel.org/stable/c/98d5afe868df998b0244f4c229ab758b4083684a
  - https://git.kernel.org/stable/c/cc43b9fdca519c5b13be6a717bacbebccd628cf6
  - https://git.kernel.org/stable/c/ebd5cb4f1f3f10b839e7575219e0f17b60c23113
  - https://git.kernel.org/stable/c/fb66e0512e5ccc093070e21cf88cce8d98c181b5

------------------------------------------------------------

CVE ID: CVE-2022-49515
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: cs35l41: Fix an out-of-bounds access in otp_packed_element_t

The CS35L41_NUM_OTP_ELEM is 100, but only 99 entries are defined in
the array otp_map_1/2[CS35L41_NUM_OTP_ELEM], this will trigger UBSAN
to report a shift-out-of-bounds warning in the cs35l41_otp_unpack()
since the last entry in the array will result in GENMASK(-1, 0).

UBSAN reports this problem:
 UBSAN: shift-out-of-bounds in /home/hwang4/build/jammy/jammy/sound/soc/codecs/cs35l41-lib.c:836:8
 shift exponent 64 is too large for 64-bit type 'long unsigned int'
 CPU: 10 PID: 595 Comm: systemd-udevd Not tainted 5.15.0-23-generic #23
 Hardware name: LENOVO \x02MFG_IN_GO/\x02MFG_IN_GO, BIOS N3GET19W (1.00 ) 03/11/2022
 Call Trace:
  <TASK>
  show_stack+0x52/0x58
  dump_stack_lvl+0x4a/0x5f
  dump_stack+0x10/0x12
  ubsan_epilogue+0x9/0x45
  __ubsan_handle_shift_out_of_bounds.cold+0x61/0xef
  ? regmap_unlock_mutex+0xe/0x10
  cs35l41_otp_unpack.cold+0x1c6/0x2b2 [snd_soc_cs35l41_lib]
  cs35l41_hda_probe+0x24f/0x33a [snd_hda_scodec_cs35l41]
  cs35l41_hda_i2c_probe+0x65/0x90 [snd_hda_scodec_cs35l41_i2c]
  ? cs35l41_hda_i2c_remove+0x20/0x20 [snd_hda_scodec_cs35l41_i2c]
  i2c_device_probe+0x252/0x2b0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9f342904216f378e88008bb0ce1ae200a4b99fe8
  - https://git.kernel.org/stable/c/a59b9958416096dd21dc4f62b0c5be525d459ca8
  - https://git.kernel.org/stable/c/dbc35268e14d5d89c7a9db72009ad4dcd9ede646

------------------------------------------------------------

CVE ID: CVE-2022-49516
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: always check VF VSI pointer values

The ice_get_vf_vsi function can return NULL in some cases, such as if
handling messages during a reset where the VSI is being removed and
recreated.

Several places throughout the driver do not bother to check whether this
VSI pointer is valid. Static analysis tools maybe report issues because
they detect paths where a potentially NULL pointer could be dereferenced.

Fix this by checking the return value of ice_get_vf_vsi everywhere.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/baeb705fd6a7245cc1fa69ed991a9cffdf44a174
  - https://git.kernel.org/stable/c/e7be3877589d539c52e5d1d23a625f889b541b9d

------------------------------------------------------------

CVE ID: CVE-2022-49517
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: mediatek: Fix missing of_node_put in mt2701_wm8960_machine_probe

This node pointer is returned by of_parse_phandle() with
refcount incremented in this function.
Calling of_node_put() to avoid the refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/05654431a18fe24e5e46a375d98904134628a102
  - https://git.kernel.org/stable/c/318afb1442eeef089fe7f8a8297d97c0302ff6f6
  - https://git.kernel.org/stable/c/61a85a20e8df5e0a92cfe169c92425c7bae0753b
  - https://git.kernel.org/stable/c/9345122f5fb9f97a206f440f38bb656e53f46912
  - https://git.kernel.org/stable/c/94587aa17abf8b26f543d2b29c44abc21bc36836
  - https://git.kernel.org/stable/c/bc2afecaabd2a2c9f17e43b4793a30e3461bfb29
  - https://git.kernel.org/stable/c/c71494f5f2b444adfd992a7359a0d2a791642b39
  - https://git.kernel.org/stable/c/f279c49f17ce10866087ea6c0c57382158974b63

------------------------------------------------------------

CVE ID: CVE-2022-49518
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: ipc3-topology: Correct get_control_data for non bytes payload

It is possible to craft a topology where sof_get_control_data() would do
out of bounds access because it expects that it is only called when the
payload is bytes type.
Confusingly it also handles other types of controls, but the payload
parsing implementation is only valid for bytes.

Fix the code to count the non bytes controls and instead of storing a
pointer to sof_abi_hdr in sof_widget_data (which is only valid for bytes),
store the pointer to the data itself and add a new member to save the size
of the data.

In case of non bytes controls we store the pointer to the chanv itself,
which is just an array of values at the end.

In case of bytes control, drop the wrong cdata->data (wdata[i].pdata) check
against NULL since it is incorrect and invalid in this context.
The data is pointing to the end of cdata struct, so it should never be
null.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/896b03bb7c7010042786cfae2115083d4c241dd3
  - https://git.kernel.org/stable/c/a962890a5a3cce903ff7c7a19fadee63ed9efdc7

------------------------------------------------------------

CVE ID: CVE-2022-49519
Description: In the Linux kernel, the following vulnerability has been resolved:

ath10k: skip ath10k_halt during suspend for driver state RESTARTING

Double free crash is observed when FW recovery(caused by wmi
timeout/crash) is followed by immediate suspend event. The FW recovery
is triggered by ath10k_core_restart() which calls driver clean up via
ath10k_halt(). When the suspend event occurs between the FW recovery,
the restart worker thread is put into frozen state until suspend completes.
The suspend event triggers ath10k_stop() which again triggers ath10k_halt()
The double invocation of ath10k_halt() causes ath10k_htt_rx_free() to be
called twice(Note: ath10k_htt_rx_alloc was not called by restart worker
thread because of its frozen state), causing the crash.

To fix this, during the suspend flow, skip call to ath10k_halt() in
ath10k_stop() when the current driver state is ATH10K_STATE_RESTARTING.
Also, for driver state ATH10K_STATE_RESTARTING, call
ath10k_wait_for_suspend() in ath10k_stop(). This is because call to
ath10k_wait_for_suspend() is skipped later in
[ath10k_halt() > ath10k_core_stop()] for the driver state
ATH10K_STATE_RESTARTING.

The frozen restart worker thread will be cancelled during resume when the
device comes out of suspend.

Below is the crash stack for reference:

[  428.469167] ------------[ cut here ]------------
[  428.469180] kernel BUG at mm/slub.c:4150!
[  428.469193] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
[  428.469219] Workqueue: events_unbound async_run_entry_fn
[  428.469230] RIP: 0010:kfree+0x319/0x31b
[  428.469241] RSP: 0018:ffffa1fac015fc30 EFLAGS: 00010246
[  428.469247] RAX: ffffedb10419d108 RBX: ffff8c05262b0000
[  428.469252] RDX: ffff8c04a8c07000 RSI: 0000000000000000
[  428.469256] RBP: ffffa1fac015fc78 R08: 0000000000000000
[  428.469276] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  428.469285] Call Trace:
[  428.469295]  ? dma_free_attrs+0x5f/0x7d
[  428.469320]  ath10k_core_stop+0x5b/0x6f
[  428.469336]  ath10k_halt+0x126/0x177
[  428.469352]  ath10k_stop+0x41/0x7e
[  428.469387]  drv_stop+0x88/0x10e
[  428.469410]  __ieee80211_suspend+0x297/0x411
[  428.469441]  rdev_suspend+0x6e/0xd0
[  428.469462]  wiphy_suspend+0xb1/0x105
[  428.469483]  ? name_show+0x2d/0x2d
[  428.469490]  dpm_run_callback+0x8c/0x126
[  428.469511]  ? name_show+0x2d/0x2d
[  428.469517]  __device_suspend+0x2e7/0x41b
[  428.469523]  async_suspend+0x1f/0x93
[  428.469529]  async_run_entry_fn+0x3d/0xd1
[  428.469535]  process_one_work+0x1b1/0x329
[  428.469541]  worker_thread+0x213/0x372
[  428.469547]  kthread+0x150/0x15f
[  428.469552]  ? pr_cont_work+0x58/0x58
[  428.469558]  ? kthread_blkcg+0x31/0x31

Tested-on: QCA6174 hw3.2 PCI WLAN.RM.4.4.1-00288-QCARMSWPZ-1
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5321e5211b5dc873e2e3d0deb749e69ecf4dbfe5
  - https://git.kernel.org/stable/c/7eb14cb604f49e58b7cf6faa87961a865a3c8649
  - https://git.kernel.org/stable/c/8aa3750986ffcf73e0692db3b40dd3a8e8c0c575
  - https://git.kernel.org/stable/c/b72a4aff947ba807177bdabb43debaf2c66bee05
  - https://git.kernel.org/stable/c/c2272428090d0d215a3f017cbbbad731c07eee53

------------------------------------------------------------

CVE ID: CVE-2022-49520
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: compat: Do not treat syscall number as ESR_ELx for a bad syscall

If a compat process tries to execute an unknown system call above the
__ARM_NR_COMPAT_END number, the kernel sends a SIGILL signal to the
offending process. Information about the error is printed to dmesg in
compat_arm_syscall() -> arm64_notify_die() -> arm64_force_sig_fault() ->
arm64_show_signal().

arm64_show_signal() interprets a non-zero value for
current->thread.fault_code as an exception syndrome and displays the
message associated with the ESR_ELx.EC field (bits 31:26).
current->thread.fault_code is set in compat_arm_syscall() ->
arm64_notify_die() with the bad syscall number instead of a valid ESR_ELx
value. This means that the ESR_ELx.EC field has the value that the user set
for the syscall number and the kernel can end up printing bogus exception
messages*. For example, for the syscall number 0x68000000, which evaluates
to ESR_ELx.EC value of 0x1A (ESR_ELx_EC_FPAC) the kernel prints this error:

[   18.349161] syscall[300]: unhandled exception: ERET/ERETAA/ERETAB, ESR 0x68000000, Oops - bad compat syscall(2) in syscall[10000+50000]
[   18.350639] CPU: 2 PID: 300 Comm: syscall Not tainted 5.18.0-rc1 #79
[   18.351249] Hardware name: Pine64 RockPro64 v2.0 (DT)
[..]

which is misleading, as the bad compat syscall has nothing to do with
pointer authentication.

Stop arm64_show_signal() from printing exception syndrome information by
having compat_arm_syscall() set the ESR_ELx value to 0, as it has no
meaning for an invalid system call number. The example above now becomes:

[   19.935275] syscall[301]: unhandled exception: Oops - bad compat syscall(2) in syscall[10000+50000]
[   19.936124] CPU: 1 PID: 301 Comm: syscall Not tainted 5.18.0-rc1-00005-g7e08006d4102 #80
[   19.936894] Hardware name: Pine64 RockPro64 v2.0 (DT)
[..]

which although shows less information because the syscall number,
wrongfully advertised as the ESR value, is missing, it is better than
showing plainly wrong information. The syscall number can be easily
obtained with strace.

*A 32-bit value above or equal to 0x8000_0000 is interpreted as a negative
integer in compat_arm_syscal() and the condition scno < __ARM_NR_COMPAT_END
evaluates to true; the syscall will exit to userspace in this case with the
ENOSYS error code instead of arm64_notify_die() being called.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/095e975f8150ccd7f852eb578c1cdbdd2f517c7a
  - https://git.kernel.org/stable/c/3910ae71cb963fa2b68e684489d4fc3d105afda0
  - https://git.kernel.org/stable/c/3fed9e551417b84038b15117732ea4505eee386b
  - https://git.kernel.org/stable/c/621916afe8cd4f322eb12759b64a2f938d4e551d
  - https://git.kernel.org/stable/c/ad97425d23af3c3b8d4f6a2bb666cb485087c007
  - https://git.kernel.org/stable/c/efd183d988b416fcdf6f7c298a17ced4859ca77d

------------------------------------------------------------

CVE ID: CVE-2022-49521
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Fix resource leak in lpfc_sli4_send_seq_to_ulp()

If no handler is found in lpfc_complete_unsol_iocb() to match the rctl of a
received frame, the frame is dropped and resources are leaked.

Fix by returning resources when discarding an unhandled frame type.  Update
lpfc_fc_frame_check() handling of NOP basic link service.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/08709769ff2fb6c5ffedcda3742700d8ea1618a8
  - https://git.kernel.org/stable/c/40cf4ea4d2d497f7732c87d350ba5c3f5e8a43a1
  - https://git.kernel.org/stable/c/646db1a560f44236b7278b822ca99a1d3b6ea72c
  - https://git.kernel.org/stable/c/7860d8f8082605b57596aa82d3d438c1fdad9a9e
  - https://git.kernel.org/stable/c/fa1b509d41c5433672f72c0615cf4aefa0611c99

------------------------------------------------------------

CVE ID: CVE-2022-49522
Description: In the Linux kernel, the following vulnerability has been resolved:

mmc: jz4740: Apply DMA engine limits to maximum segment size

Do what is done in other DMA-enabled MMC host drivers (cf. host/mmci.c) and
limit the maximum segment size based on the DMA engine's capabilities. This
is needed to avoid warnings like the following with CONFIG_DMA_API_DEBUG=y.

------------[ cut here ]------------
WARNING: CPU: 0 PID: 21 at kernel/dma/debug.c:1162 debug_dma_map_sg+0x2f4/0x39c
DMA-API: jz4780-dma 13420000.dma-controller: mapping sg segment longer than device claims to support [len=98304] [max=65536]
CPU: 0 PID: 21 Comm: kworker/0:1H Not tainted 5.18.0-rc1 #19
Workqueue: kblockd blk_mq_run_work_fn
Stack : 81575aec 00000004 80620000 80620000 80620000 805e7358 00000009 801537ac
        814c832c 806276e3 806e34b4 80620000 81575aec 00000001 81575ab8 09291444
        00000000 00000000 805e7358 81575958 ffffffea 8157596c 00000000 636f6c62
        6220646b 80387a70 0000000f 6d5f6b6c 80620000 00000000 81575ba4 00000009
        805e170c 80896640 00000001 00010000 00000000 00000000 00006098 806e0000
        ...
Call Trace:
[<80107670>] show_stack+0x84/0x120
[<80528cd8>] __warn+0xb8/0xec
[<80528d78>] warn_slowpath_fmt+0x6c/0xb8
[<8016f1d4>] debug_dma_map_sg+0x2f4/0x39c
[<80169d4c>] __dma_map_sg_attrs+0xf0/0x118
[<8016a27c>] dma_map_sg_attrs+0x14/0x28
[<804f66b4>] jz4740_mmc_prepare_dma_data+0x74/0xa4
[<804f6714>] jz4740_mmc_pre_request+0x30/0x54
[<804f4ff4>] mmc_blk_mq_issue_rq+0x6e0/0x7bc
[<804f5590>] mmc_mq_queue_rq+0x220/0x2d4
[<8038b2c0>] blk_mq_dispatch_rq_list+0x480/0x664
[<80391040>] blk_mq_do_dispatch_sched+0x2dc/0x370
[<80391468>] __blk_mq_sched_dispatch_requests+0xec/0x164
[<80391540>] blk_mq_sched_dispatch_requests+0x44/0x94
[<80387900>] __blk_mq_run_hw_queue+0xb0/0xcc
[<80134c14>] process_one_work+0x1b8/0x264
[<80134ff8>] worker_thread+0x2ec/0x3b8
[<8013b13c>] kthread+0x104/0x10c
[<80101dcc>] ret_from_kernel_thread+0x14/0x1c

---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/353298cadbd4c7d8e8a16d6000066414694933c3
  - https://git.kernel.org/stable/c/7923f95997a79cef2ad161a2facae64c25a0bca0
  - https://git.kernel.org/stable/c/807f90f1960a59dc557542b818c484a8db9ac978
  - https://git.kernel.org/stable/c/90281cadf5077f2d2bec8b08c2ead1f8cd12660e
  - https://git.kernel.org/stable/c/a828920b9ec0d89d3011198d482b7fe224d2de19
  - https://git.kernel.org/stable/c/afadb04f1d6e74b18a253403f5274cde5e3fd7bd

------------------------------------------------------------

CVE ID: CVE-2022-49523
Description: In the Linux kernel, the following vulnerability has been resolved:

ath11k: disable spectral scan during spectral deinit

When ath11k modules are removed using rmmod with spectral scan enabled,
crash is observed. Different crash trace is observed for each crash.

Send spectral scan disable WMI command to firmware before cleaning
the spectral dbring in the spectral_deinit API to avoid this crash.

call trace from one of the crash observed:
[ 1252.880802] Unable to handle kernel NULL pointer dereference at virtual address 00000008
[ 1252.882722] pgd = 0f42e886
[ 1252.890955] [00000008] *pgd=00000000
[ 1252.893478] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
[ 1253.093035] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.89 #0
[ 1253.115261] Hardware name: Generic DT based system
[ 1253.121149] PC is at ath11k_spectral_process_data+0x434/0x574 [ath11k]
[ 1253.125940] LR is at 0x88e31017
[ 1253.132448] pc : [<7f9387b8>]    lr : [<88e31017>]    psr: a0000193
[ 1253.135488] sp : 80d01bc8  ip : 00000001  fp : 970e0000
[ 1253.141737] r10: 88e31000  r9 : 970ec000  r8 : 00000080
[ 1253.146946] r7 : 94734040  r6 : a0000113  r5 : 00000057  r4 : 00000000
[ 1253.152159] r3 : e18cb694  r2 : 00000217  r1 : 1df1f000  r0 : 00000001
[ 1253.158755] Flags: NzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
[ 1253.165266] Control: 10c0383d  Table: 5e71006a  DAC: 00000055
[ 1253.172472] Process swapper/0 (pid: 0, stack limit = 0x60870141)
[ 1253.458055] [<7f9387b8>] (ath11k_spectral_process_data [ath11k]) from [<7f917fdc>] (ath11k_dbring_buffer_release_event+0x214/0x2e4 [ath11k])
[ 1253.466139] [<7f917fdc>] (ath11k_dbring_buffer_release_event [ath11k]) from [<7f8ea3c4>] (ath11k_wmi_tlv_op_rx+0x1840/0x29cc [ath11k])
[ 1253.478807] [<7f8ea3c4>] (ath11k_wmi_tlv_op_rx [ath11k]) from [<7f8fe868>] (ath11k_htc_rx_completion_handler+0x180/0x4e0 [ath11k])
[ 1253.490699] [<7f8fe868>] (ath11k_htc_rx_completion_handler [ath11k]) from [<7f91308c>] (ath11k_ce_per_engine_service+0x2c4/0x3b4 [ath11k])
[ 1253.502386] [<7f91308c>] (ath11k_ce_per_engine_service [ath11k]) from [<7f9a4198>] (ath11k_pci_ce_tasklet+0x28/0x80 [ath11k_pci])
[ 1253.514811] [<7f9a4198>] (ath11k_pci_ce_tasklet [ath11k_pci]) from [<8032227c>] (tasklet_action_common.constprop.2+0x64/0xe8)
[ 1253.526476] [<8032227c>] (tasklet_action_common.constprop.2) from [<803021e8>] (__do_softirq+0x130/0x2d0)
[ 1253.537756] [<803021e8>] (__do_softirq) from [<80322610>] (irq_exit+0xcc/0xe8)
[ 1253.547304] [<80322610>] (irq_exit) from [<8036a4a4>] (__handle_domain_irq+0x60/0xb4)
[ 1253.554428] [<8036a4a4>] (__handle_domain_irq) from [<805eb348>] (gic_handle_irq+0x4c/0x90)
[ 1253.562321] [<805eb348>] (gic_handle_irq) from [<80301a78>] (__irq_svc+0x58/0x8c)

Tested-on: QCN6122 hw1.0 AHB WLAN.HK.2.6.0.1-00851-QCAHKSWPL_SILICONZ-1
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/161c64de239c7018e0295e7e0520a19f00aa32dc
  - https://git.kernel.org/stable/c/451b9076903a057b7b8d5b24dc84b3e436a1c743
  - https://git.kernel.org/stable/c/4b9c54caef58d2b55074710952cda70540722c01
  - https://git.kernel.org/stable/c/60afa4f4e1350c876d8a061182a70c224de275dd
  - https://git.kernel.org/stable/c/8f15e67af9bec5a69e815e0230a70cffddae371a

------------------------------------------------------------

CVE ID: CVE-2022-49524
Description: In the Linux kernel, the following vulnerability has been resolved:

media: pci: cx23885: Fix the error handling in cx23885_initdev()

When the driver fails to call the dma_set_mask(), the driver will get
the following splat:

[   55.853884] BUG: KASAN: use-after-free in __process_removed_driver+0x3c/0x240
[   55.854486] Read of size 8 at addr ffff88810de60408 by task modprobe/590
[   55.856822] Call Trace:
[   55.860327]  __process_removed_driver+0x3c/0x240
[   55.861347]  bus_for_each_dev+0x102/0x160
[   55.861681]  i2c_del_driver+0x2f/0x50

This is because the driver has initialized the i2c related resources
in cx23885_dev_setup() but not released them in error handling, fix this
bug by modifying the error path that jumps after failing to call the
dma_set_mask().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/453514a874c78df1e7804e6e3aaa60c8d8deb6a8
  - https://git.kernel.org/stable/c/6041d1a0365baa729b6adfb6ed5386d9388018db
  - https://git.kernel.org/stable/c/7b9978e1c94e569d65a0e7e719abb9340f5db4a0
  - https://git.kernel.org/stable/c/86bd6a579c6c60547706cabf299cd2c9feab3332
  - https://git.kernel.org/stable/c/98106f100f50c487469903b9cf6d966785fc9cc3
  - https://git.kernel.org/stable/c/ca17e7a532d1a55466cc007b3f4d319541a27493
  - https://git.kernel.org/stable/c/e8123311cf06d7dae71e8c5fe78e0510d20cd30b
  - https://git.kernel.org/stable/c/fa636e9ee4442215cd9a2e079cd5a8e1fe0cb8ba

------------------------------------------------------------

CVE ID: CVE-2022-49525
Description: In the Linux kernel, the following vulnerability has been resolved:

media: cx25821: Fix the warning when removing the module

When removing the module, we will get the following warning:

[   14.746697] remove_proc_entry: removing non-empty directory 'irq/21', leaking at least 'cx25821[1]'
[   14.747449] WARNING: CPU: 4 PID: 368 at fs/proc/generic.c:717 remove_proc_entry+0x389/0x3f0
[   14.751611] RIP: 0010:remove_proc_entry+0x389/0x3f0
[   14.759589] Call Trace:
[   14.759792]  <TASK>
[   14.759975]  unregister_irq_proc+0x14c/0x170
[   14.760340]  irq_free_descs+0x94/0xe0
[   14.760640]  mp_unmap_irq+0xb6/0x100
[   14.760937]  acpi_unregister_gsi_ioapic+0x27/0x40
[   14.761334]  acpi_pci_irq_disable+0x1d3/0x320
[   14.761688]  pci_disable_device+0x1ad/0x380
[   14.762027]  ? _raw_spin_unlock_irqrestore+0x2d/0x60
[   14.762442]  ? cx25821_shutdown+0x20/0x9f0 [cx25821]
[   14.762848]  cx25821_finidev+0x48/0xc0 [cx25821]
[   14.763242]  pci_device_remove+0x92/0x240

Fix this by freeing the irq before call pci_disable_device().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/005fd553f5f10fe8618d92f94ad10f9051eac331
  - https://git.kernel.org/stable/c/1f0fc1dfb5fdd456657519a97fab83691b96c6a0
  - https://git.kernel.org/stable/c/2203436a4d24302871617373a7eb21bc17e38762
  - https://git.kernel.org/stable/c/222292930c8ecc3516e03ec1f9fa8448be7ff496
  - https://git.kernel.org/stable/c/258639bc55a586ee6df92d89786ccf1c71546d70
  - https://git.kernel.org/stable/c/3f94169affa33c9db4a439d88f09cb2ed3a33332
  - https://git.kernel.org/stable/c/4d6295b6d986476232332fffd08575b185f90d81
  - https://git.kernel.org/stable/c/5beb85ff7d005ddb7bf604a4f2dc76f01b84b318
  - https://git.kernel.org/stable/c/9d92291698e5cc35a2b8a1106a01ddd7d60ade2d

------------------------------------------------------------

CVE ID: CVE-2022-49526
Description: In the Linux kernel, the following vulnerability has been resolved:

md/bitmap: don't set sb values if can't pass sanity check

If bitmap area contains invalid data, kernel will crash then mdadm
triggers "Segmentation fault".
This is cluster-md speical bug. In non-clustered env, mdadm will
handle broken metadata case. In clustered array, only kernel space
handles bitmap slot info. But even this bug only happened in clustered
env, current sanity check is wrong, the code should be changed.

How to trigger: (faulty injection)

dd if=/dev/zero bs=1M count=1 oflag=direct of=/dev/sda
dd if=/dev/zero bs=1M count=1 oflag=direct of=/dev/sdb
mdadm -C /dev/md0 -b clustered -e 1.2 -n 2 -l mirror /dev/sda /dev/sdb
mdadm -Ss
echo aaa > magic.txt
 == below modifying slot 2 bitmap data ==
dd if=magic.txt of=/dev/sda seek=16384 bs=1 count=3 <== destroy magic
dd if=/dev/zero of=/dev/sda seek=16436 bs=1 count=4 <== ZERO chunksize
mdadm -A /dev/md0 /dev/sda /dev/sdb
 == kernel crashes. mdadm outputs "Segmentation fault" ==

Reason of kernel crash:

In md_bitmap_read_sb (called by md_bitmap_create), bad bitmap magic didn't
block chunksize assignment, and zero value made DIV_ROUND_UP_SECTOR_T()
trigger "divide error".

Crash log:

kernel: md: md0 stopped.
kernel: md/raid1:md0: not clean -- starting background reconstruction
kernel: md/raid1:md0: active with 2 out of 2 mirrors
kernel: dlm: ... ...
kernel: md-cluster: Joined cluster 44810aba-38bb-e6b8-daca-bc97a0b254aa slot 1
kernel: md0: invalid bitmap file superblock: bad magic
kernel: md_bitmap_copy_from_slot can't get bitmap from slot 2
kernel: md-cluster: Could not gather bitmaps from slot 2
kernel: divide error: 0000 [#1] SMP NOPTI
kernel: CPU: 0 PID: 1603 Comm: mdadm Not tainted 5.14.6-1-default
kernel: Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
kernel: RIP: 0010:md_bitmap_create+0x1d1/0x850 [md_mod]
kernel: RSP: 0018:ffffc22ac0843ba0 EFLAGS: 00010246
kernel: ... ...
kernel: Call Trace:
kernel:  ? dlm_lock_sync+0xd0/0xd0 [md_cluster 77fe..7a0]
kernel:  md_bitmap_copy_from_slot+0x2c/0x290 [md_mod 24ea..d3a]
kernel:  load_bitmaps+0xec/0x210 [md_cluster 77fe..7a0]
kernel:  md_bitmap_load+0x81/0x1e0 [md_mod 24ea..d3a]
kernel:  do_md_run+0x30/0x100 [md_mod 24ea..d3a]
kernel:  md_ioctl+0x1290/0x15a0 [md_mod 24ea....d3a]
kernel:  ? mddev_unlock+0xaa/0x130 [md_mod 24ea..d3a]
kernel:  ? blkdev_ioctl+0xb1/0x2b0
kernel:  block_ioctl+0x3b/0x40
kernel:  __x64_sys_ioctl+0x7f/0xb0
kernel:  do_syscall_64+0x59/0x80
kernel:  ? exit_to_user_mode_prepare+0x1ab/0x230
kernel:  ? syscall_exit_to_user_mode+0x18/0x40
kernel:  ? do_syscall_64+0x69/0x80
kernel:  entry_SYSCALL_64_after_hwframe+0x44/0xae
kernel: RIP: 0033:0x7f4a15fa722b
kernel: ... ...
kernel: ---[ end trace 8afa7612f559c868 ]---
kernel: RIP: 0010:md_bitmap_create+0x1d1/0x850 [md_mod]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0959aa00f9765bd8c654b1365012e41b51c733cc
  - https://git.kernel.org/stable/c/27f672af28a8e9b783ff7f0eaf7ef2fbd5a2f4ba
  - https://git.kernel.org/stable/c/422e8f7ba1e08c8e0e88d375bcb550bc2bbfe96d
  - https://git.kernel.org/stable/c/cf9392282a2cf5a8d83dd1c5aa1a097e12f172bc
  - https://git.kernel.org/stable/c/d8f1558e1daf54f53a90b4c5700ae3e3a4b13412
  - https://git.kernel.org/stable/c/e68cb83a57a458b01c9739e2ad9cb70b04d1e6d2
  - https://git.kernel.org/stable/c/e69e93120f6219b9cc4fba3b515b6ababd8548aa

------------------------------------------------------------

CVE ID: CVE-2022-49527
Description: In the Linux kernel, the following vulnerability has been resolved:

media: venus: hfi: avoid null dereference in deinit

If venus_probe fails at pm_runtime_put_sync the error handling first
calls hfi_destroy and afterwards hfi_core_deinit. As hfi_destroy sets
core->ops to NULL, hfi_core_deinit cannot call the core_deinit function
anymore.

Avoid this null pointer derefence by skipping the call when necessary.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0ac84ab50712879eac3c1dd2598440652a85d3d0
  - https://git.kernel.org/stable/c/0ed5a643b1a4a46b9b7bfba5d468c10cc30e1359
  - https://git.kernel.org/stable/c/2533acb652359c9e097dfa33587896af782e8a91
  - https://git.kernel.org/stable/c/27ad46da44177a78a4a0cae6fe03906888c61aa1
  - https://git.kernel.org/stable/c/86594f6af867b5165d2ba7b5a71fae3a5961e56c
  - https://git.kernel.org/stable/c/9c385b961d4c378228e80f6abea8509cb67feab6
  - https://git.kernel.org/stable/c/a21d15dde21d7e8ae047eb8368677407db45d840
  - https://git.kernel.org/stable/c/b73ed0510bb8d9647cd8e8a4c4c8772bbe545c3a

------------------------------------------------------------

CVE ID: CVE-2022-49528
Description: In the Linux kernel, the following vulnerability has been resolved:

media: i2c: dw9714: Disable the regulator when the driver fails to probe

When the driver fails to probe, we will get the following splat:

[   59.305988] ------------[ cut here ]------------
[   59.306417] WARNING: CPU: 2 PID: 395 at drivers/regulator/core.c:2257 _regulator_put+0x3ec/0x4e0
[   59.310345] RIP: 0010:_regulator_put+0x3ec/0x4e0
[   59.318362] Call Trace:
[   59.318582]  <TASK>
[   59.318765]  regulator_put+0x1f/0x30
[   59.319058]  devres_release_group+0x319/0x3d0
[   59.319420]  i2c_device_probe+0x766/0x940

Fix this by disabling the regulator in error handling.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/02276e18defa2fccf16413b44440277d98c2b1ea
  - https://git.kernel.org/stable/c/fa83ea1de5b3efd87fe01408d5db1fd2ff4767fa

------------------------------------------------------------

CVE ID: CVE-2022-49529
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu/pm: fix the null pointer while the smu is disabled

It needs to check if the pp_funcs is initialized while release the
context, otherwise it will trigger null pointer panic while the software
smu is not enabled.

[ 1109.404555] BUG: kernel NULL pointer dereference, address: 0000000000000078
[ 1109.404609] #PF: supervisor read access in kernel mode
[ 1109.404638] #PF: error_code(0x0000) - not-present page
[ 1109.404657] PGD 0 P4D 0
[ 1109.404672] Oops: 0000 [#1] PREEMPT SMP NOPTI
[ 1109.404701] CPU: 7 PID: 9150 Comm: amdgpu_test Tainted: G           OEL    5.16.0-custom #1
[ 1109.404732] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
[ 1109.404765] RIP: 0010:amdgpu_dpm_force_performance_level+0x1d/0x170 [amdgpu]
[ 1109.405109] Code: 5d c3 44 8b a3 f0 80 00 00 eb e5 66 90 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 41 55 41 54 53 48 83 ec 08 4c 8b b7 f0 7d 00 00 <49> 83 7e 78 00 0f 84 f2 00 00 00 80 bf 87 80 00 00 00 48 89 fb 0f
[ 1109.405176] RSP: 0018:ffffaf3083ad7c20 EFLAGS: 00010282
[ 1109.405203] RAX: 0000000000000000 RBX: ffff9796b1c14600 RCX: 0000000002862007
[ 1109.405229] RDX: ffff97968591c8c0 RSI: 0000000000000001 RDI: ffff9796a3700000
[ 1109.405260] RBP: ffffaf3083ad7c50 R08: ffffffff9897de00 R09: ffff979688d9db60
[ 1109.405286] R10: 0000000000000000 R11: ffff979688d9db90 R12: 0000000000000001
[ 1109.405316] R13: ffff9796a3700000 R14: 0000000000000000 R15: ffff9796a3708fc0
[ 1109.405345] FS:  00007ff055cff180(0000) GS:ffff9796bfdc0000(0000) knlGS:0000000000000000
[ 1109.405378] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1109.405400] CR2: 0000000000000078 CR3: 000000000a394000 CR4: 00000000000506e0
[ 1109.405434] Call Trace:
[ 1109.405445]  <TASK>
[ 1109.405456]  ? delete_object_full+0x1d/0x20
[ 1109.405480]  amdgpu_ctx_set_stable_pstate+0x7c/0xa0 [amdgpu]
[ 1109.405698]  amdgpu_ctx_fini.part.0+0xcb/0x100 [amdgpu]
[ 1109.405911]  amdgpu_ctx_do_release+0x71/0x80 [amdgpu]
[ 1109.406121]  amdgpu_ctx_ioctl+0x52d/0x550 [amdgpu]
[ 1109.406327]  ? _raw_spin_unlock+0x1a/0x30
[ 1109.406354]  ? drm_gem_handle_delete+0x81/0xb0 [drm]
[ 1109.406400]  ? amdgpu_ctx_get_entity+0x2c0/0x2c0 [amdgpu]
[ 1109.406609]  drm_ioctl_kernel+0xb6/0x140 [drm]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/49ec3441aa5e5940f3e82dd2f0205b9c856e399d
  - https://git.kernel.org/stable/c/eea5c7b3390c6e006ba4cbd906447dd8cea8cfbf

------------------------------------------------------------

CVE ID: CVE-2022-49530
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm: fix double free in si_parse_power_table()

In function si_parse_power_table(), array adev->pm.dpm.ps and its member
is allocated. If the allocation of each member fails, the array itself
is freed and returned with an error code. However, the array is later
freed again in si_dpm_fini() function which is called when the function
returns an error.

This leads to potential double free of the array adev->pm.dpm.ps, as
well as leak of its array members, since the members are not freed in
the allocation function and the array is not nulled when freed.
In addition adev->pm.dpm.num_ps, which keeps track of the allocated
array member, is not updated until the member allocation is
successfully finished, this could also lead to either use after free,
or uninitialized variable access in si_dpm_fini().

Fix this by postponing the free of the array until si_dpm_fini() and
increment adev->pm.dpm.num_ps everytime the array member is allocated.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/2615464854505188f909d0c07c37a6623693b5c7
  - https://git.kernel.org/stable/c/43eb9b667b95f2a31c63e8949b0d2161b9be59c3
  - https://git.kernel.org/stable/c/6c5bdaa1325be7f04b79ea992ab216739192d342
  - https://git.kernel.org/stable/c/a5ce7051db044290b1a95045ff03c249005a3aa4
  - https://git.kernel.org/stable/c/af832028af6f44c6c45645757079c4ed6884ade5
  - https://git.kernel.org/stable/c/c0e811c4ccf3b42705976285e3a94cc82dea7300
  - https://git.kernel.org/stable/c/ca1ce206894dd976275c78ee38dbc19873f22de9
  - https://git.kernel.org/stable/c/f3fa2becf2fc25b6ac7cf8d8b1a2e4a86b3b72bd
  - https://git.kernel.org/stable/c/fd2eff8b9dcbe469c3b7bbbc7083ab5ed94de07b

------------------------------------------------------------

CVE ID: CVE-2022-49531
Description: In the Linux kernel, the following vulnerability has been resolved:

loop: implement ->free_disk

Ensure that the lo_device which is stored in the gendisk private
data is valid until the gendisk is freed.  Currently the loop driver
uses a lot of effort to make sure a device is not freed when it is
still in use, but to to fix a potential deadlock this will be relaxed
a bit soon.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/aadd1443aae7fe8956e3b11157827067f034406a
  - https://git.kernel.org/stable/c/d2c7f56f8b5256d57f9e3fc7794c31361d43bdd9

------------------------------------------------------------

CVE ID: CVE-2022-49532
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/virtio: fix NULL pointer dereference in virtio_gpu_conn_get_modes

drm_cvt_mode may return NULL and we should check it.

This bug is found by syzkaller:

FAULT_INJECTION stacktrace:
[  168.567394] FAULT_INJECTION: forcing a failure.
name failslab, interval 1, probability 0, space 0, times 1
[  168.567403] CPU: 1 PID: 6425 Comm: syz Kdump: loaded Not tainted 4.19.90-vhulk2201.1.0.h1035.kasan.eulerosv2r10.aarch64 #1
[  168.567406] Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015
[  168.567408] Call trace:
[  168.567414]  dump_backtrace+0x0/0x310
[  168.567418]  show_stack+0x28/0x38
[  168.567423]  dump_stack+0xec/0x15c
[  168.567427]  should_fail+0x3ac/0x3d0
[  168.567437]  __should_failslab+0xb8/0x120
[  168.567441]  should_failslab+0x28/0xc0
[  168.567445]  kmem_cache_alloc_trace+0x50/0x640
[  168.567454]  drm_mode_create+0x40/0x90
[  168.567458]  drm_cvt_mode+0x48/0xc78
[  168.567477]  virtio_gpu_conn_get_modes+0xa8/0x140 [virtio_gpu]
[  168.567485]  drm_helper_probe_single_connector_modes+0x3a4/0xd80
[  168.567492]  drm_mode_getconnector+0x2e0/0xa70
[  168.567496]  drm_ioctl_kernel+0x11c/0x1d8
[  168.567514]  drm_ioctl+0x558/0x6d0
[  168.567522]  do_vfs_ioctl+0x160/0xf30
[  168.567525]  ksys_ioctl+0x98/0xd8
[  168.567530]  __arm64_sys_ioctl+0x50/0xc8
[  168.567536]  el0_svc_common+0xc8/0x320
[  168.567540]  el0_svc_handler+0xf8/0x160
[  168.567544]  el0_svc+0x10/0x218

KASAN stacktrace:
[  168.567561] BUG: KASAN: null-ptr-deref in virtio_gpu_conn_get_modes+0xb4/0x140 [virtio_gpu]
[  168.567565] Read of size 4 at addr 0000000000000054 by task syz/6425
[  168.567566]
[  168.567571] CPU: 1 PID: 6425 Comm: syz Kdump: loaded Not tainted 4.19.90-vhulk2201.1.0.h1035.kasan.eulerosv2r10.aarch64 #1
[  168.567573] Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015
[  168.567575] Call trace:
[  168.567578]  dump_backtrace+0x0/0x310
[  168.567582]  show_stack+0x28/0x38
[  168.567586]  dump_stack+0xec/0x15c
[  168.567591]  kasan_report+0x244/0x2f0
[  168.567594]  __asan_load4+0x58/0xb0
[  168.567607]  virtio_gpu_conn_get_modes+0xb4/0x140 [virtio_gpu]
[  168.567612]  drm_helper_probe_single_connector_modes+0x3a4/0xd80
[  168.567617]  drm_mode_getconnector+0x2e0/0xa70
[  168.567621]  drm_ioctl_kernel+0x11c/0x1d8
[  168.567624]  drm_ioctl+0x558/0x6d0
[  168.567628]  do_vfs_ioctl+0x160/0xf30
[  168.567632]  ksys_ioctl+0x98/0xd8
[  168.567636]  __arm64_sys_ioctl+0x50/0xc8
[  168.567641]  el0_svc_common+0xc8/0x320
[  168.567645]  el0_svc_handler+0xf8/0x160
[  168.567649]  el0_svc+0x10/0x218
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0f8bc147a963686b7351aa35d1701124ffacac08
  - https://git.kernel.org/stable/c/194d250cdc4a40ccbd179afd522a9e9846957402
  - https://git.kernel.org/stable/c/32e10aabc287f09a148ff759bb9ce70b01b0012c
  - https://git.kernel.org/stable/c/848dd072744ea662ab3097e3c8282bee552df218
  - https://git.kernel.org/stable/c/c51d00472fa54b9b05c17789ed665c17adf3a25d
  - https://git.kernel.org/stable/c/e0828456578cc8ba0a69147f7ae3428392eec287
  - https://git.kernel.org/stable/c/edafcad84c4134ebec4bc24b29ca4497a1184eea
  - https://git.kernel.org/stable/c/f85cb059fad03a3b33a50023be91e944bb065ae8
  - https://git.kernel.org/stable/c/fadc626cae99aaa1325094edc6a9e2b883f3e562

------------------------------------------------------------

CVE ID: CVE-2022-49533
Description: In the Linux kernel, the following vulnerability has been resolved:

ath11k: Change max no of active probe SSID and BSSID to fw capability

The maximum number of SSIDs in a for active probe requests is currently
reported as 16 (WLAN_SCAN_PARAMS_MAX_SSID) when registering the driver.
The scan_req_params structure only has the capacity to hold 10 SSIDs.
This leads to a buffer overflow which can be triggered from
wpa_supplicant in userspace. When copying the SSIDs into the
scan_req_params structure in the ath11k_mac_op_hw_scan route, it can
overwrite the extraie pointer.

Firmware supports 16 ssid * 4 bssid, for each ssid 4 bssid combo probe
request will be sent, so totally 64 probe requests supported. So
set both max ssid and bssid to 16 and 4 respectively. Remove the
redundant macros of ssid and bssid.

Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01300-QCAHKSWPL_SILICONZ-1
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/210505788f1d243232e21ef660efcd4838890ce8
  - https://git.kernel.org/stable/c/50dc9ce9f80554a88e33b73c30851acf2be36ed3
  - https://git.kernel.org/stable/c/ec5dfa1d66f2f71a48dab027d26a9fa78eb0f58f

------------------------------------------------------------

CVE ID: CVE-2022-49534
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Protect memory leak for NPIV ports sending PLOGI_RJT

There is a potential memory leak in lpfc_ignore_els_cmpl() and
lpfc_els_rsp_reject() that was allocated from NPIV PLOGI_RJT
(lpfc_rcv_plogi()'s login_mbox).

Check if cmdiocb->context_un.mbox was allocated in lpfc_ignore_els_cmpl(),
and then free it back to phba->mbox_mem_pool along with mbox->ctx_buf for
service parameters.

For lpfc_els_rsp_reject() failure, free both the ctx_buf for service
parameters and the login_mbox.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/672d1cb40551ea9c95efad43ab6d45e4ab4e015f
  - https://git.kernel.org/stable/c/c00df0f34a6d5e14da379f96ea67e501ce67b002

------------------------------------------------------------

CVE ID: CVE-2022-49535
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Fix null pointer dereference after failing to issue FLOGI and PLOGI

If lpfc_issue_els_flogi() fails and returns non-zero status, the node
reference count is decremented to trigger the release of the nodelist
structure. However, if there is a prior registration or dev-loss-evt work
pending, the node may be released prematurely.  When dev-loss-evt
completes, the released node is referenced causing a use-after-free null
pointer dereference.

Similarly, when processing non-zero ELS PLOGI completion status in
lpfc_cmpl_els_plogi(), the ndlp flags are checked for a transport
registration before triggering node removal.  If dev-loss-evt work is
pending, the node may be released prematurely and a subsequent call to
lpfc_dev_loss_tmo_handler() results in a use after free ndlp dereference.

Add test for pending dev-loss before decrementing the node reference count
for FLOGI, PLOGI, PRLI, and ADISC handling.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/10663ebec0ad5c78493a0dd34c9ee4d73d7ca0df
  - https://git.kernel.org/stable/c/577a942df3de2666f6947bdd3a5c9e8d30073424
  - https://git.kernel.org/stable/c/c7dc74ab7975c9b96284abfe4cca756d75fa4604

------------------------------------------------------------

CVE ID: CVE-2022-49536
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Fix SCSI I/O completion and abort handler deadlock

During stress I/O tests with 500+ vports, hard LOCKUP call traces are
observed.

CPU A:
 native_queued_spin_lock_slowpath+0x192
 _raw_spin_lock_irqsave+0x32
 lpfc_handle_fcp_err+0x4c6
 lpfc_fcp_io_cmd_wqe_cmpl+0x964
 lpfc_sli4_fp_handle_cqe+0x266
 __lpfc_sli4_process_cq+0x105
 __lpfc_sli4_hba_process_cq+0x3c
 lpfc_cq_poll_hdler+0x16
 irq_poll_softirq+0x76
 __softirqentry_text_start+0xe4
 irq_exit+0xf7
 do_IRQ+0x7f

CPU B:
 native_queued_spin_lock_slowpath+0x5b
 _raw_spin_lock+0x1c
 lpfc_abort_handler+0x13e
 scmd_eh_abort_handler+0x85
 process_one_work+0x1a7
 worker_thread+0x30
 kthread+0x112
 ret_from_fork+0x1f

Diagram of lockup:

CPUA                            CPUB
----                            ----
lpfc_cmd->buf_lock
                            phba->hbalock
                            lpfc_cmd->buf_lock
phba->hbalock

Fix by reordering the taking of the lpfc_cmd->buf_lock and phba->hbalock in
lpfc_abort_handler routine so that it tries to take the lpfc_cmd->buf_lock
first before phba->hbalock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/03cbbd7c2f5ee288f648f4aeedc765a181188553
  - https://git.kernel.org/stable/c/0c4eed901285b9cae36a622f32bea3e92490da6c
  - https://git.kernel.org/stable/c/21c0d469349957b5dc811c41200a2a998996ca8d
  - https://git.kernel.org/stable/c/7625e81de2164a082810e1f27547d388406da610

------------------------------------------------------------

CVE ID: CVE-2022-49537
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Fix call trace observed during I/O with CMF enabled

The following was seen with CMF enabled:

BUG: using smp_processor_id() in preemptible
code: systemd-udevd/31711
kernel: caller is lpfc_update_cmf_cmd+0x214/0x420  [lpfc]
kernel: CPU: 12 PID: 31711 Comm: systemd-udevd
kernel: Call Trace:
kernel: <TASK>
kernel: dump_stack_lvl+0x44/0x57
kernel: check_preemption_disabled+0xbf/0xe0
kernel: lpfc_update_cmf_cmd+0x214/0x420 [lpfc]
kernel: lpfc_nvme_fcp_io_submit+0x23b4/0x4df0 [lpfc]

this_cpu_ptr() calls smp_processor_id() in a preemptible context.

Fix by using per_cpu_ptr() with raw_smp_processor_id() instead.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/517e0835cfb2007713ff16c4fb8479f08b16aec7
  - https://git.kernel.org/stable/c/ae373d66c427812754db5292eb1481b181daf9ce
  - https://git.kernel.org/stable/c/cd7f899de4b1b829125d72ee6fbfd878b637b815
  - https://git.kernel.org/stable/c/d6d45f67a11136cb88a70a29ab22ea6db8ae6bd5

------------------------------------------------------------

CVE ID: CVE-2022-49538
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: jack: Access input_dev under mutex

It is possible when using ASoC that input_dev is unregistered while
calling snd_jack_report, which causes NULL pointer dereference.
In order to prevent this serialize access to input_dev using mutex lock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/1b6a6fc5280e97559287b61eade2d4b363e836f2
  - https://git.kernel.org/stable/c/582aea6084cc59fec881204f026816d1219f2348
  - https://git.kernel.org/stable/c/5cc6f623f4818c7d7e9e966a45ebf324901ca9c5
  - https://git.kernel.org/stable/c/74bab3bcf422593c582e47130aa8eb41ebb2dc09
  - https://git.kernel.org/stable/c/8487a88136d54a1a4d3f26f1399685db648ab879
  - https://git.kernel.org/stable/c/9e6a73b0c0f2014eb89249fb1640c5a3d58221c4
  - https://git.kernel.org/stable/c/c093b62c40027c21d649c5534ad7aa3605a99b00
  - https://git.kernel.org/stable/c/e2b8681769f6e205382f026b907d28aa5ec9d59a
  - https://git.kernel.org/stable/c/f68bed124c7699e23ffb4ce4fcc84671e9193cde

------------------------------------------------------------

CVE ID: CVE-2022-49539
Description: In the Linux kernel, the following vulnerability has been resolved:

rtw89: ser: fix CAM leaks occurring in L2 reset

The CAM, meaning address CAM and bssid CAM here, will get leaks during
SER (system error recover) L2 reset process and ieee80211_restart_hw()
which is called by L2 reset process eventually.

The normal flow would be like
-> add interface (acquire 1)
-> enter ips (release 1)
-> leave ips (acquire 1)
-> connection (occupy 1) <(A) 1 leak after L2 reset if non-sec connection>

The ieee80211_restart_hw() flow (under connection)
-> ieee80211 reconfig
-> add interface (acquire 1)
-> leave ips (acquire 1)
-> connection (occupy (A) + 2) <(B) 1 more leak>

Originally, CAM is released before HW restart only if connection is under
security. Now, release CAM whatever connection it is to fix leak in (A).
OTOH, check if CAM is already valid to avoid acquiring multiple times to
fix (B).

Besides, if AP mode, release address CAM of all stations before HW restart.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/b169f877f001a474fb89939842c390518160bcc5
  - https://git.kernel.org/stable/c/f6aff772c9978844529618d86aafb53e5d3ae161

------------------------------------------------------------

CVE ID: CVE-2022-49540
Description: In the Linux kernel, the following vulnerability has been resolved:

rcu-tasks: Fix race in schedule and flush work

While booting secondary CPUs, cpus_read_[lock/unlock] is not keeping
online cpumask stable. The transient online mask results in below
calltrace.

[    0.324121] CPU1: Booted secondary processor 0x0000000001 [0x410fd083]
[    0.346652] Detected PIPT I-cache on CPU2
[    0.347212] CPU2: Booted secondary processor 0x0000000002 [0x410fd083]
[    0.377255] Detected PIPT I-cache on CPU3
[    0.377823] CPU3: Booted secondary processor 0x0000000003 [0x410fd083]
[    0.379040] ------------[ cut here ]------------
[    0.383662] WARNING: CPU: 0 PID: 10 at kernel/workqueue.c:3084 __flush_work+0x12c/0x138
[    0.384850] Modules linked in:
[    0.385403] CPU: 0 PID: 10 Comm: rcu_tasks_rude_ Not tainted 5.17.0-rc3-v8+ #13
[    0.386473] Hardware name: Raspberry Pi 4 Model B Rev 1.4 (DT)
[    0.387289] pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[    0.388308] pc : __flush_work+0x12c/0x138
[    0.388970] lr : __flush_work+0x80/0x138
[    0.389620] sp : ffffffc00aaf3c60
[    0.390139] x29: ffffffc00aaf3d20 x28: ffffffc009c16af0 x27: ffffff80f761df48
[    0.391316] x26: 0000000000000004 x25: 0000000000000003 x24: 0000000000000100
[    0.392493] x23: ffffffffffffffff x22: ffffffc009c16b10 x21: ffffffc009c16b28
[    0.393668] x20: ffffffc009e53861 x19: ffffff80f77fbf40 x18: 00000000d744fcc9
[    0.394842] x17: 000000000000000b x16: 00000000000001c2 x15: ffffffc009e57550
[    0.396016] x14: 0000000000000000 x13: ffffffffffffffff x12: 0000000100000000
[    0.397190] x11: 0000000000000462 x10: ffffff8040258008 x9 : 0000000100000000
[    0.398364] x8 : 0000000000000000 x7 : ffffffc0093c8bf4 x6 : 0000000000000000
[    0.399538] x5 : 0000000000000000 x4 : ffffffc00a976e40 x3 : ffffffc00810444c
[    0.400711] x2 : 0000000000000004 x1 : 0000000000000000 x0 : 0000000000000000
[    0.401886] Call trace:
[    0.402309]  __flush_work+0x12c/0x138
[    0.402941]  schedule_on_each_cpu+0x228/0x278
[    0.403693]  rcu_tasks_rude_wait_gp+0x130/0x144
[    0.404502]  rcu_tasks_kthread+0x220/0x254
[    0.405264]  kthread+0x174/0x1ac
[    0.405837]  ret_from_fork+0x10/0x20
[    0.406456] irq event stamp: 102
[    0.406966] hardirqs last  enabled at (101): [<ffffffc0093c8468>] _raw_spin_unlock_irq+0x78/0xb4
[    0.408304] hardirqs last disabled at (102): [<ffffffc0093b8270>] el1_dbg+0x24/0x5c
[    0.409410] softirqs last  enabled at (54): [<ffffffc0081b80c8>] local_bh_enable+0xc/0x2c
[    0.410645] softirqs last disabled at (50): [<ffffffc0081b809c>] local_bh_disable+0xc/0x2c
[    0.411890] ---[ end trace 0000000000000000 ]---
[    0.413000] smp: Brought up 1 node, 4 CPUs
[    0.413762] SMP: Total of 4 processors activated.
[    0.414566] CPU features: detected: 32-bit EL0 Support
[    0.415414] CPU features: detected: 32-bit EL1 Support
[    0.416278] CPU features: detected: CRC32 instructions
[    0.447021] Callback from call_rcu_tasks_rude() invoked.
[    0.506693] Callback from call_rcu_tasks() invoked.

This commit therefore fixes this issue by applying a single-CPU
optimization to the RCU Tasks Rude grace-period process.  The key point
here is that the purpose of this RCU flavor is to force a schedule on
each online CPU since some past event.  But the rcu_tasks_rude_wait_gp()
function runs in the context of the RCU Tasks Rude's grace-period kthread,
so there must already have been a context switch on the current CPU since
the call to either synchronize_rcu_tasks_rude() or call_rcu_tasks_rude().
So if there is only a single CPU online, RCU Tasks Rude's grace-period
kthread does not need to anything at all.

It turns out that the rcu_tasks_rude_wait_gp() function's call to
schedule_on_each_cpu() causes problems during early boot.  During that
time, there is only one online CPU, namely the boot CPU.  Therefore,
applying this single-CPU optimization fixes early-boot instances of
this problem.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c6c3f2336642fb3074593911f5176565f47ec41
  - https://git.kernel.org/stable/c/230bf5878af6038dfb63d9184272a58475236580
  - https://git.kernel.org/stable/c/8f49a8758b5cd541bd7aa9a0d0d11c7426141c0e
  - https://git.kernel.org/stable/c/ba722d061bc4b54802d701fc63fc2fd988934603
  - https://git.kernel.org/stable/c/f75fd4b9221d93177c50dcfde671b2e907f53e86

------------------------------------------------------------

CVE ID: CVE-2022-49541
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: fix potential double free during failed mount

RHBZ: https://bugzilla.redhat.com/show_bug.cgi?id=2088799
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/8378a51e3f8140f60901fb27208cc7a6e47047b5
  - https://git.kernel.org/stable/c/9a167fc440e5693c1cdd7f07071e05658bd9d89d
  - https://git.kernel.org/stable/c/ce0008a0e410cdd95f0d8cd81b2902ec10a660c4
  - https://git.kernel.org/stable/c/ee71f8f1cd3c8c4a251fd3e8abc89215ae3457cb

------------------------------------------------------------

CVE ID: CVE-2022-49542
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Move cfg_log_verbose check before calling lpfc_dmp_dbg()

In an attempt to log message 0126 with LOG_TRACE_EVENT, the following hard
lockup call trace hangs the system.

Call Trace:
 _raw_spin_lock_irqsave+0x32/0x40
 lpfc_dmp_dbg.part.32+0x28/0x220 [lpfc]
 lpfc_cmpl_els_fdisc+0x145/0x460 [lpfc]
 lpfc_sli_cancel_jobs+0x92/0xd0 [lpfc]
 lpfc_els_flush_cmd+0x43c/0x670 [lpfc]
 lpfc_els_flush_all_cmd+0x37/0x60 [lpfc]
 lpfc_sli4_async_event_proc+0x956/0x1720 [lpfc]
 lpfc_do_work+0x1485/0x1d70 [lpfc]
 kthread+0x112/0x130
 ret_from_fork+0x1f/0x40
Kernel panic - not syncing: Hard LOCKUP

The same CPU tries to claim the phba->port_list_lock twice.

Move the cfg_log_verbose checks as part of the lpfc_printf_vlog() and
lpfc_printf_log() macros before calling lpfc_dmp_dbg().  There is no need
to take the phba->port_list_lock within lpfc_dmp_dbg().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/09c772557a4fd9490fed1bfb133268313ea22213
  - https://git.kernel.org/stable/c/271725e4028559ae7974d762a8467dc9de412f2e
  - https://git.kernel.org/stable/c/cc6501afccec55b8b6c90584cbf71f1fefa77d1e
  - https://git.kernel.org/stable/c/e294647b1aed4247fe52851f3a3b2b19ae906228

------------------------------------------------------------

CVE ID: CVE-2022-49543
Description: In the Linux kernel, the following vulnerability has been resolved:

ath11k: fix the warning of dev_wake in mhi_pm_disable_transition()

When test device recovery with below command, it has warning in message
as below.
echo assert > /sys/kernel/debug/ath11k/wcn6855\ hw2.0/simulate_fw_crash
echo assert > /sys/kernel/debug/ath11k/qca6390\ hw2.0/simulate_fw_crash

warning message:
[ 1965.642121] ath11k_pci 0000:06:00.0: simulating firmware assert crash
[ 1968.471364] ieee80211 phy0: Hardware restart was requested
[ 1968.511305] ------------[ cut here ]------------
[ 1968.511368] WARNING: CPU: 3 PID: 1546 at drivers/bus/mhi/core/pm.c:505 mhi_pm_disable_transition+0xb37/0xda0 [mhi]
[ 1968.511443] Modules linked in: ath11k_pci ath11k mac80211 libarc4 cfg80211 qmi_helpers qrtr_mhi mhi qrtr nvme nvme_core
[ 1968.511563] CPU: 3 PID: 1546 Comm: kworker/u17:0 Kdump: loaded Tainted: G        W         5.17.0-rc3-wt-ath+ #579
[ 1968.511629] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021
[ 1968.511704] Workqueue: mhi_hiprio_wq mhi_pm_st_worker [mhi]
[ 1968.511787] RIP: 0010:mhi_pm_disable_transition+0xb37/0xda0 [mhi]
[ 1968.511870] Code: a9 fe ff ff 4c 89 ff 44 89 04 24 e8 03 46 f6 e5 44 8b 04 24 41 83 f8 01 0f 84 21 fe ff ff e9 4c fd ff ff 0f 0b e9 af f8 ff ff <0f> 0b e9 5c f8 ff ff 48 89 df e8 da 9e ee e3 e9 12 fd ff ff 4c 89
[ 1968.511923] RSP: 0018:ffffc900024efbf0 EFLAGS: 00010286
[ 1968.511969] RAX: 00000000ffffffff RBX: ffff88811d241250 RCX: ffffffffc0176922
[ 1968.512014] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff888118a90a24
[ 1968.512059] RBP: ffff888118a90800 R08: 0000000000000000 R09: ffff888118a90a27
[ 1968.512102] R10: ffffed1023152144 R11: 0000000000000001 R12: ffff888118a908ac
[ 1968.512229] R13: ffff888118a90928 R14: dffffc0000000000 R15: ffff888118a90a24
[ 1968.512310] FS:  0000000000000000(0000) GS:ffff888234200000(0000) knlGS:0000000000000000
[ 1968.512405] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1968.512493] CR2: 00007f5538f443a8 CR3: 000000016dc28001 CR4: 00000000003706e0
[ 1968.512587] Call Trace:
[ 1968.512672]  <TASK>
[ 1968.512751]  ? _raw_spin_unlock_irq+0x1f/0x40
[ 1968.512859]  mhi_pm_st_worker+0x3ac/0x790 [mhi]
[ 1968.512959]  ? mhi_pm_mission_mode_transition.isra.0+0x7d0/0x7d0 [mhi]
[ 1968.513063]  process_one_work+0x86a/0x1400
[ 1968.513184]  ? pwq_dec_nr_in_flight+0x230/0x230
[ 1968.513312]  ? move_linked_works+0x125/0x290
[ 1968.513416]  worker_thread+0x6db/0xf60
[ 1968.513536]  ? process_one_work+0x1400/0x1400
[ 1968.513627]  kthread+0x241/0x2d0
[ 1968.513733]  ? kthread_complete_and_exit+0x20/0x20
[ 1968.513821]  ret_from_fork+0x22/0x30
[ 1968.513924]  </TASK>

Reason is mhi_deassert_dev_wake() from mhi_device_put() is called
but mhi_assert_dev_wake() from __mhi_device_get_sync() is not called
in progress of recovery. Commit 8e0559921f9a ("bus: mhi: core:
Skip device wake in error or shutdown state") add check for the
pm_state of mhi in __mhi_device_get_sync(), and the pm_state is not
the normal state untill recovery is completed, so it leads the
dev_wake is not 0 and above warning print in mhi_pm_disable_transition()
while checking mhi_cntrl->dev_wake.

Add check in ath11k_pci_write32()/ath11k_pci_read32() to skip call
mhi_device_put() if mhi_device_get_sync() does not really do wake,
then the warning gone.

Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d7a8a6204ea9271f1d0a8c66a9fd2f54d2e3cbc
  - https://git.kernel.org/stable/c/5f18206cddae033c488e4879f198699092ca0524
  - https://git.kernel.org/stable/c/a2d9b7357469949ad02f511fc69f8fa3a1afbf89

------------------------------------------------------------

CVE ID: CVE-2022-49544
Description: In the Linux kernel, the following vulnerability has been resolved:

ipw2x00: Fix potential NULL dereference in libipw_xmit()

crypt and crypt->ops could be null, so we need to checking null
before dereference
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.318
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.283
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.247
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.198
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/167affc11781d7d35c4c3a7630a549ac74dd0b21
  - https://git.kernel.org/stable/c/1ff6b0727c8988f25eeb670b6c038c1120bb58dd
  - https://git.kernel.org/stable/c/48d4a820fd33f012e5f63735a59d15b5a3882882
  - https://git.kernel.org/stable/c/528d2023ccf4748fd542582955236c1634a7d293
  - https://git.kernel.org/stable/c/5f7ea274e88c0eeffe6bd6dbf6cf5c479d356af6
  - https://git.kernel.org/stable/c/8fb1b9beb085bb767ae43e441db5ac6fcd66a04d
  - https://git.kernel.org/stable/c/98d1dc32f890642476dbb78ed3437a456bf421b0
  - https://git.kernel.org/stable/c/b4628e0d3754ab2fc98ee6e3d21851ba45798077
  - https://git.kernel.org/stable/c/e8366bbabe1d207cf7c5b11ae50e223ae6fc278b

------------------------------------------------------------

CVE ID: CVE-2022-49545
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: usb-audio: Cancel pending work at closing a MIDI substream

At closing a USB MIDI output substream, there might be still a pending
work, which would eventually access the rawmidi runtime object that is
being released.  For fixing the race, make sure to cancel the pending
work at closing.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0125de38122f0f66bf61336158d12a1aabfe6425
  - https://git.kernel.org/stable/c/11868ca21585561659c2575b0d6508ef8e9c4291
  - https://git.kernel.org/stable/c/40bdb5ec957aca5c5c1924602bef6b0ab18e22d3
  - https://git.kernel.org/stable/c/517dcef4d2dda0132648f1e4c079ed17bba4d1a4
  - https://git.kernel.org/stable/c/5e5fe2b6065541c6216a7a003b0cddf386be0d2d

------------------------------------------------------------

CVE ID: CVE-2022-49546
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/kexec: fix memory leak of elf header buffer

This is reported by kmemleak detector:

unreferenced object 0xffffc900002a9000 (size 4096):
  comm "kexec", pid 14950, jiffies 4295110793 (age 373.951s)
  hex dump (first 32 bytes):
    7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............
    04 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00  ..>.............
  backtrace:
    [<0000000016a8ef9f>] __vmalloc_node_range+0x101/0x170
    [<000000002b66b6c0>] __vmalloc_node+0xb4/0x160
    [<00000000ad40107d>] crash_prepare_elf64_headers+0x8e/0xcd0
    [<0000000019afff23>] crash_load_segments+0x260/0x470
    [<0000000019ebe95c>] bzImage64_load+0x814/0xad0
    [<0000000093e16b05>] arch_kexec_kernel_image_load+0x1be/0x2a0
    [<000000009ef2fc88>] kimage_file_alloc_init+0x2ec/0x5a0
    [<0000000038f5a97a>] __do_sys_kexec_file_load+0x28d/0x530
    [<0000000087c19992>] do_syscall_64+0x3b/0x90
    [<0000000066e063a4>] entry_SYSCALL_64_after_hwframe+0x44/0xae

In crash_prepare_elf64_headers(), a buffer is allocated via vmalloc() to
store elf headers.  While it's not freed back to system correctly when
kdump kernel is reloaded or unloaded.  Then memory leak is caused.  Fix it
by introducing x86 specific function arch_kimage_file_post_load_cleanup(),
and freeing the buffer there.

And also remove the incorrect elf header buffer freeing code.  Before
calling arch specific kexec_file loading function, the image instance has
been initialized.  So 'image->elf_headers' must be NULL.  It doesn't make
sense to free the elf header buffer in the place.

Three different people have reported three bugs about the memory leak on
x86_64 inside Redhat.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/115ee42a4c2f26ba2b4ace2668a3f004621f6833
  - https://git.kernel.org/stable/c/23cf39dccf7653650701a6f39b119e9116a27f1a
  - https://git.kernel.org/stable/c/8765a423a87d74ef24ea02b43b2728fe4039f248
  - https://git.kernel.org/stable/c/b3e34a47f98974d0844444c5121aaff123004e57
  - https://git.kernel.org/stable/c/f675e3a9189d84a9324ab45b0cb19906c2bc8fcb

------------------------------------------------------------

CVE ID: CVE-2022-49547
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix deadlock between concurrent dio writes when low on free data space

When reserving data space for a direct IO write we can end up deadlocking
if we have multiple tasks attempting a write to the same file range, there
are multiple extents covered by that file range, we are low on available
space for data and the writes don't expand the inode's i_size.

The deadlock can happen like this:

1) We have a file with an i_size of 1M, at offset 0 it has an extent with
   a size of 128K and at offset 128K it has another extent also with a
   size of 128K;

2) Task A does a direct IO write against file range [0, 256K), and because
   the write is within the i_size boundary, it takes the inode's lock (VFS
   level) in shared mode;

3) Task A locks the file range [0, 256K) at btrfs_dio_iomap_begin(), and
   then gets the extent map for the extent covering the range [0, 128K).
   At btrfs_get_blocks_direct_write(), it creates an ordered extent for
   that file range ([0, 128K));

4) Before returning from btrfs_dio_iomap_begin(), it unlocks the file
   range [0, 256K);

5) Task A executes btrfs_dio_iomap_begin() again, this time for the file
   range [128K, 256K), and locks the file range [128K, 256K);

6) Task B starts a direct IO write against file range [0, 256K) as well.
   It also locks the inode in shared mode, as it's within the i_size limit,
   and then tries to lock file range [0, 256K). It is able to lock the
   subrange [0, 128K) but then blocks waiting for the range [128K, 256K),
   as it is currently locked by task A;

7) Task A enters btrfs_get_blocks_direct_write() and tries to reserve data
   space. Because we are low on available free space, it triggers the
   async data reclaim task, and waits for it to reserve data space;

8) The async reclaim task decides to wait for all existing ordered extents
   to complete (through btrfs_wait_ordered_roots()).
   It finds the ordered extent previously created by task A for the file
   range [0, 128K) and waits for it to complete;

9) The ordered extent for the file range [0, 128K) can not complete
   because it blocks at btrfs_finish_ordered_io() when trying to lock the
   file range [0, 128K).

   This results in a deadlock, because:

   - task B is holding the file range [0, 128K) locked, waiting for the
     range [128K, 256K) to be unlocked by task A;

   - task A is holding the file range [128K, 256K) locked and it's waiting
     for the async data reclaim task to satisfy its space reservation
     request;

   - the async data reclaim task is waiting for ordered extent [0, 128K)
     to complete, but the ordered extent can not complete because the
     file range [0, 128K) is currently locked by task B, which is waiting
     on task A to unlock file range [128K, 256K) and task A waiting
     on the async data reclaim task.

   This results in a deadlock between 4 task: task A, task B, the async
   data reclaim task and the task doing ordered extent completion (a work
   queue task).

This type of deadlock can sporadically be triggered by the test case
generic/300 from fstests, and results in a stack trace like the following:

[12084.033689] INFO: task kworker/u16:7:123749 blocked for more than 241 seconds.
[12084.034877]       Not tainted 5.18.0-rc2-btrfs-next-115 #1
[12084.035562] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
[12084.036548] task:kworker/u16:7   state:D stack:    0 pid:123749 ppid:     2 flags:0x00004000
[12084.036554] Workqueue: btrfs-flush_delalloc btrfs_work_helper [btrfs]
[12084.036599] Call Trace:
[12084.036601]  <TASK>
[12084.036606]  __schedule+0x3cb/0xed0
[12084.036616]  schedule+0x4e/0xb0
[12084.036620]  btrfs_start_ordered_extent+0x109/0x1c0 [btrfs]
[12084.036651]  ? prepare_to_wait_exclusive+0xc0/0xc0
[12084.036659]  btrfs_run_ordered_extent_work+0x1a/0x30 [btrfs]
[12084.036688]  btrfs_work_helper+0xf8/0x400 [btrfs]
[12084.0367
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.27, Last Version (Excluding): 5.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16.13, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/cfae6f765b3c40882ee90dae8fbf9325c8de9c35
  - https://git.kernel.org/stable/c/f5585f4f0ef5b17026bbd60fbff6fcc91b99d5bf

------------------------------------------------------------

CVE ID: CVE-2022-49548
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix potential array overflow in bpf_trampoline_get_progs()

The cnt value in the 'cnt >= BPF_MAX_TRAMP_PROGS' check does not
include BPF_TRAMP_MODIFY_RETURN bpf programs, so the number of
the attached BPF_TRAMP_MODIFY_RETURN bpf programs in a trampoline
can exceed BPF_MAX_TRAMP_PROGS.

When this happens, the assignment '*progs++ = aux->prog' in
bpf_trampoline_get_progs() will cause progs array overflow as the
progs field in the bpf_tramp_progs struct can only hold at most
BPF_MAX_TRAMP_PROGS bpf programs.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.120
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.45
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.2
References:
  - https://git.kernel.org/stable/c/32c4559c61652f24c9fdd5440342196fe37453bc
  - https://git.kernel.org/stable/c/4f8897bcc20b9ae44758e0572538d741ab66f0dc
  - https://git.kernel.org/stable/c/7f845de2863334bed4f362e95853f5e7bc323737
  - https://git.kernel.org/stable/c/a2aa95b71c9bbec793b5c5fa50f0a80d882b3e8d
  - https://git.kernel.org/stable/c/e36452d5da6325df7c10cffc60a9e68d21e2606d

------------------------------------------------------------

CVE ID: CVE-2022-49549
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/MCE/AMD: Fix memory leak when threshold_create_bank() fails

In mce_threshold_create_device(), if threshold_create_bank() fails, the
previously allocated threshold banks array @bp will be leaked because
the call to mce_threshold_remove_device() will not free it.

This happens because mce_threshold_remove_device() fetches the pointer
through the threshold_banks per-CPU variable but bp is written there
only after the bank creation is successful, and not before, when
threshold_create_bank() fails.

Add a helper which unwinds all the bank creation work previously done
and pass into it the previously allocated threshold banks array for
freeing.

  [ bp: Massage. ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 5.10.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/396b8e7ab2a99ddac57d3522b3da5e58cb608d37
  - https://git.kernel.org/stable/c/9708f1956eeb70c86943e0bc62fa3b0101b59616
  - https://git.kernel.org/stable/c/b4acb8e7f1594607bc9017ef0aacb40b24a003d6
  - https://git.kernel.org/stable/c/cc0dd4456f9573bf8af9b4d8754433918e809e1e
  - https://git.kernel.org/stable/c/e5f28623ceb103e13fc3d7bd45edf9818b227fd0

------------------------------------------------------------

CVE ID: CVE-2022-49550
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: provide block_invalidate_folio to fix memory leak

The ntfs3 filesystem lacks the 'invalidate_folio' method and it causes
memory leak. If you write to the filesystem and then unmount it, the
cached written data are not freed and they are permanently leaked.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/0753245a72ec99824677586499ee2e0919164b3f
  - https://git.kernel.org/stable/c/724bbe49c5e427cb077357d72d240a649f2e4054

------------------------------------------------------------

CVE ID: CVE-2022-49551
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: isp1760: Fix out-of-bounds array access

Running the driver through kasan gives an interesting splat:

  BUG: KASAN: global-out-of-bounds in isp1760_register+0x180/0x70c
  Read of size 20 at addr f1db2e64 by task swapper/0/1
  (...)
  isp1760_register from isp1760_plat_probe+0x1d8/0x220
  (...)

This happens because the loop reading the regmap fields for the
different ISP1760 variants look like this:

  for (i = 0; i < HC_FIELD_MAX; i++) { ... }

Meaning it expects the arrays to be at least HC_FIELD_MAX - 1 long.

However the arrays isp1760_hc_reg_fields[], isp1763_hc_reg_fields[],
isp1763_hc_volatile_ranges[] and isp1763_dc_volatile_ranges[] are
dynamically sized during compilation.

Fix this by putting an empty assignment to the [HC_FIELD_MAX]
and [DC_FIELD_MAX] array member at the end of each array.
This will make the array one member longer than it needs to be,
but avoids the risk of overwriting whatever is inside
[HC_FIELD_MAX - 1] and is simple and intuitive to read. Also
add comments explaining what is going on.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.46
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.3
References:
  - https://git.kernel.org/stable/c/26ae2c942b5702f2e43d36b2a4389cfb7d616b6a
  - https://git.kernel.org/stable/c/463bddd3ff1acf4036ddb80c34a715eb99debf46
  - https://git.kernel.org/stable/c/47d39cb57e8669e507d17d9e0d067d2b3e3a87ae
  - https://git.kernel.org/stable/c/bf2558bbdce3ab1d6bcba09f354914e4515d0a2b

------------------------------------------------------------

CVE ID: CVE-2022-49552
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix combination of jit blinding and pointers to bpf subprogs.

The combination of jit blinding and pointers to bpf subprogs causes:
[   36.989548] BUG: unable to handle page fault for address: 0000000100000001
[   36.990342] #PF: supervisor instruction fetch in kernel mode
[   36.990968] #PF: error_code(0x0010) - not-present page
[   36.994859] RIP: 0010:0x100000001
[   36.995209] Code: Unable to access opcode bytes at RIP 0xffffffd7.
[   37.004091] Call Trace:
[   37.004351]  <TASK>
[   37.004576]  ? bpf_loop+0x4d/0x70
[   37.004932]  ? bpf_prog_3899083f75e4c5de_F+0xe3/0x13b

The jit blinding logic didn't recognize that ld_imm64 with an address
of bpf subprogram is a special instruction and proceeded to randomize it.
By itself it wouldn't have been an issue, but jit_subprogs() logic
relies on two step process to JIT all subprogs and then JIT them
again when addresses of all subprogs are known.
Blinding process in the first JIT phase caused second JIT to miss
adjustment of special ld_imm64.

Fix this issue by ignoring special ld_imm64 instructions that don't have
user controlled constants and shouldn't be blinded.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4b6313cf99b0d51b49aeaea98ec76ca8161ecb80
  - https://git.kernel.org/stable/c/a029b02b47dd5bb87a21550d9d9a80cb4dd3f714
  - https://git.kernel.org/stable/c/d106a3e96fca30e44081eae9c27aab28fc132a46

------------------------------------------------------------

CVE ID: CVE-2022-49553
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: validate BOOT sectors_per_clusters

When the NTFS BOOT sectors_per_clusters field is > 0x80, it represents a
shift value.  Make sure that the shift value is not too large before using
it (NTFS max cluster size is 2MB).  Return -EVINVAL if it too large.

This prevents negative shift values and shift values that are larger than
the field size.

Prevents this UBSAN error:

 UBSAN: shift-out-of-bounds in ../fs/ntfs3/super.c:673:16
 shift exponent -192 is negative
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4746c49b11b2403f5b5b07c6eac9e60663dcd9a3
  - https://git.kernel.org/stable/c/58cf68a1886d14ffdc5c892ce483a82156769e88
  - https://git.kernel.org/stable/c/a2b6986316a2d106f6951e76db70fa4b2fde64a9
  - https://git.kernel.org/stable/c/a3b774342fa752a5290c0de36375289dfcf4a260

------------------------------------------------------------

CVE ID: CVE-2022-49554
Description: In the Linux kernel, the following vulnerability has been resolved:

zsmalloc: fix races between asynchronous zspage free and page migration

The asynchronous zspage free worker tries to lock a zspage's entire page
list without defending against page migration.  Since pages which haven't
yet been locked can concurrently migrate off the zspage page list while
lock_zspage() churns away, lock_zspage() can suffer from a few different
lethal races.

It can lock a page which no longer belongs to the zspage and unsafely
dereference page_private(), it can unsafely dereference a torn pointer to
the next page (since there's a data race), and it can observe a spurious
NULL pointer to the next page and thus not lock all of the zspage's pages
(since a single page migration will reconstruct the entire page list, and
create_page_chain() unconditionally zeroes out each list pointer in the
process).

Fix the races by using migrate_read_lock() in lock_zspage() to synchronize
with page migration.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2505a981114dcb715f8977b8433f7540854851d8
  - https://git.kernel.org/stable/c/3674d8a8dadd03a447dd21069d4dacfc3399b63b
  - https://git.kernel.org/stable/c/3ec459c8810e658401be428d3168eacfc380bdd0
  - https://git.kernel.org/stable/c/645996efc2ae391246d595832aaa6f9d3cc338c7
  - https://git.kernel.org/stable/c/8ba7b7c1dad1f6503c541778f31b33f7f62eb966
  - https://git.kernel.org/stable/c/c5402fb5f71f1a725f1e55d9c6799c0c7bec308f
  - https://git.kernel.org/stable/c/fae05b2314b147a78fbed1dc4c645d9a66313758
  - https://git.kernel.org/stable/c/fc658c083904427abbf8f18280d517ee2668677c

------------------------------------------------------------

CVE ID: CVE-2022-49555
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: hci_qca: Use del_timer_sync() before freeing

While looking at a crash report on a timer list being corrupted, which
usually happens when a timer is freed while still active. This is
commonly triggered by code calling del_timer() instead of
del_timer_sync() just before freeing.

One possible culprit is the hci_qca driver, which does exactly that.

Eric mentioned that wake_retrans_timer could be rearmed via the work
queue, so also move the destruction of the work queue before
del_timer_sync().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2717654ae022e6ea959a4b7b762702fe1a4690c2
  - https://git.kernel.org/stable/c/37d17f63d085d601011964ade7371aeebeb6ed4b
  - https://git.kernel.org/stable/c/4989bb03342941f2b730b37dfa38bce27b543661
  - https://git.kernel.org/stable/c/72ef98445aca568a81c2da050532500a8345ad3a
  - https://git.kernel.org/stable/c/db03727b4bbbbb36e6ef4cb655c670eefb6448e9

------------------------------------------------------------

CVE ID: CVE-2022-49556
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: SVM: Use kzalloc for sev ioctl interfaces to prevent kernel data leak

For some sev ioctl interfaces, the length parameter that is passed maybe
less than or equal to SEV_FW_BLOB_MAX_SIZE, but larger than the data
that PSP firmware returns. In this case, kmalloc will allocate memory
that is the size of the input rather than the size of the data.
Since PSP firmware doesn't fully overwrite the allocated buffer, these
sev ioctl interface may return uninitialized kernel slab memory.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/401bef1f95de92c3a8c6eece46e02fa88d7285ee
  - https://git.kernel.org/stable/c/57a01725339f9d82b099102ba2751621b1caab93
  - https://git.kernel.org/stable/c/bbdcc644b59e01e98c68894a9fab42b9687f42b0
  - https://git.kernel.org/stable/c/d22d2474e3953996f03528b84b7f52cc26a39403
  - https://git.kernel.org/stable/c/d8fdb4b24097472ff6b3c0559448200d420b1418

------------------------------------------------------------

CVE ID: CVE-2022-49557
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/fpu: KVM: Set the base guest FPU uABI size to sizeof(struct kvm_xsave)

Set the starting uABI size of KVM's guest FPU to 'struct kvm_xsave',
i.e. to KVM's historical uABI size.  When saving FPU state for usersapce,
KVM (well, now the FPU) sets the FP+SSE bits in the XSAVE header even if
the host doesn't support XSAVE.  Setting the XSAVE header allows the VM
to be migrated to a host that does support XSAVE without the new host
having to handle FPU state that may or may not be compatible with XSAVE.

Setting the uABI size to the host's default size results in out-of-bounds
writes (setting the FP+SSE bits) and data corruption (that is thankfully
caught by KASAN) when running on hosts without XSAVE, e.g. on Core2 CPUs.

WARN if the default size is larger than KVM's historical uABI size; all
features that can push the FPU size beyond the historical size must be
opt-in.

  ==================================================================
  BUG: KASAN: slab-out-of-bounds in fpu_copy_uabi_to_guest_fpstate+0x86/0x130
  Read of size 8 at addr ffff888011e33a00 by task qemu-build/681
  CPU: 1 PID: 681 Comm: qemu-build Not tainted 5.18.0-rc5-KASAN-amd64 #1
  Hardware name:  /DG35EC, BIOS ECG3510M.86A.0118.2010.0113.1426 01/13/2010
  Call Trace:
   <TASK>
   dump_stack_lvl+0x34/0x45
   print_report.cold+0x45/0x575
   kasan_report+0x9b/0xd0
   fpu_copy_uabi_to_guest_fpstate+0x86/0x130
   kvm_arch_vcpu_ioctl+0x72a/0x1c50 [kvm]
   kvm_vcpu_ioctl+0x47f/0x7b0 [kvm]
   __x64_sys_ioctl+0x5de/0xc90
   do_syscall_64+0x31/0x50
   entry_SYSCALL_64_after_hwframe+0x44/0xae
   </TASK>
  Allocated by task 0:
  (stack is not available)
  The buggy address belongs to the object at ffff888011e33800
   which belongs to the cache kmalloc-512 of size 512
  The buggy address is located 0 bytes to the right of
   512-byte region [ffff888011e33800, ffff888011e33a00)
  The buggy address belongs to the physical page:
  page:0000000089cd4adb refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x11e30
  head:0000000089cd4adb order:2 compound_mapcount:0 compound_pincount:0
  flags: 0x4000000000010200(slab|head|zone=1)
  raw: 4000000000010200 dead000000000100 dead000000000122 ffff888001041c80
  raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000
  page dumped because: kasan: bad access detected
  Memory state around the buggy address:
   ffff888011e33900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   ffff888011e33980: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  >ffff888011e33a00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
                     ^
   ffff888011e33a80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
   ffff888011e33b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
  ==================================================================
  Disabling lock debugging due to kernel taint
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9cf15ebb7dedfe2f27120743b8ea8441c99ac73c
  - https://git.kernel.org/stable/c/c181acbd1a427859d5fda543b95fbae28f7f6068
  - https://git.kernel.org/stable/c/d187ba5312307d51818beafaad87d28a7d939adf

------------------------------------------------------------

CVE ID: CVE-2022-49558
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: double hook unregistration in netns path

__nft_release_hooks() is called from pre_netns exit path which
unregisters the hooks, then the NETDEV_UNREGISTER event is triggered
which unregisters the hooks again.

[  565.221461] WARNING: CPU: 18 PID: 193 at net/netfilter/core.c:495 __nf_unregister_net_hook+0x247/0x270
[...]
[  565.246890] CPU: 18 PID: 193 Comm: kworker/u64:1 Tainted: G            E     5.18.0-rc7+ #27
[  565.253682] Workqueue: netns cleanup_net
[  565.257059] RIP: 0010:__nf_unregister_net_hook+0x247/0x270
[...]
[  565.297120] Call Trace:
[  565.300900]  <TASK>
[  565.304683]  nf_tables_flowtable_event+0x16a/0x220 [nf_tables]
[  565.308518]  raw_notifier_call_chain+0x63/0x80
[  565.312386]  unregister_netdevice_many+0x54f/0xb50

Unregister and destroy netdev hook from netns pre_exit via kfree_rcu
so the NETDEV_UNREGISTER path see unregistered hooks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3fac8ce48fa9fd61ee9056d3ed48b2edefca8b82
  - https://git.kernel.org/stable/c/86c0154f4c3a56c5db8b9dd09e3ce885382c2c19
  - https://git.kernel.org/stable/c/9c413a8c8bb49cc16796371805ecb260e885bb2b
  - https://git.kernel.org/stable/c/a3940dcf552f2393d1e8f263b386593f98abe829
  - https://git.kernel.org/stable/c/b09e6ccf0d12f9356e8e3508d3e3dce126298538
  - https://git.kernel.org/stable/c/c73955a09408e7374d9abfd0e78ce3de9cda0635
  - https://git.kernel.org/stable/c/f9a43007d3f7ba76d5e7f9421094f00f2ef202f8

------------------------------------------------------------

CVE ID: CVE-2022-49559
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Drop WARNs that assert a triple fault never "escapes" from L2

Remove WARNs that sanity check that KVM never lets a triple fault for L2
escape and incorrectly end up in L1.  In normal operation, the sanity
check is perfectly valid, but it incorrectly assumes that it's impossible
for userspace to induce KVM_REQ_TRIPLE_FAULT without bouncing through
KVM_RUN (which guarantees kvm_check_nested_state() will see and handle
the triple fault).

The WARN can currently be triggered if userspace injects a machine check
while L2 is active and CR4.MCE=0.  And a future fix to allow save/restore
of KVM_REQ_TRIPLE_FAULT, e.g. so that a synthesized triple fault isn't
lost on migration, will make it trivially easy for userspace to trigger
the WARN.

Clearing KVM_REQ_TRIPLE_FAULT when forcibly leaving guest mode is
tempting, but wrong, especially if/when the request is saved/restored,
e.g. if userspace restores events (including a triple fault) and then
restores nested state (which may forcibly leave guest mode).  Ignoring
the fact that KVM doesn't currently provide the necessary APIs, it's
userspace's responsibility to manage pending events during save/restore.

  ------------[ cut here ]------------
  WARNING: CPU: 7 PID: 1399 at arch/x86/kvm/vmx/nested.c:4522 nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel]
  Modules linked in: kvm_intel kvm irqbypass
  CPU: 7 PID: 1399 Comm: state_test Not tainted 5.17.0-rc3+ #808
  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015
  RIP: 0010:nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel]
  Call Trace:
   <TASK>
   vmx_leave_nested+0x30/0x40 [kvm_intel]
   vmx_set_nested_state+0xca/0x3e0 [kvm_intel]
   kvm_arch_vcpu_ioctl+0xf49/0x13e0 [kvm]
   kvm_vcpu_ioctl+0x4b9/0x660 [kvm]
   __x64_sys_ioctl+0x83/0xb0
   do_syscall_64+0x3b/0xc0
   entry_SYSCALL_64_after_hwframe+0x44/0xae
   </TASK>
  ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/45846661d10422ce9e22da21f8277540b29eca22
  - https://git.kernel.org/stable/c/7de373c9b48229e428ecdb8fbde269c5a8617fd2
  - https://git.kernel.org/stable/c/8d3a2aa0976f57320ba89baf9d57fb158dd0cd0d
  - https://git.kernel.org/stable/c/f476a59d5c86c02a79eef893c6da86735f2977ac

------------------------------------------------------------

CVE ID: CVE-2022-49560
Description: In the Linux kernel, the following vulnerability has been resolved:

exfat: check if cluster num is valid

Syzbot reported slab-out-of-bounds read in exfat_clear_bitmap.
This was triggered by reproducer calling truncute with size 0,
which causes the following trace:

BUG: KASAN: slab-out-of-bounds in exfat_clear_bitmap+0x147/0x490 fs/exfat/balloc.c:174
Read of size 8 at addr ffff888115aa9508 by task syz-executor251/365

Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack_lvl+0x1e2/0x24b lib/dump_stack.c:118
 print_address_description+0x81/0x3c0 mm/kasan/report.c:233
 __kasan_report mm/kasan/report.c:419 [inline]
 kasan_report+0x1a4/0x1f0 mm/kasan/report.c:436
 __asan_report_load8_noabort+0x14/0x20 mm/kasan/report_generic.c:309
 exfat_clear_bitmap+0x147/0x490 fs/exfat/balloc.c:174
 exfat_free_cluster+0x25a/0x4a0 fs/exfat/fatent.c:181
 __exfat_truncate+0x99e/0xe00 fs/exfat/file.c:217
 exfat_truncate+0x11b/0x4f0 fs/exfat/file.c:243
 exfat_setattr+0xa03/0xd40 fs/exfat/file.c:339
 notify_change+0xb76/0xe10 fs/attr.c:336
 do_truncate+0x1ea/0x2d0 fs/open.c:65

Move the is_valid_cluster() helper from fatent.c to a common
header to make it reusable in other *.c files. And add is_valid_cluster()
to validate if cluster number is within valid range in exfat_clear_bitmap()
and exfat_set_bitmap().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.120
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.45
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.17.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.2
References:
  - https://git.kernel.org/stable/c/2193286402df2d9c53294f7a858d5e6fd7346e08
  - https://git.kernel.org/stable/c/64ba4b15e5c045f8b746c6da5fc9be9a6b00b61d
  - https://git.kernel.org/stable/c/7c58b14b6f9cde9f69e7fa053ab73f6e013a7131
  - https://git.kernel.org/stable/c/82f723b8a5adf497f9e34c702a30ca7298615654
  - https://git.kernel.org/stable/c/c504167adc3248095a905fa0700a9693897cb5ed

------------------------------------------------------------

CVE ID: CVE-2022-49561
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: conntrack: re-fetch conntrack after insertion

In case the conntrack is clashing, insertion can free skb->_nfct and
set skb->_nfct to the already-confirmed entry.

This wasn't found before because the conntrack entry and the extension
space used to free'd after an rcu grace period, plus the race needs
events enabled to trigger.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01989d7eebb61c99bd4b88ebc8e261bd2f02caed
  - https://git.kernel.org/stable/c/04e4a11dc723c52db7a36dc58f0d69ce6426f8f0
  - https://git.kernel.org/stable/c/04f9e9104c969d8ce10a4a43634f641ed082092d
  - https://git.kernel.org/stable/c/56b14ecec97f39118bf85c9ac2438c5a949509ed
  - https://git.kernel.org/stable/c/91a36ec160ec1a0c8f5352b772dffcbb0b6023e3
  - https://git.kernel.org/stable/c/92a999d1963eed0df666284e20055136ceabd12f
  - https://git.kernel.org/stable/c/b16bb373988da3ceb0308381634117e18b6ec60d
  - https://git.kernel.org/stable/c/e97222b785e70e8973281666d709baad6523d8af

------------------------------------------------------------

CVE ID: CVE-2022-49562
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Use __try_cmpxchg_user() to update guest PTE A/D bits

Use the recently introduced __try_cmpxchg_user() to update guest PTE A/D
bits instead of mapping the PTE into kernel address space.  The VM_PFNMAP
path is broken as it assumes that vm_pgoff is the base pfn of the mapped
VMA range, which is conceptually wrong as vm_pgoff is the offset relative
to the file and has nothing to do with the pfn.  The horrific hack worked
for the original use case (backing guest memory with /dev/mem), but leads
to accessing "random" pfns for pretty much any other VM_PFNMAP case.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/38b888911e8dc89b89d8147cfb1d2dbe6373bf78
  - https://git.kernel.org/stable/c/8089e5e1d18402fb8152d6b6815450a36fffa9b0
  - https://git.kernel.org/stable/c/f122dfe4476890d60b8c679128cd2259ec96a24c

------------------------------------------------------------

CVE ID: CVE-2022-49563
Description: In the Linux kernel, the following vulnerability has been resolved:

crypto: qat - add param check for RSA

Reject requests with a source buffer that is bigger than the size of the
key. This is to prevent a possible integer underflow that might happen
when copying the source scatterlist into a linear buffer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
References:
  - https://git.kernel.org/stable/c/4d6d2adce08788b7667a6e58002682ea1bbf6a79
  - https://git.kernel.org/stable/c/9714061423b8b24b8afb31b8eb4df977c63f19c4
  - https://git.kernel.org/stable/c/f993321e50ba7a8ba4f5b19939e1772a921a1c42

------------------------------------------------------------

CVE ID: CVE-2022-49564
Description: In the Linux kernel, the following vulnerability has been resolved:

crypto: qat - add param check for DH

Reject requests with a source buffer that is bigger than the size of the
key. This is to prevent a possible integer underflow that might happen
when copying the source scatterlist into a linear buffer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
References:
  - https://git.kernel.org/stable/c/2acbb8771f6ac82422886e63832ee7a0f4b1635b
  - https://git.kernel.org/stable/c/76c9216833e7c20a67c987cf89719a3f01666aaa
  - https://git.kernel.org/stable/c/e7f979ed51f96495328157df663c835b17db1e30

------------------------------------------------------------

CVE ID: CVE-2022-49565
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/x86/intel/lbr: Fix unchecked MSR access error on HSW

The fuzzer triggers the below trace.

[ 7763.384369] unchecked MSR access error: WRMSR to 0x689
(tried to write 0x1fffffff8101349e) at rIP: 0xffffffff810704a4
(native_write_msr+0x4/0x20)
[ 7763.397420] Call Trace:
[ 7763.399881]  <TASK>
[ 7763.401994]  intel_pmu_lbr_restore+0x9a/0x1f0
[ 7763.406363]  intel_pmu_lbr_sched_task+0x91/0x1c0
[ 7763.410992]  __perf_event_task_sched_in+0x1cd/0x240

On a machine with the LBR format LBR_FORMAT_EIP_FLAGS2, when the TSX is
disabled, a TSX quirk is required to access LBR from registers.
The lbr_from_signext_quirk_needed() is introduced to determine whether
the TSX quirk should be applied. However, the
lbr_from_signext_quirk_needed() is invoked before the
intel_pmu_lbr_init(), which parses the LBR format information. Without
the correct LBR format information, the TSX quirk never be applied.

Move the lbr_from_signext_quirk_needed() into the intel_pmu_lbr_init().
Checking x86_pmu.lbr_has_tsx in the lbr_from_signext_quirk_needed() is
not required anymore.

Both LBR_FORMAT_EIP_FLAGS2 and LBR_FORMAT_INFO have LBR_TSX flag, but
only the LBR_FORMAT_EIP_FLAGS2 requirs the quirk. Update the comments
accordingly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/625bcd0685a1612225df83468c83412fc0edb3d7
  - https://git.kernel.org/stable/c/b0380e13502adf7dd8be4c47d622c3522aae6c63

------------------------------------------------------------

CVE ID: CVE-2022-49566
Description: In the Linux kernel, the following vulnerability has been resolved:

crypto: qat - fix memory leak in RSA

When an RSA key represented in form 2 (as defined in PKCS #1 V2.1) is
used, some components of the private key persist even after the TFM is
released.
Replace the explicit calls to free the buffers in qat_rsa_exit_tfm()
with a call to qat_rsa_clear_ctx() which frees all buffers referenced in
the TFM context.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.8, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
References:
  - https://git.kernel.org/stable/c/0f967fdc09955221a1951a279481b0bf4d359941
  - https://git.kernel.org/stable/c/80a52e1ee7757b742f96bfb0d58f0c14eb6583d0
  - https://git.kernel.org/stable/c/a843925e0287eebb4aa808666bf22c664dfe4c53

------------------------------------------------------------

CVE ID: CVE-2022-49567
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/mempolicy: fix uninit-value in mpol_rebind_policy()

mpol_set_nodemask()(mm/mempolicy.c) does not set up nodemask when
pol->mode is MPOL_LOCAL.  Check pol->mode before access
pol->w.cpuset_mems_allowed in mpol_rebind_policy()(mm/mempolicy.c).

BUG: KMSAN: uninit-value in mpol_rebind_policy mm/mempolicy.c:352 [inline]
BUG: KMSAN: uninit-value in mpol_rebind_task+0x2ac/0x2c0 mm/mempolicy.c:368
 mpol_rebind_policy mm/mempolicy.c:352 [inline]
 mpol_rebind_task+0x2ac/0x2c0 mm/mempolicy.c:368
 cpuset_change_task_nodemask kernel/cgroup/cpuset.c:1711 [inline]
 cpuset_attach+0x787/0x15e0 kernel/cgroup/cpuset.c:2278
 cgroup_migrate_execute+0x1023/0x1d20 kernel/cgroup/cgroup.c:2515
 cgroup_migrate kernel/cgroup/cgroup.c:2771 [inline]
 cgroup_attach_task+0x540/0x8b0 kernel/cgroup/cgroup.c:2804
 __cgroup1_procs_write+0x5cc/0x7a0 kernel/cgroup/cgroup-v1.c:520
 cgroup1_tasks_write+0x94/0xb0 kernel/cgroup/cgroup-v1.c:539
 cgroup_file_write+0x4c2/0x9e0 kernel/cgroup/cgroup.c:3852
 kernfs_fop_write_iter+0x66a/0x9f0 fs/kernfs/file.c:296
 call_write_iter include/linux/fs.h:2162 [inline]
 new_sync_write fs/read_write.c:503 [inline]
 vfs_write+0x1318/0x2030 fs/read_write.c:590
 ksys_write+0x28b/0x510 fs/read_write.c:643
 __do_sys_write fs/read_write.c:655 [inline]
 __se_sys_write fs/read_write.c:652 [inline]
 __x64_sys_write+0xdb/0x120 fs/read_write.c:652
 do_syscall_x64 arch/x86/entry/common.c:51 [inline]
 do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82
 entry_SYSCALL_64_after_hwframe+0x44/0xae

Uninit was created at:
 slab_post_alloc_hook mm/slab.h:524 [inline]
 slab_alloc_node mm/slub.c:3251 [inline]
 slab_alloc mm/slub.c:3259 [inline]
 kmem_cache_alloc+0x902/0x11c0 mm/slub.c:3264
 mpol_new mm/mempolicy.c:293 [inline]
 do_set_mempolicy+0x421/0xb70 mm/mempolicy.c:853
 kernel_set_mempolicy mm/mempolicy.c:1504 [inline]
 __do_sys_set_mempolicy mm/mempolicy.c:1510 [inline]
 __se_sys_set_mempolicy+0x44c/0xb60 mm/mempolicy.c:1507
 __x64_sys_set_mempolicy+0xd8/0x110 mm/mempolicy.c:1507
 do_syscall_x64 arch/x86/entry/common.c:51 [inline]
 do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82
 entry_SYSCALL_64_after_hwframe+0x44/0xae

KMSAN: uninit-value in mpol_rebind_task (2)
https://syzkaller.appspot.com/bug?id=d6eb90f952c2a5de9ea718a1b873c55cb13b59dc

This patch seems to fix below bug too.
KMSAN: uninit-value in mpol_rebind_mm (2)
https://syzkaller.appspot.com/bug?id=f2fecd0d7013f54ec4162f60743a2b28df40926b

The uninit-value is pol->w.cpuset_mems_allowed in mpol_rebind_policy().
When syzkaller reproducer runs to the beginning of mpol_new(),

	    mpol_new() mm/mempolicy.c
	  do_mbind() mm/mempolicy.c
	kernel_mbind() mm/mempolicy.c

`mode` is 1(MPOL_PREFERRED), nodes_empty(*nodes) is `true` and `flags`
is 0. Then

	mode = MPOL_LOCAL;
	...
	policy->mode = mode;
	policy->flags = flags;

will be executed. So in mpol_set_nodemask(),

	    mpol_set_nodemask() mm/mempolicy.c
	  do_mbind()
	kernel_mbind()

pol->mode is 4 (MPOL_LOCAL), that `nodemask` in `pol` is not initialized,
which will be accessed in mpol_rebind_policy().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
References:
  - https://git.kernel.org/stable/c/018160ad314d75b1409129b2247b614a9f35894c
  - https://git.kernel.org/stable/c/13d51565cec1aa432a6ab363edc2bbc53c6f49cb
  - https://git.kernel.org/stable/c/5735845906fb1d90fe597f8b503fc0a857d475e3
  - https://git.kernel.org/stable/c/777e563f10e91e91130fe06bee85220d508e7b9b
  - https://git.kernel.org/stable/c/8c5429a04ccd8dbcc3c753dab2f4126774ec28d4
  - https://git.kernel.org/stable/c/a1f8765f68bc9bf5744b365bb9f5e0b6db93edfe
  - https://git.kernel.org/stable/c/aaa1c5d635a6fca2043513ffb5be169f9cd17d9e
  - https://git.kernel.org/stable/c/ddb3f0b68863bd1c5f43177eea476bce316d4993

------------------------------------------------------------

CVE ID: CVE-2022-49568
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: Don't null dereference ops->destroy

A KVM device cleanup happens in either of two callbacks:
1) destroy() which is called when the VM is being destroyed;
2) release() which is called when a device fd is closed.

Most KVM devices use 1) but Book3s's interrupt controller KVM devices
(XICS, XIVE, XIVE-native) use 2) as they need to close and reopen during
the machine execution. The error handling in kvm_ioctl_create_device()
assumes destroy() is always defined which leads to NULL dereference as
discovered by Syzkaller.

This adds a checks for destroy!=NULL and adds a missing release().

This is not changing kvm_destroy_devices() as devices with defined
release() should have been removed from the KVM devices list by then.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.210
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/170465715a60cbb7876e6b961b21bd3225469da8
  - https://git.kernel.org/stable/c/3616776bc51cd3262bb1be60cc01c72e0a1959cf
  - https://git.kernel.org/stable/c/d4a5a79b780891c5cbdfdc6124d46fdf8d13dba1
  - https://git.kernel.org/stable/c/e8bc2427018826e02add7b0ed0fc625a60390ae5
  - https://git.kernel.org/stable/c/e91665fbbf3ccb268b268a7d71a6513538d813ac

------------------------------------------------------------

CVE ID: CVE-2022-49569
Description: In the Linux kernel, the following vulnerability has been resolved:

spi: bcm2835: bcm2835_spi_handle_err(): fix NULL pointer deref for non DMA transfers

In case a IRQ based transfer times out the bcm2835_spi_handle_err()
function is called. Since commit 1513ceee70f2 ("spi: bcm2835: Drop
dma_pending flag") the TX and RX DMA transfers are unconditionally
canceled, leading to NULL pointer derefs if ctlr->dma_tx or
ctlr->dma_rx are not set.

Fix the NULL pointer deref by checking that ctlr->dma_tx and
ctlr->dma_rx are valid pointers before accessing them.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/49ffa473218012e765682343de2052eb4c1f06a7
  - https://git.kernel.org/stable/c/4ceaa684459d414992acbefb4e4c31f2dfc50641
  - https://git.kernel.org/stable/c/58466e05390043d2805685c70f55f3f59711bdf2
  - https://git.kernel.org/stable/c/684896e675edd8b669fd3e9f547c5038222d85bc
  - https://git.kernel.org/stable/c/76668d2a2f367d25ff448e6d7087406af7d7bb2b

------------------------------------------------------------

CVE ID: CVE-2022-49570
Description: In the Linux kernel, the following vulnerability has been resolved:

gpio: gpio-xilinx: Fix integer overflow

Current implementation is not able to configure more than 32 pins
due to incorrect data type. So type casting with unsigned long
to avoid it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/32c094a09d5829ad9b02cdf667569aefa8de0ea6
  - https://git.kernel.org/stable/c/6f16a5390640807dde420ee5ccbc4c95577aea6a
  - https://git.kernel.org/stable/c/e129e5486b981d324057e6986059f852658b0d00

------------------------------------------------------------

CVE ID: CVE-2022-49571
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_max_reordering.

While reading sysctl_tcp_max_reordering, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.19, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/064852663308c801861bd54789d81421fa4c2928
  - https://git.kernel.org/stable/c/46deb91ac8a790286ad6d24cf92e7ab0ab2582bb
  - https://git.kernel.org/stable/c/50a1d3d097503a90cf84ebe120afcde37e9c33b3
  - https://git.kernel.org/stable/c/5e38cee24f19d19280c68f1ac8bf6790d607f60a
  - https://git.kernel.org/stable/c/a11e5b3e7a59fde1a90b0eaeaa82320495cf8cae
  - https://git.kernel.org/stable/c/ce3731c61589ed73364a5b55ce34131762ef9b60

------------------------------------------------------------

CVE ID: CVE-2022-49572
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_slow_start_after_idle.

While reading sysctl_tcp_slow_start_after_idle, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.18, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0e3f82a03ec8c3808e87283e12946227415706c9
  - https://git.kernel.org/stable/c/369d99c2b89f54473adcf9acdf40ea562b5a6e0e
  - https://git.kernel.org/stable/c/3b26e11b07a09b31247688bec61e2925d4a571b6
  - https://git.kernel.org/stable/c/41aeba4506f6b70ec7500c6fe202731a4ba29fe5
  - https://git.kernel.org/stable/c/4845b5713ab18a1bb6e31d1fbb4d600240b8b691
  - https://git.kernel.org/stable/c/68b6f9506747d507c7bfa374d178929b4157e8c6

------------------------------------------------------------

CVE ID: CVE-2022-49573
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_early_retrans.

While reading sysctl_tcp_early_retrans, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.5, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/11e8b013d16e5db63f8f76acceb5b86964098aaa
  - https://git.kernel.org/stable/c/488d3ad98ef7cddce7054193dbae6b4349c6807d
  - https://git.kernel.org/stable/c/5037ca9e4b169cc9aed0174d658c3d81fdaf8ea5
  - https://git.kernel.org/stable/c/52e65865deb6a36718a463030500f16530eaab74
  - https://git.kernel.org/stable/c/83767fe800a311370330d4ec83aa76093b744a80
  - https://git.kernel.org/stable/c/d5975f6376ce90c2c483ae36bf88c9cface4c13b

------------------------------------------------------------

CVE ID: CVE-2022-49574
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_recovery.

While reading sysctl_tcp_recovery, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/52ee7f5c4811ce6be1becd14d38ba1f8a8a0df81
  - https://git.kernel.org/stable/c/92c35113c63306091df9211375eebd0abd8c2160
  - https://git.kernel.org/stable/c/a31e2d0cb5cfa2aae3144cac04f25031d5d20fb4
  - https://git.kernel.org/stable/c/c7a492db1f7c37c758a66915908677bd8bc5d368
  - https://git.kernel.org/stable/c/d8781f7cd04091744f474a2bada74772084b9dc9
  - https://git.kernel.org/stable/c/e7d2ef837e14a971a05f60ea08c47f3fed1a36e4

------------------------------------------------------------

CVE ID: CVE-2022-49575
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_thin_linear_timeouts.

While reading sysctl_tcp_thin_linear_timeouts, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.34, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/404c53ccdebd11f96954f4070cffac8e0b4d5cb6
  - https://git.kernel.org/stable/c/492f3713b282c0e67e951cd804edd22eccc25412
  - https://git.kernel.org/stable/c/7c6f2a86ca590d5187a073d987e9599985fb1c7c
  - https://git.kernel.org/stable/c/a0f96c4f179cb3560078cefccef105e8f1701210
  - https://git.kernel.org/stable/c/cc133e4f4bc225079198192623945bb872c08143
  - https://git.kernel.org/stable/c/f4b0295be9a3c4260de4585fac4062e602a88ac7

------------------------------------------------------------

CVE ID: CVE-2022-49576
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: Fix data-races around sysctl_fib_multipath_hash_fields.

While reading sysctl_fib_multipath_hash_fields, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/36f5b86f309b3b11295d087cd7433f1c897caf94
  - https://git.kernel.org/stable/c/548d6678c4a3d43667e59686665f8674b82440a3
  - https://git.kernel.org/stable/c/8895a9c2ac76fb9d3922fed4fe092c8ec5e5cccc

------------------------------------------------------------

CVE ID: CVE-2022-49577
Description: In the Linux kernel, the following vulnerability has been resolved:

udp: Fix a data-race around sysctl_udp_l3mdev_accept.

While reading sysctl_udp_l3mdev_accept, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.11, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3d72bb4188c708bb16758c60822fc4dda7a95174
  - https://git.kernel.org/stable/c/3f2ac2d6511bb0652abf4d7388d65bb9ff1c641c
  - https://git.kernel.org/stable/c/cb0d28934ca10f99c47e2c6f451405d6c954fe48
  - https://git.kernel.org/stable/c/f39b03bd727a8fea62e82f10fe2e0d753b9930ff
  - https://git.kernel.org/stable/c/fcaef69c79ec222e55643e666b80b221e70fa6a8

------------------------------------------------------------

CVE ID: CVE-2022-49578
Description: In the Linux kernel, the following vulnerability has been resolved:

ip: Fix data-races around sysctl_ip_prot_sock.

sysctl_ip_prot_sock is accessed concurrently, and there is always a chance
of data-race.  So, all readers and writers need some basic protection to
avoid load/store-tearing.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.11, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/95724fe897a4ecf2be51452ef96e818568071664
  - https://git.kernel.org/stable/c/9add240f76af6d141d2eebd3a1558a0e503a993d
  - https://git.kernel.org/stable/c/9b55c20f83369dd54541d9ddbe3a018a8377f451
  - https://git.kernel.org/stable/c/ef699813d99cc29e6e25c9f6da7766526cc8bd6e

------------------------------------------------------------

CVE ID: CVE-2022-49579
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: Fix data-races around sysctl_fib_multipath_hash_policy.

While reading sysctl_fib_multipath_hash_policy, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/21fb844bc1dc1461f5038d655aa1a14f39e13049
  - https://git.kernel.org/stable/c/7998c12a08c97cc26660532c9f90a34bd7d8da5a
  - https://git.kernel.org/stable/c/918ee6592ab9a2ff5316d06cfd4aaef60ccabec6

------------------------------------------------------------

CVE ID: CVE-2022-49580
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: Fix a data-race around sysctl_fib_multipath_use_neigh.

While reading sysctl_fib_multipath_use_neigh, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.7, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/14e996577ed2799a1ed6ffeb71c76d63acb28444
  - https://git.kernel.org/stable/c/6727f39e99e0f545d815edebb6c94228485427ec
  - https://git.kernel.org/stable/c/87507bcb4f5de16bb419e9509d874f4db6c0ad0f
  - https://git.kernel.org/stable/c/b8d345db03b4deffb4f04219a51d3b1e94171b76
  - https://git.kernel.org/stable/c/e045d672ba06e1d35bacb56374d350de0ac99066

------------------------------------------------------------

CVE ID: CVE-2022-49581
Description: In the Linux kernel, the following vulnerability has been resolved:

be2net: Fix buffer overflow in be_get_module_eeprom

be_cmd_read_port_transceiver_data assumes that it is given a buffer that
is at least PAGE_DATA_LEN long, or twice that if the module supports SFF
8472. However, this is not always the case.

Fix this by passing the desired offset and length to
be_cmd_read_port_transceiver_data so that we only copy the bytes once.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/18043da94c023f3ef09c15017bdb04e8f695ef10
  - https://git.kernel.org/stable/c/665cbe91de2f7c97c51ca8fce39aae26477c1948
  - https://git.kernel.org/stable/c/8ff4f9df73e5c551a72ee6034886c17e8de6596d
  - https://git.kernel.org/stable/c/a5a8fc0679a8fd58d47aa2ebcfc5742631f753f9
  - https://git.kernel.org/stable/c/a8569f76df7ec5b4b51155c57523a0b356db5741
  - https://git.kernel.org/stable/c/aba8ff847f4f927ad7a1a1ee4a9f29989a1a728f
  - https://git.kernel.org/stable/c/d7241f679a59cfe27f92cb5c6272cb429fb1f7ec
  - https://git.kernel.org/stable/c/fe4473fc7940f14c4a12db873b9729134c212654

------------------------------------------------------------

CVE ID: CVE-2022-49582
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: fix NULL pointer dereference in dsa_port_reset_vlan_filtering

The "ds" iterator variable used in dsa_port_reset_vlan_filtering() ->
dsa_switch_for_each_port() overwrites the "dp" received as argument,
which is later used to call dsa_port_vlan_filtering() proper.

As a result, switches which do enter that code path (the ones with
vlan_filtering_is_global=true) will dereference an invalid dp in
dsa_port_reset_vlan_filtering() after leaving a VLAN-aware bridge.

Use a dedicated "other_dp" iterator variable to avoid this from
happening.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1699b4d502eda3c7ea4070debad3ee570b5091b1
  - https://git.kernel.org/stable/c/3240e12fe203a3a79b9814e83327106b770ed7b0

------------------------------------------------------------

CVE ID: CVE-2022-49583
Description: In the Linux kernel, the following vulnerability has been resolved:

iavf: Fix handling of dummy receive descriptors

Fix memory leak caused by not handling dummy receive descriptor properly.
iavf_get_rx_buffer now sets the rx_buffer return value for dummy receive
descriptors. Without this patch, when the hardware writes a dummy
descriptor, iavf would not free the page allocated for the previous receive
buffer. This is an unlikely event but can still happen.

[Jesse: massaged commit message]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.1.20, Last Version (Excluding): 5.2
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2.3, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2918419c06088f6709ceb543feb01752779ade4c
  - https://git.kernel.org/stable/c/6edb818732fc05fda495f5b3a749bd1cee01398b
  - https://git.kernel.org/stable/c/a9f49e0060301a9bfebeca76739158d0cf91cdf6
  - https://git.kernel.org/stable/c/c6af94324911ef0846af1a5ce5e049ca736db34b
  - https://git.kernel.org/stable/c/d88d59faf4e6f9cc4767664206afdb999b10ec77

------------------------------------------------------------

CVE ID: CVE-2022-49584
Description: In the Linux kernel, the following vulnerability has been resolved:

ixgbe: Add locking to prevent panic when setting sriov_numvfs to zero

It is possible to disable VFs while the PF driver is processing requests
from the VF driver.  This can result in a panic.

BUG: unable to handle kernel paging request at 000000000000106c
PGD 0 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 8 PID: 0 Comm: swapper/8 Kdump: loaded Tainted: G I      --------- -
Hardware name: Dell Inc. PowerEdge R740/06WXJT, BIOS 2.8.2 08/27/2020
RIP: 0010:ixgbe_msg_task+0x4c8/0x1690 [ixgbe]
Code: 00 00 48 8d 04 40 48 c1 e0 05 89 7c 24 24 89 fd 48 89 44 24 10 83 ff
01 0f 84 b8 04 00 00 4c 8b 64 24 10 4d 03 a5 48 22 00 00 <41> 80 7c 24 4c
00 0f 84 8a 03 00 00 0f b7 c7 83 f8 08 0f 84 8f 0a
RSP: 0018:ffffb337869f8df8 EFLAGS: 00010002
RAX: 0000000000001020 RBX: 0000000000000000 RCX: 000000000000002b
RDX: 0000000000000002 RSI: 0000000000000008 RDI: 0000000000000006
RBP: 0000000000000006 R08: 0000000000000002 R09: 0000000000029780
R10: 00006957d8f42832 R11: 0000000000000000 R12: 0000000000001020
R13: ffff8a00e8978ac0 R14: 000000000000002b R15: ffff8a00e8979c80
FS:  0000000000000000(0000) GS:ffff8a07dfd00000(0000) knlGS:00000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000000000000106c CR3: 0000000063e10004 CR4: 00000000007726e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 <IRQ>
 ? ttwu_do_wakeup+0x19/0x140
 ? try_to_wake_up+0x1cd/0x550
 ? ixgbevf_update_xcast_mode+0x71/0xc0 [ixgbevf]
 ixgbe_msix_other+0x17e/0x310 [ixgbe]
 __handle_irq_event_percpu+0x40/0x180
 handle_irq_event_percpu+0x30/0x80
 handle_irq_event+0x36/0x53
 handle_edge_irq+0x82/0x190
 handle_irq+0x1c/0x30
 do_IRQ+0x49/0xd0
 common_interrupt+0xf/0xf

This can be eventually be reproduced with the following script:

while :
do
    echo 63 > /sys/class/net/<devname>/device/sriov_numvfs
    sleep 1
    echo 0 > /sys/class/net/<devname>/device/sriov_numvfs
    sleep 1
done

Add lock when disabling SR-IOV to prevent process VF mailbox communication.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/031af9e617a6f51075d97e56fc9e712c7dde2508
  - https://git.kernel.org/stable/c/16f929a5e76fd047fd8697e1e568bdd7d771955c
  - https://git.kernel.org/stable/c/1e53834ce541d4fe271cdcca7703e50be0a44f8a
  - https://git.kernel.org/stable/c/9d925d2dc82cec2bcbd8625457645d8a548ab22e
  - https://git.kernel.org/stable/c/b82de63f8f817b5735480293dda8e92ba8170c52

------------------------------------------------------------

CVE ID: CVE-2022-49585
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_fastopen_blackhole_timeout.

While reading sysctl_tcp_fastopen_blackhole_timeout, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/021266ec640c7a4527e6cd4b7349a512b351de1d
  - https://git.kernel.org/stable/c/0dc2f19d8c2636cebda7976b5ea40c6d69f0d891
  - https://git.kernel.org/stable/c/8afa5604e295046c02b79ccf9e2bbbf8d969d60e
  - https://git.kernel.org/stable/c/a77a75a0e7f397550ab039f96115103e78dd5c69

------------------------------------------------------------

CVE ID: CVE-2022-49586
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_fastopen.

While reading sysctl_tcp_fastopen, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.6, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/03da610696a32578fc4f986479341ce9d430df08
  - https://git.kernel.org/stable/c/22938534c611136f35e2ca545bb668073ca5ef49
  - https://git.kernel.org/stable/c/25d53d858a6c0b89a6e69e376c2a57c4f4c2c8cc
  - https://git.kernel.org/stable/c/448ab998947996a0a451f8229f19087964cf2670
  - https://git.kernel.org/stable/c/539d9ab79eba3974b479cad61a8688c41fe62e12
  - https://git.kernel.org/stable/c/5a54213318c43f4009ae158347aa6016e3b9b55a

------------------------------------------------------------

CVE ID: CVE-2022-49587
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_notsent_lowat.

While reading sysctl_tcp_notsent_lowat, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.12, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0f75343584ee474303e17efe0610bdd170af1d13
  - https://git.kernel.org/stable/c/55be873695ed8912eb77ff46d1d1cadf028bd0f3
  - https://git.kernel.org/stable/c/62e56cfeb2ae4b53ae9ca24c80f54093250ce64a
  - https://git.kernel.org/stable/c/80d4d0c461674eea87f0977e12a2ecd334b9b79c
  - https://git.kernel.org/stable/c/91e21df688f8a75255ca9c459da39ac96300113a
  - https://git.kernel.org/stable/c/c1b85c5a34294f7444c13bf828e0e84b0a0eed85
  - https://git.kernel.org/stable/c/e9362a993886613ef0284c2a4911c6017c97d803
  - https://git.kernel.org/stable/c/fd6f1284e380c377932186042ff0b5c987fb2b92

------------------------------------------------------------

CVE ID: CVE-2022-49588
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_migrate_req.

While reading sysctl_tcp_migrate_req, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.188, Last Version (Excluding): 5.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4177f545895b1da08447a80692f30617154efa6e
  - https://git.kernel.org/stable/c/6e569a11eea20a1ccebc3c4e6366bf0574a449e1
  - https://git.kernel.org/stable/c/fcf6c6d8aeffebca66f37b17ef1b57112e5e09c1

------------------------------------------------------------

CVE ID: CVE-2022-49589
Description: In the Linux kernel, the following vulnerability has been resolved:

igmp: Fix data-races around sysctl_igmp_qrv.

While reading sysctl_igmp_qrv, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.

This test can be packed into a helper, so such changes will be in the
follow-up series after net is merged into net-next.

  qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18, Last Version (Excluding): 4.19.255
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.209
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.135
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.59
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/8ebcc62c738f68688ee7c6fec2efe5bc6d3d7e60
  - https://git.kernel.org/stable/c/9eeb3a7702998bdccbfcc37997b5dd9215b9a7f7
  - https://git.kernel.org/stable/c/b399ffafffba39f47b731b26a5da1dc0ffc4b3ad
  - https://git.kernel.org/stable/c/c2954671010cd1127d1ffa328c6e6f8e99930982
  - https://git.kernel.org/stable/c/c721324afc589f8ea54bae04756b150aeaae5fa4
  - https://git.kernel.org/stable/c/e20dd1b0e0ea15bee1e528536a0840dba972ca0e

------------------------------------------------------------

CVE ID: CVE-2022-49590
Description: In the Linux kernel, the following vulnerability has been resolved:

igmp: Fix data-races around sysctl_igmp_llm_reports.

While reading sysctl_igmp_llm_reports, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.

This test can be packed into a helper, so such changes will be in the
follow-up series after net is merged into net-next.

  if (ipv4_is_local_multicast(pmc->multiaddr) &&
      !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.3, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1656ecaddf90e2a070ec2d2404cdae3edf80faca
  - https://git.kernel.org/stable/c/260446eb8e5541402b271343a4516f2b33dec1e4
  - https://git.kernel.org/stable/c/46307adceb67bdf2ec38408dd9cebc378a6b5c46
  - https://git.kernel.org/stable/c/473aad9ad57ff760005377e6f45a2ad4210e08ce
  - https://git.kernel.org/stable/c/a84b4afaca2573ed3aed1f8854aefe3ca5a82e72
  - https://git.kernel.org/stable/c/d77969e7d4ccc26bf1f414a39ef35050a83ba6d5
  - https://git.kernel.org/stable/c/ed876e99ccf417b8bd7fd8408ba5e8b008e46cc8
  - https://git.kernel.org/stable/c/f6da2267e71106474fbc0943dc24928b9cb79119

------------------------------------------------------------

CVE ID: CVE-2022-49591
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: microchip: ksz_common: Fix refcount leak bug

In ksz_switch_register(), we should call of_node_put() for the
reference returned by of_get_child_by_name() which has increased
the refcount.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.9, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4165e02716518bbbe9c9104b39530d40928bc7ce
  - https://git.kernel.org/stable/c/88ec2ff42da3ac93b2437dc52fe25cd4372148e6
  - https://git.kernel.org/stable/c/a14bd7475452c51835dd5a0cee4c8fa48dd0b539

------------------------------------------------------------

CVE ID: CVE-2022-49592
Description: In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: fix dma queue left shift overflow issue

When queue number is > 4, left shift overflows due to 32 bits
integer variable. Mask calculation is wrong for MTL_RXQ_DMA_MAP1.

If CONFIG_UBSAN is enabled, kernel dumps below warning:
[   10.363842] ==================================================================
[   10.363882] UBSAN: shift-out-of-bounds in /build/linux-intel-iotg-5.15-8e6Tf4/
linux-intel-iotg-5.15-5.15.0/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c:224:12
[   10.363929] shift exponent 40 is too large for 32-bit type 'unsigned int'
[   10.363953] CPU: 1 PID: 599 Comm: NetworkManager Not tainted 5.15.0-1003-intel-iotg
[   10.363956] Hardware name: ADLINK Technology Inc. LEC-EL/LEC-EL, BIOS 0.15.11 12/22/2021
[   10.363958] Call Trace:
[   10.363960]  <TASK>
[   10.363963]  dump_stack_lvl+0x4a/0x5f
[   10.363971]  dump_stack+0x10/0x12
[   10.363974]  ubsan_epilogue+0x9/0x45
[   10.363976]  __ubsan_handle_shift_out_of_bounds.cold+0x61/0x10e
[   10.363979]  ? wake_up_klogd+0x4a/0x50
[   10.363983]  ? vprintk_emit+0x8f/0x240
[   10.363986]  dwmac4_map_mtl_dma.cold+0x42/0x91 [stmmac]
[   10.364001]  stmmac_mtl_configuration+0x1ce/0x7a0 [stmmac]
[   10.364009]  ? dwmac410_dma_init_channel+0x70/0x70 [stmmac]
[   10.364020]  stmmac_hw_setup.cold+0xf/0xb14 [stmmac]
[   10.364030]  ? page_pool_alloc_pages+0x4d/0x70
[   10.364034]  ? stmmac_clear_tx_descriptors+0x6e/0xe0 [stmmac]
[   10.364042]  stmmac_open+0x39e/0x920 [stmmac]
[   10.364050]  __dev_open+0xf0/0x1a0
[   10.364054]  __dev_change_flags+0x188/0x1f0
[   10.364057]  dev_change_flags+0x26/0x60
[   10.364059]  do_setlink+0x908/0xc40
[   10.364062]  ? do_setlink+0xb10/0xc40
[   10.364064]  ? __nla_validate_parse+0x4c/0x1a0
[   10.364068]  __rtnl_newlink+0x597/0xa10
[   10.364072]  ? __nla_reserve+0x41/0x50
[   10.364074]  ? __kmalloc_node_track_caller+0x1d0/0x4d0
[   10.364079]  ? pskb_expand_head+0x75/0x310
[   10.364082]  ? nla_reserve_64bit+0x21/0x40
[   10.364086]  ? skb_free_head+0x65/0x80
[   10.364089]  ? security_sock_rcv_skb+0x2c/0x50
[   10.364094]  ? __cond_resched+0x19/0x30
[   10.364097]  ? kmem_cache_alloc_trace+0x15a/0x420
[   10.364100]  rtnl_newlink+0x49/0x70

This change fixes MTL_RXQ_DMA_MAP1 mask issue and channel/queue
mapping warning.

BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=216195
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/508d86ead36cbd8dfb60773a33276790d668c473
  - https://git.kernel.org/stable/c/573768dede0e2b7de38ecbc11cb3ee47643902dc
  - https://git.kernel.org/stable/c/613b065ca32e90209024ec4a6bb5ca887ee70980
  - https://git.kernel.org/stable/c/7c687a893f5cae5ca40d189635602e93af9bab73
  - https://git.kernel.org/stable/c/a3ac79f38d354b10925824899cdbd2caadce55ba
  - https://git.kernel.org/stable/c/ad2febdfbd01e1d092a08bfdba92ede79ea05ff3
  - https://git.kernel.org/stable/c/e846bde09677fa3b203057846620b7ed96540f5f

------------------------------------------------------------

CVE ID: CVE-2022-49593
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_probe_interval.

While reading sysctl_tcp_probe_interval, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.1, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2a85388f1d94a9f8b5a529118a2c5eaa0520d85c
  - https://git.kernel.org/stable/c/73a11588751a2c13f25d9da8117efc9a79b1843f
  - https://git.kernel.org/stable/c/80dabd089086e6553b7acfcff2ec223bdada87a1
  - https://git.kernel.org/stable/c/b14cc8afbbcbc6dce4797913c0b85266b897f541
  - https://git.kernel.org/stable/c/b3798d3519eda9c409bb0815b0102f27ec42468d
  - https://git.kernel.org/stable/c/c61aede097d350d890fa1edc9521b0072e14a0b8
  - https://git.kernel.org/stable/c/e6b6f027e2854a51f345a5e3e808d7a88001d4f8

------------------------------------------------------------

CVE ID: CVE-2022-49594
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_mtu_probe_floor.

While reading sysctl_tcp_mtu_probe_floor, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/033963b220633ed1602d458e7e4ac06afa9fefb2
  - https://git.kernel.org/stable/c/8e92d4423615a5257d0d871fc067aa561f597deb
  - https://git.kernel.org/stable/c/cc36c37f5fe066c4708e623ead96dc8f57224bf5
  - https://git.kernel.org/stable/c/d5bece4df6090395f891110ef52a6f82d16685db
  - https://git.kernel.org/stable/c/e2ecbf3f0aa88277d43908c53b99399d55729ff9

------------------------------------------------------------

CVE ID: CVE-2022-49595
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_probe_threshold.

While reading sysctl_tcp_probe_threshold, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.1, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/44768749980d53bc01980d9c060f736808d11af0
  - https://git.kernel.org/stable/c/92c0aa4175474483d6cf373314343d4e624e882a
  - https://git.kernel.org/stable/c/96900fa61777402eb5056269d8000aace33a8b6c
  - https://git.kernel.org/stable/c/9b5dc7ad6da1373d3c60d4b869d688f996e5d219
  - https://git.kernel.org/stable/c/b04817c94fbd285a967d9b830b274fe9998c9c0b
  - https://git.kernel.org/stable/c/d452ce36f2d4c402fa3f5275c9677f80166e7fc6
  - https://git.kernel.org/stable/c/f524c3e7f6cdad66b3b6a912cef47b656f8b0de3
  - https://git.kernel.org/stable/c/fa5fb2cf9393db898772db8cb897ed5fd265eb78

------------------------------------------------------------

CVE ID: CVE-2022-49596
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_min_snd_mss.

While reading sysctl_tcp_min_snd_mss, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16.69, Last Version (Excluding): 3.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.182, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.182, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.127, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.52, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.1.11, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0d8a39feb58910a7f7746b1770ee5578cc551fe6
  - https://git.kernel.org/stable/c/0fc9357282df055e30990b29f4b7afa53ab42cdb
  - https://git.kernel.org/stable/c/78eb166cdefcc3221c8c7c1e2d514e91a2eb5014
  - https://git.kernel.org/stable/c/97992e8feff33b3ae154a113ec398546bbacda80
  - https://git.kernel.org/stable/c/fdb96b69f5909ffcdd6f1e0902219fc6d7689ff7

------------------------------------------------------------

CVE ID: CVE-2022-49597
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_base_mss.

While reading sysctl_tcp_base_mss, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.17, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/30b73edc1d2459ba2c71cb58fbf84a1a6e640fbf
  - https://git.kernel.org/stable/c/4d7dea651b7fe0322be95054f64e3711afccc543
  - https://git.kernel.org/stable/c/514d2254c7b8aa2d257f5ffc79f0d96be2d6bfda
  - https://git.kernel.org/stable/c/88d78bc097cd8ebc6541e93316c9d9bf651b13e8
  - https://git.kernel.org/stable/c/9ca18116bc16ec31b9a3ce28ea1350badfa36128

------------------------------------------------------------

CVE ID: CVE-2022-49598
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_mtu_probing.

While reading sysctl_tcp_mtu_probing, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.17, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/77a04845f0d28a3561494a5f3121488470a968a4
  - https://git.kernel.org/stable/c/7e8fc428a7f680f1c4994a40e52d7f95a9a93038
  - https://git.kernel.org/stable/c/aabe9438fdfe004e021d5a206227ec105dbe2416
  - https://git.kernel.org/stable/c/b0920ca09d9ce19980c8391b9002455baa9c1417
  - https://git.kernel.org/stable/c/f47d00e077e7d61baf69e46dde3210c886360207
  - https://git.kernel.org/stable/c/f966773e13cdd3f12baa90071b7b660f6c633ccb

------------------------------------------------------------

CVE ID: CVE-2022-49599
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix data-races around sysctl_tcp_l3mdev_accept.

While reading sysctl_tcp_l3mdev_accept, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.5, Last Version (Excluding): 5.10.137
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/08a75f10679470552a3a443f9aefd1399604d31d
  - https://git.kernel.org/stable/c/1d9c81833dec46ccb52a1d0db970fefb7c4fa071
  - https://git.kernel.org/stable/c/7d38d86b818104cf88961f3aebea34da89364a8e
  - https://git.kernel.org/stable/c/9ba9cd43b5776c27d25e5a32dde9e80bdeb1c6a1

------------------------------------------------------------

CVE ID: CVE-2022-49600
Description: In the Linux kernel, the following vulnerability has been resolved:

ip: Fix a data-race around sysctl_ip_autobind_reuse.

While reading sysctl_ip_autobind_reuse, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0db232765887d9807df8bcb7b6f29b2871539eab
  - https://git.kernel.org/stable/c/611ba70e5aca252ef43374dda97ed4cf1c47a07c
  - https://git.kernel.org/stable/c/87ceaa199a72c5856d49a030941fabcd5c3928d4
  - https://git.kernel.org/stable/c/fa7cdcf9b28d13aac1eeb34b948db8a18e041341

------------------------------------------------------------

CVE ID: CVE-2022-49601
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp/dccp: Fix a data-race around sysctl_tcp_fwmark_accept.

While reading sysctl_tcp_fwmark_accept, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/13207f9485b5de68decf296ceb0046f5eabb2485
  - https://git.kernel.org/stable/c/1a0008f9df59451d0a17806c1ee1a19857032fa8
  - https://git.kernel.org/stable/c/45fc82706a97242539d6b841ddd7a077ec20757b
  - https://git.kernel.org/stable/c/526d8cf8824f613c72dba2155542295e70135f62
  - https://git.kernel.org/stable/c/a7386602a2fe2f6192477e8ede291a815da09d81
  - https://git.kernel.org/stable/c/abf70de2ec026ae8d7da4e79bec61888a880e00b
  - https://git.kernel.org/stable/c/bf3134feffe61b7a0e21f60a04743f8da0958b53
  - https://git.kernel.org/stable/c/d4f65615db7fca3df9f7e79eadf937e6ddb03c54

------------------------------------------------------------

CVE ID: CVE-2022-49602
Description: In the Linux kernel, the following vulnerability has been resolved:

ip: Fix a data-race around sysctl_fwmark_reflect.

While reading sysctl_fwmark_reflect, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0ee76fe01ff3c0b4efaa500aecc90d7c8d3a8860
  - https://git.kernel.org/stable/c/25a635a67c830766110410fea88ec4e6ee29684b
  - https://git.kernel.org/stable/c/5e7a1be3e68deef250ad43cc91f7bb8d7d758b48
  - https://git.kernel.org/stable/c/85d0b4dbd74b95cc492b1f4e34497d3f894f5d9a
  - https://git.kernel.org/stable/c/9096edcf4854289f92252e086cf6e498c7f8c21d
  - https://git.kernel.org/stable/c/a475ecc9ad919aa3ebdd4e4a6ee612b793bf74b3
  - https://git.kernel.org/stable/c/dccf8a67f30e18980d13f07006e5a536bbd1e136
  - https://git.kernel.org/stable/c/fc92e3b4bebfdd986ef1d2c5019f236837b0b982

------------------------------------------------------------

CVE ID: CVE-2022-49603
Description: In the Linux kernel, the following vulnerability has been resolved:

ip: Fix data-races around sysctl_ip_fwd_update_priority.

While reading sysctl_ip_fwd_update_priority, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/11038fa781ab916535c53351537b22d6d405667d
  - https://git.kernel.org/stable/c/351f81f7d7185d18a9ff76f8f8c2fa8c4eea563b
  - https://git.kernel.org/stable/c/7bf9e18d9a5e99e3c83482973557e9f047b051e7
  - https://git.kernel.org/stable/c/bcc03369d3277ae075ed421f0c8bf4adb5e65b74

------------------------------------------------------------

CVE ID: CVE-2022-49604
Description: In the Linux kernel, the following vulnerability has been resolved:

ip: Fix data-races around sysctl_ip_fwd_use_pmtu.

While reading sysctl_ip_fwd_use_pmtu, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.14, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/60c158dc7b1f0558f6cadd5b50d0386da0000d50
  - https://git.kernel.org/stable/c/7828309df0f89419a9349761a37c7d1b0da45697
  - https://git.kernel.org/stable/c/93fbc06da1d819f3981a7bd7928c3641ea67b364
  - https://git.kernel.org/stable/c/b96ed5ccb09ae71103023ed13acefb194f609794
  - https://git.kernel.org/stable/c/e364b5f6ffbfc457a997ad09a7baa16c19581edc
  - https://git.kernel.org/stable/c/eb15262128b793e4b1d1c4514d3e6d19c3959764

------------------------------------------------------------

CVE ID: CVE-2022-49605
Description: In the Linux kernel, the following vulnerability has been resolved:

igc: Reinstate IGC_REMOVED logic and implement it properly

The initially merged version of the igc driver code (via commit
146740f9abc4, "igc: Add support for PF") contained the following
IGC_REMOVED checks in the igc_rd32/wr32() MMIO accessors:

	u32 igc_rd32(struct igc_hw *hw, u32 reg)
	{
		u8 __iomem *hw_addr = READ_ONCE(hw->hw_addr);
		u32 value = 0;

		if (IGC_REMOVED(hw_addr))
			return ~value;

		value = readl(&hw_addr[reg]);

		/* reads should not return all F's */
		if (!(~value) && (!reg || !(~readl(hw_addr))))
			hw->hw_addr = NULL;

		return value;
	}

And:

	#define wr32(reg, val) \
	do { \
		u8 __iomem *hw_addr = READ_ONCE((hw)->hw_addr); \
		if (!IGC_REMOVED(hw_addr)) \
			writel((val), &hw_addr[(reg)]); \
	} while (0)

E.g. igb has similar checks in its MMIO accessors, and has a similar
macro E1000_REMOVED, which is implemented as follows:

	#define E1000_REMOVED(h) unlikely(!(h))

These checks serve to detect and take note of an 0xffffffff MMIO read
return from the device, which can be caused by a PCIe link flap or some
other kind of PCI bus error, and to avoid performing MMIO reads and
writes from that point onwards.

However, the IGC_REMOVED macro was not originally implemented:

	#ifndef IGC_REMOVED
	#define IGC_REMOVED(a) (0)
	#endif /* IGC_REMOVED */

This led to the IGC_REMOVED logic to be removed entirely in a
subsequent commit (commit 3c215fb18e70, "igc: remove IGC_REMOVED
function"), with the rationale that such checks matter only for
virtualization and that igc does not support virtualization -- but a
PCIe device can become detached even without virtualization being in
use, and without proper checks, a PCIe bus error affecting an igc
adapter will lead to various NULL pointer dereferences, as the first
access after the error will set hw->hw_addr to NULL, and subsequent
accesses will blindly dereference this now-NULL pointer.

This patch reinstates the IGC_REMOVED checks in igc_rd32/wr32(), and
implements IGC_REMOVED the way it is done for igb, by checking for the
unlikely() case of hw_addr being NULL.  This change prevents the oopses
seen when a PCIe link flap occurs on an igc adapter.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/16cb6717f4f42487ef10583eb8bc98e7d1e33d65
  - https://git.kernel.org/stable/c/70965b6e5c03aa70cc754af1226b9f9cde0c4bf3
  - https://git.kernel.org/stable/c/77836dbe35382aaf8108489060c5c89530c77494
  - https://git.kernel.org/stable/c/7c1ddcee5311f3315096217881d2dbe47cc683f9
  - https://git.kernel.org/stable/c/e75b73081f1ec169518773626c2ff3950476660b

------------------------------------------------------------

CVE ID: CVE-2022-49606
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/irdma: Fix sleep from invalid context BUG

Taking the qos_mutex to process RoCEv2 QP's on netdev events causes a
kernel splat.

Fix this by removing the handling for RoCEv2 in
irdma_cm_teardown_connections that uses the mutex. This handling is only
needed for iWARP to avoid having connections established while the link is
down or having connections remain functional after the IP address is
removed.

  BUG: sleeping function called from invalid context at kernel/locking/mutex.
  Call Trace:
  kernel: dump_stack+0x66/0x90
  kernel: ___might_sleep.cold.92+0x8d/0x9a
  kernel: mutex_lock+0x1c/0x40
  kernel: irdma_cm_teardown_connections+0x28e/0x4d0 [irdma]
  kernel: ? check_preempt_curr+0x7a/0x90
  kernel: ? select_idle_sibling+0x22/0x3c0
  kernel: ? select_task_rq_fair+0x94c/0xc90
  kernel: ? irdma_exec_cqp_cmd+0xc27/0x17c0 [irdma]
  kernel: ? __wake_up_common+0x7a/0x190
  kernel: irdma_if_notify+0x3cc/0x450 [irdma]
  kernel: ? sched_clock_cpu+0xc/0xb0
  kernel: irdma_inet6addr_event+0xc6/0x150 [irdma]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2cae7e519032e4b4672cb9204d5586a441924364
  - https://git.kernel.org/stable/c/a4c5115140ed1833197bad9a6b80265840ff427f
  - https://git.kernel.org/stable/c/cc0315564d6eec91c716d314b743321be24c70b3

------------------------------------------------------------

CVE ID: CVE-2022-49607
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/core: Fix data race between perf_event_set_output() and perf_mmap_close()

Yang Jihing reported a race between perf_event_set_output() and
perf_mmap_close():

	CPU1					CPU2

	perf_mmap_close(e2)
	  if (atomic_dec_and_test(&e2->rb->mmap_count)) // 1 - > 0
	    detach_rest = true

						ioctl(e1, IOC_SET_OUTPUT, e2)
						  perf_event_set_output(e1, e2)

	  ...
	  list_for_each_entry_rcu(e, &e2->rb->event_list, rb_entry)
	    ring_buffer_attach(e, NULL);
	    // e1 isn't yet added and
	    // therefore not detached

						    ring_buffer_attach(e1, e2->rb)
						      list_add_rcu(&e1->rb_entry,
								   &e2->rb->event_list)

After this; e1 is attached to an unmapped rb and a subsequent
perf_mmap() will loop forever more:

	again:
		mutex_lock(&e->mmap_mutex);
		if (event->rb) {
			...
			if (!atomic_inc_not_zero(&e->rb->mmap_count)) {
				...
				mutex_unlock(&e->mmap_mutex);
				goto again;
			}
		}

The loop in perf_mmap_close() holds e2->mmap_mutex, while the attach
in perf_event_set_output() holds e1->mmap_mutex. As such there is no
serialization to avoid this race.

Change perf_event_set_output() to take both e1->mmap_mutex and
e2->mmap_mutex to alleviate that problem. Additionally, have the loop
in perf_mmap() detach the rb directly, this avoids having to wait for
the concurrent perf_mmap_close() to get around to doing it to make
progress.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.2.49, Last Version (Excluding): 3.3
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.4.52, Last Version (Excluding): 3.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.9.8, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/17f5417194136517ee9bbd6511249e5310e5617c
  - https://git.kernel.org/stable/c/3bbd868099287ff9027db59029b502fcfa2202a0
  - https://git.kernel.org/stable/c/43128b3eee337824158f34da6648163d2f2fb937
  - https://git.kernel.org/stable/c/68e3c69803dada336893640110cb87221bb01dcf
  - https://git.kernel.org/stable/c/98c3c8fd0d4c560e0f8335b79c407bbf7fc9462c
  - https://git.kernel.org/stable/c/a9391ff7a7c5f113d6f2bf6621d49110950de49c
  - https://git.kernel.org/stable/c/da3c256e2d0ebc87c7db0c605c9692b6f1722074
  - https://git.kernel.org/stable/c/f836f9ac95df15f1e0af4beb0ec20021e8c91998

------------------------------------------------------------

CVE ID: CVE-2022-49608
Description: In the Linux kernel, the following vulnerability has been resolved:

pinctrl: ralink: Check for null return of devm_kcalloc

Because of the possible failure of the allocation, data->domains might
be NULL pointer and will cause the dereference of the NULL pointer
later.
Therefore, it might be better to check it and directly return -ENOMEM
without releasing data manually if fails, because the comment of the
devm_kmalloc() says "Memory allocated with this function is
automatically freed on driver detach.".
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.18, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/13596e6c9e541e90e5fc2c52b23f08b951370da9
  - https://git.kernel.org/stable/c/44016a85419ca0d4f1e4d0127b330f8e4e2a57d0
  - https://git.kernel.org/stable/c/5595d30c4dc27d939635c3188c68203b6ece1711
  - https://git.kernel.org/stable/c/5694b162f275fb9a9f89422701b2b963be11e496
  - https://git.kernel.org/stable/c/6194c021496addc11763d1ffa89ce5751889fe3c
  - https://git.kernel.org/stable/c/c3b821e8e406d5650e587b7ac624ac24e9b780a8

------------------------------------------------------------

CVE ID: CVE-2022-49609
Description: In the Linux kernel, the following vulnerability has been resolved:

power/reset: arm-versatile: Fix refcount leak in versatile_reboot_probe

of_find_matching_node_and_match() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18, Last Version (Excluding): 4.9.325
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.290
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.208
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.58
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.15
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/493ceca3271316e74639c89ff8ac35883de64256
  - https://git.kernel.org/stable/c/49fa778ee044b00471dd9ccae5f6a121fffea1ac
  - https://git.kernel.org/stable/c/6689754b121bd487f99680280102b3a5cd7374af
  - https://git.kernel.org/stable/c/71ab83ac65e2d671552374123bf920c1d698335a
  - https://git.kernel.org/stable/c/78bdf732cf5d74d1c6ecda06830a91f80a4aef6f
  - https://git.kernel.org/stable/c/80192eff64eee9b3bc0594a47381937b94b9d65a
  - https://git.kernel.org/stable/c/a9ed3ad3a8d1dfbc829d86edb3236873a315db11
  - https://git.kernel.org/stable/c/b4d224eec96a18fa8959512cd9e5b6a50bd16a41

------------------------------------------------------------

CVE ID: CVE-2022-49610
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: VMX: Prevent RSB underflow before vmenter

On VMX, there are some balanced returns between the time the guest's
SPEC_CTRL value is written, and the vmenter.

Balanced returns (matched by a preceding call) are usually ok, but it's
at least theoretically possible an NMI with a deep call stack could
empty the RSB before one of the returns.

For maximum paranoia, don't allow *any* returns (balanced or otherwise)
between the SPEC_CTRL write and the vmenter.

  [ bp: Fix 32-bit build. ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/07853adc29a058c5fd143c14e5ac528448a72ed9
  - https://git.kernel.org/stable/c/afd743f6dde87296c6f3414706964c491bb85862

------------------------------------------------------------

CVE ID: CVE-2022-49611
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/speculation: Fill RSB on vmexit for IBRS

Prevent RSB underflow/poisoning attacks with RSB.  While at it, add a
bunch of comments to attempt to document the current state of tribal
knowledge about RSB attacks and what exactly is being mitigated.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/17a9fc4a7b91f8599223631bb6ae6416bc0de1c0
  - https://git.kernel.org/stable/c/3d323b99ff5c8c57005184056d65f6af5b0479d8
  - https://git.kernel.org/stable/c/4d7f72b6e1bc630bec7e4cd51814bc2b092bf153
  - https://git.kernel.org/stable/c/8c38306e2e9257af4af2819aa287a4711ff36329
  - https://git.kernel.org/stable/c/8d5cff499a6d740c91ff37963907e0e983c37f0f
  - https://git.kernel.org/stable/c/9756bba28470722dacb79ffce554336dd1f6a6cd
  - https://git.kernel.org/stable/c/f744b88dfc201bf8092833ec70b23c720188b527

------------------------------------------------------------

CVE ID: CVE-2022-49612
Description: In the Linux kernel, the following vulnerability has been resolved:

power: supply: core: Fix boundary conditions in interpolation

The functions power_supply_temp2resist_simple and power_supply_ocv2cap_simple
handle boundary conditions incorrectly.
The change was introduced in a4585ba2050f460f749bbaf2b67bd56c41e30283
("power: supply: core: Use library interpolation").
There are two issues: First, the lines "high = i - 1" and "high = i" in ocv2cap
have the wrong order compared to temp2resist. As a consequence, ocv2cap
sets high=-1 if ocv>table[0].ocv, which causes an out-of-bounds read.
Second, the logic of temp2resist is also not correct.
Consider the case table[] = {{20, 100}, {10, 80}, {0, 60}}.
For temp=5, we expect a resistance of 70% by interpolation.
However, temp2resist sets high=low=2 and returns 60.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/093d27bb6f2d1963f927ef59c9a2d37059175426
  - https://git.kernel.org/stable/c/a762cee5d933fe4e2e1b773d60fc74fb8248d8c4

------------------------------------------------------------

CVE ID: CVE-2022-49613
Description: In the Linux kernel, the following vulnerability has been resolved:

serial: 8250: Fix PM usage_count for console handover

When console is enabled, univ8250_console_setup() calls
serial8250_console_setup() before .dev is set to uart_port. Therefore,
it will not call pm_runtime_get_sync(). Later, when the actual driver
is going to take over univ8250_console_exit() is called. As .dev is
already set, serial8250_console_exit() makes pm_runtime_put_sync() call
with usage count being zero triggering PM usage count warning
(extra debug for univ8250_console_setup(), univ8250_console_exit(), and
serial8250_register_ports()):

[    0.068987] univ8250_console_setup ttyS0 nodev
[    0.499670] printk: console [ttyS0] enabled
[    0.717955] printk: console [ttyS0] printing thread started
[    1.960163] serial8250_register_ports assigned dev for ttyS0
[    1.976830] printk: console [ttyS0] disabled
[    1.976888] printk: console [ttyS0] printing thread stopped
[    1.977073] univ8250_console_exit ttyS0 usage:0
[    1.977075] serial8250 serial8250: Runtime PM usage count underflow!
[    1.977429] dw-apb-uart.6: ttyS0 at MMIO 0x4010006000 (irq = 33, base_baud = 115200) is a 16550A
[    1.977812] univ8250_console_setup ttyS0 usage:2
[    1.978167] printk: console [ttyS0] printing thread started
[    1.978203] printk: console [ttyS0] enabled

To fix the issue, call pm_runtime_get_sync() in
serial8250_register_ports() as soon as .dev is set for an uart_port
if it has console enabled.

This problem became apparent only recently because 82586a721595 ("PM:
runtime: Avoid device usage count underflows") added the warning
printout. I confirmed this problem also occurs with v5.18 (w/o the
warning printout, obviously).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/190ce5cdc55d1b66ea582ac2be6fd5a72e3cc486
  - https://git.kernel.org/stable/c/5df66302f03f87ae8953785a882d78e911f00c55
  - https://git.kernel.org/stable/c/d9cb6fabc90102f9e61fe35bd0160db88f4f53b4
  - https://git.kernel.org/stable/c/f9b11229b79c0fb2100b5bb4628a101b1d37fbf6

------------------------------------------------------------

CVE ID: CVE-2022-49615
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: rt711-sdca: fix kernel NULL pointer dereference when IO error

The initial settings will be written before the codec probe function.
But, the rt711->component doesn't be assigned yet.
If IO error happened during initial settings operations, it will cause the kernel panic.
This patch changed component->dev to slave->dev to fix this issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1df793d479bef546569fc2e409ff8bb3f0fb8e99
  - https://git.kernel.org/stable/c/269be8b2907378adf72d7347cfa43ef230351a06
  - https://git.kernel.org/stable/c/7bb71133cae88d3003a3490b97864af76533072b

------------------------------------------------------------

CVE ID: CVE-2022-49616
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: rt7*-sdw: harden jack_detect_handler

Realtek headset codec drivers typically check if the card is
instantiated before proceeding with the jack detection.

The rt700, rt711 and rt711-sdca are however missing a check on the
card pointer, which can lead to NULL dereferences encountered in
driver bind/unbind tests.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0484271ab0ce50649329fa9dc23c50853c5b26a4
  - https://git.kernel.org/stable/c/07a606e1389a63b61cb8cd591026f30529117573
  - https://git.kernel.org/stable/c/1d75b73ec6d6b705cca528b36d8315e43e8d7fa5

------------------------------------------------------------

CVE ID: CVE-2022-49617
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: Intel: sof_sdw: handle errors on card registration

If the card registration fails, typically because of deferred probes,
the device properties added for headset codecs are not removed, which
leads to kernel oopses in driver bind/unbind tests.

We already clean-up the device properties when the card is removed,
this code can be moved as a helper and called upon card registration
errors.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09bca0ffc95c50369f1345d80ecfaca51864126f
  - https://git.kernel.org/stable/c/f2556ce6b35ae0fc72000a4daa21ded12665e2f2
  - https://git.kernel.org/stable/c/fe154c4ff376bc31041c6441958a08243df09c99

------------------------------------------------------------

CVE ID: CVE-2022-49618
Description: In the Linux kernel, the following vulnerability has been resolved:

pinctrl: aspeed: Fix potential NULL dereference in aspeed_pinmux_set_mux()

pdesc could be null but still dereference pdesc->name and it will lead to
a null pointer access. So we move a null check before dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3cb392b64304a05bf647e2e44efacd9a1f3c3c6a
  - https://git.kernel.org/stable/c/84a85d3fef2e75b1fe9fc2af6f5267122555a1ed
  - https://git.kernel.org/stable/c/e162a24f1dd06c0dcae71f2565c9f3da2827b98e
  - https://git.kernel.org/stable/c/ef1e38532f4b2f0f3b460e938a2e7076c3bed5ee

------------------------------------------------------------

CVE ID: CVE-2022-49619
Description: In the Linux kernel, the following vulnerability has been resolved:

net: sfp: fix memory leak in sfp_probe()

sfp_probe() allocates a memory chunk from sfp with sfp_alloc(). When
devm_add_action() fails, sfp is not freed, which leads to a memory leak.

We should use devm_add_action_or_reset() instead of devm_add_action().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0a18d802d65cf662644fd1d369c86d84a5630652
  - https://git.kernel.org/stable/c/1545bc727625ea6e8decd717e5d1e8cc704ccf8f
  - https://git.kernel.org/stable/c/204543581a2f26bb3b997a304c0bd06926ba7f15
  - https://git.kernel.org/stable/c/67dc32542a1fb7790d0853cf4a5cf859ac6a2002
  - https://git.kernel.org/stable/c/9ec5a97f327a89031fce6cfc3e95543c53936638
  - https://git.kernel.org/stable/c/ede990cfc42775bd0141e21f37ee365dcaeeb50f
  - https://git.kernel.org/stable/c/f22ddc8a5278d7fb6369a0aeb0d8775a0aefaaee

------------------------------------------------------------

CVE ID: CVE-2022-49620
Description: In the Linux kernel, the following vulnerability has been resolved:

net: tipc: fix possible refcount leak in tipc_sk_create()

Free sk in case tipc_sk_insert() fails.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.324
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/00aff3590fc0a73bddd3b743863c14e76fd35c0c
  - https://git.kernel.org/stable/c/3b2957fc09fe1ac7f07f40dd50dd5f93e3f3a7a2
  - https://git.kernel.org/stable/c/4919d82f7041157a421ca9bf39a78551d5ad8a1b
  - https://git.kernel.org/stable/c/638fa20b618b2bbcf86da71231624cc82121a036
  - https://git.kernel.org/stable/c/7bc9e7f70bc57d8f02ffea2a42094281effb15ef
  - https://git.kernel.org/stable/c/833ecd0eae76eadf81d6d747bb5bc992d1151867
  - https://git.kernel.org/stable/c/ef488669b2652bde5b6ee5a409a5b048a2a50db4
  - https://git.kernel.org/stable/c/efa78f2ae363428525fb4981bb63c555ee79f3c7

------------------------------------------------------------

CVE ID: CVE-2022-49621
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: pmac32-cpufreq: Fix refcount leak bug

In pmac_cpufreq_init_MacRISC3(), we need to add corresponding
of_node_put() for the three node pointers whose refcount have
been incremented by of_find_node_by_name().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.324
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/37c16fc2cb13a13f3c0193bfc6f2edef7d7df7d7
  - https://git.kernel.org/stable/c/3ea9dbf7c2f436952bca331c6f5d72f75aca224e
  - https://git.kernel.org/stable/c/4513018d0bd739097570d26a7760551cba3deb56
  - https://git.kernel.org/stable/c/4585890ab2dbf455d80e254d3d859d4c1e357920
  - https://git.kernel.org/stable/c/4f242486bf46d314b2e3838cc64b56f008a3c4d7
  - https://git.kernel.org/stable/c/57289b6601fe78c09921599b042a0b430fb420ec
  - https://git.kernel.org/stable/c/8dda30f81c751b01cd71f2cfaeef26ad4393b1d1
  - https://git.kernel.org/stable/c/ccd7567d4b6cf187fdfa55f003a9e461ee629e36

------------------------------------------------------------

CVE ID: CVE-2022-49622
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: avoid skb access on nf_stolen

When verdict is NF_STOLEN, the skb might have been freed.

When tracing is enabled, this can result in a use-after-free:
1. access to skb->nf_trace
2. access to skb->mark
3. computation of trace id
4. dump of packet payload

To avoid 1, keep a cached copy of skb->nf_trace in the
trace state struct.
Refresh this copy whenever verdict is != STOLEN.

Avoid 2 by skipping skb->mark access if verdict is STOLEN.

3 is avoided by precomputing the trace id.

Only dump the packet when verdict is not "STOLEN".
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0016d5d46d7440729a3132f61a8da3bf7f84e2ba
  - https://git.kernel.org/stable/c/e34b9ed96ce3b06c79bf884009b16961ca478f87

------------------------------------------------------------

CVE ID: CVE-2022-49623
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/xive/spapr: correct bitmap allocation size

kasan detects access beyond the end of the xibm->bitmap allocation:

BUG: KASAN: slab-out-of-bounds in _find_first_zero_bit+0x40/0x140
Read of size 8 at addr c00000001d1d0118 by task swapper/0/1

CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-rc2-00001-g90df023b36dd #28
Call Trace:
[c00000001d98f770] [c0000000012baab8] dump_stack_lvl+0xac/0x108 (unreliable)
[c00000001d98f7b0] [c00000000068faac] print_report+0x37c/0x710
[c00000001d98f880] [c0000000006902c0] kasan_report+0x110/0x354
[c00000001d98f950] [c000000000692324] __asan_load8+0xa4/0xe0
[c00000001d98f970] [c0000000011c6ed0] _find_first_zero_bit+0x40/0x140
[c00000001d98f9b0] [c0000000000dbfbc] xive_spapr_get_ipi+0xcc/0x260
[c00000001d98fa70] [c0000000000d6d28] xive_setup_cpu_ipi+0x1e8/0x450
[c00000001d98fb30] [c000000004032a20] pSeries_smp_probe+0x5c/0x118
[c00000001d98fb60] [c000000004018b44] smp_prepare_cpus+0x944/0x9ac
[c00000001d98fc90] [c000000004009f9c] kernel_init_freeable+0x2d4/0x640
[c00000001d98fd90] [c0000000000131e8] kernel_init+0x28/0x1d0
[c00000001d98fe10] [c00000000000cd54] ret_from_kernel_thread+0x5c/0x64

Allocated by task 0:
 kasan_save_stack+0x34/0x70
 __kasan_kmalloc+0xb4/0xf0
 __kmalloc+0x268/0x540
 xive_spapr_init+0x4d0/0x77c
 pseries_init_irq+0x40/0x27c
 init_IRQ+0x44/0x84
 start_kernel+0x2a4/0x538
 start_here_common+0x1c/0x20

The buggy address belongs to the object at c00000001d1d0118
 which belongs to the cache kmalloc-8 of size 8
The buggy address is located 0 bytes inside of
 8-byte region [c00000001d1d0118, c00000001d1d0120)

The buggy address belongs to the physical page:
page:c00c000000074740 refcount:1 mapcount:0 mapping:0000000000000000 index:0xc00000001d1d0558 pfn:0x1d1d
flags: 0x7ffff000000200(slab|node=0|zone=0|lastcpupid=0x7ffff)
raw: 007ffff000000200 c00000001d0003c8 c00000001d0003c8 c00000001d010480
raw: c00000001d1d0558 0000000001e1000a 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 c00000001d1d0000: fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 c00000001d1d0080: fc fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc
>c00000001d1d0100: fc fc fc 02 fc fc fc fc fc fc fc fc fc fc fc fc
                            ^
 c00000001d1d0180: fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc fc
 c00000001d1d0200: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc

This happens because the allocation uses the wrong unit (bits) when it
should pass (BITS_TO_LONGS(count) * sizeof(long)) or equivalent. With small
numbers of bits, the allocated object can be smaller than sizeof(long),
which results in invalid accesses.

Use bitmap_zalloc() to allocate and initialize the irq bitmap, paired with
bitmap_free() for consistency.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/10f2cd373e65bcd3be8f3cdc71c330c25763dfd8
  - https://git.kernel.org/stable/c/19fc5bb93c6bbdce8292b4d7eed04e2fa118d2fe
  - https://git.kernel.org/stable/c/99d1c36bddd93919072b5a51a89297bbb5ad6a6f

------------------------------------------------------------

CVE ID: CVE-2022-49624
Description: In the Linux kernel, the following vulnerability has been resolved:

net: atlantic: remove aq_nic_deinit() when resume

aq_nic_deinit() has been called while suspending, so we don't have to call
it again on resume.
Actually, call it again leads to another hang issue when resuming from
S3.

Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992345] Call Trace:
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992346] <TASK>
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992348] aq_nic_deinit+0xb4/0xd0 [atlantic]
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992356] aq_pm_thaw+0x7f/0x100 [atlantic]
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992362] pci_pm_resume+0x5c/0x90
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992366] ? pci_pm_thaw+0x80/0x80
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992368] dpm_run_callback+0x4e/0x120
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992371] device_resume+0xad/0x200
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992373] async_resume+0x1e/0x40
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992374] async_run_entry_fn+0x33/0x120
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992377] process_one_work+0x220/0x3c0
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992380] worker_thread+0x4d/0x3f0
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992382] ? process_one_work+0x3c0/0x3c0
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992384] kthread+0x12a/0x150
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992386] ? set_kthread_struct+0x40/0x40
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992387] ret_from_fork+0x22/0x30
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992391] </TASK>
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992392] ---[ end trace 1ec8c79604ed5e0d ]---
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992394] PM: dpm_run_callback(): pci_pm_resume+0x0/0x90 returns -110
Jul 8 03:09:44 u-Precision-7865-Tower kernel: [ 5910.992397] atlantic 0000:02:00.0: PM: failed to resume async: error -110
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2e15c51fefaffaf9f72255eaef4fada05055e4c5
  - https://git.kernel.org/stable/c/58c90993933e7a76305519bc70da8c0cd2907c1f
  - https://git.kernel.org/stable/c/702419db7ded2e3686fbc05040b61d7428d611d5
  - https://git.kernel.org/stable/c/c2978d0124f26e453ed30fda6a37f62d8c7f19cb

------------------------------------------------------------

CVE ID: CVE-2022-49625
Description: In the Linux kernel, the following vulnerability has been resolved:

sfc: fix kernel panic when creating VF

When creating VFs a kernel panic can happen when calling to
efx_ef10_try_update_nic_stats_vf.

When releasing a DMA coherent buffer, sometimes, I don't know in what
specific circumstances, it has to unmap memory with vunmap. It is
disallowed to do that in IRQ context or with BH disabled. Otherwise, we
hit this line in vunmap, causing the crash:
  BUG_ON(in_interrupt());

This patch reenables BH to release the buffer.

Log messages when the bug is hit:
 kernel BUG at mm/vmalloc.c:2727!
 invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
 CPU: 6 PID: 1462 Comm: NetworkManager Kdump: loaded Tainted: G          I      --------- ---  5.14.0-119.el9.x86_64 #1
 Hardware name: Dell Inc. PowerEdge R740/06WXJT, BIOS 2.8.2 08/27/2020
 RIP: 0010:vunmap+0x2e/0x30
 ...skip...
 Call Trace:
  __iommu_dma_free+0x96/0x100
  efx_nic_free_buffer+0x2b/0x40 [sfc]
  efx_ef10_try_update_nic_stats_vf+0x14a/0x1c0 [sfc]
  efx_ef10_update_stats_vf+0x18/0x40 [sfc]
  efx_start_all+0x15e/0x1d0 [sfc]
  efx_net_open+0x5a/0xe0 [sfc]
  __dev_open+0xe7/0x1a0
  __dev_change_flags+0x1d7/0x240
  dev_change_flags+0x21/0x60
  ...skip...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/16662524ec5da801fb78a1afcaf6e782f1cf103a
  - https://git.kernel.org/stable/c/68e5f32f0de9594629ff9e599294d9801c6187de
  - https://git.kernel.org/stable/c/82bcb730f856086f033e6c04082eb4503d4c2fa4
  - https://git.kernel.org/stable/c/ada74c5539eba06cf8b47d068f92e0b3963a9a6e
  - https://git.kernel.org/stable/c/b82e4ad58a7fb72456503958a93060f87896e629
  - https://git.kernel.org/stable/c/b9072305270579a9d6afc9b926166231e5b1a7c8
  - https://git.kernel.org/stable/c/d9840212a9c00507347c703f4fdeda16400407e0
  - https://git.kernel.org/stable/c/da346adcf5573fd8663cabfdfe8371009629a906

------------------------------------------------------------

CVE ID: CVE-2022-49626
Description: In the Linux kernel, the following vulnerability has been resolved:

sfc: fix use after free when disabling sriov

Use after free is detected by kfence when disabling sriov. What was read
after being freed was vf->pci_dev: it was freed from pci_disable_sriov
and later read in efx_ef10_sriov_free_vf_vports, called from
efx_ef10_sriov_free_vf_vswitching.

Set the pointer to NULL at release time to not trying to read it later.

Reproducer and dmesg log (note that kfence doesn't detect it every time):
$ echo 1 > /sys/class/net/enp65s0f0np0/device/sriov_numvfs
$ echo 0 > /sys/class/net/enp65s0f0np0/device/sriov_numvfs

 BUG: KFENCE: use-after-free read in efx_ef10_sriov_free_vf_vswitching+0x82/0x170 [sfc]

 Use-after-free read at 0x00000000ff3c1ba5 (in kfence-#224):
  efx_ef10_sriov_free_vf_vswitching+0x82/0x170 [sfc]
  efx_ef10_pci_sriov_disable+0x38/0x70 [sfc]
  efx_pci_sriov_configure+0x24/0x40 [sfc]
  sriov_numvfs_store+0xfe/0x140
  kernfs_fop_write_iter+0x11c/0x1b0
  new_sync_write+0x11f/0x1b0
  vfs_write+0x1eb/0x280
  ksys_write+0x5f/0xe0
  do_syscall_64+0x5c/0x80
  entry_SYSCALL_64_after_hwframe+0x44/0xae

 kfence-#224: 0x00000000edb8ef95-0x00000000671f5ce1, size=2792, cache=kmalloc-4k

 allocated by task 6771 on cpu 10 at 3137.860196s:
  pci_alloc_dev+0x21/0x60
  pci_iov_add_virtfn+0x2a2/0x320
  sriov_enable+0x212/0x3e0
  efx_ef10_sriov_configure+0x67/0x80 [sfc]
  efx_pci_sriov_configure+0x24/0x40 [sfc]
  sriov_numvfs_store+0xba/0x140
  kernfs_fop_write_iter+0x11c/0x1b0
  new_sync_write+0x11f/0x1b0
  vfs_write+0x1eb/0x280
  ksys_write+0x5f/0xe0
  do_syscall_64+0x5c/0x80
  entry_SYSCALL_64_after_hwframe+0x44/0xae

 freed by task 6771 on cpu 12 at 3170.991309s:
  device_release+0x34/0x90
  kobject_cleanup+0x3a/0x130
  pci_iov_remove_virtfn+0xd9/0x120
  sriov_disable+0x30/0xe0
  efx_ef10_pci_sriov_disable+0x57/0x70 [sfc]
  efx_pci_sriov_configure+0x24/0x40 [sfc]
  sriov_numvfs_store+0xfe/0x140
  kernfs_fop_write_iter+0x11c/0x1b0
  new_sync_write+0x11f/0x1b0
  vfs_write+0x1eb/0x280
  ksys_write+0x5f/0xe0
  do_syscall_64+0x5c/0x80
  entry_SYSCALL_64_after_hwframe+0x44/0xae
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2, Last Version (Excluding): 4.9.324
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3199e34912d84cdfb8a93a984c5ae5c73fb13e84
  - https://git.kernel.org/stable/c/58d93e9d160c0de6d867c7eb4c2206671a351eb1
  - https://git.kernel.org/stable/c/9c854ae512b89229aeee93849e9bd4c115b37909
  - https://git.kernel.org/stable/c/bcad880865bfb421885364b1f0c7351280fe2b97
  - https://git.kernel.org/stable/c/c2240500817b3b4b996cdf2a461a3a5679f49b94
  - https://git.kernel.org/stable/c/c9e75bb22a26e391f189f5a5133dd63dcb57fdaa
  - https://git.kernel.org/stable/c/e435c4aeeaa073091f7f3b7735af2ef5c97d63f2
  - https://git.kernel.org/stable/c/ebe41da5d47ac0fff877e57bd14c54dccf168827

------------------------------------------------------------

CVE ID: CVE-2022-49627
Description: In the Linux kernel, the following vulnerability has been resolved:

ima: Fix potential memory leak in ima_init_crypto()

On failure to allocate the SHA1 tfm, IMA fails to initialize and exits
without freeing the ima_algo_array. Add the missing kfree() for
ima_algo_array to avoid the potential memory leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/067d2521874135267e681c19d42761c601d503d6
  - https://git.kernel.org/stable/c/601ae26aa2802a4c10c94d7388a99eabdbefab2b
  - https://git.kernel.org/stable/c/830de9667b3ada0a75a3f098dfc7159709fe397b
  - https://git.kernel.org/stable/c/c1d9702ceb4a091da6bee380627596d1fba09274

------------------------------------------------------------

CVE ID: CVE-2022-49628
Description: In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: fix leaks in probe

These two error paths should clean up before returning.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/23aa6d5088e3bd65de77c5c307237b9937f8b48a
  - https://git.kernel.org/stable/c/dd91bc60f305610401b2196bedb573693d6c8e46
  - https://git.kernel.org/stable/c/f4bd3202a2b4194ab6c0ce61628095d54f994db4

------------------------------------------------------------

CVE ID: CVE-2022-49629
Description: In the Linux kernel, the following vulnerability has been resolved:

nexthop: Fix data-races around nexthop_compat_mode.

While reading nexthop_compat_mode, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0d17723afea3ae8c9f245c9bbd2ba5945b77e812
  - https://git.kernel.org/stable/c/a51040d4b120f3520df64fb0b9c63b31d69bea9b
  - https://git.kernel.org/stable/c/ae3054f6fbccc90f14ecd6cf9b2c09a2401c64fd
  - https://git.kernel.org/stable/c/bdf00bf24bef9be1ca641a6390fd5487873e0d2e

------------------------------------------------------------

CVE ID: CVE-2022-49630
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: Fix a data-race around sysctl_tcp_ecn_fallback.

While reading sysctl_tcp_ecn_fallback, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/12b8d9ca7e678abc48195294494f1815b555d658
  - https://git.kernel.org/stable/c/1ec3d6c2626ee6e1b36b7bd006873a271406ba61
  - https://git.kernel.org/stable/c/8bcf7339f2cf70ea4461df6ea045d1aadfabfa11

------------------------------------------------------------

CVE ID: CVE-2022-49631
Description: In the Linux kernel, the following vulnerability has been resolved:

raw: Fix a data-race around sysctl_raw_l3mdev_accept.

While reading sysctl_raw_l3mdev_accept, it can be changed concurrently.
Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/038a87b3e460d2ee579c8b1bd3890d816d6687b1
  - https://git.kernel.org/stable/c/1dace014928e6e385363032d359a04dee9158af0
  - https://git.kernel.org/stable/c/46e9c46203fd4676720ddca0fef7eff26826648e
  - https://git.kernel.org/stable/c/ab5adca2e17d6595f3fc0e25ccb6bcbe2e01ca4f
  - https://git.kernel.org/stable/c/cc9540ba5b3652c473af7e54892a48cdced87983

------------------------------------------------------------

CVE ID: CVE-2022-49632
Description: In the Linux kernel, the following vulnerability has been resolved:

icmp: Fix a data-race around sysctl_icmp_errors_use_inbound_ifaddr.

While reading sysctl_icmp_errors_use_inbound_ifaddr, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its reader.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/d2efabce81db7eed1c98fa1a3f203f0edd738ac3
  - https://git.kernel.org/stable/c/de9490c32bc10020efdd1509689a28f197d6dfb8
  - https://git.kernel.org/stable/c/f9617844e4d5d6331dbce3fb19a24e5bda201e58

------------------------------------------------------------

CVE ID: CVE-2022-49633
Description: In the Linux kernel, the following vulnerability has been resolved:

icmp: Fix data-races around sysctl_icmp_echo_enable_probe.

While reading sysctl_icmp_echo_enable_probe, it can be changed
concurrently.  Thus, we need to add READ_ONCE() to its readers.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/05c615033174f1d19374f42285ccd8e9af13e427
  - https://git.kernel.org/stable/c/4a2f7083cc6cb72dade9a63699ca352fad26d1cd
  - https://git.kernel.org/stable/c/cce955efa0ab81f7fb72e22beed372054c86005c

------------------------------------------------------------

CVE ID: CVE-2022-49634
Description: In the Linux kernel, the following vulnerability has been resolved:

sysctl: Fix data-races in proc_dou8vec_minmax().

A sysctl variable is accessed concurrently, and there is always a chance
of data-race.  So, all readers and writers need some basic protection to
avoid load/store-tearing.

This patch changes proc_dou8vec_minmax() to use READ_ONCE() and
WRITE_ONCE() internally to fix data-races on the sysctl side.  For now,
proc_dou8vec_minmax() itself is tolerant to a data-race, but we still
need to add annotations on the other subsystem's side.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5f776daef0b5354615ec4b4234cd9539ca05f273
  - https://git.kernel.org/stable/c/7dee5d7747a69aa2be41f04c6a7ecfe3ac8cdf18
  - https://git.kernel.org/stable/c/e58b02e445463065b4078bf621561da75197853f
  - https://git.kernel.org/stable/c/f177b382c33900d0e5a9766493c11a1074076f78

------------------------------------------------------------

CVE ID: CVE-2022-49635
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915/selftests: fix subtraction overflow bug

On some machines hole_end can be small enough to cause subtraction
overflow. On the other side (addr + 2 * min_alignment) can overflow
in case of mock tests. This patch should handle both cases.

(cherry picked from commit ab3edc679c552a466e4bf0b11af3666008bd65a2)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/333991c4e66b3d4b5613315f18016da80344f659
  - https://git.kernel.org/stable/c/e8997d2d6b8d764e12489f1af2a1ce1d7384ca2a

------------------------------------------------------------

CVE ID: CVE-2022-49636
Description: In the Linux kernel, the following vulnerability has been resolved:

vlan: fix memory leak in vlan_newlink()

Blamed commit added back a bug I fixed in commit 9bbd917e0bec
("vlan: fix memory leak in vlan_dev_set_egress_priority")

If a memory allocation fails in vlan_changelink() after other allocations
succeeded, we need to call vlan_dev_free_egress_priority()
to free all allocated memory because after a failed ->newlink()
we do not call any methods like ndo_uninit() or dev->priv_destructor().

In following example, if the allocation for last element 2000:2001 fails,
we need to free eight prior allocations:

ip link add link dummy0 dummy0.100 type vlan id 100 \
	egress-qos-map 1:2 2:3 3:4 4:5 5:6 6:7 7:8 8:9 2000:2001

syzbot report was:

BUG: memory leak
unreferenced object 0xffff888117bd1060 (size 32):
comm "syz-executor408", pid 3759, jiffies 4294956555 (age 34.090s)
hex dump (first 32 bytes):
09 00 00 00 00 a0 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
backtrace:
[<ffffffff83fc60ad>] kmalloc include/linux/slab.h:600 [inline]
[<ffffffff83fc60ad>] vlan_dev_set_egress_priority+0xed/0x170 net/8021q/vlan_dev.c:193
[<ffffffff83fc6628>] vlan_changelink+0x178/0x1d0 net/8021q/vlan_netlink.c:128
[<ffffffff83fc67c8>] vlan_newlink+0x148/0x260 net/8021q/vlan_netlink.c:185
[<ffffffff838b1278>] rtnl_newlink_create net/core/rtnetlink.c:3363 [inline]
[<ffffffff838b1278>] __rtnl_newlink+0xa58/0xdc0 net/core/rtnetlink.c:3580
[<ffffffff838b1629>] rtnl_newlink+0x49/0x70 net/core/rtnetlink.c:3593
[<ffffffff838ac66c>] rtnetlink_rcv_msg+0x21c/0x5c0 net/core/rtnetlink.c:6089
[<ffffffff839f9c37>] netlink_rcv_skb+0x87/0x1d0 net/netlink/af_netlink.c:2501
[<ffffffff839f8da7>] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
[<ffffffff839f8da7>] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345
[<ffffffff839f9266>] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921
[<ffffffff8384dbf6>] sock_sendmsg_nosec net/socket.c:714 [inline]
[<ffffffff8384dbf6>] sock_sendmsg+0x56/0x80 net/socket.c:734
[<ffffffff8384e15c>] ____sys_sendmsg+0x36c/0x390 net/socket.c:2488
[<ffffffff838523cb>] ___sys_sendmsg+0x8b/0xd0 net/socket.c:2542
[<ffffffff838525b8>] __sys_sendmsg net/socket.c:2571 [inline]
[<ffffffff838525b8>] __do_sys_sendmsg net/socket.c:2580 [inline]
[<ffffffff838525b8>] __se_sys_sendmsg net/socket.c:2578 [inline]
[<ffffffff838525b8>] __x64_sys_sendmsg+0x78/0xf0 net/socket.c:2578
[<ffffffff845ad8d5>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]
[<ffffffff845ad8d5>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
[<ffffffff8460006a>] entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.142, Last Version (Excluding): 5.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4c43069bb1097dd6cc1cf0f7c43a36d1f7b3910b
  - https://git.kernel.org/stable/c/549de58dba4bf1b2adc72e9948b9c76fa88be9d2
  - https://git.kernel.org/stable/c/72a0b329114b1caa8e69dfa7cdad1dd3c69b8602
  - https://git.kernel.org/stable/c/df27729a4fe0002dfd80c96fe1c142829c672728
  - https://git.kernel.org/stable/c/f5dc10b910bdac523e5947336445a77066c51bf9

------------------------------------------------------------

CVE ID: CVE-2022-49637
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: Fix a data-race around sysctl_fib_sync_mem.

While reading sysctl_fib_sync_mem, it can be changed concurrently.
So, we need to add READ_ONCE() to avoid a data-race.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/190cd4ff128373271e065afb20f1d2247b3f10c3
  - https://git.kernel.org/stable/c/418b191d5f223a8cb6cab09eae1f72c04ba6adf2
  - https://git.kernel.org/stable/c/73318c4b7dbd0e781aaababff17376b2894745c0
  - https://git.kernel.org/stable/c/7c1acd98fb221dc0d847451b9ab86319f8b9916c
  - https://git.kernel.org/stable/c/9be8aac91960ea32fd0e874758c9afee665c57d2

------------------------------------------------------------

CVE ID: CVE-2022-49638
Description: In the Linux kernel, the following vulnerability has been resolved:

icmp: Fix data-races around sysctl.

While reading icmp sysctl variables, they can be changed concurrently.
So, we need to add READ_ONCE() to avoid data-races.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18, Last Version (Excluding): 4.9.324
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0cba7ca667ceb06934746ddd9833a25847bde81d
  - https://git.kernel.org/stable/c/1740e5922fbb705637ae9fa5203db132fc45f9f6
  - https://git.kernel.org/stable/c/48d7ee321ea5182c6a70782aa186422a70e67e22
  - https://git.kernel.org/stable/c/53ecd09ef2fb35fa69667ae8e414ef6b00fd3bf6
  - https://git.kernel.org/stable/c/798c2cf57c63ab39c8aac24d6a3d50f4fa5eeb06
  - https://git.kernel.org/stable/c/e088ceb73c24ab4774da391d54a6426f4bfaefce
  - https://git.kernel.org/stable/c/e2828e8c605853f71267825c9415437c0a93e4f2
  - https://git.kernel.org/stable/c/edeec63b13c252193d626c2a48d7a2f0e7016dc2

------------------------------------------------------------

CVE ID: CVE-2022-49639
Description: In the Linux kernel, the following vulnerability has been resolved:

cipso: Fix data-races around sysctl.

While reading cipso sysctl variables, they can be changed concurrently.
So, we need to add READ_ONCE() to avoid data-races.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.19, Last Version (Excluding): 4.9.324
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07b0caf8aeb9b82e6ecc6c292a3e47c7fcdb1148
  - https://git.kernel.org/stable/c/0e41a0f73ccb9be112a80bde3804a771633caaef
  - https://git.kernel.org/stable/c/2764f82bbc158d106693ae3ced3675cf4b963b35
  - https://git.kernel.org/stable/c/59e26906b89cc35bb54476498772b45cbc32323f
  - https://git.kernel.org/stable/c/c321e99d2725d11f7e6a4ebd9ce752259f0bae81
  - https://git.kernel.org/stable/c/ca26ca5e2f3eeb3e6fe699cd6effa3b4b2aa8698
  - https://git.kernel.org/stable/c/dd44f04b9214adb68ef5684ae87a81ba03632250
  - https://git.kernel.org/stable/c/fe2a35fa2c4f9c8ce5ef970eb927031387f9446a

------------------------------------------------------------

CVE ID: CVE-2022-49640
Description: In the Linux kernel, the following vulnerability has been resolved:

sysctl: Fix data races in proc_douintvec_minmax().

A sysctl variable is accessed concurrently, and there is always a chance
of data-race.  So, all readers and writers need some basic protection to
avoid load/store-tearing.

This patch changes proc_douintvec_minmax() to use READ_ONCE() and
WRITE_ONCE() internally to fix data-races on the sysctl side.  For now,
proc_douintvec_minmax() itself is tolerant to a data-race, but we still
need to add annotations on the other subsystem's side.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.13, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2d3b559df3ed39258737789aae2ae7973d205bc1
  - https://git.kernel.org/stable/c/40e0477a7371d101c55b69d9c32a7a1ed82ab5ea
  - https://git.kernel.org/stable/c/b60eddf98b9716651069dfda296c91311a7a6293
  - https://git.kernel.org/stable/c/e3a2144b3b6bf9ecafd91087c8b8b48171ec19df

------------------------------------------------------------

CVE ID: CVE-2022-49641
Description: In the Linux kernel, the following vulnerability has been resolved:

sysctl: Fix data races in proc_douintvec().

A sysctl variable is accessed concurrently, and there is always a chance
of data-race.  So, all readers and writers need some basic protection to
avoid load/store-tearing.

This patch changes proc_douintvec() to use READ_ONCE() and WRITE_ONCE()
internally to fix data-races on the sysctl side.  For now, proc_douintvec()
itself is tolerant to a data-race, but we still need to add annotations on
the other subsystem's side.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.24, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.7.7, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4762b532ec9539755aab61445d5da6e1926ccb99
  - https://git.kernel.org/stable/c/630c76850d554d7140232e71b5d1663e88cffb54
  - https://git.kernel.org/stable/c/d335db59f7fb3353f56e52371f1ee796ae9c8f09
  - https://git.kernel.org/stable/c/d5d54714e329f646bd7af4994fc427d88ee68936

------------------------------------------------------------

CVE ID: CVE-2022-49642
Description: In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: dwc-qos: Disable split header for Tegra194

There is a long-standing issue with the Synopsys DWC Ethernet driver
for Tegra194 where random system crashes have been observed [0]. The
problem occurs when the split header feature is enabled in the stmmac
driver. In the bad case, a larger than expected buffer length is
received and causes the calculation of the total buffer length to
overflow. This results in a very large buffer length that causes the
kernel to crash. Why this larger buffer length is received is not clear,
however, the feedback from the NVIDIA design team is that the split
header feature is not supported for Tegra194. Therefore, disable split
header support for Tegra194 to prevent these random crashes from
occurring.

[0] https://lore.kernel.org/linux-tegra/b0b17697-f23e-8fa5-3757-604a86f3a095@nvidia.com/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/029c1c2059e9c4b38f97a06204cdecd10cfbeb8a
  - https://git.kernel.org/stable/c/2968830c9b47ce093237483c6207c61065712386
  - https://git.kernel.org/stable/c/9cc8edc571b871d974b3289868553f9ce544aba6
  - https://git.kernel.org/stable/c/cfa4caf3e881ad6dd366c903c34f1c7f21b857ab
  - https://git.kernel.org/stable/c/d5c315a787652c35045044877a249f7d5c8a4104

------------------------------------------------------------

CVE ID: CVE-2022-49643
Description: In the Linux kernel, the following vulnerability has been resolved:

ima: Fix a potential integer overflow in ima_appraise_measurement

When the ima-modsig is enabled, the rc passed to evm_verifyxattr() may be
negative, which may cause the integer overflow problem.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/388f3df7c3c8b7f2a32b9ae0a9b2f9f6ad3b1b77
  - https://git.kernel.org/stable/c/640cea4c2839a821adfbb703b590a5928abe9286
  - https://git.kernel.org/stable/c/831e190175f10652be93b08436cc7bf2e62e4bb6
  - https://git.kernel.org/stable/c/c8d5d81940938b5f6c0f495ca9538e7740416f30
  - https://git.kernel.org/stable/c/d2ee2cfc4aa85ff6a2a3b198a3a524ec54e3d999

------------------------------------------------------------

CVE ID: CVE-2022-49644
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915: fix a possible refcount leak in intel_dp_add_mst_connector()

If drm_connector_init fails, intel_connector_free will be called to take
care of proper free. So it is necessary to drop the refcount of port
before intel_connector_free.

(cherry picked from commit cea9ed611e85d36a05db52b6457bf584b7d969e2)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/505114dda5bbfd07f4ce9a2df5b7d8ef5f2a1218
  - https://git.kernel.org/stable/c/592f3bad00b7e2a95a6fb7a4f9e742c061c9c3c1
  - https://git.kernel.org/stable/c/72f231b9a88abcfac9f5ddaa1a0aacb3f9f87ba5
  - https://git.kernel.org/stable/c/85144df9ff4652816448369de76897c57cbb1b93
  - https://git.kernel.org/stable/c/a91522b4279bebb098106a19b91f82b9c3213be9

------------------------------------------------------------

CVE ID: CVE-2022-49645
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/panfrost: Fix shrinker list corruption by madvise IOCTL

Calling madvise IOCTL twice on BO causes memory shrinker list corruption
and crashes kernel because BO is already on the list and it's added to
the list again, while BO should be removed from the list before it's
re-added. Fix it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0581613df7f9a4c5fac096ce1d5fb15b7b994240
  - https://git.kernel.org/stable/c/1807d8867402a58b831a7fc16832747ff559a0d1
  - https://git.kernel.org/stable/c/393594aad55179eb761af41533d8d1d6eb4543b0
  - https://git.kernel.org/stable/c/9fc33eaaa979d112d10fea729edcd2a2e21aa912
  - https://git.kernel.org/stable/c/f036392edd9c49090781d8cca26ad6557a63bae4

------------------------------------------------------------

CVE ID: CVE-2022-49646
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: fix queue selection for mesh/OCB interfaces

When using iTXQ, the code assumes that there is only one vif queue for
broadcast packets, using the BE queue. Allowing non-BE queue marking
violates that assumption and txq->ac == skb_queue_mapping is no longer
guaranteed. This can cause issues with queue handling in the driver and
also causes issues with the recent ATF change, resulting in an AQL
underflow warning.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/41ecab279a70dced9005f4d55fa0fcde8938603f
  - https://git.kernel.org/stable/c/444be5a02b77f3b7a8ac9c1a0b074fbb3bd89cd0
  - https://git.kernel.org/stable/c/50e2ab39291947b6c6c7025cf01707c270fcde59
  - https://git.kernel.org/stable/c/5a9df31017999197b6e60535940f2f2fe1bd3b0d
  - https://git.kernel.org/stable/c/e013ea2a51a94b903b396a8dff531a07d470335d

------------------------------------------------------------

CVE ID: CVE-2022-49647
Description: In the Linux kernel, the following vulnerability has been resolved:

cgroup: Use separate src/dst nodes when preloading css_sets for migration

Each cset (css_set) is pinned by its tasks. When we're moving tasks around
across csets for a migration, we need to hold the source and destination
csets to ensure that they don't go away while we're moving tasks about. This
is done by linking cset->mg_preload_node on either the
mgctx->preloaded_src_csets or mgctx->preloaded_dst_csets list. Using the
same cset->mg_preload_node for both the src and dst lists was deemed okay as
a cset can't be both the source and destination at the same time.

Unfortunately, this overloading becomes problematic when multiple tasks are
involved in a migration and some of them are identity noop migrations while
others are actually moving across cgroups. For example, this can happen with
the following sequence on cgroup1:

 #1> mkdir -p /sys/fs/cgroup/misc/a/b
 #2> echo $$ > /sys/fs/cgroup/misc/a/cgroup.procs
 #3> RUN_A_COMMAND_WHICH_CREATES_MULTIPLE_THREADS &
 #4> PID=$!
 #5> echo $PID > /sys/fs/cgroup/misc/a/b/tasks
 #6> echo $PID > /sys/fs/cgroup/misc/a/cgroup.procs

the process including the group leader back into a. In this final migration,
non-leader threads would be doing identity migration while the group leader
is doing an actual one.

After #3, let's say the whole process was in cset A, and that after #4, the
leader moves to cset B. Then, during #6, the following happens:

 1. cgroup_migrate_add_src() is called on B for the leader.

 2. cgroup_migrate_add_src() is called on A for the other threads.

 3. cgroup_migrate_prepare_dst() is called. It scans the src list.

 4. It notices that B wants to migrate to A, so it tries to A to the dst
    list but realizes that its ->mg_preload_node is already busy.

 5. and then it notices A wants to migrate to A as it's an identity
    migration, it culls it by list_del_init()'ing its ->mg_preload_node and
    putting references accordingly.

 6. The rest of migration takes place with B on the src list but nothing on
    the dst list.

This means that A isn't held while migration is in progress. If all tasks
leave A before the migration finishes and the incoming task pins it, the
cset will be destroyed leading to use-after-free.

This is caused by overloading cset->mg_preload_node for both src and dst
preload lists. We wanted to exclude the cset from the src list but ended up
inadvertently excluding it from the dst list too.

This patch fixes the issue by separating out cset->mg_preload_node into
->mg_src_preload_node and ->mg_dst_preload_node, so that the src and dst
preloadings don't interfere with each other.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/05f7658210d1d331e8dd4cb6e7bbbe3df5f5ac27
  - https://git.kernel.org/stable/c/07fd5b6cdf3cc30bfde8fe0f644771688be04447
  - https://git.kernel.org/stable/c/0e41774b564befa6d271e8d5086bf870d617a4e6
  - https://git.kernel.org/stable/c/54aee4e5ce8c21555286a6333e46c1713880cf93
  - https://git.kernel.org/stable/c/7657e3958535d101a24ab4400f9b8062b9107cc4
  - https://git.kernel.org/stable/c/ad44e05f3e016bdcb1ad25af35ade5b5f41ccd68
  - https://git.kernel.org/stable/c/cec2bbdcc14fbaa6b95ee15a7c423b05d97038be

------------------------------------------------------------

CVE ID: CVE-2022-49648
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing/histograms: Fix memory leak problem

This reverts commit 46bbe5c671e06f070428b9be142cc4ee5cedebac.

As commit 46bbe5c671e0 ("tracing: fix double free") said, the
"double free" problem reported by clang static analyzer is:
  > In parse_var_defs() if there is a problem allocating
  > var_defs.expr, the earlier var_defs.name is freed.
  > This free is duplicated by free_var_defs() which frees
  > the rest of the list.

However, if there is a problem allocating N-th var_defs.expr:
  + in parse_var_defs(), the freed 'earlier var_defs.name' is
    actually the N-th var_defs.name;
  + then in free_var_defs(), the names from 0th to (N-1)-th are freed;

                        IF ALLOCATING PROBLEM HAPPENED HERE!!! -+
                                                                 \
                                                                  |
          0th           1th                 (N-1)-th      N-th    V
          +-------------+-------------+-----+-------------+-----------
var_defs: | name | expr | name | expr | ... | name | expr | name | ///
          +-------------+-------------+-----+-------------+-----------

These two frees don't act on same name, so there was no "double free"
problem before. Conversely, after that commit, we get a "memory leak"
problem because the above "N-th var_defs.name" is not freed.

If enable CONFIG_DEBUG_KMEMLEAK and inject a fault at where the N-th
var_defs.expr allocated, then execute on shell like:
  $ echo 'hist:key=call_site:val=$v1,$v2:v1=bytes_req,v2=bytes_alloc' > \
/sys/kernel/debug/tracing/events/kmem/kmalloc/trigger

Then kmemleak reports:
  unreferenced object 0xffff8fb100ef3518 (size 8):
    comm "bash", pid 196, jiffies 4295681690 (age 28.538s)
    hex dump (first 8 bytes):
      76 31 00 00 b1 8f ff ff                          v1......
    backtrace:
      [<0000000038fe4895>] kstrdup+0x2d/0x60
      [<00000000c99c049a>] event_hist_trigger_parse+0x206f/0x20e0
      [<00000000ae70d2cc>] trigger_process_regex+0xc0/0x110
      [<0000000066737a4c>] event_trigger_write+0x75/0xd0
      [<000000007341e40c>] vfs_write+0xbb/0x2a0
      [<0000000087fde4c2>] ksys_write+0x59/0xd0
      [<00000000581e9cdf>] do_syscall_64+0x3a/0x80
      [<00000000cf3b065c>] entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.149, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.69, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8.13, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/22eeff55679d9e7c0f768c79bfbd83e2f8142d89
  - https://git.kernel.org/stable/c/4d453eb5e1eec89971aa5b3262857ee26cfdffd3
  - https://git.kernel.org/stable/c/78a1400c42ee11197eb1f0f85ba51df9a4fdfff0
  - https://git.kernel.org/stable/c/7edc3945bdce9c39198a10d6129377a5c53559c2
  - https://git.kernel.org/stable/c/eb622d5580b9e2ff694f62da6410618bd73853cb
  - https://git.kernel.org/stable/c/ecc6dec12c33aa92c086cd702af9f544ddaf3c75

------------------------------------------------------------

CVE ID: CVE-2022-49649
Description: In the Linux kernel, the following vulnerability has been resolved:

xen/netback: avoid entering xenvif_rx_next_skb() with an empty rx queue

xenvif_rx_next_skb() is expecting the rx queue not being empty, but
in case the loop in xenvif_rx_action() is doing multiple iterations,
the availability of another skb in the rx queue is not being checked.

This can lead to crashes:

[40072.537261] BUG: unable to handle kernel NULL pointer dereference at 0000000000000080
[40072.537407] IP: xenvif_rx_skb+0x23/0x590 [xen_netback]
[40072.537534] PGD 0 P4D 0
[40072.537644] Oops: 0000 [#1] SMP NOPTI
[40072.537749] CPU: 0 PID: 12505 Comm: v1-c40247-q2-gu Not tainted 4.12.14-122.121-default #1 SLE12-SP5
[40072.537867] Hardware name: HP ProLiant DL580 Gen9/ProLiant DL580 Gen9, BIOS U17 11/23/2021
[40072.537999] task: ffff880433b38100 task.stack: ffffc90043d40000
[40072.538112] RIP: e030:xenvif_rx_skb+0x23/0x590 [xen_netback]
[40072.538217] RSP: e02b:ffffc90043d43de0 EFLAGS: 00010246
[40072.538319] RAX: 0000000000000000 RBX: ffffc90043cd7cd0 RCX: 00000000000000f7
[40072.538430] RDX: 0000000000000000 RSI: 0000000000000006 RDI: ffffc90043d43df8
[40072.538531] RBP: 000000000000003f R08: 000077ff80000000 R09: 0000000000000008
[40072.538644] R10: 0000000000007ff0 R11: 00000000000008f6 R12: ffffc90043ce2708
[40072.538745] R13: 0000000000000000 R14: ffffc90043d43ed0 R15: ffff88043ea748c0
[40072.538861] FS: 0000000000000000(0000) GS:ffff880484600000(0000) knlGS:0000000000000000
[40072.538988] CS: e033 DS: 0000 ES: 0000 CR0: 0000000080050033
[40072.539088] CR2: 0000000000000080 CR3: 0000000407ac8000 CR4: 0000000000040660
[40072.539211] Call Trace:
[40072.539319] xenvif_rx_action+0x71/0x90 [xen_netback]
[40072.539429] xenvif_kthread_guest_rx+0x14a/0x29c [xen_netback]

Fix that by stopping the loop in case the rx queue becomes empty.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 4.9.324
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.289
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.253
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.56
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.13
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5a071aefd6414af5a20321ab58a0557b81993687
  - https://git.kernel.org/stable/c/7425479d20f9e96f7c3ec8e8a93fe0d7478724cb
  - https://git.kernel.org/stable/c/94e8100678889ab428e68acadf042de723f094b9
  - https://git.kernel.org/stable/c/b99174ac57fe5d8867448c03b23828e63f24cb1c
  - https://git.kernel.org/stable/c/b9c32a6886af79d6e0ad87a7b01800ed079cdd02
  - https://git.kernel.org/stable/c/c0fcceb5f3f1ec197c014fe218c2f28108cacd27
  - https://git.kernel.org/stable/c/d5320c6a27aa975aff740f9cb481dcbde48f4348
  - https://git.kernel.org/stable/c/f0b5c819b062df8bf5f2acf4697e3871cb3722da

------------------------------------------------------------

CVE ID: CVE-2022-49650
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: qcom: bam_dma: fix runtime PM underflow

Commit dbad41e7bb5f ("dmaengine: qcom: bam_dma: check if the runtime pm enabled")
caused unbalanced pm_runtime_get/put() calls when the bam is
controlled remotely. This commit reverts it and just enables pm_runtime
in all cases, the clk_* functions already just nop when the clock is NULL.

Also clean up a bit by removing unnecessary bamclk null checks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0ac9c3dd0d6fe293cd5044cfad10bec27d171e4e
  - https://git.kernel.org/stable/c/2f6ded79068cac8cff41d5d5632564165d98ee12
  - https://git.kernel.org/stable/c/b702a1077b51fcb39507cc3bd39206f539319a96

------------------------------------------------------------

CVE ID: CVE-2022-49651
Description: In the Linux kernel, the following vulnerability has been resolved:

srcu: Tighten cleanup_srcu_struct() GP checks

Currently, cleanup_srcu_struct() checks for a grace period in progress,
but it does not check for a grace period that has not yet started but
which might start at any time.  Such a situation could result in a
use-after-free bug, so this commit adds a check for a grace period that
is needed but not yet started to cleanup_srcu_struct().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.11
References:
  - https://git.kernel.org/stable/c/8ed00760203d8018bee042fbfe8e076579be2c2b
  - https://git.kernel.org/stable/c/e997dda6502eefbc1032d6b0da7b353c53344b07

------------------------------------------------------------

CVE ID: CVE-2022-49652
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: ti: Fix refcount leak in ti_dra7_xbar_route_allocate

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not needed anymore.

Add missing of_node_put() in to fix this.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.5, Last Version (Excluding): 4.9.323
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.288
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.252
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.205
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.54
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.11
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/37147e22cd8dfc0412495cb361708836157a4486
  - https://git.kernel.org/stable/c/3bd66010398871807c1cebacee07d60ded1b1402
  - https://git.kernel.org/stable/c/452b9dfd7aca96befce22634fadb111737f22bbe
  - https://git.kernel.org/stable/c/61b4ef19c346dc21ab1d4f39f5c412e3037b2bdc
  - https://git.kernel.org/stable/c/b31ab132561c7f1b6459039152b8d09e44eb3565
  - https://git.kernel.org/stable/c/b5a817f8d62e9e13280928f3756e54854ae4962e
  - https://git.kernel.org/stable/c/c132fe78ad7b4ce8b5d49a501a15c29d08eeb23a
  - https://git.kernel.org/stable/c/cb9813d7eae917acd34436160a278b8b5d48ca53

------------------------------------------------------------

CVE ID: CVE-2022-49653
Description: In the Linux kernel, the following vulnerability has been resolved:

i2c: piix4: Fix a memory leak in the EFCH MMIO support

The recently added support for EFCH MMIO regions introduced a memory
leak in that code path. The leak is caused by the fact that
release_resource() merely removes the resource from the tree but does
not free its memory. We need to call release_mem_region() instead,
which does free the memory. As a nice side effect, this brings back
some symmetry between the legacy and MMIO paths.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.42, Last Version (Excluding): 5.15.54
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17.10, Last Version (Excluding): 5.18.11
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/8ad59b397f86a4d8014966fdc0552095a0c4fb2b
  - https://git.kernel.org/stable/c/a3263e4cf8265f0c9eb0ed8a9b50f132c7a42e19
  - https://git.kernel.org/stable/c/d2bf1a6480e8d44658a8ac3bdcec081238873212

------------------------------------------------------------

CVE ID: CVE-2022-49654
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: qca8k: reset cpu port on MTU change

It was discovered that the Documentation lacks of a fundamental detail
on how to correctly change the MAX_FRAME_SIZE of the switch.

In fact if the MAX_FRAME_SIZE is changed while the cpu port is on, the
switch panics and cease to send any packet. This cause the mgmt ethernet
system to not receive any packet (the slow fallback still works) and
makes the device not reachable. To recover from this a switch reset is
required.

To correctly handle this, turn off the cpu ports before changing the
MAX_FRAME_SIZE and turn on again after the value is applied.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/188c798f3c2554fa0d7147e9b97baf144b817019
  - https://git.kernel.org/stable/c/1993f5a06736ada59dd54b50dc96755a38796ee5
  - https://git.kernel.org/stable/c/386228c694bf1e7a7688e44412cb33500b0ac585

------------------------------------------------------------

CVE ID: CVE-2022-49655
Description: In the Linux kernel, the following vulnerability has been resolved:

fscache: Fix invalidation/lookup race

If an NFS file is opened for writing and closed, fscache_invalidate() will
be asked to invalidate the file - however, if the cookie is in the
LOOKING_UP state (or the CREATING state), then request to invalidate
doesn't get recorded for fscache_cookie_state_machine() to do something
with.

Fix this by making __fscache_invalidate() set a flag if it sees the cookie
is in the LOOKING_UP state to indicate that we need to go to invalidation.
Note that this requires a count on the n_accesses counter for the state
machine, which that will release when it's done.

fscache_cookie_state_machine() then shifts to the INVALIDATING state if it
sees the flag.

Without this, an nfs file can get corrupted if it gets modified locally and
then read locally as the cache contents may not get updated.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/85e4ea1049c70fb99de5c6057e835d151fb647da
  - https://git.kernel.org/stable/c/b1ae9f617f8a5c848d9205b8e228c6f0d1af754b

------------------------------------------------------------

CVE ID: CVE-2022-49656
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: meson: Fix refcount leak in meson_smp_prepare_cpus

of_find_compatible_node() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.252
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.205
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.54
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.11
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2e1bcd33478ef44e63a45457055060b5fe4118ad
  - https://git.kernel.org/stable/c/34d2cd3fccced12b958b8848e3eff0ee4296764c
  - https://git.kernel.org/stable/c/3cf8ece9113242c10f83c7675ea4f4f67959ee43
  - https://git.kernel.org/stable/c/3d90607e7e6afa89768b0aaa915b58bd2b849276
  - https://git.kernel.org/stable/c/7208101ded1e9dcc52c8f0f8b16474211c871c1a
  - https://git.kernel.org/stable/c/c5fbf4f74c94fd60d5e9bf9f7f8268c3601562ca

------------------------------------------------------------

CVE ID: CVE-2022-49657
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet: fix memory leak in error case

usbnet_write_cmd_async() mixed up which buffers
need to be freed in which error case.

v2: add Fixes tag
v3: fix uninitialized buf pointer
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.8, Last Version (Excluding): 4.9.323
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.288
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.252
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.205
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.54
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.11
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0085da9df3dced730027923a6b48f58e9016af91
  - https://git.kernel.org/stable/c/04894ab34faf40ab72a8a5ab5b404bb0606bbbff
  - https://git.kernel.org/stable/c/3eed421ca5c809da93456f69203d164d5220be3d
  - https://git.kernel.org/stable/c/5269209f54dd8dfd15f9383f3a3a1fe8370764f8
  - https://git.kernel.org/stable/c/b55a21b764c1e182014630fa5486d717484ac58f
  - https://git.kernel.org/stable/c/d5165e657987ff4ba0ace896d4376a3718a9fbc3
  - https://git.kernel.org/stable/c/db89582ff330556188da856e01382ccbf3a5e706
  - https://git.kernel.org/stable/c/e7b4f69946a38209b4a4f660bf0e4cbed94f9b4b

------------------------------------------------------------

CVE ID: CVE-2022-49658
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix insufficient bounds propagation from adjust_scalar_min_max_vals

Kuee reported a corner case where the tnum becomes constant after the call
to __reg_bound_offset(), but the register's bounds are not, that is, its
min bounds are still not equal to the register's max bounds.

This in turn allows to leak pointers through turning a pointer register as
is into an unknown scalar via adjust_ptr_min_max_vals().

Before:

  func#0 @0
  0: R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))
  0: (b7) r0 = 1                        ; R0_w=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0))
  1: (b7) r3 = 0                        ; R3_w=scalar(imm=0,umax=0,var_off=(0x0; 0x0))
  2: (87) r3 = -r3                      ; R3_w=scalar()
  3: (87) r3 = -r3                      ; R3_w=scalar()
  4: (47) r3 |= 32767                   ; R3_w=scalar(smin=-9223372036854743041,umin=32767,var_off=(0x7fff; 0xffffffffffff8000),s32_min=-2147450881)
  5: (75) if r3 s>= 0x0 goto pc+1       ; R3_w=scalar(umin=9223372036854808575,var_off=(0x8000000000007fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)
  6: (95) exit

  from 5 to 7: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))
  7: (d5) if r3 s<= 0x8000 goto pc+1    ; R3=scalar(umin=32769,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)
  8: (95) exit

  from 7 to 9: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=32768,var_off=(0x7fff; 0x8000)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))
  9: (07) r3 += -32767                  ; R3_w=scalar(imm=0,umax=1,var_off=(0x0; 0x0))  <--- [*]
  10: (95) exit

What can be seen here is that R3=scalar(umin=32767,umax=32768,var_off=(0x7fff;
0x8000)) after the operation R3 += -32767 results in a 'malformed' constant, that
is, R3_w=scalar(imm=0,umax=1,var_off=(0x0; 0x0)). Intersecting with var_off has
not been done at that point via __update_reg_bounds(), which would have improved
the umax to be equal to umin.

Refactor the tnum <> min/max bounds information flow into a reg_bounds_sync()
helper and use it consistently everywhere. After the fix, bounds have been
corrected to R3_w=scalar(imm=0,umax=0,var_off=(0x0; 0x0)) and thus the register
is regarded as a 'proper' constant scalar of 0.

After:

  func#0 @0
  0: R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))
  0: (b7) r0 = 1                        ; R0_w=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0))
  1: (b7) r3 = 0                        ; R3_w=scalar(imm=0,umax=0,var_off=(0x0; 0x0))
  2: (87) r3 = -r3                      ; R3_w=scalar()
  3: (87) r3 = -r3                      ; R3_w=scalar()
  4: (47) r3 |= 32767                   ; R3_w=scalar(smin=-9223372036854743041,umin=32767,var_off=(0x7fff; 0xffffffffffff8000),s32_min=-2147450881)
  5: (75) if r3 s>= 0x0 goto pc+1       ; R3_w=scalar(umin=9223372036854808575,var_off=(0x8000000000007fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)
  6: (95) exit

  from 5 to 7: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))
  7: (d5) if r3 s<= 0x8000 goto pc+1    ; R3=scalar(umin=32769,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)
  8: (95) exit

  from 7 to 9: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=32768,var_off=(0x7fff; 0x8000)) R10=fp(off=0
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3844d153a41adea718202c10ae91dc96b37453b5
  - https://git.kernel.org/stable/c/a7de8d436db92bab8b1f44624297c2554a6ac36b
  - https://git.kernel.org/stable/c/b2a28bb36664c94375926cbbb91976242847699d
  - https://git.kernel.org/stable/c/e917be1f83ea14a68b3cf64d3da9968eaf991dae

------------------------------------------------------------

CVE ID: CVE-2022-49659
Description: In the Linux kernel, the following vulnerability has been resolved:

can: m_can: m_can_{read_fifo,echo_tx_event}(): shift timestamp to full 32 bits

In commit 1be37d3b0414 ("can: m_can: fix periph RX path: use
rx-offload to ensure skbs are sent from softirq context") the RX path
for peripheral devices was switched to RX-offload.

Received CAN frames are pushed to RX-offload together with a
timestamp. RX-offload is designed to handle overflows of the timestamp
correctly, if 32 bit timestamps are provided.

The timestamps of m_can core are only 16 bits wide. So this patch
shifts them to full 32 bit before passing them to RX-offload.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2a2914a5bd7f38efe55a8372178146de82e0bce9
  - https://git.kernel.org/stable/c/4c3333693f07313f5f0145a922f14a7d3c0f4f21
  - https://git.kernel.org/stable/c/c7333f79888497bfd75dcd02a94eaf836dd1042c

------------------------------------------------------------

CVE ID: CVE-2022-49661
Description: In the Linux kernel, the following vulnerability has been resolved:

can: gs_usb: gs_usb_open/close(): fix memory leak

The gs_usb driver appears to suffer from a malady common to many USB
CAN adapter drivers in that it performs usb_alloc_coherent() to
allocate a number of USB request blocks (URBs) for RX, and then later
relies on usb_kill_anchored_urbs() to free them, but this doesn't
actually free them. As a result, this may be leaking DMA memory that's
been used by the driver.

This commit is an adaptation of the techniques found in the esd_usb2
driver where a similar design pattern led to a memory leak. It
explicitly frees the RX URBs and their DMA memory via a call to
usb_free_coherent(). Since the RX URBs were allocated in the
gs_can_open(), we remove them in gs_can_close() rather than in the
disconnect function as was done in esd_usb2.

For more information, see the 928150fad41b ("can: esd_usb2: fix memory
leak").
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e60230bc64355c80abe993d1719fdb318094e20
  - https://git.kernel.org/stable/c/2bda24ef95c0311ab93bda00db40486acf30bd0a
  - https://git.kernel.org/stable/c/339fa9f80d3b94177a7a459c6d115d3b56007d5a
  - https://git.kernel.org/stable/c/6f655b5e13fa4b27e915b6c209ac0da74fd75963
  - https://git.kernel.org/stable/c/c1d806bc29ff7ffe0e2a023583c8720ed96cb0b0
  - https://git.kernel.org/stable/c/d0b8e223998866b3e7b2895927d4e9689b0a80d8
  - https://git.kernel.org/stable/c/d91492638b054f4a359621ef216242be5973ed6b
  - https://git.kernel.org/stable/c/ffb6cc6601ec7c8fa963dcf76025df4a02f2cf5c

------------------------------------------------------------

CVE ID: CVE-2022-49662
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: fix lockdep splat in in6_dump_addrs()

As reported by syzbot, we should not use rcu_dereference()
when rcu_read_lock() is not held.

WARNING: suspicious RCU usage
5.19.0-rc2-syzkaller #0 Not tainted

net/ipv6/addrconf.c:5175 suspicious rcu_dereference_check() usage!

other info that might help us debug this:

rcu_scheduler_active = 2, debug_locks = 1
1 lock held by syz-executor326/3617:
 #0: ffffffff8d5848e8 (rtnl_mutex){+.+.}-{3:3}, at: netlink_dump+0xae/0xc20 net/netlink/af_netlink.c:2223

stack backtrace:
CPU: 0 PID: 3617 Comm: syz-executor326 Not tainted 5.19.0-rc2-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
 in6_dump_addrs+0x12d1/0x1790 net/ipv6/addrconf.c:5175
 inet6_dump_addr+0x9c1/0xb50 net/ipv6/addrconf.c:5300
 netlink_dump+0x541/0xc20 net/netlink/af_netlink.c:2275
 __netlink_dump_start+0x647/0x900 net/netlink/af_netlink.c:2380
 netlink_dump_start include/linux/netlink.h:245 [inline]
 rtnetlink_rcv_msg+0x73e/0xc90 net/core/rtnetlink.c:6046
 netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2501
 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
 netlink_unicast+0x543/0x7f0 net/netlink/af_netlink.c:1345
 netlink_sendmsg+0x917/0xe10 net/netlink/af_netlink.c:1921
 sock_sendmsg_nosec net/socket.c:714 [inline]
 sock_sendmsg+0xcf/0x120 net/socket.c:734
 ____sys_sendmsg+0x6eb/0x810 net/socket.c:2492
 ___sys_sendmsg+0xf3/0x170 net/socket.c:2546
 __sys_sendmsg net/socket.c:2575 [inline]
 __do_sys_sendmsg net/socket.c:2584 [inline]
 __se_sys_sendmsg net/socket.c:2582 [inline]
 __x64_sys_sendmsg+0x132/0x220 net/socket.c:2582
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2930ee1a166df0e12fe9fec4b79cc3dc9634ae45
  - https://git.kernel.org/stable/c/4e43e64d0f1332fcc503babad4dc31aead7131ca
  - https://git.kernel.org/stable/c/b39fda51c32dd879451e0119881f31493bf83283

------------------------------------------------------------

CVE ID: CVE-2022-49663
Description: In the Linux kernel, the following vulnerability has been resolved:

tunnels: do not assume mac header is set in skb_tunnel_check_pmtu()

Recently added debug in commit f9aefd6b2aa3 ("net: warn if mac header
was not set") caught a bug in skb_tunnel_check_pmtu(), as shown
in this syzbot report [1].

In ndo_start_xmit() paths, there is really no need to use skb->mac_header,
because skb->data is supposed to point at it.

[1] WARNING: CPU: 1 PID: 8604 at include/linux/skbuff.h:2784 skb_mac_header_len include/linux/skbuff.h:2784 [inline]
WARNING: CPU: 1 PID: 8604 at include/linux/skbuff.h:2784 skb_tunnel_check_pmtu+0x5de/0x2f90 net/ipv4/ip_tunnel_core.c:413
Modules linked in:
CPU: 1 PID: 8604 Comm: syz-executor.3 Not tainted 5.19.0-rc2-syzkaller-00443-g8720bd951b8e #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:skb_mac_header_len include/linux/skbuff.h:2784 [inline]
RIP: 0010:skb_tunnel_check_pmtu+0x5de/0x2f90 net/ipv4/ip_tunnel_core.c:413
Code: 00 00 00 00 fc ff df 4c 89 fa 48 c1 ea 03 80 3c 02 00 0f 84 b9 fe ff ff 4c 89 ff e8 7c 0f d7 f9 e9 ac fe ff ff e8 c2 13 8a f9 <0f> 0b e9 28 fc ff ff e8 b6 13 8a f9 48 8b 54 24 70 48 b8 00 00 00
RSP: 0018:ffffc90002e4f520 EFLAGS: 00010212
RAX: 0000000000000324 RBX: ffff88804d5fd500 RCX: ffffc90005b52000
RDX: 0000000000040000 RSI: ffffffff87f05e3e RDI: 0000000000000003
RBP: ffffc90002e4f650 R08: 0000000000000003 R09: 000000000000ffff
R10: 000000000000ffff R11: 0000000000000000 R12: 000000000000ffff
R13: 0000000000000000 R14: 000000000000ffcd R15: 000000000000001f
FS: 00007f3babba9700(0000) GS:ffff8880b9b00000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000020000080 CR3: 0000000075319000 CR4: 00000000003506e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
geneve_xmit_skb drivers/net/geneve.c:927 [inline]
geneve_xmit+0xcf8/0x35d0 drivers/net/geneve.c:1107
__netdev_start_xmit include/linux/netdevice.h:4805 [inline]
netdev_start_xmit include/linux/netdevice.h:4819 [inline]
__dev_direct_xmit+0x500/0x730 net/core/dev.c:4309
dev_direct_xmit include/linux/netdevice.h:3007 [inline]
packet_direct_xmit+0x1b8/0x2c0 net/packet/af_packet.c:282
packet_snd net/packet/af_packet.c:3073 [inline]
packet_sendmsg+0x21f4/0x55d0 net/packet/af_packet.c:3104
sock_sendmsg_nosec net/socket.c:714 [inline]
sock_sendmsg+0xcf/0x120 net/socket.c:734
____sys_sendmsg+0x6eb/0x810 net/socket.c:2489
___sys_sendmsg+0xf3/0x170 net/socket.c:2543
__sys_sendmsg net/socket.c:2572 [inline]
__do_sys_sendmsg net/socket.c:2581 [inline]
__se_sys_sendmsg net/socket.c:2579 [inline]
__x64_sys_sendmsg+0x132/0x220 net/socket.c:2579
do_syscall_x64 arch/x86/entry/common.c:50 [inline]
do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
entry_SYSCALL_64_after_hwframe+0x46/0xb0
RIP: 0033:0x7f3baaa89109
Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f3babba9168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
RAX: ffffffffffffffda RBX: 00007f3baab9bf60 RCX: 00007f3baaa89109
RDX: 0000000000000000 RSI: 0000000020000a00 RDI: 0000000000000003
RBP: 00007f3baaae305d R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
R13: 00007ffe74f2543f R14: 00007f3babba9300 R15: 0000000000022000
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/32dcf62efa0003f92a976aea0c57f118e689de8b
  - https://git.kernel.org/stable/c/59c51c3b545128a92ebfb6dbae990d3abee110e7
  - https://git.kernel.org/stable/c/674a641e5b67e16ba3112eacd680ff87b38539de
  - https://git.kernel.org/stable/c/853a7614880231747040cada91d2b8d2e995c51a

------------------------------------------------------------

CVE ID: CVE-2022-49664
Description: In the Linux kernel, the following vulnerability has been resolved:

tipc: move bc link creation back to tipc_node_create

Shuang Li reported a NULL pointer dereference crash:

  [] BUG: kernel NULL pointer dereference, address: 0000000000000068
  [] RIP: 0010:tipc_link_is_up+0x5/0x10 [tipc]
  [] Call Trace:
  []  <IRQ>
  []  tipc_bcast_rcv+0xa2/0x190 [tipc]
  []  tipc_node_bc_rcv+0x8b/0x200 [tipc]
  []  tipc_rcv+0x3af/0x5b0 [tipc]
  []  tipc_udp_recv+0xc7/0x1e0 [tipc]

It was caused by the 'l' passed into tipc_bcast_rcv() is NULL. When it
creates a node in tipc_node_check_dest(), after inserting the new node
into hashtable in tipc_node_create(), it creates the bc link. However,
there is a gap between this insert and bc link creation, a bc packet
may come in and get the node from the hashtable then try to dereference
its bc link, which is NULL.

This patch is to fix it by moving the bc link creation before inserting
into the hashtable.

Note that for a preliminary node becoming "real", the bc link creation
should also be called before it's rehashed, as we don't create it for
preliminary nodes.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.287, Last Version (Excluding): 5.10.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.53
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.10
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/35fcb2ba35b4d9b592b558c3bcc6e0d90e213588
  - https://git.kernel.org/stable/c/456bc338871c4a52117dd5ef29cce3745456d248
  - https://git.kernel.org/stable/c/cb8092d70a6f5f01ec1490fce4d35efed3ed996c
  - https://git.kernel.org/stable/c/e52910e671f58c619e33dac476b11b35e2d3ab6f

------------------------------------------------------------

CVE ID: CVE-2022-49665
Description: In the Linux kernel, the following vulnerability has been resolved:

platform/x86: thinkpad_acpi: Fix a memory leak of EFCH MMIO resource

Unlike release_mem_region(), a call to release_resource() does not
free the resource, so it has to be freed explicitly to avoid a memory
leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3884bf75fa044c73e843d95dd71a424e80ebb095
  - https://git.kernel.org/stable/c/d2f33f0c3ad7b0d5262d9b986f1353265fad7a08

------------------------------------------------------------

CVE ID: CVE-2022-49666
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/memhotplug: Add add_pages override for PPC

With commit ffa0b64e3be5 ("powerpc: Fix virt_addr_valid() for 64-bit Book3E & 32-bit")
the kernel now validate the addr against high_memory value. This results
in the below BUG_ON with dax pfns.

[  635.798741][T26531] kernel BUG at mm/page_alloc.c:5521!
1:mon> e
cpu 0x1: Vector: 700 (Program Check) at [c000000007287630]
    pc: c00000000055ed48: free_pages.part.0+0x48/0x110
    lr: c00000000053ca70: tlb_finish_mmu+0x80/0xd0
    sp: c0000000072878d0
   msr: 800000000282b033
  current = 0xc00000000afabe00
  paca    = 0xc00000037ffff300   irqmask: 0x03   irq_happened: 0x05
    pid   = 26531, comm = 50-landscape-sy
kernel BUG at :5521!
Linux version 5.19.0-rc3-14659-g4ec05be7c2e1 (kvaneesh@ltc-boston8) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #625 SMP Thu Jun 23 00:35:43 CDT 2022
1:mon> t
[link register   ] c00000000053ca70 tlb_finish_mmu+0x80/0xd0
[c0000000072878d0] c00000000053ca54 tlb_finish_mmu+0x64/0xd0 (unreliable)
[c000000007287900] c000000000539424 exit_mmap+0xe4/0x2a0
[c0000000072879e0] c00000000019fc1c mmput+0xcc/0x210
[c000000007287a20] c000000000629230 begin_new_exec+0x5e0/0xf40
[c000000007287ae0] c00000000070b3cc load_elf_binary+0x3ac/0x1e00
[c000000007287c10] c000000000627af0 bprm_execve+0x3b0/0xaf0
[c000000007287cd0] c000000000628414 do_execveat_common.isra.0+0x1e4/0x310
[c000000007287d80] c00000000062858c sys_execve+0x4c/0x60
[c000000007287db0] c00000000002c1b0 system_call_exception+0x160/0x2c0
[c000000007287e10] c00000000000c53c system_call_common+0xec/0x250

The fix is to make sure we update high_memory on memory hotplug.
This is similar to what x86 does in commit 3072e413e305 ("mm/memory_hotplug: introduce add_pages")
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/84d146fd35a01b08e9515041de60f0f915a417d5
  - https://git.kernel.org/stable/c/89296ac435e2cf8a5101f7fab8f0c7b754b92052
  - https://git.kernel.org/stable/c/ac790d09885d36143076e7e02825c541e8eee899

------------------------------------------------------------

CVE ID: CVE-2022-49667
Description: In the Linux kernel, the following vulnerability has been resolved:

net: bonding: fix use-after-free after 802.3ad slave unbind

commit 0622cab0341c ("bonding: fix 802.3ad aggregator reselection"),
resolve case, when there is several aggregation groups in the same bond.
bond_3ad_unbind_slave will invalidate (clear) aggregator when
__agg_active_ports return zero. So, ad_clear_agg can be executed even, when
num_of_ports!=0. Than bond_3ad_unbind_slave can be executed again for,
previously cleared aggregator. NOTE: at this time bond_3ad_unbind_slave
will not update slave ports list, because lag_ports==NULL. So, here we
got slave ports, pointing to freed aggregator memory.

Fix with checking actual number of ports in group (as was before
commit 0622cab0341c ("bonding: fix 802.3ad aggregator reselection") ),
before ad_clear_agg().

The KASAN logs are as follows:

[  767.617392] ==================================================================
[  767.630776] BUG: KASAN: use-after-free in bond_3ad_state_machine_handler+0x13dc/0x1470
[  767.638764] Read of size 2 at addr ffff00011ba9d430 by task kworker/u8:7/767
[  767.647361] CPU: 3 PID: 767 Comm: kworker/u8:7 Tainted: G           O 5.15.11 #15
[  767.655329] Hardware name: DNI AmazonGo1 A7040 board (DT)
[  767.660760] Workqueue: lacp_1 bond_3ad_state_machine_handler
[  767.666468] Call trace:
[  767.668930]  dump_backtrace+0x0/0x2d0
[  767.672625]  show_stack+0x24/0x30
[  767.675965]  dump_stack_lvl+0x68/0x84
[  767.679659]  print_address_description.constprop.0+0x74/0x2b8
[  767.685451]  kasan_report+0x1f0/0x260
[  767.689148]  __asan_load2+0x94/0xd0
[  767.692667]  bond_3ad_state_machine_handler+0x13dc/0x1470
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.7, Last Version (Excluding): 4.9.322
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.287
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.251
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.204
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.53
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.10
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/050133e1aa2cb49bb17be847d48a4431598ef562
  - https://git.kernel.org/stable/c/2765749def4765c5052a4c66445cf4c96fcccdbc
  - https://git.kernel.org/stable/c/63b2fe509f69b90168a75e04e14573dccf7984e6
  - https://git.kernel.org/stable/c/893825289ba840afd86bfffcb6f7f363c73efff8
  - https://git.kernel.org/stable/c/a853b7a3a9fd1d74a4ccdd9cd73512b7dace2f1e
  - https://git.kernel.org/stable/c/b90ac60303063a43e17dd4aec159067599d255e6
  - https://git.kernel.org/stable/c/ef0af7d08d26c5333ff4944a559279464edf6f15
  - https://git.kernel.org/stable/c/f162f7c348fa2a5555bafdb5cc890b89b221e69c

------------------------------------------------------------

CVE ID: CVE-2022-49668
Description: In the Linux kernel, the following vulnerability has been resolved:

PM / devfreq: exynos-ppmu: Fix refcount leak in of_get_devfreq_events

of_get_child_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
This function only calls of_node_put() in normal path,
missing it in error paths.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 5.4.204
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.53
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.10
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/01121e39ef537289926ae6f5374dce92c796d863
  - https://git.kernel.org/stable/c/194781229d4cbc804b8ded13156eb8addce87d6c
  - https://git.kernel.org/stable/c/bdecd912e99acfd61507f1720d3f4eed1b3418d8
  - https://git.kernel.org/stable/c/e65027fdebbacd40595e96ef7b5d2418f71bddf2
  - https://git.kernel.org/stable/c/f44b799603a9b5d2e375b0b2d54dd0b791eddfc2

------------------------------------------------------------

CVE ID: CVE-2022-49669
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: fix race on unaccepted mptcp sockets

When the listener socket owning the relevant request is closed,
it frees the unaccepted subflows and that causes later deletion
of the paired MPTCP sockets.

The mptcp socket's worker can run in the time interval between such delete
operations. When that happens, any access to msk->first will cause an UaF
access, as the subflow cleanup did not cleared such field in the mptcp
socket.

Address the issue explicitly traversing the listener socket accept
queue at close time and performing the needed cleanup on the pending
msk.

Note that the locking is a bit tricky, as we need to acquire the msk
socket lock, while still owning the subflow socket one.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 5.18.10
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6aeed9045071f2252ff4e98fc13d1e304f33e5b0
  - https://git.kernel.org/stable/c/a8a3e95c74e48c2c9b07b81fafda9122993f2e12

------------------------------------------------------------

CVE ID: CVE-2022-49670
Description: In the Linux kernel, the following vulnerability has been resolved:

linux/dim: Fix divide by 0 in RDMA DIM

Fix a divide 0 error in rdma_dim_stats_compare() when prev->cpe_ratio ==
0.

CallTrace:
  Hardware name: H3C R4900 G3/RS33M2C9S, BIOS 2.00.37P21 03/12/2020
  task: ffff880194b78000 task.stack: ffffc90006714000
  RIP: 0010:backport_rdma_dim+0x10e/0x240 [mlx_compat]
  RSP: 0018:ffff880c10e83ec0 EFLAGS: 00010202
  RAX: 0000000000002710 RBX: ffff88096cd7f780 RCX: 0000000000000064
  RDX: 0000000000000000 RSI: 0000000000000002 RDI: 0000000000000001
  RBP: 0000000000000001 R08: 0000000000000000 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000000000 R12: 000000001d7c6c09
  R13: ffff88096cd7f780 R14: ffff880b174fe800 R15: 0000000000000000
  FS:  0000000000000000(0000) GS:ffff880c10e80000(0000)
  knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00000000a0965b00 CR3: 000000000200a003 CR4: 00000000007606e0
  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
  PKRU: 55555554
  Call Trace:
   <IRQ>
   ib_poll_handler+0x43/0x80 [ib_core]
   irq_poll_softirq+0xae/0x110
   __do_softirq+0xd1/0x28c
   irq_exit+0xde/0xf0
   do_IRQ+0x54/0xe0
   common_interrupt+0x8f/0x8f
   </IRQ>
   ? cpuidle_enter_state+0xd9/0x2a0
   ? cpuidle_enter_state+0xc7/0x2a0
   ? do_idle+0x170/0x1d0
   ? cpu_startup_entry+0x6f/0x80
   ? start_secondary+0x1b9/0x210
   ? secondary_startup_64+0xa5/0xb0
  Code: 0f 87 e1 00 00 00 8b 4c 24 14 44 8b 43 14 89 c8 4d 63 c8 44 29 c0 99 31 d0 29 d0 31 d2 48 98 48 8d 04 80 48 8d 04 80 48 c1 e0 02 <49> f7 f1 48 83 f8 0a 0f 86 c1 00 00 00 44 39 c1 7f 10 48 89 df
  RIP: backport_rdma_dim+0x10e/0x240 [mlx_compat] RSP: ffff880c10e83ec0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.3, Last Version (Excluding): 5.4.204
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.53
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.10
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0b6e0eb5c45e79e9095de2498cc0ca5ec563fc5e
  - https://git.kernel.org/stable/c/0fe3dbbefb74a8575f61d7801b08dbc50523d60d
  - https://git.kernel.org/stable/c/5af106f8e072aebd88b95e164a08fa320651a99a
  - https://git.kernel.org/stable/c/7c1963391af51ee322378d1b2849c60e9037f069
  - https://git.kernel.org/stable/c/fae2a9fb1eaf348ad8732f90d42ebbb971bd7e95

------------------------------------------------------------

CVE ID: CVE-2022-49671
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/cm: Fix memory leak in ib_cm_insert_listen

cm_alloc_id_priv() allocates resource for the cm_id_priv. When
cm_init_listen() fails it doesn't free it, leading to memory leak.

Add the missing error unwind.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.53
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.10
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2990f223ffa7bb25422956b9f79f9176a5b38346
  - https://git.kernel.org/stable/c/2febf09a8a8ae4accf908f043f1bab1421056568
  - https://git.kernel.org/stable/c/889000874c1204e47c7f2a4945db262a47e7efc9
  - https://git.kernel.org/stable/c/b0cab8b517aeaf2592c3479294f934209c41a26f

------------------------------------------------------------

CVE ID: CVE-2022-49672
Description: In the Linux kernel, the following vulnerability has been resolved:

net: tun: unlink NAPI from device on destruction

Syzbot found a race between tun file and device destruction.
NAPIs live in struct tun_file which can get destroyed before
the netdev so we have to del them explicitly. The current
code is missing deleting the NAPI if the queue was detached
first.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3b9bc84d311104906d2b4995a9a02d7b7ddab2db
  - https://git.kernel.org/stable/c/8145f77d38de4f88b8a69e1463f5c09ba189d77c
  - https://git.kernel.org/stable/c/82e729aee59acefe135fceffadcbc5b86dd4f1b9
  - https://git.kernel.org/stable/c/8661d4b8faa2f7ee7a559969c0a7c57f077b1728
  - https://git.kernel.org/stable/c/a8cf919022373c97a84fe596bbea544f909c485d
  - https://git.kernel.org/stable/c/bec1be0a745ab420718217e3e0d9542a75108989

------------------------------------------------------------

CVE ID: CVE-2022-49673
Description: In the Linux kernel, the following vulnerability has been resolved:

dm raid: fix KASAN warning in raid5_add_disks

There's a KASAN warning in raid5_add_disk when running the LVM testsuite.
The warning happens in the test
lvconvert-raid-reshape-linear_to_raid6-single-type.sh. We fix the warning
by verifying that rdev->saved_raid_disk is within limits.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/02cffb1921edadd9b6e4eee7ada4a5213e8ba12e
  - https://git.kernel.org/stable/c/2d4e7c9898c20fb3d3f55381cab601761aab7d64
  - https://git.kernel.org/stable/c/2fb2928728038280bd925ce2aafb4997e9d47ee9
  - https://git.kernel.org/stable/c/3553a69bb52be2deba61d0ca064c41aee842bb35
  - https://git.kernel.org/stable/c/617b365872a247480e9dcd50a32c8d1806b21861
  - https://git.kernel.org/stable/c/d5b06039b195d4b6f94f5d345b1e4ac1975a9832
  - https://git.kernel.org/stable/c/d8bca518d5272fe349e0a722fdb9e3acb661f3f0
  - https://git.kernel.org/stable/c/f157bd9cf377a947fdb7035e69466b6ecdc17c17

------------------------------------------------------------

CVE ID: CVE-2022-49674
Description: In the Linux kernel, the following vulnerability has been resolved:

dm raid: fix accesses beyond end of raid member array

On dm-raid table load (using raid_ctr), dm-raid allocates an array
rs->devs[rs->raid_disks] for the raid device members. rs->raid_disks
is defined by the number of raid metadata and image tupples passed
into the target's constructor.

In the case of RAID layout changes being requested, that number can be
different from the current number of members for existing raid sets as
defined in their superblocks. Example RAID layout changes include:
- raid1 legs being added/removed
- raid4/5/6/10 number of stripes changed (stripe reshaping)
- takeover to higher raid level (e.g. raid5 -> raid6)

When accessing array members, rs->raid_disks must be used in control
loops instead of the potentially larger value in rs->md.raid_disks.
Otherwise it will cause memory access beyond the end of the rs->devs
array.

Fix this by changing code that is prone to out-of-bounds access.
Also fix validate_raid_redundancy() to validate all devices that are
added. Also, use braces to help clean up raid_iterate_devices().

The out-of-bounds memory accesses was discovered using KASAN.

This commit was verified to pass all LVM2 RAID tests (with KASAN
enabled).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/332bd0778775d0cf105c4b9e03e460b590749916
  - https://git.kernel.org/stable/c/5e161a8826b63c0b8b43e4a7fad1f956780f42ab
  - https://git.kernel.org/stable/c/6352b2f4d8e95ec0ae576d7705435d64cfa29503
  - https://git.kernel.org/stable/c/90de15357504c8097ab29769dc6852e16281e9e8
  - https://git.kernel.org/stable/c/9bf2b0757b04c78dc5d6e3a198acca98457b32a1
  - https://git.kernel.org/stable/c/bcff98500ea3b4e7615ec31d2bdd326bc1ef5134
  - https://git.kernel.org/stable/c/df1a5ab0dd0775f2ea101c71f2addbc4c0ea0f85

------------------------------------------------------------

CVE ID: CVE-2022-49675
Description: In the Linux kernel, the following vulnerability has been resolved:

tick/nohz: unexport __init-annotated tick_nohz_full_setup()

EXPORT_SYMBOL and __init is a bad combination because the .init.text
section is freed up after the initialization. Hence, modules cannot
use symbols annotated __init. The access to a freed symbol may end up
with kernel panic.

modpost used to detect it, but it had been broken for a decade.

Commit 28438794aba4 ("modpost: fix section mismatch check for exported
init/exit sections") fixed it so modpost started to warn it again, then
this showed up:

    MODPOST vmlinux.symvers
  WARNING: modpost: vmlinux.o(___ksymtab_gpl+tick_nohz_full_setup+0x0): Section mismatch in reference from the variable __ksymtab_tick_nohz_full_setup to the function .init.text:tick_nohz_full_setup()
  The symbol tick_nohz_full_setup is exported and annotated __init
  Fix this by removing the __init annotation of tick_nohz_full_setup or drop the export.

Drop the export because tick_nohz_full_setup() is only called from the
built-in code in kernel/sched/isolation.c.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2390095113e98fc52fffe35c5206d30d9efe3f78
  - https://git.kernel.org/stable/c/c4ff3ffe0138234774602152fe67e3a898c615c6
  - https://git.kernel.org/stable/c/ea32b27e2f8c58c92bff5ecba7fcf64b97707089
  - https://git.kernel.org/stable/c/f4a80ec8c51d68be4b7a7830c510f75080c5e417

------------------------------------------------------------

CVE ID: CVE-2022-49676
Description: In the Linux kernel, the following vulnerability has been resolved:

memory: samsung: exynos5422-dmc: Fix refcount leak in of_get_dram_timings

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
This function doesn't call of_node_put() in some error paths.
To unify the structure, Add put_node label and goto it on errors.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1332661e09304b7b8e84e5edc11811ba08d12abe
  - https://git.kernel.org/stable/c/889aad2203e09eed2071ca8985c25e9d6aea5735
  - https://git.kernel.org/stable/c/bb2a481778c60f912c363e271ae46b55ff8132db
  - https://git.kernel.org/stable/c/cde4480b5ab06195b9164184b0c02ced71e601b4

------------------------------------------------------------

CVE ID: CVE-2022-49677
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: cns3xxx: Fix refcount leak in cns3xxx_init

of_find_compatible_node() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.10, Last Version (Excluding): 4.9.321
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.286
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1ba904b6b16e08de5aed7c1349838d9cd0d178c5
  - https://git.kernel.org/stable/c/45bebbc8cea7d586a6216dc62814bdb380b9b29b
  - https://git.kernel.org/stable/c/68d4303bf59662b64bd555e2aa0518282d20aa4f
  - https://git.kernel.org/stable/c/b8b84e01ca94e2e1f5492353e9c24dab520b2e5b
  - https://git.kernel.org/stable/c/c980392af1473d6d5662f70d8089c8e6d85144a4
  - https://git.kernel.org/stable/c/d1359e4129ad43e43972a28838b87291c51de23d
  - https://git.kernel.org/stable/c/da3ee7cd2f15922ad88a7ca6deee2eafdc7cd214
  - https://git.kernel.org/stable/c/dc5170aae24e04068fd5ea125d06c0ab51f48a27

------------------------------------------------------------

CVE ID: CVE-2022-49678
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: bcm: brcmstb: pm: pm-arm: Fix refcount leak in brcmstb_pm_probe

of_find_matching_node() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.

In brcmstb_init_sram, it pass dn to of_address_to_resource(),
of_address_to_resource() will call of_find_device_by_node() to take
reference, so we should release the reference returned by
of_find_matching_node().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/10ba9d499a9fd82ed40897e734ba19870a879407
  - https://git.kernel.org/stable/c/30bbfeb480ae8b5ee43199d72417b232590440c2
  - https://git.kernel.org/stable/c/37d838de369b07b596c19ff3662bf0293fdb09ee
  - https://git.kernel.org/stable/c/4f5877bdf7b593e988f1924f4c3df6523f80b39c
  - https://git.kernel.org/stable/c/734a4d15142bb4c8ecad2d8ec70d7564e78ae34d
  - https://git.kernel.org/stable/c/dcafd5463d8f20c4f90ddc138a5738adb99f74c8

------------------------------------------------------------

CVE ID: CVE-2022-49679
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: Fix refcount leak in axxia_boot_secondary

of_find_compatible_node() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16, Last Version (Excluding): 4.9.321
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.286
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/29ca9c4efacccdc15104a8d4bf10b5183fc92840
  - https://git.kernel.org/stable/c/3c19fe3f04f4f4e7a2b722c2fd3c98356fc1d72b
  - https://git.kernel.org/stable/c/44a5b3a073e5aaa5720929dba95b2725eb32bb65
  - https://git.kernel.org/stable/c/4d9c60e868f7cf8e09956e7d5bb44d807d712699
  - https://git.kernel.org/stable/c/71e12e5b02674459a24f16e965255d63b31fe049
  - https://git.kernel.org/stable/c/7c7ff68daa93d8c4cdea482da4f2429c0398fcde
  - https://git.kernel.org/stable/c/a9b76c232a1ce4cbf27862097f7eb634dcc779eb
  - https://git.kernel.org/stable/c/b385cb59aac8d61c29bc72ebf3d19a536914af96

------------------------------------------------------------

CVE ID: CVE-2022-49680
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: exynos: Fix refcount leak in exynos_map_pmu

of_find_matching_node() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
of_node_put() checks null pointer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.17, Last Version (Excluding): 4.9.321
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.286
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/31d09571bb071c20f6bdc0bb7ac1ef8dd2987c04
  - https://git.kernel.org/stable/c/545ae5cbae839ce39bfe09828e413f1c916082de
  - https://git.kernel.org/stable/c/68f28d52e6cbab8dcfa249cac4356d1d0573e868
  - https://git.kernel.org/stable/c/7571bcecf01b69f0d3ec60ca41ce5d4c75411a4a
  - https://git.kernel.org/stable/c/c4c79525042a4a7df96b73477feaf232fe44ae81
  - https://git.kernel.org/stable/c/d23f76018e17618559da9eea179d137362023f95
  - https://git.kernel.org/stable/c/f9b77a52937582a5b99a5a07e4ef1e2f48f87347
  - https://git.kernel.org/stable/c/fc354856e9fad9cd36e2ad28f9da70716025055a

------------------------------------------------------------

CVE ID: CVE-2022-49681
Description: In the Linux kernel, the following vulnerability has been resolved:

xtensa: xtfpga: Fix refcount leak bug in setup

In machine_setup(), of_find_compatible_node() will return a node
pointer with refcount incremented. We should use of_node_put() when
it is not used anymore.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.321
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.286
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0162451723178602c37f0555d235dfa17e486112
  - https://git.kernel.org/stable/c/0715d0e60052662c3f225342062f174dd721d1c7
  - https://git.kernel.org/stable/c/173940b3ae40114d4179c251a98ee039dc9cd5b3
  - https://git.kernel.org/stable/c/35d7e961be68732eb3acaeba81fb81ca16eafd05
  - https://git.kernel.org/stable/c/6c0839cf1b9e1b3c88da6af76794583cbfae8da3
  - https://git.kernel.org/stable/c/9b30c5c8884eda3f541229899671cebbad15979b
  - https://git.kernel.org/stable/c/a52972ee706b438302eb0350e61f378eb191e3d1
  - https://git.kernel.org/stable/c/b12d5c52f073a0420622aaf2f21b615cce8b36cc

------------------------------------------------------------

CVE ID: CVE-2022-49682
Description: In the Linux kernel, the following vulnerability has been resolved:

xtensa: Fix refcount leak bug in time.c

In calibrate_ccount(), of_find_compatible_node() will return a node
pointer with refcount incremented. We should use of_node_put() when
it is not used anymore.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.321
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.286
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0dcc1dd8a5dd9240639f1051dfaa2dffc9fbbde5
  - https://git.kernel.org/stable/c/0e403a383c14b63c86bd9df085b7e573e9caee64
  - https://git.kernel.org/stable/c/3e5eb904d9ba657308fc75a5de434b0e58dcb8d7
  - https://git.kernel.org/stable/c/7de4502af68f4f3932f450157f5483eb7b33cb74
  - https://git.kernel.org/stable/c/a0117dc956429f2ede17b323046e1968d1849150
  - https://git.kernel.org/stable/c/af0ff2da01521144bc11194f4c26485d7c9cee73
  - https://git.kernel.org/stable/c/e5234a9d64a976abd134a14710dcd5188158a7c5
  - https://git.kernel.org/stable/c/f1eaf4ba5372ad111f687a80c67e270708e14c23

------------------------------------------------------------

CVE ID: CVE-2022-49683
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: adc: adi-axi-adc: Fix refcount leak in adi_axi_adc_attach_client

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/501652a2ad5450b4908e1f204ce75b2414c305b7
  - https://git.kernel.org/stable/c/5eaa84e1605035a90a64d25b6cba79e89d188175
  - https://git.kernel.org/stable/c/ab7bf025cee89db73c649216ddd2bc589c3d3862
  - https://git.kernel.org/stable/c/ada7b0c0dedafd7d059115adf49e48acba3153a8

------------------------------------------------------------

CVE ID: CVE-2022-49684
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: adc: aspeed: Fix refcount leak in aspeed_adc_set_trim_data

of_find_node_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when done.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/8a2b6b5687984a010ed094b4f436a2f091987758
  - https://git.kernel.org/stable/c/9664491db50a84be92696c8fad2c3b49a7a5f36f

------------------------------------------------------------

CVE ID: CVE-2022-49685
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: trigger: sysfs: fix use-after-free on remove

Ensure that the irq_work has completed before the trigger is freed.

 ==================================================================
 BUG: KASAN: use-after-free in irq_work_run_list
 Read of size 8 at addr 0000000064702248 by task python3/25

 Call Trace:
  irq_work_run_list
  irq_work_tick
  update_process_times
  tick_sched_handle
  tick_sched_timer
  __hrtimer_run_queues
  hrtimer_interrupt

 Allocated by task 25:
  kmem_cache_alloc_trace
  iio_sysfs_trig_add
  dev_attr_store
  sysfs_kf_write
  kernfs_fop_write_iter
  new_sync_write
  vfs_write
  ksys_write
  sys_write

 Freed by task 25:
  kfree
  iio_sysfs_trig_remove
  dev_attr_store
  sysfs_kf_write
  kernfs_fop_write_iter
  new_sync_write
  vfs_write
  ksys_write
  sys_write

 ==================================================================
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.7, Last Version (Excluding): 4.9.321
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.286
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.250
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/31ff3309b47d98313c61b8301bf595820cc3cc33
  - https://git.kernel.org/stable/c/4687c3f955240ca2a576bdc3f742d4d915b6272d
  - https://git.kernel.org/stable/c/4ef1e521be610b720daeb7cf899fedc7db0274c4
  - https://git.kernel.org/stable/c/5e39397d60dacc7f5d81d442c1c958eaaaf31128
  - https://git.kernel.org/stable/c/78601726d4a59a291acc5a52da1d3a0a6831e4e8
  - https://git.kernel.org/stable/c/b07a30a774b3c3e584a68dc91779c68ea2da4813
  - https://git.kernel.org/stable/c/d6111e7bdb8ec27eb43d01c4cd4ff1620a75f7f2
  - https://git.kernel.org/stable/c/fd5d8fb298a2866c337da635c79d63c3afabcaf7

------------------------------------------------------------

CVE ID: CVE-2022-49686
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: uvc: fix list double add in uvcg_video_pump

A panic can occur if the endpoint becomes disabled and the
uvcg_video_pump adds the request back to the req_free list after it has
already been queued to the endpoint. The endpoint complete will add the
request back to the req_free list. Invalidate the local request handle
once it's been queued.

<6>[  246.796704][T13726] configfs-gadget gadget: uvc: uvc_function_set_alt(1, 0)
<3>[  246.797078][   T26] list_add double add: new=ffffff878bee5c40, prev=ffffff878bee5c40, next=ffffff878b0f0a90.
<6>[  246.797213][   T26] ------------[ cut here ]------------
<2>[  246.797224][   T26] kernel BUG at lib/list_debug.c:31!
<6>[  246.807073][   T26] Call trace:
<6>[  246.807180][   T26]  uvcg_video_pump+0x364/0x38c
<6>[  246.807366][   T26]  process_one_work+0x2a4/0x544
<6>[  246.807394][   T26]  worker_thread+0x350/0x784
<6>[  246.807442][   T26]  kthread+0x2ac/0x320
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/96163f835e65f8c9897487fac965819f0651d671
  - https://git.kernel.org/stable/c/d95ac8b920de1d39525fadc408ce675697626ca6

------------------------------------------------------------

CVE ID: CVE-2022-49687
Description: In the Linux kernel, the following vulnerability has been resolved:

virtio_net: fix xdp_rxq_info bug after suspend/resume

The following sequence currently causes a driver bug warning
when using virtio_net:

  # ip link set eth0 up
  # echo mem > /sys/power/state (or e.g. # rtcwake -s 10 -m mem)
  <resume>
  # ip link set eth0 down

  Missing register, driver bug
  WARNING: CPU: 0 PID: 375 at net/core/xdp.c:138 xdp_rxq_info_unreg+0x58/0x60
  Call trace:
   xdp_rxq_info_unreg+0x58/0x60
   virtnet_close+0x58/0xac
   __dev_close_many+0xac/0x140
   __dev_change_flags+0xd8/0x210
   dev_change_flags+0x24/0x64
   do_setlink+0x230/0xdd0
   ...

This happens because virtnet_freeze() frees the receive_queue
completely (including struct xdp_rxq_info) but does not call
xdp_rxq_info_unreg(). Similarly, virtnet_restore() sets up the
receive_queue again but does not call xdp_rxq_info_reg().

Actually, parts of virtnet_freeze_down() and virtnet_restore_up()
are almost identical to virtnet_close() and virtnet_open(): only
the calls to xdp_rxq_info_(un)reg() are missing. This means that
we can fix this easily and avoid such problems in the future by
just calling virtnet_close()/open() from the freeze/restore handlers.

Aside from adding the missing xdp_rxq_info calls the only difference
is that the refill work is only cancelled if netif_running(). However,
this should not make any functional difference since the refill work
should only be active if the network interface is actually up.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/340fbdc8011f2dc678f622c5ce1cbb5ab8305de7
  - https://git.kernel.org/stable/c/57ee40f1b198b59d43c216fbc4672f9300d3c8b0
  - https://git.kernel.org/stable/c/8af52fe9fd3bf5e7478da99193c0632276e1dfce
  - https://git.kernel.org/stable/c/8c7a32b7c15555beddc5810c3334d9cefff061bf
  - https://git.kernel.org/stable/c/8d7fe9ad6fddc2af8bde4b921b4f8fab231ed38c
  - https://git.kernel.org/stable/c/9222672fa6370f0ec3d899662cb8680e9282fc4c

------------------------------------------------------------

CVE ID: CVE-2022-49688
Description: In the Linux kernel, the following vulnerability has been resolved:

afs: Fix dynamic root getattr

The recent patch to make afs_getattr consult the server didn't account
for the pseudo-inodes employed by the dynamic root-type afs superblock
not having a volume or a server to access, and thus an oops occurs if
such a directory is stat'd.

Fix this by checking to see if the vnode->volume pointer actually points
anywhere before following it in afs_getattr().

This can be tested by stat'ing a directory in /afs.  It may be
sufficient just to do "ls /afs" and the oops looks something like:

        BUG: kernel NULL pointer dereference, address: 0000000000000020
        ...
        RIP: 0010:afs_getattr+0x8b/0x14b
        ...
        Call Trace:
         <TASK>
         vfs_statx+0x79/0xf5
         vfs_fstatat+0x49/0x62
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b2bba96526f25f2eba74ecadb031de2e05a83ce
  - https://git.kernel.org/stable/c/65c24caf1b9f5b08397c6e805ec24ebc390c6e4d
  - https://git.kernel.org/stable/c/7844ceada44eca740d31beb3d97b8511b1ca0a9b
  - https://git.kernel.org/stable/c/7b564e3254b7db5fbfbf11a824627a6c31b932b4
  - https://git.kernel.org/stable/c/cb78d1b5efffe4cf97e16766329dd7358aed3deb
  - https://git.kernel.org/stable/c/e3a232e5767051483ffad4cef7d0a89d292a192b

------------------------------------------------------------

CVE ID: CVE-2022-49691
Description: In the Linux kernel, the following vulnerability has been resolved:

erspan: do not assume transport header is always set

Rewrite tests in ip6erspan_tunnel_xmit() and
erspan_fb_xmit() to not assume transport header is set.

syzbot reported:

WARNING: CPU: 0 PID: 1350 at include/linux/skbuff.h:2911 skb_transport_header include/linux/skbuff.h:2911 [inline]
WARNING: CPU: 0 PID: 1350 at include/linux/skbuff.h:2911 ip6erspan_tunnel_xmit+0x15af/0x2eb0 net/ipv6/ip6_gre.c:963
Modules linked in:
CPU: 0 PID: 1350 Comm: aoe_tx0 Not tainted 5.19.0-rc2-syzkaller-00160-g274295c6e53f #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014
RIP: 0010:skb_transport_header include/linux/skbuff.h:2911 [inline]
RIP: 0010:ip6erspan_tunnel_xmit+0x15af/0x2eb0 net/ipv6/ip6_gre.c:963
Code: 0f 47 f0 40 88 b5 7f fe ff ff e8 8c 16 4b f9 89 de bf ff ff ff ff e8 a0 12 4b f9 66 83 fb ff 0f 85 1d f1 ff ff e8 71 16 4b f9 <0f> 0b e9 43 f0 ff ff e8 65 16 4b f9 48 8d 85 30 ff ff ff ba 60 00
RSP: 0018:ffffc90005daf910 EFLAGS: 00010293
RAX: 0000000000000000 RBX: 000000000000ffff RCX: 0000000000000000
RDX: ffff88801f032100 RSI: ffffffff882e8d3f RDI: 0000000000000003
RBP: ffffc90005dafab8 R08: 0000000000000003 R09: 000000000000ffff
R10: 000000000000ffff R11: 0000000000000000 R12: ffff888024f21d40
R13: 000000000000a288 R14: 00000000000000b0 R15: ffff888025a2e000
FS: 0000000000000000(0000) GS:ffff88802c800000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000001b2e425000 CR3: 000000006d099000 CR4: 0000000000152ef0
Call Trace:
<TASK>
__netdev_start_xmit include/linux/netdevice.h:4805 [inline]
netdev_start_xmit include/linux/netdevice.h:4819 [inline]
xmit_one net/core/dev.c:3588 [inline]
dev_hard_start_xmit+0x188/0x880 net/core/dev.c:3604
sch_direct_xmit+0x19f/0xbe0 net/sched/sch_generic.c:342
__dev_xmit_skb net/core/dev.c:3815 [inline]
__dev_queue_xmit+0x14a1/0x3900 net/core/dev.c:4219
dev_queue_xmit include/linux/netdevice.h:2994 [inline]
tx+0x6a/0xc0 drivers/block/aoe/aoenet.c:63
kthread+0x1e7/0x3b0 drivers/block/aoe/aoecmd.c:1229
kthread+0x2e9/0x3a0 kernel/kthread.c:376
ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:302
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/02da602bc2f353dccd9e489a604490034ded941e
  - https://git.kernel.org/stable/c/2c8aeffc7c586d53e1d380f010bdca4f710f2480
  - https://git.kernel.org/stable/c/301bd140ed0b24f0da660874c7e8a47dad8c8222
  - https://git.kernel.org/stable/c/a3b2470399f679587c45abe56e551caf10becca2
  - https://git.kernel.org/stable/c/cec9867ee55478ef5dcb2adf030fe0c442a4c4ee
  - https://git.kernel.org/stable/c/fb401f37f6eadf24956d93687e5758c163c0d12b

------------------------------------------------------------

CVE ID: CVE-2022-49692
Description: In the Linux kernel, the following vulnerability has been resolved:

net: phy: at803x: fix NULL pointer dereference on AR9331 PHY

Latest kernel will explode on the PHY interrupt config, since it depends
now on allocated priv. So, run probe to allocate priv to fix it.

 ar9331_switch ethernet.1:10 lan0 (uninitialized): PHY [!ahb!ethernet@1a000000!mdio!switch@10:00] driver [Qualcomm Atheros AR9331 built-in PHY] (irq=13)
 CPU 0 Unable to handle kernel paging request at virtual address 0000000a, epc == 8050e8a8, ra == 80504b34
         ...
 Call Trace:
 [<8050e8a8>] at803x_config_intr+0x5c/0xd0
 [<80504b34>] phy_request_interrupt+0xa8/0xd0
 [<8050289c>] phylink_bringup_phy+0x2d8/0x3ac
 [<80502b68>] phylink_fwnode_phy_connect+0x118/0x130
 [<8074d8ec>] dsa_slave_create+0x270/0x420
 [<80743b04>] dsa_port_setup+0x12c/0x148
 [<8074580c>] dsa_register_switch+0xaf0/0xcc0
 [<80511344>] ar9331_sw_probe+0x370/0x388
 [<8050cb78>] mdio_probe+0x44/0x70
 [<804df300>] really_probe+0x200/0x424
 [<804df7b4>] __driver_probe_device+0x290/0x298
 [<804df810>] driver_probe_device+0x54/0xe4
 [<804dfd50>] __device_attach_driver+0xe4/0x130
 [<804dcb00>] bus_for_each_drv+0xb4/0xd8
 [<804dfac4>] __device_attach+0x104/0x1a4
 [<804ddd24>] bus_probe_device+0x48/0xc4
 [<804deb44>] deferred_probe_work_func+0xf0/0x10c
 [<800a0ffc>] process_one_work+0x314/0x4d4
 [<800a17fc>] worker_thread+0x2a4/0x354
 [<800a9a54>] kthread+0x134/0x13c
 [<8006306c>] ret_from_kernel_thread+0x14/0x1c

Same Issue would affect some other PHYs (QCA8081, QCA9561), so fix it
too.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/66fa352215e8455ba2e5f33793535795bd3e36ca
  - https://git.kernel.org/stable/c/9926de7315be3d606cc011a305ad9adb9e8e14c9

------------------------------------------------------------

CVE ID: CVE-2022-49693
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/mdp4: Fix refcount leak in mdp4_modeset_init_intf

of_graph_get_remote_node() returns remote device node pointer with
refcount incremented, we should use of_node_put() on it
when not need anymore.
Add missing of_node_put() to avoid refcount leak.

Patchwork: https://patchwork.freedesktop.org/patch/488473/
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.4.202
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3c39a17197733bc37786ed68c83267c2f491840b
  - https://git.kernel.org/stable/c/b9cc4598607cb7f7eae5c75fc1e3209cd52ff5e0
  - https://git.kernel.org/stable/c/d1592d3e362cc59b29f15019707b16c695d70ca3
  - https://git.kernel.org/stable/c/d16a4339825e64f9ddcdff5277982d640bae933b
  - https://git.kernel.org/stable/c/d607da76fd2b1cf1d377af9d9b7c6f8fecbb0e1d

------------------------------------------------------------

CVE ID: CVE-2022-49694
Description: In the Linux kernel, the following vulnerability has been resolved:

block: disable the elevator int del_gendisk

The elevator is only used for file system requests, which are stopped in
del_gendisk.  Move disabling the elevator and freeing the scheduler tags
to the end of del_gendisk instead of doing that work in disk_release and
blk_cleanup_queue to avoid a use after free on q->tag_set from
disk_release as the tag_set might not be alive at that point.

Move the blk_qos_exit call as well, as it just depends on the elevator
exit and would be the only reason to keep the not exactly cheap queue
freeze in disk_release.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/50e34d78815e474d410f342fbe783b18192ca518
  - https://git.kernel.org/stable/c/f28699fafc047ec33299da01e928c3a0073c5cc6

------------------------------------------------------------

CVE ID: CVE-2022-49695
Description: In the Linux kernel, the following vulnerability has been resolved:

igb: fix a use-after-free issue in igb_clean_tx_ring

Fix the following use-after-free bug in igb_clean_tx_ring routine when
the NIC is running in XDP mode. The issue can be triggered redirecting
traffic into the igb NIC and then closing the device while the traffic
is flowing.

[   73.322719] CPU: 1 PID: 487 Comm: xdp_redirect Not tainted 5.18.3-apu2 #9
[   73.330639] Hardware name: PC Engines APU2/APU2, BIOS 4.0.7 02/28/2017
[   73.337434] RIP: 0010:refcount_warn_saturate+0xa7/0xf0
[   73.362283] RSP: 0018:ffffc9000081f798 EFLAGS: 00010282
[   73.367761] RAX: 0000000000000000 RBX: ffffc90000420f80 RCX: 0000000000000000
[   73.375200] RDX: ffff88811ad22d00 RSI: ffff88811ad171e0 RDI: ffff88811ad171e0
[   73.382590] RBP: 0000000000000900 R08: ffffffff82298f28 R09: 0000000000000058
[   73.390008] R10: 0000000000000219 R11: ffffffff82280f40 R12: 0000000000000090
[   73.397356] R13: ffff888102343a40 R14: ffff88810359e0e4 R15: 0000000000000000
[   73.404806] FS:  00007ff38d31d740(0000) GS:ffff88811ad00000(0000) knlGS:0000000000000000
[   73.413129] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   73.419096] CR2: 000055cff35f13f8 CR3: 0000000106391000 CR4: 00000000000406e0
[   73.426565] Call Trace:
[   73.429087]  <TASK>
[   73.431314]  igb_clean_tx_ring+0x43/0x140 [igb]
[   73.436002]  igb_down+0x1d7/0x220 [igb]
[   73.439974]  __igb_close+0x3c/0x120 [igb]
[   73.444118]  igb_xdp+0x10c/0x150 [igb]
[   73.447983]  ? igb_pci_sriov_configure+0x70/0x70 [igb]
[   73.453362]  dev_xdp_install+0xda/0x110
[   73.457371]  dev_xdp_attach+0x1da/0x550
[   73.461369]  do_setlink+0xfd0/0x10f0
[   73.465166]  ? __nla_validate_parse+0x89/0xc70
[   73.469714]  rtnl_setlink+0x11a/0x1e0
[   73.473547]  rtnetlink_rcv_msg+0x145/0x3d0
[   73.477709]  ? rtnl_calcit.isra.0+0x130/0x130
[   73.482258]  netlink_rcv_skb+0x8d/0x110
[   73.486229]  netlink_unicast+0x230/0x340
[   73.490317]  netlink_sendmsg+0x215/0x470
[   73.494395]  __sys_sendto+0x179/0x190
[   73.498268]  ? move_addr_to_user+0x37/0x70
[   73.502547]  ? __sys_getsockname+0x84/0xe0
[   73.506853]  ? netlink_setsockopt+0x1c1/0x4a0
[   73.511349]  ? __sys_setsockopt+0xc8/0x1d0
[   73.515636]  __x64_sys_sendto+0x20/0x30
[   73.519603]  do_syscall_64+0x3b/0x80
[   73.523399]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[   73.528712] RIP: 0033:0x7ff38d41f20c
[   73.551866] RSP: 002b:00007fff3b945a68 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   73.559640] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ff38d41f20c
[   73.567066] RDX: 0000000000000034 RSI: 00007fff3b945b30 RDI: 0000000000000003
[   73.574457] RBP: 0000000000000003 R08: 0000000000000000 R09: 0000000000000000
[   73.581852] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff3b945ab0
[   73.589179] R13: 0000000000000000 R14: 0000000000000003 R15: 00007fff3b945b30
[   73.596545]  </TASK>
[   73.598842] ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2af944210dc23d43d8208dafac4df7be7e3c168b
  - https://git.kernel.org/stable/c/3f6a57ee8544ec3982f8a3cbcbf4aea7d47eb9ec
  - https://git.kernel.org/stable/c/68a0ed06dcd5d3ea732d011c0b83d66e4791f521
  - https://git.kernel.org/stable/c/c12a2c9b1b460ed72e6b3c33aac1ef51b0329b66

------------------------------------------------------------

CVE ID: CVE-2022-49696
Description: In the Linux kernel, the following vulnerability has been resolved:

tipc: fix use-after-free Read in tipc_named_reinit

syzbot found the following issue on:
==================================================================
BUG: KASAN: use-after-free in tipc_named_reinit+0x94f/0x9b0
net/tipc/name_distr.c:413
Read of size 8 at addr ffff88805299a000 by task kworker/1:9/23764

CPU: 1 PID: 23764 Comm: kworker/1:9 Not tainted
5.18.0-rc4-syzkaller-00878-g17d49e6e8012 #0
Hardware name: Google Compute Engine/Google Compute Engine,
BIOS Google 01/01/2011
Workqueue: events tipc_net_finalize_work
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
 print_address_description.constprop.0.cold+0xeb/0x495
mm/kasan/report.c:313
 print_report mm/kasan/report.c:429 [inline]
 kasan_report.cold+0xf4/0x1c6 mm/kasan/report.c:491
 tipc_named_reinit+0x94f/0x9b0 net/tipc/name_distr.c:413
 tipc_net_finalize+0x234/0x3d0 net/tipc/net.c:138
 process_one_work+0x996/0x1610 kernel/workqueue.c:2289
 worker_thread+0x665/0x1080 kernel/workqueue.c:2436
 kthread+0x2e9/0x3a0 kernel/kthread.c:376
 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:298
 </TASK>
[...]
==================================================================

In the commit
d966ddcc3821 ("tipc: fix a deadlock when flushing scheduled work"),
the cancel_work_sync() function just to make sure ONLY the work
tipc_net_finalize_work() is executing/pending on any CPU completed before
tipc namespace is destroyed through tipc_exit_net(). But this function
is not guaranteed the work is the last queued. So, the destroyed instance
may be accessed in the work which will try to enqueue later.

In order to completely fix, we re-order the calling of cancel_work_sync()
to make sure the work tipc_net_finalize_work() was last queued and it
must be completed by calling cancel_work_sync().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.83, Last Version (Excluding): 5.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.9.14, Last Version (Excluding): 5.10.127
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/361c5521c1e49843b710f455cae3c0a50b714323
  - https://git.kernel.org/stable/c/8b246ddd394d7d9640816611693b0096b998e27a
  - https://git.kernel.org/stable/c/911600bf5a5e84bfda4d33ee32acc75ecf6159f0
  - https://git.kernel.org/stable/c/cd7789e659e84f137631dc1f5ec8d794f2700e6c

------------------------------------------------------------

CVE ID: CVE-2022-49697
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix request_sock leak in sk lookup helpers

A customer reported a request_socket leak in a Calico cloud environment. We
found that a BPF program was doing a socket lookup with takes a refcnt on
the socket and that it was finding the request_socket but returning the parent
LISTEN socket via sk_to_full_sk() without decrementing the child request socket
1st, resulting in request_sock slab object leak. This patch retains the
existing behaviour of returning full socks to the caller but it also decrements
the child request_socket if one is present before doing so to prevent the leak.

Thanks to Curtis Taylor for all the help in diagnosing and testing this. And
thanks to Antoine Tenart for the reproducer and patch input.

v2 of this patch contains, refactor as per Daniel Borkmann's suggestions to
validate RCU flags on the listen socket so that it balances with bpf_sk_release()
and update comments as per Martin KaFai Lau's suggestion. One small change to
Daniels suggestion, put "sk = sk2" under "if (sk2 != sk)" to avoid an extra
instruction.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3046a827316c0e55fc563b4fb78c93b9ca5c7c37
  - https://git.kernel.org/stable/c/516760f1d2979903eaad5b437256913c5cd98416
  - https://git.kernel.org/stable/c/5a62b5ba4c0ce8315b6382cd4ace81b48cd121cd
  - https://git.kernel.org/stable/c/8ffe2e50e9678c8373027492035f094b130437f1
  - https://git.kernel.org/stable/c/b03607437ea81b850599f705096b05b85e7a4a71

------------------------------------------------------------

CVE ID: CVE-2022-49698
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: use get_random_u32 instead of prandom

bh might occur while updating per-cpu rnd_state from user context,
ie. local_out path.

BUG: using smp_processor_id() in preemptible [00000000] code: nginx/2725
caller is nft_ng_random_eval+0x24/0x54 [nft_numgen]
Call Trace:
 check_preemption_disabled+0xde/0xe0
 nft_ng_random_eval+0x24/0x54 [nft_numgen]

Use the random driver instead, this also avoids need for local prandom
state. Moreover, prandom now uses the random driver since d4150779e60f
("random32: use real rng for non-deterministic randomness").

Based on earlier patch from Pablo Neira.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/15cc30ac2a8d7185f8ebf97dd1ddd90a7c79783b
  - https://git.kernel.org/stable/c/6ce71f83f798be7e1ca68707fec449fbecb38852
  - https://git.kernel.org/stable/c/b1fd94e704571f98b21027340eecf821b2bdffba
  - https://git.kernel.org/stable/c/d0906b0fffc9f19bc42708ca3e84e2089088386c

------------------------------------------------------------

CVE ID: CVE-2022-49699
Description: In the Linux kernel, the following vulnerability has been resolved:

filemap: Handle sibling entries in filemap_get_read_batch()

If a read races with an invalidation followed by another read, it is
possible for a folio to be replaced with a higher-order folio.  If that
happens, we'll see a sibling entry for the new folio in the next iteration
of the loop.  This manifests as a NULL pointer dereference while holding
the RCU read lock.

Handle this by simply returning.  The next call will find the new folio
and handle it correctly.  The other ways of handling this rare race are
more complex and it's just not worth it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a66f131d30e53000f08301776bf85c912ef47aad
  - https://git.kernel.org/stable/c/cb995f4eeba9d268fd4b56c2423ad6c1d1ea1b82

------------------------------------------------------------

CVE ID: CVE-2022-49700
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/slub: add missing TID updates on slab deactivation

The fastpath in slab_alloc_node() assumes that c->slab is stable as long as
the TID stays the same. However, two places in __slab_alloc() currently
don't update the TID when deactivating the CPU slab.

If multiple operations race the right way, this could lead to an object
getting lost; or, in an even more unlikely situation, it could even lead to
an object being freed onto the wrong slab's freelist, messing up the
`inuse` counter and eventually causing a page to be freed to the page
allocator while it still contains slab objects.

(I haven't actually tested these cases though, this is just based on
looking at the code. Writing testcases for this stuff seems like it'd be
a pain...)

The race leading to state inconsistency is (all operations on the same CPU
and kmem_cache):

 - task A: begin do_slab_free():
    - read TID
    - read pcpu freelist (==NULL)
    - check `slab == c->slab` (true)
 - [PREEMPT A->B]
 - task B: begin slab_alloc_node():
    - fastpath fails (`c->freelist` is NULL)
    - enter __slab_alloc()
    - slub_get_cpu_ptr() (disables preemption)
    - enter ___slab_alloc()
    - take local_lock_irqsave()
    - read c->freelist as NULL
    - get_freelist() returns NULL
    - write `c->slab = NULL`
    - drop local_unlock_irqrestore()
    - goto new_slab
    - slub_percpu_partial() is NULL
    - get_partial() returns NULL
    - slub_put_cpu_ptr() (enables preemption)
 - [PREEMPT B->A]
 - task A: finish do_slab_free():
    - this_cpu_cmpxchg_double() succeeds()
    - [CORRUPT STATE: c->slab==NULL, c->freelist!=NULL]

From there, the object on c->freelist will get lost if task B is allowed to
continue from here: It will proceed to the retry_load_slab label,
set c->slab, then jump to load_freelist, which clobbers c->freelist.

But if we instead continue as follows, we get worse corruption:

 - task A: run __slab_free() on object from other struct slab:
    - CPU_PARTIAL_FREE case (slab was on no list, is now on pcpu partial)
 - task A: run slab_alloc_node() with NUMA node constraint:
    - fastpath fails (c->slab is NULL)
    - call __slab_alloc()
    - slub_get_cpu_ptr() (disables preemption)
    - enter ___slab_alloc()
    - c->slab is NULL: goto new_slab
    - slub_percpu_partial() is non-NULL
    - set c->slab to slub_percpu_partial(c)
    - [CORRUPT STATE: c->slab points to slab-1, c->freelist has objects
      from slab-2]
    - goto redo
    - node_match() fails
    - goto deactivate_slab
    - existing c->freelist is passed into deactivate_slab()
    - inuse count of slab-1 is decremented to account for object from
      slab-2

At this point, the inuse count of slab-1 is 1 lower than it should be.
This means that if we free all allocated objects in slab-1 except for one,
SLUB will think that slab-1 is completely unused, and may free its page,
leading to use-after-free.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.1, Last Version (Excluding): 4.9.323
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.288
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.252
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.205
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.54
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0515cc9b6b24877f59b222ade704bfaa42caa2a6
  - https://git.kernel.org/stable/c/197e257da473c725dfe47759c3ee02f2398d8ea5
  - https://git.kernel.org/stable/c/308c6d0e1f200fd26c71270c6e6bfcf0fc6ff082
  - https://git.kernel.org/stable/c/6c32496964da0dc230cea763a0e934b2e02dabd5
  - https://git.kernel.org/stable/c/d6a597450e686d4c6388bd3cdcb17224b4dae7f0
  - https://git.kernel.org/stable/c/e2b2f0e2e34d71ae6c2a1114fd3c525930e84bc7
  - https://git.kernel.org/stable/c/e7e3e90d671078455a3a08189f89d85b3da2de9e
  - https://git.kernel.org/stable/c/eeaa345e128515135ccb864c04482180c08e3259

------------------------------------------------------------

CVE ID: CVE-2022-49701
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ibmvfc: Allocate/free queue resource only during probe/remove

Currently, the sub-queues and event pool resources are allocated/freed for
every CRQ connection event such as reset and LPM. This exposes the driver
to a couple issues. First the inefficiency of freeing and reallocating
memory that can simply be resued after being sanitized. Further, a system
under memory pressue runs the risk of allocation failures that could result
in a crippled driver. Finally, there is a race window where command
submission/compeletion can try to pull/return elements from/to an event
pool that is being deleted or already has been deleted due to the lack of
host state around freeing/allocating resources. The following is an example
of list corruption following a live partition migration (LPM):

Oops: Exception in kernel mode, sig: 5 [#1]
LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries
Modules linked in: vfat fat isofs cdrom ext4 mbcache jbd2 nft_counter nft_compat nf_tables nfnetlink rpadlpar_io rpaphp xsk_diag nfsv3 nfs_acl nfs lockd grace fscache netfs rfkill bonding tls sunrpc pseries_rng drm drm_panel_orientation_quirks xfs libcrc32c dm_service_time sd_mod t10_pi sg ibmvfc scsi_transport_fc ibmveth vmx_crypto dm_multipath dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler fuse
CPU: 0 PID: 2108 Comm: ibmvfc_0 Kdump: loaded Not tainted 5.14.0-70.9.1.el9_0.ppc64le #1
NIP: c0000000007c4bb0 LR: c0000000007c4bac CTR: 00000000005b9a10
REGS: c00000025c10b760 TRAP: 0700  Not tainted (5.14.0-70.9.1.el9_0.ppc64le)
MSR: 800000000282b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE> CR: 2800028f XER: 0000000f
CFAR: c0000000001f55bc IRQMASK: 0
        GPR00: c0000000007c4bac c00000025c10ba00 c000000002a47c00 000000000000004e
        GPR04: c0000031e3006f88 c0000031e308bd00 c00000025c10b768 0000000000000027
        GPR08: 0000000000000000 c0000031e3009dc0 00000031e0eb0000 0000000000000000
        GPR12: c0000031e2ffffa8 c000000002dd0000 c000000000187108 c00000020fcee2c0
        GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
        GPR20: 0000000000000000 0000000000000000 0000000000000000 c008000002f81300
        GPR24: 5deadbeef0000100 5deadbeef0000122 c000000263ba6910 c00000024cc88000
        GPR28: 000000000000003c c0000002430a0000 c0000002430ac300 000000000000c300
NIP [c0000000007c4bb0] __list_del_entry_valid+0x90/0x100
LR [c0000000007c4bac] __list_del_entry_valid+0x8c/0x100
Call Trace:
[c00000025c10ba00] [c0000000007c4bac] __list_del_entry_valid+0x8c/0x100 (unreliable)
[c00000025c10ba60] [c008000002f42284] ibmvfc_free_queue+0xec/0x210 [ibmvfc]
[c00000025c10bb10] [c008000002f4246c] ibmvfc_deregister_scsi_channel+0xc4/0x160 [ibmvfc]
[c00000025c10bba0] [c008000002f42580] ibmvfc_release_sub_crqs+0x78/0x130 [ibmvfc]
[c00000025c10bc20] [c008000002f4f6cc] ibmvfc_do_work+0x5c4/0xc70 [ibmvfc]
[c00000025c10bce0] [c008000002f4fdec] ibmvfc_work+0x74/0x1e8 [ibmvfc]
[c00000025c10bda0] [c0000000001872b8] kthread+0x1b8/0x1c0
[c00000025c10be10] [c00000000000cd64] ret_from_kernel_thread+0x5c/0x64
Instruction dump:
40820034 38600001 38210060 4e800020 7c0802a6 7c641b78 3c62fe7a 7d254b78
3863b590 f8010070 4ba309cd 60000000 <0fe00000> 7c0802a6 3c62fe7a 3863b640
---[ end trace 11a2b65a92f8b66c ]---
ibmvfc 30000003: Send warning. Receive queue closed, will retry.

Add registration/deregistration helpers that are called instead during
connection resets to sanitize and reconfigure the queues.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/161ec2a0807ddd58bc0f24f3e1e7e3d4fef5297f
  - https://git.kernel.org/stable/c/72ea7fe0db73d65c7d977208842d8ade9b823de9
  - https://git.kernel.org/stable/c/9f23c499ca601b2a1e1d2e761d03964b739bca0e

------------------------------------------------------------

CVE ID: CVE-2022-49702
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix hang during unmount when block group reclaim task is running

When we start an unmount, at close_ctree(), if we have the reclaim task
running and in the middle of a data block group relocation, we can trigger
a deadlock when stopping an async reclaim task, producing a trace like the
following:

[629724.498185] task:kworker/u16:7   state:D stack:    0 pid:681170 ppid:     2 flags:0x00004000
[629724.499760] Workqueue: events_unbound btrfs_async_reclaim_metadata_space [btrfs]
[629724.501267] Call Trace:
[629724.501759]  <TASK>
[629724.502174]  __schedule+0x3cb/0xed0
[629724.502842]  schedule+0x4e/0xb0
[629724.503447]  btrfs_wait_on_delayed_iputs+0x7c/0xc0 [btrfs]
[629724.504534]  ? prepare_to_wait_exclusive+0xc0/0xc0
[629724.505442]  flush_space+0x423/0x630 [btrfs]
[629724.506296]  ? rcu_read_unlock_trace_special+0x20/0x50
[629724.507259]  ? lock_release+0x220/0x4a0
[629724.507932]  ? btrfs_get_alloc_profile+0xb3/0x290 [btrfs]
[629724.508940]  ? do_raw_spin_unlock+0x4b/0xa0
[629724.509688]  btrfs_async_reclaim_metadata_space+0x139/0x320 [btrfs]
[629724.510922]  process_one_work+0x252/0x5a0
[629724.511694]  ? process_one_work+0x5a0/0x5a0
[629724.512508]  worker_thread+0x52/0x3b0
[629724.513220]  ? process_one_work+0x5a0/0x5a0
[629724.514021]  kthread+0xf2/0x120
[629724.514627]  ? kthread_complete_and_exit+0x20/0x20
[629724.515526]  ret_from_fork+0x22/0x30
[629724.516236]  </TASK>
[629724.516694] task:umount          state:D stack:    0 pid:719055 ppid:695412 flags:0x00004000
[629724.518269] Call Trace:
[629724.518746]  <TASK>
[629724.519160]  __schedule+0x3cb/0xed0
[629724.519835]  schedule+0x4e/0xb0
[629724.520467]  schedule_timeout+0xed/0x130
[629724.521221]  ? lock_release+0x220/0x4a0
[629724.521946]  ? lock_acquired+0x19c/0x420
[629724.522662]  ? trace_hardirqs_on+0x1b/0xe0
[629724.523411]  __wait_for_common+0xaf/0x1f0
[629724.524189]  ? usleep_range_state+0xb0/0xb0
[629724.524997]  __flush_work+0x26d/0x530
[629724.525698]  ? flush_workqueue_prep_pwqs+0x140/0x140
[629724.526580]  ? lock_acquire+0x1a0/0x310
[629724.527324]  __cancel_work_timer+0x137/0x1c0
[629724.528190]  close_ctree+0xfd/0x531 [btrfs]
[629724.529000]  ? evict_inodes+0x166/0x1c0
[629724.529510]  generic_shutdown_super+0x74/0x120
[629724.530103]  kill_anon_super+0x14/0x30
[629724.530611]  btrfs_kill_super+0x12/0x20 [btrfs]
[629724.531246]  deactivate_locked_super+0x31/0xa0
[629724.531817]  cleanup_mnt+0x147/0x1c0
[629724.532319]  task_work_run+0x5c/0xa0
[629724.532984]  exit_to_user_mode_prepare+0x1a6/0x1b0
[629724.533598]  syscall_exit_to_user_mode+0x16/0x40
[629724.534200]  do_syscall_64+0x48/0x90
[629724.534667]  entry_SYSCALL_64_after_hwframe+0x44/0xae
[629724.535318] RIP: 0033:0x7fa2b90437a7
[629724.535804] RSP: 002b:00007ffe0b7e4458 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
[629724.536912] RAX: 0000000000000000 RBX: 00007fa2b9182264 RCX: 00007fa2b90437a7
[629724.538156] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000555d6cf20dd0
[629724.539053] RBP: 0000555d6cf20ba0 R08: 0000000000000000 R09: 00007ffe0b7e3200
[629724.539956] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
[629724.540883] R13: 0000555d6cf20dd0 R14: 0000555d6cf20cb0 R15: 0000000000000000
[629724.541796]  </TASK>

This happens because:

1) Before entering close_ctree() we have the async block group reclaim
   task running and relocating a data block group;

2) There's an async metadata (or data) space reclaim task running;

3) We enter close_ctree() and park the cleaner kthread;

4) The async space reclaim task is at flush_space() and runs all the
   existing delayed iputs;

5) Before the async space reclaim task calls
   btrfs_wait_on_delayed_iputs(), the block group reclaim task which is
   doing the data block group relocation, creates a delayed iput at
   replace_file_extents() (called when COWing leaves that have file extent
   items pointing to relocated data exten
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/31e70e527806c546a72262f2fc3d982ee23c42d3
  - https://git.kernel.org/stable/c/341d33128a940c6634175dcb6ca92dc454cfa7d2
  - https://git.kernel.org/stable/c/9fadb11f1295289e0da4d3342ecb6b92c1c99540

------------------------------------------------------------

CVE ID: CVE-2022-49703
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ibmvfc: Store vhost pointer during subcrq allocation

Currently the back pointer from a queue to the vhost adapter isn't set
until after subcrq interrupt registration. The value is available when a
queue is first allocated and can/should be also set for primary and async
queues as well as subcrqs.

This fixes a crash observed during kexec/kdump on Power 9 with legacy XICS
interrupt controller where a pending subcrq interrupt from the previous
kernel can be replayed immediately upon IRQ registration resulting in
dereference of a garbage backpointer in ibmvfc_interrupt_scsi().

Kernel attempted to read user page (58) - exploit attempt? (uid: 0)
BUG: Kernel NULL pointer dereference on read at 0x00000058
Faulting instruction address: 0xc008000003216a08
Oops: Kernel access of bad area, sig: 11 [#1]
...
NIP [c008000003216a08] ibmvfc_interrupt_scsi+0x40/0xb0 [ibmvfc]
LR [c0000000082079e8] __handle_irq_event_percpu+0x98/0x270
Call Trace:
[c000000047fa3d80] [c0000000123e6180] 0xc0000000123e6180 (unreliable)
[c000000047fa3df0] [c0000000082079e8] __handle_irq_event_percpu+0x98/0x270
[c000000047fa3ea0] [c000000008207d18] handle_irq_event+0x98/0x188
[c000000047fa3ef0] [c00000000820f564] handle_fasteoi_irq+0xc4/0x310
[c000000047fa3f40] [c000000008205c60] generic_handle_irq+0x50/0x80
[c000000047fa3f60] [c000000008015c40] __do_irq+0x70/0x1a0
[c000000047fa3f90] [c000000008016d7c] __do_IRQ+0x9c/0x130
[c000000014622f60] [0000000020000000] 0x20000000
[c000000014622ff0] [c000000008016e50] do_IRQ+0x40/0xa0
[c000000014623020] [c000000008017044] replay_soft_interrupts+0x194/0x2f0
[c000000014623210] [c0000000080172a8] arch_local_irq_restore+0x108/0x170
[c000000014623240] [c000000008eb1008] _raw_spin_unlock_irqrestore+0x58/0xb0
[c000000014623270] [c00000000820b12c] __setup_irq+0x49c/0x9f0
[c000000014623310] [c00000000820b7c0] request_threaded_irq+0x140/0x230
[c000000014623380] [c008000003212a50] ibmvfc_register_scsi_channel+0x1e8/0x2f0 [ibmvfc]
[c000000014623450] [c008000003213d1c] ibmvfc_init_sub_crqs+0xc4/0x1f0 [ibmvfc]
[c0000000146234d0] [c0080000032145a8] ibmvfc_reset_crq+0x150/0x210 [ibmvfc]
[c000000014623550] [c0080000032147c8] ibmvfc_init_crq+0x160/0x280 [ibmvfc]
[c0000000146235f0] [c00800000321a9cc] ibmvfc_probe+0x2a4/0x530 [ibmvfc]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6d38e3b614ded59da8b95377a98df969a5a5627a
  - https://git.kernel.org/stable/c/8540f66196ca35b7b5e902932571c18b9fde0cd1
  - https://git.kernel.org/stable/c/aeaadcde1a60138bceb65de3cdaeec78170b4459

------------------------------------------------------------

CVE ID: CVE-2022-49704
Description: In the Linux kernel, the following vulnerability has been resolved:

9p: fix fid refcount leak in v9fs_vfs_get_link

we check for protocol version later than required, after a fid has
been obtained. Just move the version check earlier.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/e5690f263208c5abce7451370b7786eb25b405eb
  - https://git.kernel.org/stable/c/e7b6d622bd812013eb39c8f4cd65b7ee8ede1e02
  - https://git.kernel.org/stable/c/f0126bcaee81dabc1926012126aa74caa03a4c6e

------------------------------------------------------------

CVE ID: CVE-2022-49705
Description: In the Linux kernel, the following vulnerability has been resolved:

9p: fix fid refcount leak in v9fs_vfs_atomic_open_dotl

We need to release directory fid if we fail halfway through open

This fixes fid leaking with xfstests generic 531
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.51
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.8
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/22832ac3eb5be3f7168816a76b64c1284e12eb3c
  - https://git.kernel.org/stable/c/8bc5412ba1a45edfd1e451874c483c26a097af2b
  - https://git.kernel.org/stable/c/beca774fc51a9ba8abbc869cf0c3d965ff17cd24

------------------------------------------------------------

CVE ID: CVE-2022-49706
Description: In the Linux kernel, the following vulnerability has been resolved:

zonefs: fix zonefs_iomap_begin() for reads

If a readahead is issued to a sequential zone file with an offset
exactly equal to the current file size, the iomap type is set to
IOMAP_UNWRITTEN, which will prevent an IO, but the iomap length is
calculated as 0. This causes a WARN_ON() in iomap_iter():

[17309.548939] WARNING: CPU: 3 PID: 2137 at fs/iomap/iter.c:34 iomap_iter+0x9cf/0xe80
[...]
[17309.650907] RIP: 0010:iomap_iter+0x9cf/0xe80
[...]
[17309.754560] Call Trace:
[17309.757078]  <TASK>
[17309.759240]  ? lock_is_held_type+0xd8/0x130
[17309.763531]  iomap_readahead+0x1a8/0x870
[17309.767550]  ? iomap_read_folio+0x4c0/0x4c0
[17309.771817]  ? lockdep_hardirqs_on_prepare+0x400/0x400
[17309.778848]  ? lock_release+0x370/0x750
[17309.784462]  ? folio_add_lru+0x217/0x3f0
[17309.790220]  ? reacquire_held_locks+0x4e0/0x4e0
[17309.796543]  read_pages+0x17d/0xb60
[17309.801854]  ? folio_add_lru+0x238/0x3f0
[17309.807573]  ? readahead_expand+0x5f0/0x5f0
[17309.813554]  ? policy_node+0xb5/0x140
[17309.819018]  page_cache_ra_unbounded+0x27d/0x450
[17309.825439]  filemap_get_pages+0x500/0x1450
[17309.831444]  ? filemap_add_folio+0x140/0x140
[17309.837519]  ? lock_is_held_type+0xd8/0x130
[17309.843509]  filemap_read+0x28c/0x9f0
[17309.848953]  ? zonefs_file_read_iter+0x1ea/0x4d0 [zonefs]
[17309.856162]  ? trace_contention_end+0xd6/0x130
[17309.862416]  ? __mutex_lock+0x221/0x1480
[17309.868151]  ? zonefs_file_read_iter+0x166/0x4d0 [zonefs]
[17309.875364]  ? filemap_get_pages+0x1450/0x1450
[17309.881647]  ? __mutex_unlock_slowpath+0x15e/0x620
[17309.888248]  ? wait_for_completion_io_timeout+0x20/0x20
[17309.895231]  ? lock_is_held_type+0xd8/0x130
[17309.901115]  ? lock_is_held_type+0xd8/0x130
[17309.906934]  zonefs_file_read_iter+0x356/0x4d0 [zonefs]
[17309.913750]  new_sync_read+0x2d8/0x520
[17309.919035]  ? __x64_sys_lseek+0x1d0/0x1d0

Furthermore, this causes iomap_readahead() to loop forever as
iomap_readahead_iter() always returns 0, making no progress.

Fix this by treating reads after the file size as access to holes,
setting the iomap type to IOMAP_HOLE, the iomap addr to IOMAP_NULL_ADDR
and using the length argument as is for the iomap length. To simplify
the code with this change, zonefs_iomap_begin() is split into the read
variant, zonefs_read_iomap_begin() and zonefs_read_iomap_ops, and the
write variant, zonefs_write_iomap_begin() and zonefs_write_iomap_ops.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/355be6131164c5bacf2e810763835aecb6e01fcb
  - https://git.kernel.org/stable/c/3a7f05f104347b407e865c10be2675cd833a4e48
  - https://git.kernel.org/stable/c/c1c1204c0d0c1dccc1310b9277fb2bd8b663d8fe
  - https://git.kernel.org/stable/c/c2f71b9bb398e2e573bdc2574149f42b45efe410

------------------------------------------------------------

CVE ID: CVE-2022-49707
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: add reserved GDT blocks check

We capture a NULL pointer issue when resizing a corrupt ext4 image which
is freshly clear resize_inode feature (not run e2fsck). It could be
simply reproduced by following steps. The problem is because of the
resize_inode feature was cleared, and it will convert the filesystem to
meta_bg mode in ext4_resize_fs(), but the es->s_reserved_gdt_blocks was
not reduced to zero, so could we mistakenly call reserve_backup_gdb()
and passing an uninitialized resize_inode to it when adding new group
descriptors.

 mkfs.ext4 /dev/sda 3G
 tune2fs -O ^resize_inode /dev/sda #forget to run requested e2fsck
 mount /dev/sda /mnt
 resize2fs /dev/sda 8G

 ========
 BUG: kernel NULL pointer dereference, address: 0000000000000028
 CPU: 19 PID: 3243 Comm: resize2fs Not tainted 5.18.0-rc7-00001-gfde086c5ebfd #748
 ...
 RIP: 0010:ext4_flex_group_add+0xe08/0x2570
 ...
 Call Trace:
  <TASK>
  ext4_resize_fs+0xbec/0x1660
  __ext4_ioctl+0x1749/0x24e0
  ext4_ioctl+0x12/0x20
  __x64_sys_ioctl+0xa6/0x110
  do_syscall_64+0x3b/0x90
  entry_SYSCALL_64_after_hwframe+0x44/0xae
 RIP: 0033:0x7f2dd739617b
 ========

The fix is simple, add a check in ext4_resize_begin() to make sure that
the es->s_reserved_gdt_blocks is zero when the resize_inode feature is
disabled.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.320
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0dc2fca8e4f9ac4a40e8424a10163369cca0cc06
  - https://git.kernel.org/stable/c/33b1bba31f4c784d33d2c2517964bdccdc9204cd
  - https://git.kernel.org/stable/c/7c921328ac760bba780bdace41f4cd045f7f1405
  - https://git.kernel.org/stable/c/af75c481a2e45e70f62f5942c93695e95bf7bd21
  - https://git.kernel.org/stable/c/b55c3cd102a6f48b90e61c44f7f3dda8c290c694
  - https://git.kernel.org/stable/c/b9747263b13e5290ac4d63bec47e38f701303cad
  - https://git.kernel.org/stable/c/bfd004a1d3a062aac300523d406ac1f3e5f1a82c
  - https://git.kernel.org/stable/c/fba54289176702a7caac0b64738406775817f451

------------------------------------------------------------

CVE ID: CVE-2022-49708
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix bug_on ext4_mb_use_inode_pa

Hulk Robot reported a BUG_ON:
==================================================================
kernel BUG at fs/ext4/mballoc.c:3211!
[...]
RIP: 0010:ext4_mb_mark_diskspace_used.cold+0x85/0x136f
[...]
Call Trace:
 ext4_mb_new_blocks+0x9df/0x5d30
 ext4_ext_map_blocks+0x1803/0x4d80
 ext4_map_blocks+0x3a4/0x1a10
 ext4_writepages+0x126d/0x2c30
 do_writepages+0x7f/0x1b0
 __filemap_fdatawrite_range+0x285/0x3b0
 file_write_and_wait_range+0xb1/0x140
 ext4_sync_file+0x1aa/0xca0
 vfs_fsync_range+0xfb/0x260
 do_fsync+0x48/0xa0
[...]
==================================================================

Above issue may happen as follows:
-------------------------------------
do_fsync
 vfs_fsync_range
  ext4_sync_file
   file_write_and_wait_range
    __filemap_fdatawrite_range
     do_writepages
      ext4_writepages
       mpage_map_and_submit_extent
        mpage_map_one_extent
         ext4_map_blocks
          ext4_mb_new_blocks
           ext4_mb_normalize_request
            >>> start + size <= ac->ac_o_ex.fe_logical
           ext4_mb_regular_allocator
            ext4_mb_simple_scan_group
             ext4_mb_use_best_found
              ext4_mb_new_preallocation
               ext4_mb_new_inode_pa
                ext4_mb_use_inode_pa
                 >>> set ac->ac_b_ex.fe_len <= 0
           ext4_mb_mark_diskspace_used
            >>> BUG_ON(ac->ac_b_ex.fe_len <= 0);

we can easily reproduce this problem with the following commands:
	`fallocate -l100M disk`
	`mkfs.ext4 -b 1024 -g 256 disk`
	`mount disk /mnt`
	`fsstress -d /mnt -l 0 -n 1000 -p 1`

The size must be smaller than or equal to EXT4_BLOCKS_PER_GROUP.
Therefore, "start + size <= ac->ac_o_ex.fe_logical" may occur
when the size is truncated. So start should be the start position of
the group where ac_o_ex.fe_logical is located after alignment.
In addition, when the value of fe_logical or EXT4_BLOCKS_PER_GROUP
is very large, the value calculated by start_off is more accurate.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5707d721d1819db57dba57b1d4623034fcb32047
  - https://git.kernel.org/stable/c/6880fb2e64331b9fdc85d3f32b1d7e81ad8703f1
  - https://git.kernel.org/stable/c/6fdaf31ad5f3d3afab744dfd9a8b0d9142aa881f
  - https://git.kernel.org/stable/c/887a3e9ad4b8309a2266bce7ae749b2bf1f7a687
  - https://git.kernel.org/stable/c/90f0f9d45dff0128c0fca0d2358c4153b024afa6
  - https://git.kernel.org/stable/c/a08f789d2ab5242c07e716baf9a835725046be89
  - https://git.kernel.org/stable/c/a37c1359714da42517dd19d36fc3c4d17edba832
  - https://git.kernel.org/stable/c/a6b31616e5afe1d3972cb0682a373e50597faf5c

------------------------------------------------------------

CVE ID: CVE-2022-49709
Description: In the Linux kernel, the following vulnerability has been resolved:

cfi: Fix __cfi_slowpath_diag RCU usage with cpuidle

RCU_NONIDLE usage during __cfi_slowpath_diag can result in an invalid
RCU state in the cpuidle code path:

  WARNING: CPU: 1 PID: 0 at kernel/rcu/tree.c:613 rcu_eqs_enter+0xe4/0x138
  ...
  Call trace:
    rcu_eqs_enter+0xe4/0x138
    rcu_idle_enter+0xa8/0x100
    cpuidle_enter_state+0x154/0x3a8
    cpuidle_enter+0x3c/0x58
    do_idle.llvm.6590768638138871020+0x1f4/0x2ec
    cpu_startup_entry+0x28/0x2c
    secondary_start_kernel+0x1b8/0x220
    __secondary_switched+0x94/0x98

Instead, call rcu_irq_enter/exit to wake up RCU only when needed and
disable interrupts for the entire CFI shadow/module check when we do.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/57cd6d157eb479f0a8e820fd36b7240845c8a937
  - https://git.kernel.org/stable/c/75f3a5fa2ad049c85ab5d5ee1ed9cfaa7e62c5ed
  - https://git.kernel.org/stable/c/ca3897f2ac02ceae5e6fa794f83c36f9885b93da

------------------------------------------------------------

CVE ID: CVE-2022-49710
Description: In the Linux kernel, the following vulnerability has been resolved:

dm mirror log: round up region bitmap size to BITS_PER_LONG

The code in dm-log rounds up bitset_size to 32 bits. It then uses
find_next_zero_bit_le on the allocated region. find_next_zero_bit_le
accesses the bitmap using unsigned long pointers. So, on 64-bit
architectures, it may access 4 bytes beyond the allocated size.

Fix this bug by rounding up bitset_size to BITS_PER_LONG.

This bug was found by running the lvm2 testsuite with kasan.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d2209b54f1de0c2f99cab246d4cf2cfe24aaaa9
  - https://git.kernel.org/stable/c/85e123c27d5cbc22cfdc01de1e2ca1d9003a02d0
  - https://git.kernel.org/stable/c/9a02f3275acc628c0d956be771405ced79ac36df
  - https://git.kernel.org/stable/c/ae460312875159285cef5bf3dc654593f404a1ef
  - https://git.kernel.org/stable/c/ba751f0d25f07aa21ce9b85372a3792bf7969d13

------------------------------------------------------------

CVE ID: CVE-2022-49711
Description: In the Linux kernel, the following vulnerability has been resolved:

bus: fsl-mc-bus: fix KASAN use-after-free in fsl_mc_bus_remove()

In fsl_mc_bus_remove(), mc->root_mc_bus_dev->mc_io is passed to
fsl_destroy_mc_io(). However, mc->root_mc_bus_dev is already freed in
fsl_mc_device_remove(). Then reference to mc->root_mc_bus_dev->mc_io
triggers KASAN use-after-free. To avoid the use-after-free, keep the
reference to mc->root_mc_bus_dev->mc_io in a local variable and pass to
fsl_destroy_mc_io().

This patch needs rework to apply to kernels older than v5.15.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.8, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/161b68b0a728377aaa10a8e14c70e7734f3c9ff7
  - https://git.kernel.org/stable/c/928ea98252ad75118950941683893cf904541da9
  - https://git.kernel.org/stable/c/ccd1751092341ac120a961835211f9f2e3735963

------------------------------------------------------------

CVE ID: CVE-2022-49712
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: lpc32xx_udc: Fix refcount leak in lpc32xx_udc_probe

of_parse_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
of_node_put() will check NULL pointer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.5, Last Version (Excluding): 4.9.320
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0ef6917c0524da5b88496b9706628ffef108b9bb
  - https://git.kernel.org/stable/c/2a598da14856ead80c726b38ba426c68637d9211
  - https://git.kernel.org/stable/c/46da1e4a8b6329479433b2a4056941dfdd7f3efd
  - https://git.kernel.org/stable/c/4757c9ade34178b351580133771f510b5ffcf9c8
  - https://git.kernel.org/stable/c/57901c658f77d9ea2e772f35cb38e47efb54c558
  - https://git.kernel.org/stable/c/727c82d003e0ec64411fd1257a9a57de4ad7a99a
  - https://git.kernel.org/stable/c/b75bddfcc18170ce8e3fb695a76ec2dec4ce0ea5
  - https://git.kernel.org/stable/c/d85e4e6284a91aa2d1ab004e9d84b9c09b4aa203

------------------------------------------------------------

CVE ID: CVE-2022-49713
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: dwc2: Fix memory leak in dwc2_hcd_init

usb_create_hcd will alloc memory for hcd, and we should
call usb_put_hcd to free it when platform_get_resource()
fails to prevent memory leak.
goto error2 label instead error1 to fix this.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.250, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.210, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.152, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.72, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3755278f078460b021cd0384562977bf2039a57a
  - https://git.kernel.org/stable/c/52bfcedbfd5bf962dbdcb6e761f4d0dd3ba26dfd
  - https://git.kernel.org/stable/c/6506aff2dc2f7059aa3d45ee2e8639b25e87090f
  - https://git.kernel.org/stable/c/701d8ec01e0f229d4db6f43d3d64ee479120cbeb
  - https://git.kernel.org/stable/c/84e6d0af87e27bbc0db94f2e7323b34abe17b6e5
  - https://git.kernel.org/stable/c/981ee40649e5fd9550f82db1fbb3bfab037da346
  - https://git.kernel.org/stable/c/a44a8a762f7fe9ad3c065813d058e835a6180cb2

------------------------------------------------------------

CVE ID: CVE-2022-49714
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/realtek-rtl: Fix refcount leak in map_interrupts

of_find_node_by_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
This function doesn't call of_node_put() in error path.
Call of_node_put() directly after of_property_read_u32() to cover
both normal path and error path.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/e85b1b797de0e7a271b906291ce28245822820b8
  - https://git.kernel.org/stable/c/eff4780f83d0ae3e5b6c02ff5d999dc4c1c5c8ce
  - https://git.kernel.org/stable/c/f6d6223df0666fbc054e3a8c6ac14eb0af37c286

------------------------------------------------------------

CVE ID: CVE-2022-49715
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/gic-v3: Fix refcount leak in gic_populate_ppi_partitions

of_find_node_by_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.7, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/506a88a5bf261d76a5214c0338a320f2214c67ac
  - https://git.kernel.org/stable/c/8d884c08eeb83142a7173cb46bcff0434ec42cf1
  - https://git.kernel.org/stable/c/c136c2924a59a399aa789858cfb320d481964fb7
  - https://git.kernel.org/stable/c/cc5984cf270b69d03f9f4b27063e535036c659e9
  - https://git.kernel.org/stable/c/e824482e2c5edacc961b7dd30a92fd47606c3036
  - https://git.kernel.org/stable/c/fa1ad9d4cc47ca2470cd904ad4519f05d7e43a2b

------------------------------------------------------------

CVE ID: CVE-2022-49716
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/gic-v3: Fix error handling in gic_populate_ppi_partitions

of_get_child_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
When kcalloc fails, it missing of_node_put() and results in refcount
leak. Fix this by goto out_put_node label.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0b325d993995a321f6ab4e6c51f0504ec092bf5b
  - https://git.kernel.org/stable/c/58e67c81e229351027d28c610638378606e33a08
  - https://git.kernel.org/stable/c/7c9dd9d23f26dabcfb14148b9acdfba540418b19
  - https://git.kernel.org/stable/c/c83c34c57798fc41faefcf078be78683db2f4beb
  - https://git.kernel.org/stable/c/ec8401a429ffee34ccf38cebf3443f8d5ae6cb0d

------------------------------------------------------------

CVE ID: CVE-2022-49717
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/apple-aic: Fix refcount leak in build_fiq_affinity

of_find_node_by_phandle() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2dc14cebe5dc053434b507bb24e6821cb795050f
  - https://git.kernel.org/stable/c/b1ac803f47cb1615468f35cf1ccb553c52087301

------------------------------------------------------------

CVE ID: CVE-2022-49718
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/apple-aic: Fix refcount leak in aic_of_ic_init

of_get_child_by_name() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3d45670fab3c25a7452721e4588cc95c51cda134
  - https://git.kernel.org/stable/c/6c0010d1dc67c89bcc857c46f542efe318f84ddc

------------------------------------------------------------

CVE ID: CVE-2022-49719
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/gic/realview: Fix refcount leak in realview_gic_of_init

of_find_matching_node_and_match() returns a node pointer with refcount
incremented, we should use of_node_put() on it when not need anymore.
Add missing of_node_put() to avoid refcount leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.6, Last Version (Excluding): 4.9.320
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/16b603cb8d34c2d917983918db1f88c8b831baaa
  - https://git.kernel.org/stable/c/486f68f85085d9b16ae097679b1486dcb1b6eb69
  - https://git.kernel.org/stable/c/56526c3883fc7a1f5898b1d40a02c8b8685a5d92
  - https://git.kernel.org/stable/c/5d38720661a4b9c87705c206a6081177ffb8ec1d
  - https://git.kernel.org/stable/c/87da903ce632d5689bef66d56ee5dae700d82104
  - https://git.kernel.org/stable/c/b634af84bc1edece4e63317b0ad95618dd3a8693
  - https://git.kernel.org/stable/c/e52a58b79f11755ea7e877015c4a1704303fa55f
  - https://git.kernel.org/stable/c/f4b98e314888cc51486421bcf6d52852452ea48b

------------------------------------------------------------

CVE ID: CVE-2022-49720
Description: In the Linux kernel, the following vulnerability has been resolved:

block: Fix handling of offline queues in blk_mq_alloc_request_hctx()

This patch prevents that test nvme/004 triggers the following:

UBSAN: array-index-out-of-bounds in block/blk-mq.h:135:9
index 512 is out of range for type 'long unsigned int [512]'
Call Trace:
 show_stack+0x52/0x58
 dump_stack_lvl+0x49/0x5e
 dump_stack+0x10/0x12
 ubsan_epilogue+0x9/0x3b
 __ubsan_handle_out_of_bounds.cold+0x44/0x49
 blk_mq_alloc_request_hctx+0x304/0x310
 __nvme_submit_sync_cmd+0x70/0x200 [nvme_core]
 nvmf_connect_io_queue+0x23e/0x2a0 [nvme_fabrics]
 nvme_loop_connect_io_queues+0x8d/0xb0 [nvme_loop]
 nvme_loop_create_ctrl+0x58e/0x7d0 [nvme_loop]
 nvmf_create_ctrl+0x1d7/0x4d0 [nvme_fabrics]
 nvmf_dev_write+0xae/0x111 [nvme_fabrics]
 vfs_write+0x144/0x560
 ksys_write+0xb7/0x140
 __x64_sys_write+0x42/0x50
 do_syscall_64+0x35/0x80
 entry_SYSCALL_64_after_hwframe+0x44/0xae
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.16, Last Version (Excluding): 5.10.214
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/14dc7a18abbe4176f5626c13c333670da8e06aa1
  - https://git.kernel.org/stable/c/7fa28a7c3d74933a4fc22d341b60927952f31c19
  - https://git.kernel.org/stable/c/b202a0bd2580ee5b0453772c46d464152fafff73
  - https://git.kernel.org/stable/c/b5e65ef044d627effdc2599040b6d204e003f955

------------------------------------------------------------

CVE ID: CVE-2022-49721
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: ftrace: consistently handle PLTs.

Sometimes it is necessary to use a PLT entry to call an ftrace
trampoline. This is handled by ftrace_make_call() and ftrace_make_nop(),
with each having *almost* identical logic, but this is not handled by
ftrace_modify_call() since its introduction in commit:

  3b23e4991fb66f6d ("arm64: implement ftrace with regs")

Due to this, if we ever were to call ftrace_modify_call() for a callsite
which requires a PLT entry for a trampoline, then either:

a) If the old addr requires a trampoline, ftrace_modify_call() will use
   an out-of-range address to generate the 'old' branch instruction.
   This will result in warnings from aarch64_insn_gen_branch_imm() and
   ftrace_modify_code(), and no instructions will be modified. As
   ftrace_modify_call() will return an error, this will result in
   subsequent internal ftrace errors.

b) If the old addr does not require a trampoline, but the new addr does,
   ftrace_modify_call() will use an out-of-range address to generate the
   'new' branch instruction. This will result in warnings from
   aarch64_insn_gen_branch_imm(), and ftrace_modify_code() will replace
   the 'old' branch with a BRK. This will result in a kernel panic when
   this BRK is later executed.

Practically speaking, case (a) is vastly more likely than case (b), and
typically this will result in internal ftrace errors that don't
necessarily affect the rest of the system. This can be demonstrated with
an out-of-tree test module which triggers ftrace_modify_call(), e.g.

| # insmod test_ftrace.ko
| test_ftrace: Function test_function raw=0xffffb3749399201c, callsite=0xffffb37493992024
| branch_imm_common: offset out of range
| branch_imm_common: offset out of range
| ------------[ ftrace bug ]------------
| ftrace failed to modify
| [<ffffb37493992024>] test_function+0x8/0x38 [test_ftrace]
|  actual:   1d:00:00:94
| Updating ftrace call site to call a different ftrace function
| ftrace record flags: e0000002
|  (2) R
|  expected tramp: ffffb374ae42ed54
| ------------[ cut here ]------------
| WARNING: CPU: 0 PID: 165 at kernel/trace/ftrace.c:2085 ftrace_bug+0x280/0x2b0
| Modules linked in: test_ftrace(+)
| CPU: 0 PID: 165 Comm: insmod Not tainted 5.19.0-rc2-00002-g4d9ead8b45ce #13
| Hardware name: linux,dummy-virt (DT)
| pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
| pc : ftrace_bug+0x280/0x2b0
| lr : ftrace_bug+0x280/0x2b0
| sp : ffff80000839ba00
| x29: ffff80000839ba00 x28: 0000000000000000 x27: ffff80000839bcf0
| x26: ffffb37493994180 x25: ffffb374b0991c28 x24: ffffb374b0d70000
| x23: 00000000ffffffea x22: ffffb374afcc33b0 x21: ffffb374b08f9cc8
| x20: ffff572b8462c000 x19: ffffb374b08f9000 x18: ffffffffffffffff
| x17: 6c6c6163202c6331 x16: ffffb374ae5ad110 x15: ffffb374b0d51ee4
| x14: 0000000000000000 x13: 3435646532346561 x12: 3437336266666666
| x11: 203a706d61727420 x10: 6465746365707865 x9 : ffffb374ae5149e8
| x8 : 336266666666203a x7 : 706d617274206465 x6 : 00000000fffff167
| x5 : ffff572bffbc4a08 x4 : 00000000fffff167 x3 : 0000000000000000
| x2 : 0000000000000000 x1 : ffff572b84461e00 x0 : 0000000000000022
| Call trace:
|  ftrace_bug+0x280/0x2b0
|  ftrace_replace_code+0x98/0xa0
|  ftrace_modify_all_code+0xe0/0x144
|  arch_ftrace_update_code+0x14/0x20
|  ftrace_startup+0xf8/0x1b0
|  register_ftrace_function+0x38/0x90
|  test_ftrace_init+0xd0/0x1000 [test_ftrace]
|  do_one_initcall+0x50/0x2b0
|  do_init_module+0x50/0x1f0
|  load_module+0x17c8/0x1d64
|  __do_sys_finit_module+0xa8/0x100
|  __arm64_sys_finit_module+0x2c/0x3c
|  invoke_syscall+0x50/0x120
|  el0_svc_common.constprop.0+0xdc/0x100
|  do_el0_svc+0x3c/0xd0
|  el0_svc+0x34/0xb0
|  el0t_64_sync_handler+0xbc/0x140
|  el0t_64_sync+0x18c/0x190
| ---[ end trace 0000000000000000 ]---

We can solve this by consistently determining whether to use a PLT entry
for an address.

Note that since (the earlier) commit:

  f1a54ae9
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a6253579977e4c6f7818eeb05bf2bc65678a7187
  - https://git.kernel.org/stable/c/bc28fde90937a920f7714ec4408269cac744f796
  - https://git.kernel.org/stable/c/db73aa9466338ec821ed2a0b01721fe4d06876b1
  - https://git.kernel.org/stable/c/dcecc96ed16f73417de5550f384e348c9d56f279

------------------------------------------------------------

CVE ID: CVE-2022-49722
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: Fix memory corruption in VF driver

Disable VF's RX/TX queues, when it's disabled. VF can have queues enabled,
when it requests a reset. If PF driver assumes that VF is disabled,
while VF still has queues configured, VF may unmap DMA resources.
In such scenario device still can map packets to memory, which ends up
silently corrupting it.
Previously, VF driver could experience memory corruption, which lead to
crash:
[ 5119.170157] BUG: unable to handle kernel paging request at 00001b9780003237
[ 5119.170166] PGD 0 P4D 0
[ 5119.170173] Oops: 0002 [#1] PREEMPT_RT SMP PTI
[ 5119.170181] CPU: 30 PID: 427592 Comm: kworker/u96:2 Kdump: loaded Tainted: G        W I      --------- -  - 4.18.0-372.9.1.rt7.166.el8.x86_64 #1
[ 5119.170189] Hardware name: Dell Inc. PowerEdge R740/014X06, BIOS 2.3.10 08/15/2019
[ 5119.170193] Workqueue: iavf iavf_adminq_task [iavf]
[ 5119.170219] RIP: 0010:__page_frag_cache_drain+0x5/0x30
[ 5119.170238] Code: 0f 0f b6 77 51 85 f6 74 07 31 d2 e9 05 df ff ff e9 90 fe ff ff 48 8b 05 49 db 33 01 eb b4 0f 1f 80 00 00 00 00 0f 1f 44 00 00 <f0> 29 77 34 74 01 c3 48 8b 07 f6 c4 80 74 0f 0f b6 77 51 85 f6 74
[ 5119.170244] RSP: 0018:ffffa43b0bdcfd78 EFLAGS: 00010282
[ 5119.170250] RAX: ffffffff896b3e40 RBX: ffff8fb282524000 RCX: 0000000000000002
[ 5119.170254] RDX: 0000000049000000 RSI: 0000000000000000 RDI: 00001b9780003203
[ 5119.170259] RBP: ffff8fb248217b00 R08: 0000000000000022 R09: 0000000000000009
[ 5119.170262] R10: 2b849d6300000000 R11: 0000000000000020 R12: 0000000000000000
[ 5119.170265] R13: 0000000000001000 R14: 0000000000000009 R15: 0000000000000000
[ 5119.170269] FS:  0000000000000000(0000) GS:ffff8fb1201c0000(0000) knlGS:0000000000000000
[ 5119.170274] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 5119.170279] CR2: 00001b9780003237 CR3: 00000008f3e1a003 CR4: 00000000007726e0
[ 5119.170283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[ 5119.170286] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[ 5119.170290] PKRU: 55555554
[ 5119.170292] Call Trace:
[ 5119.170298]  iavf_clean_rx_ring+0xad/0x110 [iavf]
[ 5119.170324]  iavf_free_rx_resources+0xe/0x50 [iavf]
[ 5119.170342]  iavf_free_all_rx_resources.part.51+0x30/0x40 [iavf]
[ 5119.170358]  iavf_virtchnl_completion+0xd8a/0x15b0 [iavf]
[ 5119.170377]  ? iavf_clean_arq_element+0x210/0x280 [iavf]
[ 5119.170397]  iavf_adminq_task+0x126/0x2e0 [iavf]
[ 5119.170416]  process_one_work+0x18f/0x420
[ 5119.170429]  worker_thread+0x30/0x370
[ 5119.170437]  ? process_one_work+0x420/0x420
[ 5119.170445]  kthread+0x151/0x170
[ 5119.170452]  ? set_kthread_struct+0x40/0x40
[ 5119.170460]  ret_from_fork+0x35/0x40
[ 5119.170477] Modules linked in: iavf sctp ip6_udp_tunnel udp_tunnel mlx4_en mlx4_core nfp tls vhost_net vhost vhost_iotlb tap tun xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache sunrpc intel_rapl_msr iTCO_wdt iTCO_vendor_support dell_smbios wmi_bmof dell_wmi_descriptor dcdbas kvm_intel kvm irqbypass intel_rapl_common isst_if_common skx_edac irdma nfit libnvdimm x86_pkg_temp_thermal i40e intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ib_uverbs rapl ipmi_ssif intel_cstate intel_uncore mei_me pcspkr acpi_ipmi ib_core mei lpc_ich i2c_i801 ipmi_si ipmi_devintf wmi ipmi_msghandler acpi_power_meter xfs libcrc32c sd_mod t10_pi sg mgag200 drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops ice ahci drm libahci crc32c_intel libata tg3 megaraid_sas
[ 5119.170613]  i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod fuse [last unloaded: iavf]
[ 5119.170627] CR2: 00001b9780003237
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1bb8253b1dd44cf004e12c333acc6f25ee286cf3
  - https://git.kernel.org/stable/c/efe41860008e57fb6b69855b4b93fdf34bc42798

------------------------------------------------------------

CVE ID: CVE-2022-49723
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915/reset: Fix error_state_read ptr + offset use

Fix our pointer offset usage in error_state_read
when there is no i915_gpu_coredump but buf offset
is non-zero.

This fixes a kernel page fault can happen when
multiple tests are running concurrently in a loop
and one is producing engine resets and consuming
the i915 error_state dump while the other is
forcing full GT resets. (takes a while to trigger).

The dmesg call trace:

[ 5590.803000] BUG: unable to handle page fault for address:
               ffffffffa0b0e000
[ 5590.803009] #PF: supervisor read access in kernel mode
[ 5590.803013] #PF: error_code(0x0000) - not-present page
[ 5590.803016] PGD 5814067 P4D 5814067 PUD 5815063 PMD 109de4067
               PTE 0
[ 5590.803022] Oops: 0000 [#1] PREEMPT SMP NOPTI
[ 5590.803026] CPU: 5 PID: 13656 Comm: i915_hangman Tainted: G U
                    5.17.0-rc5-ups69-guc-err-capt-rev6+ #136
[ 5590.803033] Hardware name: Intel Corporation Alder Lake Client
                    Platform/AlderLake-M LP4x RVP, BIOS ADLPFWI1.R00.
                    3031.A02.2201171222	01/17/2022
[ 5590.803039] RIP: 0010:memcpy_erms+0x6/0x10
[ 5590.803045] Code: fe ff ff cc eb 1e 0f 1f 00 48 89 f8 48 89 d1
                     48 c1 e9 03 83 e2 07 f3 48 a5 89 d1 f3 a4 c3
                     66 0f 1f 44 00 00 48 89 f8 48 89 d1 <f3> a4
                     c3 0f 1f 80 00 00 00 00 48 89 f8 48 83 fa 20
                     72 7e 40 38 fe
[ 5590.803054] RSP: 0018:ffffc90003a8fdf0 EFLAGS: 00010282
[ 5590.803057] RAX: ffff888107ee9000 RBX: ffff888108cb1a00
               RCX: 0000000000000f8f
[ 5590.803061] RDX: 0000000000001000 RSI: ffffffffa0b0e000
               RDI: ffff888107ee9071
[ 5590.803065] RBP: 0000000000000000 R08: 0000000000000001
               R09: 0000000000000001
[ 5590.803069] R10: 0000000000000001 R11: 0000000000000002
               R12: 0000000000000019
[ 5590.803073] R13: 0000000000174fff R14: 0000000000001000
               R15: ffff888107ee9000
[ 5590.803077] FS: 00007f62a99bee80(0000) GS:ffff88849f880000(0000)
               knlGS:0000000000000000
[ 5590.803082] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 5590.803085] CR2: ffffffffa0b0e000 CR3: 000000010a1a8004
               CR4: 0000000000770ee0
[ 5590.803089] PKRU: 55555554
[ 5590.803091] Call Trace:
[ 5590.803093] <TASK>
[ 5590.803096] error_state_read+0xa1/0xd0 [i915]
[ 5590.803175] kernfs_fop_read_iter+0xb2/0x1b0
[ 5590.803180] new_sync_read+0x116/0x1a0
[ 5590.803185] vfs_read+0x114/0x1b0
[ 5590.803189] ksys_read+0x63/0xe0
[ 5590.803193] do_syscall_64+0x38/0xc0
[ 5590.803197] entry_SYSCALL_64_after_hwframe+0x44/0xae
[ 5590.803201] RIP: 0033:0x7f62aaea5912
[ 5590.803204] Code: c0 e9 b2 fe ff ff 50 48 8d 3d 5a b9 0c 00 e8 05
                     19 02 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25
                     18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff
                     ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24
[ 5590.803213] RSP: 002b:00007fff5b659ae8 EFLAGS: 00000246
               ORIG_RAX: 0000000000000000
[ 5590.803218] RAX: ffffffffffffffda RBX: 0000000000100000
               RCX: 00007f62aaea5912
[ 5590.803221] RDX: 000000000008b000 RSI: 00007f62a8c4000f
               RDI: 0000000000000006
[ 5590.803225] RBP: 00007f62a8bcb00f R08: 0000000000200010
               R09: 0000000000101000
[ 5590.803229] R10: 0000000000000001 R11: 0000000000000246
               R12: 0000000000000006
[ 5590.803233] R13: 0000000000075000 R14: 00007f62a8acb010
               R15: 0000000000200000
[ 5590.803238] </TASK>
[ 5590.803240] Modules linked in: i915 ttm drm_buddy drm_dp_helper
                        drm_kms_helper syscopyarea sysfillrect sysimgblt
                        fb_sys_fops prime_numbers nfnetlink br_netfilter
                        overlay mei_pxp mei_hdcp x86_pkg_temp_thermal
                        coretemp kvm_intel snd_hda_codec_hdmi snd_hda_intel
        
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/606e5d565605e26bf61a0933a6d56940f339c080
  - https://git.kernel.org/stable/c/63b26fe0252f923e6aca373e3ad4b31202dcd331
  - https://git.kernel.org/stable/c/c9b576d0c7bf55aeae1a736da7974fa202c4394d
  - https://git.kernel.org/stable/c/f4c5eba87675a07a6c28cdaca7366aeb4258ec78

------------------------------------------------------------

CVE ID: CVE-2022-49724
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: goldfish: Fix free_irq() on remove

Pass the correct dev_id to free_irq() to fix this splat when the driver
is unbound:

 WARNING: CPU: 0 PID: 30 at kernel/irq/manage.c:1895 free_irq
 Trying to free already-free IRQ 65
 Call Trace:
  warn_slowpath_fmt
  free_irq
  goldfish_tty_remove
  platform_remove
  device_remove
  device_release_driver_internal
  device_driver_detach
  unbind_store
  drv_attr_store
  ...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/499e13aac6c762e1e828172b0f0f5275651d6512
  - https://git.kernel.org/stable/c/65ca4db68b6819244df9024aea4be55edf8af1ef
  - https://git.kernel.org/stable/c/a6fcd7ffd76a9c1d998a2d02d518c78a55c5bed8
  - https://git.kernel.org/stable/c/c4b0b8edccb0cfb15a8cecf4161e0571d3daac64
  - https://git.kernel.org/stable/c/c83a1d40dc624070a203eb383ef9fb60eb634136
  - https://git.kernel.org/stable/c/f7183c76d500324b8b5bd0af5e663cfa57b7b836
  - https://git.kernel.org/stable/c/fb15e79cacddfbc62264e6e807bde50ad688e988

------------------------------------------------------------

CVE ID: CVE-2022-49725
Description: In the Linux kernel, the following vulnerability has been resolved:

i40e: Fix call trace in setup_tx_descriptors

After PF reset and ethtool -t there was call trace in dmesg
sometimes leading to panic. When there was some time, around 5
seconds, between reset and test there were no errors.

Problem was that pf reset calls i40e_vsi_close in prep_for_reset
and ethtool -t calls i40e_vsi_close in diag_test. If there was not
enough time between those commands the second i40e_vsi_close starts
before previous i40e_vsi_close was done which leads to crash.

Add check to diag_test if pf is in reset and don't start offline
tests if it is true.
Add netif_info("testing failed") into unhappy path of i40e_diag_test()
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a4e5a3dc5e41212870e6043895ae02455c93f63
  - https://git.kernel.org/stable/c/15950157e2c24865b696db1c9ccc72743ae0e967
  - https://git.kernel.org/stable/c/322271351b0e41565171e4cce70ea41854fac115
  - https://git.kernel.org/stable/c/5ba9956ca57e361fb13ea369bb753eb33177acc7
  - https://git.kernel.org/stable/c/814092927a215f5ca6c08249ec72a205e0b473cd
  - https://git.kernel.org/stable/c/fd5855e6b1358e816710afee68a1d2bc685176ca
  - https://git.kernel.org/stable/c/ff6e03fe84bc917bb0c907d02de668c2fe101712

------------------------------------------------------------

CVE ID: CVE-2022-49726
Description: In the Linux kernel, the following vulnerability has been resolved:

clocksource: hyper-v: unexport __init-annotated hv_init_clocksource()

EXPORT_SYMBOL and __init is a bad combination because the .init.text
section is freed up after the initialization. Hence, modules cannot
use symbols annotated __init. The access to a freed symbol may end up
with kernel panic.

modpost used to detect it, but it has been broken for a decade.

Recently, I fixed modpost so it started to warn it again, then this
showed up in linux-next builds.

There are two ways to fix it:

  - Remove __init
  - Remove EXPORT_SYMBOL

I chose the latter for this case because the only in-tree call-site,
arch/x86/kernel/cpu/mshyperv.c is never compiled as modular.
(CONFIG_HYPERVISOR_GUEST is boolean)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0414eab7c78f3518143d383e448d44fc573ac6d2
  - https://git.kernel.org/stable/c/245b993d8f6c4e25f19191edfbd8080b645e12b1
  - https://git.kernel.org/stable/c/937fcbb55a1e48a6422e87e8f49422c92265f102
  - https://git.kernel.org/stable/c/cff3a7ce6e81418b6e8bac941779bbf5d342d626
  - https://git.kernel.org/stable/c/db965e2757d95f695e606856418cd84003dd036d

------------------------------------------------------------

CVE ID: CVE-2022-49727
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: Fix signed integer overflow in l2tp_ip6_sendmsg

When len >= INT_MAX - transhdrlen, ulen = len + transhdrlen will be
overflow. To fix, we can follow what udpv6 does and subtract the
transhdrlen from the max.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.320
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/034246122f5c5e2e2a0b9fe04e24517920e9beb1
  - https://git.kernel.org/stable/c/0e818d433fc2718fe4da044ffca7431812a7e04e
  - https://git.kernel.org/stable/c/27a37755ceb401111ded76810359d3adc4b268a1
  - https://git.kernel.org/stable/c/2cf73c7cb6125083408d77f43d0e84d86aed0000
  - https://git.kernel.org/stable/c/2f42389d270f2304c8855b0b63498a5a4d0c053d
  - https://git.kernel.org/stable/c/6c4e3486d21173d60925ef52e512cae727b43d30
  - https://git.kernel.org/stable/c/b8879ca1fd7348b4d5db7db86dcb97f60c73d751
  - https://git.kernel.org/stable/c/f638a84afef3dfe10554c51820c16e39a278c915

------------------------------------------------------------

CVE ID: CVE-2022-49728
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: Fix signed integer overflow in __ip6_append_data

Resurrect ubsan overflow checks and ubsan report this warning,
fix it by change the variable [length] type to size_t.

UBSAN: signed-integer-overflow in net/ipv6/ip6_output.c:1489:19
2147479552 + 8567 cannot be represented in type 'int'
CPU: 0 PID: 253 Comm: err Not tainted 5.16.0+ #1
Hardware name: linux,dummy-virt (DT)
Call trace:
  dump_backtrace+0x214/0x230
  show_stack+0x30/0x78
  dump_stack_lvl+0xf8/0x118
  dump_stack+0x18/0x30
  ubsan_epilogue+0x18/0x60
  handle_overflow+0xd0/0xf0
  __ubsan_handle_add_overflow+0x34/0x44
  __ip6_append_data.isra.48+0x1598/0x1688
  ip6_append_data+0x128/0x260
  udpv6_sendmsg+0x680/0xdd0
  inet6_sendmsg+0x54/0x90
  sock_sendmsg+0x70/0x88
  ____sys_sendmsg+0xe8/0x368
  ___sys_sendmsg+0x98/0xe0
  __sys_sendmmsg+0xf4/0x3b8
  __arm64_sys_sendmmsg+0x34/0x48
  invoke_syscall+0x64/0x160
  el0_svc_common.constprop.4+0x124/0x300
  do_el0_svc+0x44/0xc8
  el0_svc+0x3c/0x1e8
  el0t_64_sync_handler+0x88/0xb0
  el0t_64_sync+0x16c/0x170

Changes since v1:
-Change the variable [length] type to unsigned, as Eric Dumazet suggested.
Changes since v2:
-Don't change exthdrlen type in ip6_make_skb, as Paolo Abeni suggested.
Changes since v3:
-Don't change ulen type in udpv6_sendmsg and l2tp_ip6_sendmsg, as
Jakub Kicinski suggested.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/70549c80fe80ac4e2a22068c76ebebced24f7e74
  - https://git.kernel.org/stable/c/84dc940890e91e42898e4443a093281702440abf
  - https://git.kernel.org/stable/c/f26422eabeb517629568edf8c2dd9c6cb9147584
  - https://git.kernel.org/stable/c/f93431c86b631bbca5614c66f966bf3ddb3c2803

------------------------------------------------------------

CVE ID: CVE-2022-49729
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: nfcmrvl: Fix memory leak in nfcmrvl_play_deferred

Similar to the handling of play_deferred in commit 19cfe912c37b
("Bluetooth: btusb: Fix memory leak in play_deferred"), we thought
a patch might be needed here as well.

Currently usb_submit_urb is called directly to submit deferred tx
urbs after unanchor them.

So the usb_giveback_urb_bh would failed to unref it in usb_unanchor_urb
and cause memory leak.

Put those urbs in tx_anchor to avoid the leak, and also fix the error
handling.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.320
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0eeec1a8b0cd38c47edeb042980a6aeacecf35ed
  - https://git.kernel.org/stable/c/1eb0afecfb9cd0f38424b82bd9aaa542310934ee
  - https://git.kernel.org/stable/c/3e7c7df6991ac349f2fa8540047757df666e610f
  - https://git.kernel.org/stable/c/3eadc560c1919b8193d17334145dad9a917960e4
  - https://git.kernel.org/stable/c/6616872cfe7f0474a22dd1f12699f95bcf81a54d
  - https://git.kernel.org/stable/c/6b4d8b44e7163a77fe942f5b80e1651c1b78c537
  - https://git.kernel.org/stable/c/8a4d480702b71184fabcf379b80bf7539716752e
  - https://git.kernel.org/stable/c/f21f908347712b8288ffe83b531b5e977042b29c

------------------------------------------------------------

CVE ID: CVE-2022-49730
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Resolve NULL ptr dereference after an ELS LOGO is aborted

A use-after-free crash can occur after an ELS LOGO is aborted.

Specifically, a nodelist structure is freed and then
ndlp->vport->cfg_log_verbose is dereferenced in lpfc_nlp_get() when the
discovery state machine is mistakenly called a second time with
NLP_EVT_DEVICE_RM argument.

Rework lpfc_cmpl_els_logo() to prevent the duplicate calls to release a
nodelist structure.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5e83869e29448958f8ae2c6911f350318f75e4fc
  - https://git.kernel.org/stable/c/b1b3440f437b75fb2a9b0cfe58df461e40eca474
  - https://git.kernel.org/stable/c/eea34ce23dc3a595695856dc73bb132a9c5a2902

------------------------------------------------------------

CVE ID: CVE-2022-49731
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: libata-core: fix NULL pointer deref in ata_host_alloc_pinfo()

In an unlikely (and probably wrong?) case that the 'ppi' parameter of
ata_host_alloc_pinfo() points to an array starting with a NULL pointer,
there's going to be a kernel oops as the 'pi' local variable won't get
reassigned from the initial value of NULL. Initialize 'pi' instead to
'&ata_dummy_port_info' to fix the possible kernel oops for good...

Found by Linux Verification Center (linuxtesting.org) with the SVACE static
analysis tool.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.320
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.285
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.249
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.200
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.124
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.49
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.18.6
  - Vendor: linux, Product: linux_kernel, Version: 5.19, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07cbdb4807d369fbda73062a91b570c4dc5ec429
  - https://git.kernel.org/stable/c/1ac5efee33f29e704226506d429b84575a5d66f8
  - https://git.kernel.org/stable/c/253334f84c81bc6a43af489f108c0bddad989eef
  - https://git.kernel.org/stable/c/36cd19e7d4e5571d77a2ed20c5b6ef50cf57734a
  - https://git.kernel.org/stable/c/a810bd5af06977a847d1f202b22d7defd5c62497
  - https://git.kernel.org/stable/c/bf476fe22aa1851bab4728e0c49025a6a0bea307
  - https://git.kernel.org/stable/c/ca4693e6e06e4fd2b240c0fec47aa2498c94848e
  - https://git.kernel.org/stable/c/ff128fbea720bf763fa345680dda5f050bc24a47

------------------------------------------------------------

CVE ID: CVE-2022-49732
Description: In the Linux kernel, the following vulnerability has been resolved:

sock: redo the psock vs ULP protection check

Commit 8a59f9d1e3d4 ("sock: Introduce sk->sk_prot->psock_update_sk_prot()")
has moved the inet_csk_has_ulp(sk) check from sk_psock_init() to
the new tcp_bpf_update_proto() function. I'm guessing that this
was done to allow creating psocks for non-inet sockets.

Unfortunately the destruction path for psock includes the ULP
unwind, so we need to fail the sk_psock_init() itself.
Otherwise if ULP is already present we'll notice that later,
and call tcp_update_ulp() with the sk_proto of the ULP
itself, which will most likely result in the ULP looping
its callbacks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/72fa0f65b56605b8a9ae9fba2082f2123f7fe017
  - https://git.kernel.org/stable/c/922309e50befb0cfa5cb65e4989b7706d6578846
  - https://git.kernel.org/stable/c/e34a07c0ae3906f97eb18df50902e2a01c1015b6

------------------------------------------------------------

CVE ID: CVE-2025-1726
Description: There is a SQL injection issue in Esri ArcGIS Monitor versions 2023.0 through 2024.x on Windows and Linux that allows a remote, authenticated attacker with low privileges to improperly read limited database schema information by passing crafted queries. While it is possible to enumerate some internal database identifiers, the impact to the confidentiality vector is "LOW' because any sensitive data returned in a response is encrypted. There is no evidence of impact to the integrity or availability vectors. This issue is addressed in ArcGIS Monitor 2024.1.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N
CPEs:
  - No CPE data available.
References:
  - https://www.esri.com/arcgis-blog/products/monitor/administration/whats-new-in-arcgis-monitor-2024-1/

------------------------------------------------------------

CVE ID: CVE-2024-57953
Description: In the Linux kernel, the following vulnerability has been resolved:

rtc: tps6594: Fix integer overflow on 32bit systems

The problem is this multiply in tps6594_rtc_set_offset()

	tmp = offset * TICKS_PER_HOUR;

The "tmp" variable is an s64 but "offset" is a long in the
(-277774)-277774 range.  On 32bit systems a long can hold numbers up to
approximately two billion.  The number of TICKS_PER_HOUR is really large,
(32768 * 3600) or roughly a hundred million.  When you start multiplying
by a hundred million it doesn't take long to overflow the two billion
mark.

Probably the safest way to fix this is to change the type of
TICKS_PER_HOUR to long long because it's such a large number.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/09c4a610153286cef54d4f0c85398f4e32fc227e
  - https://git.kernel.org/stable/c/5127f3cbfc78a7b301b86328247230bec47e0bb3
  - https://git.kernel.org/stable/c/53b0c7b15accb18d15d95c7fe68f61630ebfd1ca

------------------------------------------------------------

CVE ID: CVE-2024-57973
Description: In the Linux kernel, the following vulnerability has been resolved:

rdma/cxgb4: Prevent potential integer overflow on 32bit

The "gl->tot_len" variable is controlled by the user.  It comes from
process_responses().  On 32bit systems, the "gl->tot_len + sizeof(struct
cpl_pass_accept_req) + sizeof(struct rss_header)" addition could have an
integer wrapping bug.  Use size_add() to prevent this.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.8, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2b759f78b83221f4a1cae3aeb20b500e375f3ee6
  - https://git.kernel.org/stable/c/4422f452d028850b9cc4fd8f1cf45a8ff91855eb
  - https://git.kernel.org/stable/c/aeb814484387811b3579d5c78ad4eb301e3bf1c8
  - https://git.kernel.org/stable/c/bd96a3935e89486304461a21752f824fc25e0f0b
  - https://git.kernel.org/stable/c/d64148a10a85952352de6091ceed99fb9ce2d3ee
  - https://git.kernel.org/stable/c/dd352107f22bfbecbbf3b74bde14f3f932296309
  - https://git.kernel.org/stable/c/de8d88b68d0cfd41152a7a63d6aec0ed3e1b837a
  - https://git.kernel.org/stable/c/e53ca458f543aa352d09b484550de173cb9085c2

------------------------------------------------------------

CVE ID: CVE-2024-57974
Description: In the Linux kernel, the following vulnerability has been resolved:

udp: Deal with race between UDP socket address change and rehash

If a UDP socket changes its local address while it's receiving
datagrams, as a result of connect(), there is a period during which
a lookup operation might fail to find it, after the address is changed
but before the secondary hash (port and address) and the four-tuple
hash (local and remote ports and addresses) are updated.

Secondary hash chains were introduced by commit 30fff9231fad ("udp:
bind() optimisation") and, as a result, a rehash operation became
needed to make a bound socket reachable again after a connect().

This operation was introduced by commit 719f835853a9 ("udp: add
rehash on connect()") which isn't however a complete fix: the
socket will be found once the rehashing completes, but not while
it's pending.

This is noticeable with a socat(1) server in UDP4-LISTEN mode, and a
client sending datagrams to it. After the server receives the first
datagram (cf. _xioopen_ipdgram_listen()), it issues a connect() to
the address of the sender, in order to set up a directed flow.

Now, if the client, running on a different CPU thread, happens to
send a (subsequent) datagram while the server's socket changes its
address, but is not rehashed yet, this will result in a failed
lookup and a port unreachable error delivered to the client, as
apparent from the following reproducer:

  LEN=$(($(cat /proc/sys/net/core/wmem_default) / 4))
  dd if=/dev/urandom bs=1 count=${LEN} of=tmp.in

  while :; do
  	taskset -c 1 socat UDP4-LISTEN:1337,null-eof OPEN:tmp.out,create,trunc &
  	sleep 0.1 || sleep 1
  	taskset -c 2 socat OPEN:tmp.in UDP4:localhost:1337,shut-null
  	wait
  done

where the client will eventually get ECONNREFUSED on a write()
(typically the second or third one of a given iteration):

  2024/11/13 21:28:23 socat[46901] E write(6, 0x556db2e3c000, 8192): Connection refused

This issue was first observed as a seldom failure in Podman's tests
checking UDP functionality while using pasta(1) to connect the
container's network namespace, which leads us to a reproducer with
the lookup error resulting in an ICMP packet on a tap device:

  LOCAL_ADDR="$(ip -j -4 addr show|jq -rM '.[] | .addr_info[0] | select(.scope == "global").local')"

  while :; do
  	./pasta --config-net -p pasta.pcap -u 1337 socat UDP4-LISTEN:1337,null-eof OPEN:tmp.out,create,trunc &
  	sleep 0.2 || sleep 1
  	socat OPEN:tmp.in UDP4:${LOCAL_ADDR}:1337,shut-null
  	wait
  	cmp tmp.in tmp.out
  done

Once this fails:

  tmp.in tmp.out differ: char 8193, line 29

we can finally have a look at what's going on:

  $ tshark -r pasta.pcap
      1   0.000000           :: ? ff02::16     ICMPv6 110 Multicast Listener Report Message v2
      2   0.168690 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192
      3   0.168767 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192
      4   0.168806 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192
      5   0.168827 c6:47:05:8d:dc:04 ? Broadcast    ARP 42 Who has 88.198.0.161? Tell 88.198.0.164
      6   0.168851 9a:55:9a:55:9a:55 ? c6:47:05:8d:dc:04 ARP 42 88.198.0.161 is at 9a:55:9a:55:9a:55
      7   0.168875 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192
      8   0.168896 88.198.0.164 ? 88.198.0.161 ICMP 590 Destination unreachable (Port unreachable)
      9   0.168926 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192
     10   0.168959 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192
     11   0.168989 88.198.0.161 ? 88.198.0.164 UDP 4138 60260 ? 1337 Len=4096
     12   0.169010 88.198.0.161 ? 88.198.0.164 UDP 42 60260 ? 1337 Len=0

On the third datagram received, the network namespace of the container
initiates an ARP lookup to deliver the ICMP message.

In another variant of this reproducer, starting the client with:

  strace -f pasta --config-net -u 1337 socat UDP4-LISTEN:1337,null-eof OPEN:tmp.out,create,tru
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4f8344fce91c5766d368edb0ad80142eacd805c7
  - https://git.kernel.org/stable/c/a502ea6fa94b1f7be72a24bcf9e3f5f6b7e6e90c
  - https://git.kernel.org/stable/c/d65d3bf309b2649d27b24efd0d8784da2d81f2a6

------------------------------------------------------------

CVE ID: CVE-2024-57975
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: do proper folio cleanup when run_delalloc_nocow() failed

[BUG]
With CONFIG_DEBUG_VM set, test case generic/476 has some chance to crash
with the following VM_BUG_ON_FOLIO():

  BTRFS error (device dm-3): cow_file_range failed, start 1146880 end 1253375 len 106496 ret -28
  BTRFS error (device dm-3): run_delalloc_nocow failed, start 1146880 end 1253375 len 106496 ret -28
  page: refcount:4 mapcount:0 mapping:00000000592787cc index:0x12 pfn:0x10664
  aops:btrfs_aops [btrfs] ino:101 dentry name(?):"f1774"
  flags: 0x2fffff80004028(uptodate|lru|private|node=0|zone=2|lastcpupid=0xfffff)
  page dumped because: VM_BUG_ON_FOLIO(!folio_test_locked(folio))
  ------------[ cut here ]------------
  kernel BUG at mm/page-writeback.c:2992!
  Internal error: Oops - BUG: 00000000f2000800 [#1] SMP
  CPU: 2 UID: 0 PID: 3943513 Comm: kworker/u24:15 Tainted: G           OE      6.12.0-rc7-custom+ #87
  Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022
  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]
  pc : folio_clear_dirty_for_io+0x128/0x258
  lr : folio_clear_dirty_for_io+0x128/0x258
  Call trace:
   folio_clear_dirty_for_io+0x128/0x258
   btrfs_folio_clamp_clear_dirty+0x80/0xd0 [btrfs]
   __process_folios_contig+0x154/0x268 [btrfs]
   extent_clear_unlock_delalloc+0x5c/0x80 [btrfs]
   run_delalloc_nocow+0x5f8/0x760 [btrfs]
   btrfs_run_delalloc_range+0xa8/0x220 [btrfs]
   writepage_delalloc+0x230/0x4c8 [btrfs]
   extent_writepage+0xb8/0x358 [btrfs]
   extent_write_cache_pages+0x21c/0x4e8 [btrfs]
   btrfs_writepages+0x94/0x150 [btrfs]
   do_writepages+0x74/0x190
   filemap_fdatawrite_wbc+0x88/0xc8
   start_delalloc_inodes+0x178/0x3a8 [btrfs]
   btrfs_start_delalloc_roots+0x174/0x280 [btrfs]
   shrink_delalloc+0x114/0x280 [btrfs]
   flush_space+0x250/0x2f8 [btrfs]
   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]
   process_one_work+0x164/0x408
   worker_thread+0x25c/0x388
   kthread+0x100/0x118
   ret_from_fork+0x10/0x20
  Code: 910a8021 a90363f7 a9046bf9 94012379 (d4210000)
  ---[ end trace 0000000000000000 ]---

[CAUSE]
The first two lines of extra debug messages show the problem is caused
by the error handling of run_delalloc_nocow().

E.g. we have the following dirtied range (4K blocksize 4K page size):

    0                 16K                  32K
    |//////////////////////////////////////|
    |  Pre-allocated  |

And the range [0, 16K) has a preallocated extent.

- Enter run_delalloc_nocow() for range [0, 16K)
  Which found range [0, 16K) is preallocated, can do the proper NOCOW
  write.

- Enter fallback_to_fow() for range [16K, 32K)
  Since the range [16K, 32K) is not backed by preallocated extent, we
  have to go COW.

- cow_file_range() failed for range [16K, 32K)
  So cow_file_range() will do the clean up by clearing folio dirty,
  unlock the folios.

  Now the folios in range [16K, 32K) is unlocked.

- Enter extent_clear_unlock_delalloc() from run_delalloc_nocow()
  Which is called with PAGE_START_WRITEBACK to start page writeback.
  But folios can only be marked writeback when it's properly locked,
  thus this triggered the VM_BUG_ON_FOLIO().

Furthermore there is another hidden but common bug that
run_delalloc_nocow() is not clearing the folio dirty flags in its error
handling path.
This is the common bug shared between run_delalloc_nocow() and
cow_file_range().

[FIX]
- Clear folio dirty for range [@start, @cur_offset)
  Introduce a helper, cleanup_dirty_folios(), which
  will find and lock the folio in the range, clear the dirty flag and
  start/end the writeback, with the extra handling for the
  @locked_folio.

- Introduce a helper to clear folio dirty, start and end writeback

- Introduce a helper to record the last failed COW range end
  This is to trace which range we should skip, to avoid double
  unlocking.

- Skip the failed COW range for the e
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2434533f1c963e7317c45880c98287e5bed98325
  - https://git.kernel.org/stable/c/5ae72abbf91eb172ce3a838a4dc34be3c9707296
  - https://git.kernel.org/stable/c/c2b47df81c8e20a8e8cd94f0d7df211137ae94ed

------------------------------------------------------------

CVE ID: CVE-2024-57976
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: do proper folio cleanup when cow_file_range() failed

[BUG]
When testing with COW fixup marked as BUG_ON() (this is involved with the
new pin_user_pages*() change, which should not result new out-of-band
dirty pages), I hit a crash triggered by the BUG_ON() from hitting COW
fixup path.

This BUG_ON() happens just after a failed btrfs_run_delalloc_range():

  BTRFS error (device dm-2): failed to run delalloc range, root 348 ino 405 folio 65536 submit_bitmap 6-15 start 90112 len 106496: -28
  ------------[ cut here ]------------
  kernel BUG at fs/btrfs/extent_io.c:1444!
  Internal error: Oops - BUG: 00000000f2000800 [#1] SMP
  CPU: 0 UID: 0 PID: 434621 Comm: kworker/u24:8 Tainted: G           OE      6.12.0-rc7-custom+ #86
  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022
  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]
  pc : extent_writepage_io+0x2d4/0x308 [btrfs]
  lr : extent_writepage_io+0x2d4/0x308 [btrfs]
  Call trace:
   extent_writepage_io+0x2d4/0x308 [btrfs]
   extent_writepage+0x218/0x330 [btrfs]
   extent_write_cache_pages+0x1d4/0x4b0 [btrfs]
   btrfs_writepages+0x94/0x150 [btrfs]
   do_writepages+0x74/0x190
   filemap_fdatawrite_wbc+0x88/0xc8
   start_delalloc_inodes+0x180/0x3b0 [btrfs]
   btrfs_start_delalloc_roots+0x174/0x280 [btrfs]
   shrink_delalloc+0x114/0x280 [btrfs]
   flush_space+0x250/0x2f8 [btrfs]
   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]
   process_one_work+0x164/0x408
   worker_thread+0x25c/0x388
   kthread+0x100/0x118
   ret_from_fork+0x10/0x20
  Code: aa1403e1 9402f3ef aa1403e0 9402f36f (d4210000)
  ---[ end trace 0000000000000000 ]---

[CAUSE]
That failure is mostly from cow_file_range(), where we can hit -ENOSPC.

Although the -ENOSPC is already a bug related to our space reservation
code, let's just focus on the error handling.

For example, we have the following dirty range [0, 64K) of an inode,
with 4K sector size and 4K page size:

   0        16K        32K       48K       64K
   |///////////////////////////////////////|
   |#######################################|

Where |///| means page are still dirty, and |###| means the extent io
tree has EXTENT_DELALLOC flag.

- Enter extent_writepage() for page 0

- Enter btrfs_run_delalloc_range() for range [0, 64K)

- Enter cow_file_range() for range [0, 64K)

- Function btrfs_reserve_extent() only reserved one 16K extent
  So we created extent map and ordered extent for range [0, 16K)

   0        16K        32K       48K       64K
   |////////|//////////////////////////////|
   |<- OE ->|##############################|

   And range [0, 16K) has its delalloc flag cleared.
   But since we haven't yet submit any bio, involved 4 pages are still
   dirty.

- Function btrfs_reserve_extent() returns with -ENOSPC
  Now we have to run error cleanup, which will clear all
  EXTENT_DELALLOC* flags and clear the dirty flags for the remaining
  ranges:

   0        16K        32K       48K       64K
   |////////|                              |
   |        |                              |

  Note that range [0, 16K) still has its pages dirty.

- Some time later, writeback is triggered again for the range [0, 16K)
  since the page range still has dirty flags.

- btrfs_run_delalloc_range() will do nothing because there is no
  EXTENT_DELALLOC flag.

- extent_writepage_io() finds page 0 has no ordered flag
  Which falls into the COW fixup path, triggering the BUG_ON().

Unfortunately this error handling bug dates back to the introduction of
btrfs.  Thankfully with the abuse of COW fixup, at least it won't crash
the kernel.

[FIX]
Instead of immediately unlocking the extent and folios, we keep the extent
and folios locked until either erroring out or the whole delalloc range
finished.

When the whole delalloc range finished without error, we just unlock the
whole range with PAGE_SET_ORDERED (and PAGE_UNLOCK for !keep_locked
cases)
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/06f364284794f149d2abc167c11d556cf20c954b
  - https://git.kernel.org/stable/c/692cf71173bb41395c855acbbbe197d3aedfa5d4

------------------------------------------------------------

CVE ID: CVE-2024-57977
Description: In the Linux kernel, the following vulnerability has been resolved:

memcg: fix soft lockup in the OOM process

A soft lockup issue was found in the product with about 56,000 tasks were
in the OOM cgroup, it was traversing them when the soft lockup was
triggered.

watchdog: BUG: soft lockup - CPU#2 stuck for 23s! [VM Thread:1503066]
CPU: 2 PID: 1503066 Comm: VM Thread Kdump: loaded Tainted: G
Hardware name: Huawei Cloud OpenStack Nova, BIOS
RIP: 0010:console_unlock+0x343/0x540
RSP: 0000:ffffb751447db9a0 EFLAGS: 00000247 ORIG_RAX: ffffffffffffff13
RAX: 0000000000000001 RBX: 0000000000000000 RCX: 00000000ffffffff
RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000247
RBP: ffffffffafc71f90 R08: 0000000000000000 R09: 0000000000000040
R10: 0000000000000080 R11: 0000000000000000 R12: ffffffffafc74bd0
R13: ffffffffaf60a220 R14: 0000000000000247 R15: 0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f2fe6ad91f0 CR3: 00000004b2076003 CR4: 0000000000360ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 vprintk_emit+0x193/0x280
 printk+0x52/0x6e
 dump_task+0x114/0x130
 mem_cgroup_scan_tasks+0x76/0x100
 dump_header+0x1fe/0x210
 oom_kill_process+0xd1/0x100
 out_of_memory+0x125/0x570
 mem_cgroup_out_of_memory+0xb5/0xd0
 try_charge+0x720/0x770
 mem_cgroup_try_charge+0x86/0x180
 mem_cgroup_try_charge_delay+0x1c/0x40
 do_anonymous_page+0xb5/0x390
 handle_mm_fault+0xc4/0x1f0

This is because thousands of processes are in the OOM cgroup, it takes a
long time to traverse all of them.  As a result, this lead to soft lockup
in the OOM process.

To fix this issue, call 'cond_resched' in the 'mem_cgroup_scan_tasks'
function per 1000 iterations.  For global OOM, call
'touch_softlockup_watchdog' per 1000 iterations to avoid this issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.6, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0a09d56e1682c951046bf15542b3e9553046c9f6
  - https://git.kernel.org/stable/c/110399858194c71f11afefad6e7be9e3876b284f
  - https://git.kernel.org/stable/c/46576834291869457d4772bb7df72d7c2bb3d57f
  - https://git.kernel.org/stable/c/72f2c0b7c152c2983ed51d48c3272cab4f34d965
  - https://git.kernel.org/stable/c/972486d37169fe85035e81b8c5dff21f70df1173
  - https://git.kernel.org/stable/c/a9042dbc1ed4bf25a5f5c699d10c3d676abf8ca2
  - https://git.kernel.org/stable/c/ade81479c7dda1ce3eedb215c78bc615bbd04f06
  - https://git.kernel.org/stable/c/c3a3741db8c1202aa959c77df3a4c361612d1eb1

------------------------------------------------------------

CVE ID: CVE-2024-57978
Description: In the Linux kernel, the following vulnerability has been resolved:

media: imx-jpeg: Fix potential error pointer dereference in detach_pm()

The proble is on the first line:

	if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))

If jpeg->pd_dev[i] is an error pointer, then passing it to
pm_runtime_suspended() will lead to an Oops.  The other conditions
check for both error pointers and NULL, but it would be more clear to
use the IS_ERR_OR_NULL() check for that.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.174, Last Version (Excluding): 5.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.120, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.64, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.4, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/1378ffec30367233152b7dbf4fa6a25ee98585d1
  - https://git.kernel.org/stable/c/1b2af918bb714937a8be6cb637f528585461cd98
  - https://git.kernel.org/stable/c/6e601a64f7777e2f78c02db1a8b5ba3b7c5e9e31
  - https://git.kernel.org/stable/c/a32ba399a030853f2db45a90ba5474fdd3494aad
  - https://git.kernel.org/stable/c/f0b8535a7885ed4fd0b11625addb5476cae0f845
  - https://git.kernel.org/stable/c/fde89fe11b44500bfcb2d405825b69a5df805d19

------------------------------------------------------------

CVE ID: CVE-2024-57979
Description: In the Linux kernel, the following vulnerability has been resolved:

pps: Fix a use-after-free

On a board running ntpd and gpsd, I'm seeing a consistent use-after-free
in sys_exit() from gpsd when rebooting:

    pps pps1: removed
    ------------[ cut here ]------------
    kobject: '(null)' (00000000db4bec24): is not initialized, yet kobject_put() is being called.
    WARNING: CPU: 2 PID: 440 at lib/kobject.c:734 kobject_put+0x120/0x150
    CPU: 2 UID: 299 PID: 440 Comm: gpsd Not tainted 6.11.0-rc6-00308-gb31c44928842 #1
    Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT)
    pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    pc : kobject_put+0x120/0x150
    lr : kobject_put+0x120/0x150
    sp : ffffffc0803d3ae0
    x29: ffffffc0803d3ae0 x28: ffffff8042dc9738 x27: 0000000000000001
    x26: 0000000000000000 x25: ffffff8042dc9040 x24: ffffff8042dc9440
    x23: ffffff80402a4620 x22: ffffff8042ef4bd0 x21: ffffff80405cb600
    x20: 000000000008001b x19: ffffff8040b3b6e0 x18: 0000000000000000
    x17: 0000000000000000 x16: 0000000000000000 x15: 696e6920746f6e20
    x14: 7369203a29343263 x13: 205d303434542020 x12: 0000000000000000
    x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000
    x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000
    x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000
    x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000
    Call trace:
     kobject_put+0x120/0x150
     cdev_put+0x20/0x3c
     __fput+0x2c4/0x2d8
     ____fput+0x1c/0x38
     task_work_run+0x70/0xfc
     do_exit+0x2a0/0x924
     do_group_exit+0x34/0x90
     get_signal+0x7fc/0x8c0
     do_signal+0x128/0x13b4
     do_notify_resume+0xdc/0x160
     el0_svc+0xd4/0xf8
     el0t_64_sync_handler+0x140/0x14c
     el0t_64_sync+0x190/0x194
    ---[ end trace 0000000000000000 ]---

...followed by more symptoms of corruption, with similar stacks:

    refcount_t: underflow; use-after-free.
    kernel BUG at lib/list_debug.c:62!
    Kernel panic - not syncing: Oops - BUG: Fatal exception

This happens because pps_device_destruct() frees the pps_device with the
embedded cdev immediately after calling cdev_del(), but, as the comment
above cdev_del() notes, fops for previously opened cdevs are still
callable even after cdev_del() returns. I think this bug has always
been there: I can't explain why it suddenly started happening every time
I reboot this particular board.

In commit d953e0e837e6 ("pps: Fix a use-after free bug when
unregistering a source."), George Spelvin suggested removing the
embedded cdev. That seems like the simplest way to fix this, so I've
implemented his suggestion, using __register_chrdev() with pps_idr
becoming the source of truth for which minor corresponds to which
device.

But now that pps_idr defines userspace visibility instead of cdev_add(),
we need to be sure the pps->dev refcount can't reach zero while
userspace can still find it again. So, the idr_remove() call moves to
pps_unregister_cdev(), and pps_idr now holds a reference to pps->dev.

    pps_core: source serial1 got cdev (251:1)
    <...>
    pps pps1: removed
    pps_core: unregistering pps1
    pps_core: deallocating pps1
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.2.40, Last Version (Excluding): 3.3
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.4.87, Last Version (Excluding): 3.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.8.1, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/1a7735ab2cb9747518a7416fb5929e85442dec62
  - https://git.kernel.org/stable/c/785c78ed0d39d1717cca3ef931d3e51337b5e90e
  - https://git.kernel.org/stable/c/7e5ee3281dc09014367f5112b6d566ba36ea2d49
  - https://git.kernel.org/stable/c/85241f7de216f8298f6e48540ea13d7dcd100870
  - https://git.kernel.org/stable/c/91932db1d96b2952299ce30c1c693d834d10ace6
  - https://git.kernel.org/stable/c/c4041b6b0a7a3def8cf3f3d6120ff337bc4c40f7
  - https://git.kernel.org/stable/c/c79a39dc8d060b9e64e8b0fa9d245d44befeefbe
  - https://git.kernel.org/stable/c/cd3bbcb6b3a7caa5ce67de76723b6d8531fb7f64

------------------------------------------------------------

CVE ID: CVE-2024-57980
Description: In the Linux kernel, the following vulnerability has been resolved:

media: uvcvideo: Fix double free in error path

If the uvc_status_init() function fails to allocate the int_urb, it will
free the dev->status pointer but doesn't reset the pointer to NULL. This
results in the kfree() call in uvc_status_cleanup() trying to
double-free the memory. Fix it by resetting the dev->status pointer to
NULL after freeing it.

Reviewed by: Ricardo Ribalda <ribalda@chromium.org>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.28, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/3ba8884a56a3eb97c22f0ce0e4dd410d4ca4c277
  - https://git.kernel.org/stable/c/6c36dcd662ec5276782838660f8533a7cb26be49
  - https://git.kernel.org/stable/c/87522ef165e5b6de8ef98cc318f3335166a1512c
  - https://git.kernel.org/stable/c/9232719ac9ce4d5c213cebda23d72aec3e1c4c0d
  - https://git.kernel.org/stable/c/c6ef3a7fa97ec823a1e1af9085cf13db9f7b3bac
  - https://git.kernel.org/stable/c/d1f8e69eec91d5a75ef079778a5d0151db2a7f22
  - https://git.kernel.org/stable/c/d6e5ba2516c5bef87c1fcb8189b6f3cad7c64b2d
  - https://git.kernel.org/stable/c/d8e63dd7b6683969d3d47c7b8e9635f96d554ad4

------------------------------------------------------------

CVE ID: CVE-2024-57981
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: xhci: Fix NULL pointer dereference on certain command aborts

If a command is queued to the final usable TRB of a ring segment, the
enqueue pointer is advanced to the subsequent link TRB and no further.
If the command is later aborted, when the abort completion is handled
the dequeue pointer is advanced to the first TRB of the next segment.

If no further commands are queued, xhci_handle_stopped_cmd_ring() sees
the ring pointers unequal and assumes that there is a pending command,
so it calls xhci_mod_cmd_timer() which crashes if cur_cmd was NULL.

Don't attempt timer setup if cur_cmd is NULL. The subsequent doorbell
ring likely is unnecessary too, but it's harmless. Leave it alone.

This is probably Bug 219532, but no confirmation has been received.

The issue has been independently reproduced and confirmed fixed using
a USB MCU programmed to NAK the Status stage of SET_ADDRESS forever.
Everything continued working normally after several prevented crashes.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0ce5c0dac768be14afe2426101b568a0f66bfc4d
  - https://git.kernel.org/stable/c/1e0a19912adb68a4b2b74fd77001c96cd83eb073
  - https://git.kernel.org/stable/c/4ff18870af793ce2034a6ad746e91d0a3d985b88
  - https://git.kernel.org/stable/c/ae069cd2ba09a2bd6a87a68c59ef0b7ea39cd641
  - https://git.kernel.org/stable/c/b44253956407046e5907d4d72c8fa5b93ae94485
  - https://git.kernel.org/stable/c/b649f0d5bc256f691c7d234c3986685d54053de1
  - https://git.kernel.org/stable/c/cf30300a216a4f8dce94e11781a866a09d4b50d4
  - https://git.kernel.org/stable/c/fd8bfaeba4a85b14427899adec0efb3954300653

------------------------------------------------------------

CVE ID: CVE-2024-57982
Description: In the Linux kernel, the following vulnerability has been resolved:

xfrm: state: fix out-of-bounds read during lookup

lookup and resize can run in parallel.

The xfrm_state_hash_generation seqlock ensures a retry, but the hash
functions can observe a hmask value that is too large for the new hlist
array.

rehash does:
  rcu_assign_pointer(net->xfrm.state_bydst, ndst) [..]
  net->xfrm.state_hmask = nhashmask;

While state lookup does:
  h = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family);
  hlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) {

This is only safe in case the update to state_bydst is larger than
net->xfrm.xfrm_state_hmask (or if the lookup function gets
serialized via state spinlock again).

Fix this by prefetching state_hmask and the associated pointers.
The xfrm_state_hash_generation seqlock retry will ensure that the pointer
and the hmask will be consistent.

The existing helpers, like xfrm_dst_hash(), are now unsafe for RCU side,
add lockdep assertions to document that they are only safe for insert
side.

xfrm_state_lookup_byaddr() uses the spinlock rather than RCU.
AFAICS this is an oversight from back when state lookup was converted to
RCU, this lock should be replaced with RCU in a future patch.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/a16871c7832ea6435abb6e0b58289ae7dcb7e4fc
  - https://git.kernel.org/stable/c/dd4c2a174994238d55ab54da2545543d36f4e0d0
  - https://git.kernel.org/stable/c/e952837f3ddb0ff726d5b582aa1aad9aa38d024d

------------------------------------------------------------

CVE ID: CVE-2024-57983
Description: In the Linux kernel, the following vulnerability has been resolved:

mailbox: th1520: Fix memory corruption due to incorrect array size

The functions th1520_mbox_suspend_noirq and th1520_mbox_resume_noirq are
intended to save and restore the interrupt mask registers in the MBOX
ICU0. However, the array used to store these registers was incorrectly
sized, leading to memory corruption when accessing all four registers.

This commit corrects the array size to accommodate all four interrupt
mask registers, preventing memory corruption during suspend and resume
operations.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2cd12c7fba59f30369e8647a2b726c7280903304
  - https://git.kernel.org/stable/c/db049866943a38bf46a34fa120d526663339d7a5

------------------------------------------------------------

CVE ID: CVE-2024-57984
Description: In the Linux kernel, the following vulnerability has been resolved:

i3c: dw: Fix use-after-free in dw_i3c_master driver due to race condition

In dw_i3c_common_probe, &master->hj_work is bound with
dw_i3c_hj_work. And dw_i3c_master_irq_handler can call
dw_i3c_master_irq_handle_ibis function to start the work.

If we remove the module which will call dw_i3c_common_remove to
make cleanup, it will free master->base through i3c_master_unregister
while the work mentioned above will be used. The sequence of operations
that may lead to a UAF bug is as follows:

CPU0                                      CPU1

                                     | dw_i3c_hj_work
dw_i3c_common_remove                 |
i3c_master_unregister(&master->base) |
device_unregister(&master->dev)      |
device_release                       |
//free master->base                  |
                                     | i3c_master_do_daa(&master->base)
                                     | //use master->base

Fix it by ensuring that the work is canceled before proceeding with
the cleanup in dw_i3c_common_remove.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/60d2fb033a999bb644f8e8606ff4a1b82de36c6f
  - https://git.kernel.org/stable/c/9b0063098fcde17cd2894f2c96459b23388507ca
  - https://git.kernel.org/stable/c/b75439c945b94dd8a2b645355bdb56f948052601
  - https://git.kernel.org/stable/c/fc84dd3c909a372c0d130f5f84c404717c17eed8

------------------------------------------------------------

CVE ID: CVE-2024-57985
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: qcom: scm: Cleanup global '__scm' on probe failures

If SCM driver fails the probe, it should not leave global '__scm'
variable assigned, because external users of this driver will assume the
probe finished successfully.  For example TZMEM parts ('__scm->mempool')
are initialized later in the probe, but users of it (__scm_smc_call())
rely on the '__scm' variable.

This fixes theoretical NULL pointer exception, triggered via introducing
probe deferral in SCM driver with call trace:

  qcom_tzmem_alloc+0x70/0x1ac (P)
  qcom_tzmem_alloc+0x64/0x1ac (L)
  qcom_scm_assign_mem+0x78/0x194
  qcom_rmtfs_mem_probe+0x2d4/0x38c
  platform_probe+0x68/0xc8
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1e76b546e6fca7eb568161f408133904ca6bcf4f
  - https://git.kernel.org/stable/c/390d3baeba51a126f75c97b90ec28b9384ce4b84
  - https://git.kernel.org/stable/c/faf1715798fe72b79e4432ce8c6d03ca69765425

------------------------------------------------------------

CVE ID: CVE-2024-57986
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: core: Fix assumption that Resolution Multipliers must be in Logical Collections

A report in 2019 by the syzbot fuzzer was found to be connected to two
errors in the HID core associated with Resolution Multipliers.  One of
the errors was fixed by commit ea427a222d8b ("HID: core: Fix deadloop
in hid_apply_multiplier."), but the other has not been fixed.

This error arises because hid_apply_multipler() assumes that every
Resolution Multiplier control is contained in a Logical Collection,
i.e., there's no way the routine can ever set multiplier_collection to
NULL.  This is in spite of the fact that the function starts with a
big comment saying:

	 * "The Resolution Multiplier control must be contained in the same
	 * Logical Collection as the control(s) to which it is to be applied.
	   ...
	 *  If no Logical Collection is
	 * defined, the Resolution Multiplier is associated with all
	 * controls in the report."
	 * HID Usage Table, v1.12, Section 4.3.1, p30
	 *
	 * Thus, search from the current collection upwards until we find a
	 * logical collection...

The comment and the code overlook the possibility that none of the
collections found may be a Logical Collection.

The fix is to set the multiplier_collection pointer to NULL if the
collection found isn't a Logical Collection.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/05dd7d10675b540b8b7b31035c0a8abb6e6f3b88
  - https://git.kernel.org/stable/c/3a002e4029230d9a6be89f869b2328b258612f5c
  - https://git.kernel.org/stable/c/64f2657b579343cf923aa933f08074e6258eb07b
  - https://git.kernel.org/stable/c/a32ea3f982b389ea43a41ce77b6fb70d74006d9b
  - https://git.kernel.org/stable/c/a5498f1f864ea26f4c613c77f54409c776a95a90
  - https://git.kernel.org/stable/c/bebf542e8d7c44a18a95f306b1b5dc160c823506
  - https://git.kernel.org/stable/c/ebaeca33d32c8bdb705a8c88267737a456f354b1
  - https://git.kernel.org/stable/c/ed3d3883476423f337aac0f22c521819b3f1e970

------------------------------------------------------------

CVE ID: CVE-2024-57987
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btrtl: check for NULL in btrtl_setup_realtek()

If insert an USB dongle which chip is not maintained in ic_id_table, it
will hit the NULL point accessed. Add a null point check to avoid the
Kernel Oops.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/02f9da874e5e4626f81772eacc18967921998a71
  - https://git.kernel.org/stable/c/1158ad8e8abb361d4b2aaa010c9af74de20ab82b
  - https://git.kernel.org/stable/c/3c15082f3567032d196e8760753373332508c2ca

------------------------------------------------------------

CVE ID: CVE-2024-57988
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btbcm: Fix NULL deref in btbcm_get_board_name()

devm_kstrdup() can return a NULL pointer on failure,but this
returned value in btbcm_get_board_name() is not checked.
Add NULL check in btbcm_get_board_name(), to handle kernel NULL
pointer dereference error.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/74af8b9d0e79deefd2d43e14b84575839a849169
  - https://git.kernel.org/stable/c/b88655bc6593c6a7fdc1248b212d17e581c4334e
  - https://git.kernel.org/stable/c/df2f2d9199e61819cca5da0121dfa4d4cb57000f

------------------------------------------------------------

CVE ID: CVE-2024-57989
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7925: fix NULL deref check in mt7925_change_vif_links

In mt7925_change_vif_links() devm_kzalloc() may return NULL but this
returned value is not checked.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2f709fe755c16b811ba7339ae4c3ee2c72323d3d
  - https://git.kernel.org/stable/c/5872530c2862700070223a2c2ea85642bf2f8875
  - https://git.kernel.org/stable/c/5cd0bd815c8a48862a296df9b30e0ea0da14acd3

------------------------------------------------------------

CVE ID: CVE-2024-57990
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7925: fix off by one in mt7925_load_clc()

This comparison should be >= instead of > to prevent an out of bounds
read and write.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10.13, Last Version (Excluding): 6.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11.2, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/08fa656c91fd5fdf47ba393795b9c0d1e97539ed
  - https://git.kernel.org/stable/c/2d1628d32300e4f67ac0b7409cbfa7b912a8fe9d
  - https://git.kernel.org/stable/c/d03b8fe1b518fc2ea2d82588e905f56d80cd64b2

------------------------------------------------------------

CVE ID: CVE-2024-57991
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: chan: fix soft lockup in rtw89_entity_recalc_mgnt_roles()

During rtw89_entity_recalc_mgnt_roles(), there is a normalizing process
which will re-order the list if an entry with target pattern is found.
And once one is found, should have aborted the list_for_each_entry. But,
`break` just aborted the inner for-loop. The outer list_for_each_entry
still continues. Normally, only the first entry will match the target
pattern, and the re-ordering will change nothing, so there won't be
soft lockup. However, in some special cases, soft lockup would happen.

Fix it by `goto fill` to break from the list_for_each_entry.

The following is a sample of kernel log for this problem.

watchdog: BUG: soft lockup - CPU#1 stuck for 26s! [wpa_supplicant:2055]
[...]
RIP: 0010:rtw89_entity_recalc ([...] chan.c:392 chan.c:479) rtw89_core
[...]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/01d2d34e9fcc9897081c3c16a666f793c8a38c58
  - https://git.kernel.org/stable/c/223ba95fdcd3c6090e2bd51dce66abb6dd4f9df9
  - https://git.kernel.org/stable/c/e4790b3e314a4814f1680a5dc552031fb199b878

------------------------------------------------------------

CVE ID: CVE-2024-57992
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: wilc1000: unregister wiphy only if it has been registered

There is a specific error path in probe functions in wilc drivers (both
sdio and spi) which can lead to kernel panic, as this one for example
when using SPI:

Unable to handle kernel paging request at virtual address 9f000000 when read
[9f000000] *pgd=00000000
Internal error: Oops: 5 [#1] ARM
Modules linked in: wilc1000_spi(+) crc_itu_t crc7 wilc1000 cfg80211 bluetooth ecdh_generic ecc
CPU: 0 UID: 0 PID: 106 Comm: modprobe Not tainted 6.13.0-rc3+ #22
Hardware name: Atmel SAMA5
PC is at wiphy_unregister+0x244/0xc40 [cfg80211]
LR is at wiphy_unregister+0x1c0/0xc40 [cfg80211]
[...]
 wiphy_unregister [cfg80211] from wilc_netdev_cleanup+0x380/0x494 [wilc1000]
 wilc_netdev_cleanup [wilc1000] from wilc_bus_probe+0x360/0x834 [wilc1000_spi]
 wilc_bus_probe [wilc1000_spi] from spi_probe+0x15c/0x1d4
 spi_probe from really_probe+0x270/0xb2c
 really_probe from __driver_probe_device+0x1dc/0x4e8
 __driver_probe_device from driver_probe_device+0x5c/0x140
 driver_probe_device from __driver_attach+0x220/0x540
 __driver_attach from bus_for_each_dev+0x13c/0x1a8
 bus_for_each_dev from bus_add_driver+0x2a0/0x6a4
 bus_add_driver from driver_register+0x27c/0x51c
 driver_register from do_one_initcall+0xf8/0x564
 do_one_initcall from do_init_module+0x2e4/0x82c
 do_init_module from load_module+0x59a0/0x70c4
 load_module from init_module_from_file+0x100/0x148
 init_module_from_file from sys_finit_module+0x2fc/0x924
 sys_finit_module from ret_fast_syscall+0x0/0x1c

The issue can easily be reproduced, for example by not wiring correctly
a wilc device through SPI (and so, make it unresponsive to early SPI
commands). It is due to a recent change decoupling wiphy allocation from
wiphy registration, however wilc_netdev_cleanup has not been updated
accordingly, letting it possibly call wiphy unregister on a wiphy which
has never been registered.

Fix this crash by moving wiphy_unregister/wiphy_free out of
wilc_netdev_cleanup, and by adjusting error paths in both drivers
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1be94490b6b8a06ff14cd23fda8714e6ec37cdfb
  - https://git.kernel.org/stable/c/c7115b8229f3e6cdfae43b1cdd180f5b6c67cd70

------------------------------------------------------------

CVE ID: CVE-2024-57993
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: hid-thrustmaster: Fix warning in thrustmaster_probe by adding endpoint check

syzbot has found a type mismatch between a USB pipe and the transfer
endpoint, which is triggered by the hid-thrustmaster driver[1].
There is a number of similar, already fixed issues [2].
In this case as in others, implementing check for endpoint type fixes the issue.

[1] https://syzkaller.appspot.com/bug?extid=040e8b3db6a96908d470
[2] https://syzkaller.appspot.com/bug?extid=348331f63b034f89b622
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/220883fba32549a34f0734e4859d07f4dcd56992
  - https://git.kernel.org/stable/c/50420d7c79c37a3efe4010ff9b1bb14bc61ebccf
  - https://git.kernel.org/stable/c/816e84602900f7f951458d743fa12769635ebfd5
  - https://git.kernel.org/stable/c/ae730deded66150204c494282969bfa98dc3ae67
  - https://git.kernel.org/stable/c/e5bcae4212a6a4b4204f46a1b8bcba08909d2007

------------------------------------------------------------

CVE ID: CVE-2024-57994
Description: In the Linux kernel, the following vulnerability has been resolved:

ptr_ring: do not block hard interrupts in ptr_ring_resize_multiple()

Jakub added a lockdep_assert_no_hardirq() check in __page_pool_put_page()
to increase test coverage.

syzbot found a splat caused by hard irq blocking in
ptr_ring_resize_multiple() [1]

As current users of ptr_ring_resize_multiple() do not require
hard irqs being masked, replace it to only block BH.

Rename helpers to better reflect they are safe against BH only.

- ptr_ring_resize_multiple() to ptr_ring_resize_multiple_bh()
- skb_array_resize_multiple() to skb_array_resize_multiple_bh()

[1]

WARNING: CPU: 1 PID: 9150 at net/core/page_pool.c:709 __page_pool_put_page net/core/page_pool.c:709 [inline]
WARNING: CPU: 1 PID: 9150 at net/core/page_pool.c:709 page_pool_put_unrefed_netmem+0x157/0xa40 net/core/page_pool.c:780
Modules linked in:
CPU: 1 UID: 0 PID: 9150 Comm: syz.1.1052 Not tainted 6.11.0-rc3-syzkaller-00202-gf8669d7b5f5d #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024
RIP: 0010:__page_pool_put_page net/core/page_pool.c:709 [inline]
RIP: 0010:page_pool_put_unrefed_netmem+0x157/0xa40 net/core/page_pool.c:780
Code: 74 0e e8 7c aa fb f7 eb 43 e8 75 aa fb f7 eb 3c 65 8b 1d 38 a8 6a 76 31 ff 89 de e8 a3 ae fb f7 85 db 74 0b e8 5a aa fb f7 90 <0f> 0b 90 eb 1d 65 8b 1d 15 a8 6a 76 31 ff 89 de e8 84 ae fb f7 85
RSP: 0018:ffffc9000bda6b58 EFLAGS: 00010083
RAX: ffffffff8997e523 RBX: 0000000000000000 RCX: 0000000000040000
RDX: ffffc9000fbd0000 RSI: 0000000000001842 RDI: 0000000000001843
RBP: 0000000000000000 R08: ffffffff8997df2c R09: 1ffffd40003a000d
R10: dffffc0000000000 R11: fffff940003a000e R12: ffffea0001d00040
R13: ffff88802e8a4000 R14: dffffc0000000000 R15: 00000000ffffffff
FS:  00007fb7aaf716c0(0000) GS:ffff8880b9300000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fa15a0d4b72 CR3: 00000000561b0000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 tun_ptr_free drivers/net/tun.c:617 [inline]
 __ptr_ring_swap_queue include/linux/ptr_ring.h:571 [inline]
 ptr_ring_resize_multiple_noprof include/linux/ptr_ring.h:643 [inline]
 tun_queue_resize drivers/net/tun.c:3694 [inline]
 tun_device_event+0xaaf/0x1080 drivers/net/tun.c:3714
 notifier_call_chain+0x19f/0x3e0 kernel/notifier.c:93
 call_netdevice_notifiers_extack net/core/dev.c:2032 [inline]
 call_netdevice_notifiers net/core/dev.c:2046 [inline]
 dev_change_tx_queue_len+0x158/0x2a0 net/core/dev.c:9024
 do_setlink+0xff6/0x41f0 net/core/rtnetlink.c:2923
 rtnl_setlink+0x40d/0x5a0 net/core/rtnetlink.c:3201
 rtnetlink_rcv_msg+0x73f/0xcf0 net/core/rtnetlink.c:6647
 netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2550
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3257dac521d0ac6653108c755141dce634bb8ff2
  - https://git.kernel.org/stable/c/a126061c80d5efb4baef4bcf346094139cd81df6
  - https://git.kernel.org/stable/c/e74801b7628dc52b17471aec729bc675479ddc73

------------------------------------------------------------

CVE ID: CVE-2024-57995
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath12k: fix read pointer after free in ath12k_mac_assign_vif_to_vdev()

In ath12k_mac_assign_vif_to_vdev(), if arvif is created on a different
radio, it gets deleted from that radio through a call to
ath12k_mac_unassign_link_vif(). This action frees the arvif pointer.
Subsequently, there is a check involving arvif, which will result in a
read-after-free scenario.

Fix this by moving this check after arvif is again assigned via call to
ath12k_mac_assign_link_vif().

Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/5a10971c7645a95f5d5dc23c26fbac4bf61801d0
  - https://git.kernel.org/stable/c/f3a95a312419e4f1e992525917da9dbcd247038f

------------------------------------------------------------

CVE ID: CVE-2024-57996
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: sch_sfq: don't allow 1 packet limit

The current implementation does not work correctly with a limit of
1. iproute2 actually checks for this and this patch adds the check in
kernel as well.

This fixes the following syzkaller reported crash:

UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:210:6
index 65535 is out of range for type 'struct sfq_head[128]'
CPU: 0 PID: 2569 Comm: syz-executor101 Not tainted 5.10.0-smp-DEV #1
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Call Trace:
  __dump_stack lib/dump_stack.c:79 [inline]
  dump_stack+0x125/0x19f lib/dump_stack.c:120
  ubsan_epilogue lib/ubsan.c:148 [inline]
  __ubsan_handle_out_of_bounds+0xed/0x120 lib/ubsan.c:347
  sfq_link net/sched/sch_sfq.c:210 [inline]
  sfq_dec+0x528/0x600 net/sched/sch_sfq.c:238
  sfq_dequeue+0x39b/0x9d0 net/sched/sch_sfq.c:500
  sfq_reset+0x13/0x50 net/sched/sch_sfq.c:525
  qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
  tbf_reset+0x3d/0x100 net/sched/sch_tbf.c:319
  qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
  dev_reset_queue+0x8c/0x140 net/sched/sch_generic.c:1296
  netdev_for_each_tx_queue include/linux/netdevice.h:2350 [inline]
  dev_deactivate_many+0x6dc/0xc20 net/sched/sch_generic.c:1362
  __dev_close_many+0x214/0x350 net/core/dev.c:1468
  dev_close_many+0x207/0x510 net/core/dev.c:1506
  unregister_netdevice_many+0x40f/0x16b0 net/core/dev.c:10738
  unregister_netdevice_queue+0x2be/0x310 net/core/dev.c:10695
  unregister_netdevice include/linux/netdevice.h:2893 [inline]
  __tun_detach+0x6b6/0x1600 drivers/net/tun.c:689
  tun_detach drivers/net/tun.c:705 [inline]
  tun_chr_close+0x104/0x1b0 drivers/net/tun.c:3640
  __fput+0x203/0x840 fs/file_table.c:280
  task_work_run+0x129/0x1b0 kernel/task_work.c:185
  exit_task_work include/linux/task_work.h:33 [inline]
  do_exit+0x5ce/0x2200 kernel/exit.c:931
  do_group_exit+0x144/0x310 kernel/exit.c:1046
  __do_sys_exit_group kernel/exit.c:1057 [inline]
  __se_sys_exit_group kernel/exit.c:1055 [inline]
  __x64_sys_exit_group+0x3b/0x40 kernel/exit.c:1055
 do_syscall_64+0x6c/0xd0
 entry_SYSCALL_64_after_hwframe+0x61/0xcb
RIP: 0033:0x7fe5e7b52479
Code: Unable to access opcode bytes at RIP 0x7fe5e7b5244f.
RSP: 002b:00007ffd3c800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fe5e7b52479
RDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000
RBP: 00007fe5e7bcd2d0 R08: ffffffffffffffb8 R09: 0000000000000014
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe5e7bcd2d0
R13: 0000000000000000 R14: 00007fe5e7bcdd20 R15: 00007fe5e7b24270

The crash can be also be reproduced with the following (with a tc
recompiled to allow for sfq limits of 1):

tc qdisc add dev dummy0 handle 1: root tbf rate 1Kbit burst 100b lat 1s
../iproute2-6.9.0/tc/tc qdisc add dev dummy0 handle 2: parent 1:10 sfq limit 1
ifconfig dummy0 up
ping -I dummy0 -f -c2 -W0.1 8.8.8.8
sleep 1

Scenario that triggers the crash:

* the first packet is sent and queued in TBF and SFQ; qdisc qlen is 1

* TBF dequeues: it peeks from SFQ which moves the packet to the
  gso_skb list and keeps qdisc qlen set to 1. TBF is out of tokens so
  it schedules itself for later.

* the second packet is sent and TBF tries to queues it to SFQ. qdisc
  qlen is now 2 and because the SFQ limit is 1 the packet is dropped
  by SFQ. At this point qlen is 1, and all of the SFQ slots are empty,
  however q->tail is not NULL.

At this point, assuming no more packets are queued, when sch_dequeue
runs again it will decrement the qlen for the current empty slot
causing an underflow and the subsequent out of bounds access.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/10685681bafce6febb39770f3387621bf5d67d0b
  - https://git.kernel.org/stable/c/35d0137305ae2f97260a9047f445bd4434bd6cc7
  - https://git.kernel.org/stable/c/7d8947f2153ee9c5ab4cb17861a11cc45f30e8c4
  - https://git.kernel.org/stable/c/7fefc294204f10a3405f175f4ac2be16d63f135e
  - https://git.kernel.org/stable/c/833e9a1c27b82024db7ff5038a51651f48f05e5e

------------------------------------------------------------

CVE ID: CVE-2024-57997
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: wcn36xx: fix channel survey memory allocation size

KASAN reported a memory allocation issue in wcn->chan_survey
due to incorrect size calculation.
This commit uses kcalloc to allocate memory for wcn->chan_survey,
ensuring proper initialization and preventing the use of uninitialized
values when there are no frames on the channel.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/34cd2817708aec51ef1a6c007e0d6d5342a025d7
  - https://git.kernel.org/stable/c/6200d947f050efdba4090dfefd8a01981363d954
  - https://git.kernel.org/stable/c/64c4dcaeac1dc1030e47883b04a617ca9a4f164e
  - https://git.kernel.org/stable/c/ae68efdff7a7a42ab251cac79d8713de6f0dbaa0
  - https://git.kernel.org/stable/c/e95f9c408ff8311f75eeabc8acf34a66670d8815

------------------------------------------------------------

CVE ID: CVE-2024-57998
Description: In the Linux kernel, the following vulnerability has been resolved:

OPP: add index check to assert to avoid buffer overflow in _read_freq()

Pass the freq index to the assert function to make sure
we do not read a freq out of the opp->rates[] table when called
from the indexed variants:
dev_pm_opp_find_freq_exact_indexed() or
dev_pm_opp_find_freq_ceil/floor_indexed().

Add a secondary parameter to the assert function, unused
for assert_single_clk() then add assert_clk_index() which
will check for the clock index when called from the _indexed()
find functions.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/774dd6f0f0a61c9c3848e025d7d9eeed1a7ca4cd
  - https://git.kernel.org/stable/c/7d68c20638e50d5eb4576492a7958328ae445248
  - https://git.kernel.org/stable/c/d659bc68ed489022ea33342cfbda2911a81e7a0d
  - https://git.kernel.org/stable/c/da2a6acc73933b7812c94794726e438cde39e037
  - https://git.kernel.org/stable/c/eb6ffa0192ba83ece1a318b956265519c5c7dcec

------------------------------------------------------------

CVE ID: CVE-2024-57999
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/pseries/iommu: IOMMU incorrectly marks MMIO range in DDW

Power Hypervisor can possibily allocate MMIO window intersecting with
Dynamic DMA Window (DDW) range, which is over 32-bit addressing.

These MMIO pages needs to be marked as reserved so that IOMMU doesn't map
DMA buffers in this range.

The current code is not marking these pages correctly which is resulting
in LPAR to OOPS while booting. The stack is at below

BUG: Unable to handle kernel data access on read at 0xc00800005cd40000
Faulting instruction address: 0xc00000000005cdac
Oops: Kernel access of bad area, sig: 11 [#1]
LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries
Modules linked in: af_packet rfkill ibmveth(X) lpfc(+) nvmet_fc nvmet nvme_keyring crct10dif_vpmsum nvme_fc nvme_fabrics nvme_core be2net(+) nvme_auth rtc_generic nfsd auth_rpcgss nfs_acl lockd grace sunrpc fuse configfs ip_tables x_tables xfs libcrc32c dm_service_time ibmvfc(X) scsi_transport_fc vmx_crypto gf128mul crc32c_vpmsum dm_mirror dm_region_hash dm_log dm_multipath dm_mod sd_mod scsi_dh_emc scsi_dh_rdac scsi_dh_alua t10_pi crc64_rocksoft_generic crc64_rocksoft sg crc64 scsi_mod
Supported: Yes, External
CPU: 8 PID: 241 Comm: kworker/8:1 Kdump: loaded Not tainted 6.4.0-150600.23.14-default #1 SLE15-SP6 b44ee71c81261b9e4bab5e0cde1f2ed891d5359b
Hardware name: IBM,9080-M9S POWER9 (raw) 0x4e2103 0xf000005 of:IBM,FW950.B0 (VH950_149) hv:phyp pSeries
Workqueue: events work_for_cpu_fn
NIP:  c00000000005cdac LR: c00000000005e830 CTR: 0000000000000000
REGS: c00001400c9ff770 TRAP: 0300   Not tainted  (6.4.0-150600.23.14-default)
MSR:  800000000280b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>  CR: 24228448  XER: 00000001
CFAR: c00000000005cdd4 DAR: c00800005cd40000 DSISR: 40000000 IRQMASK: 0
GPR00: c00000000005e830 c00001400c9ffa10 c000000001987d00 c00001400c4fe800
GPR04: 0000080000000000 0000000000000001 0000000004000000 0000000000800000
GPR08: 0000000004000000 0000000000000001 c00800005cd40000 ffffffffffffffff
GPR12: 0000000084228882 c00000000a4c4f00 0000000000000010 0000080000000000
GPR16: c00001400c4fe800 0000000004000000 0800000000000000 c00000006088b800
GPR20: c00001401a7be980 c00001400eff3800 c000000002a2da68 000000000000002b
GPR24: c0000000026793a8 c000000002679368 000000000000002a c0000000026793c8
GPR28: 000008007effffff 0000080000000000 0000000000800000 c00001400c4fe800
NIP [c00000000005cdac] iommu_table_reserve_pages+0xac/0x100
LR [c00000000005e830] iommu_init_table+0x80/0x1e0
Call Trace:
[c00001400c9ffa10] [c00000000005e810] iommu_init_table+0x60/0x1e0 (unreliable)
[c00001400c9ffa90] [c00000000010356c] iommu_bypass_supported_pSeriesLP+0x9cc/0xe40
[c00001400c9ffc30] [c00000000005c300] dma_iommu_dma_supported+0xf0/0x230
[c00001400c9ffcb0] [c00000000024b0c4] dma_supported+0x44/0x90
[c00001400c9ffcd0] [c00000000024b14c] dma_set_mask+0x3c/0x80
[c00001400c9ffd00] [c0080000555b715c] be_probe+0xc4/0xb90 [be2net]
[c00001400c9ffdc0] [c000000000986f3c] local_pci_probe+0x6c/0x110
[c00001400c9ffe40] [c000000000188f28] work_for_cpu_fn+0x38/0x60
[c00001400c9ffe70] [c00000000018e454] process_one_work+0x314/0x620
[c00001400c9fff10] [c00000000018f280] worker_thread+0x2b0/0x620
[c00001400c9fff90] [c00000000019bb18] kthread+0x148/0x150
[c00001400c9fffe0] [c00000000000ded8] start_kernel_thread+0x14/0x18

There are 2 issues in the code

1. The index is "int" while the address is "unsigned long". This results in
   negative value when setting the bitmap.

2. The DMA offset is page shifted but the MMIO range is used as-is (64-bit
   address). MMIO address needs to be page shifted as well.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7043d58ecd1381674f5b2c894deb6986a1a4896b
  - https://git.kernel.org/stable/c/8f70caad82e9c088ed93b4fea48d941ab6441886
  - https://git.kernel.org/stable/c/d8cc20a8cceb3b5e8ad2e11365e3100ba36a27e9

------------------------------------------------------------

CVE ID: CVE-2024-58000
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring: prevent reg-wait speculations

With *ENTER_EXT_ARG_REG instead of passing a user pointer with arguments
for the waiting loop the user can specify an offset into a pre-mapped
region of memory, in which case the
[offset, offset + sizeof(io_uring_reg_wait)) will be intepreted as the
argument.

As we address a kernel array using a user given index, it'd be a subject
to speculation type of exploits. Use array_index_nospec() to prevent
that. Make sure to pass not the full region size but truncate by the
maximum offset allowed considering the structure size.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/29b95ac917927ce9f95bf38797e16333ecb489b1
  - https://git.kernel.org/stable/c/2a6de94df7bfa76d9850443547e7b3333f63a16a

------------------------------------------------------------

CVE ID: CVE-2025-21705
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: handle fastopen disconnect correctly

Syzbot was able to trigger a data stream corruption:

  WARNING: CPU: 0 PID: 9846 at net/mptcp/protocol.c:1024 __mptcp_clean_una+0xddb/0xff0 net/mptcp/protocol.c:1024
  Modules linked in:
  CPU: 0 UID: 0 PID: 9846 Comm: syz-executor351 Not tainted 6.13.0-rc2-syzkaller-00059-g00a5acdbf398 #0
  Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 11/25/2024
  RIP: 0010:__mptcp_clean_una+0xddb/0xff0 net/mptcp/protocol.c:1024
  Code: fa ff ff 48 8b 4c 24 18 80 e1 07 fe c1 38 c1 0f 8c 8e fa ff ff 48 8b 7c 24 18 e8 e0 db 54 f6 e9 7f fa ff ff e8 e6 80 ee f5 90 <0f> 0b 90 4c 8b 6c 24 40 4d 89 f4 e9 04 f5 ff ff 44 89 f1 80 e1 07
  RSP: 0018:ffffc9000c0cf400 EFLAGS: 00010293
  RAX: ffffffff8bb0dd5a RBX: ffff888033f5d230 RCX: ffff888059ce8000
  RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
  RBP: ffffc9000c0cf518 R08: ffffffff8bb0d1dd R09: 1ffff110170c8928
  R10: dffffc0000000000 R11: ffffed10170c8929 R12: 0000000000000000
  R13: ffff888033f5d220 R14: dffffc0000000000 R15: ffff8880592b8000
  FS:  00007f6e866496c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007f6e86f491a0 CR3: 00000000310e6000 CR4: 00000000003526f0
  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
  Call Trace:
   <TASK>
   __mptcp_clean_una_wakeup+0x7f/0x2d0 net/mptcp/protocol.c:1074
   mptcp_release_cb+0x7cb/0xb30 net/mptcp/protocol.c:3493
   release_sock+0x1aa/0x1f0 net/core/sock.c:3640
   inet_wait_for_connect net/ipv4/af_inet.c:609 [inline]
   __inet_stream_connect+0x8bd/0xf30 net/ipv4/af_inet.c:703
   mptcp_sendmsg_fastopen+0x2a2/0x530 net/mptcp/protocol.c:1755
   mptcp_sendmsg+0x1884/0x1b10 net/mptcp/protocol.c:1830
   sock_sendmsg_nosec net/socket.c:711 [inline]
   __sock_sendmsg+0x1a6/0x270 net/socket.c:726
   ____sys_sendmsg+0x52a/0x7e0 net/socket.c:2583
   ___sys_sendmsg net/socket.c:2637 [inline]
   __sys_sendmsg+0x269/0x350 net/socket.c:2669
   do_syscall_x64 arch/x86/entry/common.c:52 [inline]
   do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
   entry_SYSCALL_64_after_hwframe+0x77/0x7f
  RIP: 0033:0x7f6e86ebfe69
  Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 1f 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48
  RSP: 002b:00007f6e86649168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
  RAX: ffffffffffffffda RBX: 00007f6e86f491b8 RCX: 00007f6e86ebfe69
  RDX: 0000000030004001 RSI: 0000000020000080 RDI: 0000000000000003
  RBP: 00007f6e86f491b0 R08: 00007f6e866496c0 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000000246 R12: 00007f6e86f491bc
  R13: 000000000000006e R14: 00007ffe445d9420 R15: 00007ffe445d9508
   </TASK>

The root cause is the bad handling of disconnect() generated internally
by the MPTCP protocol in case of connect FASTOPEN errors.

Address the issue increasing the socket disconnect counter even on such
a case, to allow other threads waiting on the same socket lock to
properly error out.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0263fb2e7b7b88075a5d86e74c4384ee4400828d
  - https://git.kernel.org/stable/c/619af16b3b57a3a4ee50b9a30add9ff155541e71
  - https://git.kernel.org/stable/c/6ec806762318a4adde0ea63342d42d0feae95079
  - https://git.kernel.org/stable/c/73e268b4be27b36ae68ea10755cb003f43b38884
  - https://git.kernel.org/stable/c/84ac44d9fed3a56440971cbd7600a02b70b5b32a

------------------------------------------------------------

CVE ID: CVE-2025-21706
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: pm: only set fullmesh for subflow endp

With the in-kernel path-manager, it is possible to change the 'fullmesh'
flag. The code in mptcp_pm_nl_fullmesh() expects to change it only on
'subflow' endpoints, to recreate more or less subflows using the linked
address.

Unfortunately, the set_flags() hook was a bit more permissive, and
allowed 'implicit' endpoints to get the 'fullmesh' flag while it is not
allowed before.

That's what syzbot found, triggering the following warning:

  WARNING: CPU: 0 PID: 6499 at net/mptcp/pm_netlink.c:1496 __mark_subflow_endp_available net/mptcp/pm_netlink.c:1496 [inline]
  WARNING: CPU: 0 PID: 6499 at net/mptcp/pm_netlink.c:1496 mptcp_pm_nl_fullmesh net/mptcp/pm_netlink.c:1980 [inline]
  WARNING: CPU: 0 PID: 6499 at net/mptcp/pm_netlink.c:1496 mptcp_nl_set_flags net/mptcp/pm_netlink.c:2003 [inline]
  WARNING: CPU: 0 PID: 6499 at net/mptcp/pm_netlink.c:1496 mptcp_pm_nl_set_flags+0x974/0xdc0 net/mptcp/pm_netlink.c:2064
  Modules linked in:
  CPU: 0 UID: 0 PID: 6499 Comm: syz.1.413 Not tainted 6.13.0-rc5-syzkaller-00172-gd1bf27c4e176 #0
  Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
  RIP: 0010:__mark_subflow_endp_available net/mptcp/pm_netlink.c:1496 [inline]
  RIP: 0010:mptcp_pm_nl_fullmesh net/mptcp/pm_netlink.c:1980 [inline]
  RIP: 0010:mptcp_nl_set_flags net/mptcp/pm_netlink.c:2003 [inline]
  RIP: 0010:mptcp_pm_nl_set_flags+0x974/0xdc0 net/mptcp/pm_netlink.c:2064
  Code: 01 00 00 49 89 c5 e8 fb 45 e8 f5 e9 b8 fc ff ff e8 f1 45 e8 f5 4c 89 f7 be 03 00 00 00 e8 44 1d 0b f9 eb a0 e8 dd 45 e8 f5 90 <0f> 0b 90 e9 17 ff ff ff 89 d9 80 e1 07 38 c1 0f 8c c9 fc ff ff 48
  RSP: 0018:ffffc9000d307240 EFLAGS: 00010293
  RAX: ffffffff8bb72e03 RBX: 0000000000000000 RCX: ffff88807da88000
  RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
  RBP: ffffc9000d307430 R08: ffffffff8bb72cf0 R09: 1ffff1100b842a5e
  R10: dffffc0000000000 R11: ffffed100b842a5f R12: ffff88801e2e5ac0
  R13: ffff88805c214800 R14: ffff88805c2152e8 R15: 1ffff1100b842a5d
  FS:  00005555619f6500(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 0000000020002840 CR3: 00000000247e6000 CR4: 00000000003526f0
  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
  Call Trace:
   <TASK>
   genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]
   genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
   genl_rcv_msg+0xb14/0xec0 net/netlink/genetlink.c:1210
   netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2542
   genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219
   netlink_unicast_kernel net/netlink/af_netlink.c:1321 [inline]
   netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1347
   netlink_sendmsg+0x8e4/0xcb0 net/netlink/af_netlink.c:1891
   sock_sendmsg_nosec net/socket.c:711 [inline]
   __sock_sendmsg+0x221/0x270 net/socket.c:726
   ____sys_sendmsg+0x52a/0x7e0 net/socket.c:2583
   ___sys_sendmsg net/socket.c:2637 [inline]
   __sys_sendmsg+0x269/0x350 net/socket.c:2669
   do_syscall_x64 arch/x86/entry/common.c:52 [inline]
   do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
   entry_SYSCALL_64_after_hwframe+0x77/0x7f
  RIP: 0033:0x7f5fe8785d29
  Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48
  RSP: 002b:00007fff571f5558 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
  RAX: ffffffffffffffda RBX: 00007f5fe8975fa0 RCX: 00007f5fe8785d29
  RDX: 0000000000000000 RSI: 0000000020000480 RDI: 0000000000000007
  RBP: 00007f5fe8801b08 R08: 0000000000000000 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
  R13: 00007f5fe8975fa0 R14: 00007f5fe8975fa0 R15: 000000
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1bb0d1348546ad059f55c93def34e67cb2a034a6
  - https://git.kernel.org/stable/c/22b0734c9401a74ed4ebd9e8ef0da33e493852eb
  - https://git.kernel.org/stable/c/8ac344cbd84fda75e05e1f445f7f8fb24dc175e1
  - https://git.kernel.org/stable/c/9e3d61620a3cd033319553b980ff3a350adbe1bc
  - https://git.kernel.org/stable/c/de3b8d41d2547452c4cafb146d003fa4689fbaf2

------------------------------------------------------------

CVE ID: CVE-2025-21707
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: consolidate suboption status

MPTCP maintains the received sub-options status is the bitmask carrying
the received suboptions and in several bitfields carrying per suboption
additional info.

Zeroing the bitmask before parsing is not enough to ensure a consistent
status, and the MPTCP code has to additionally clear some bitfiled
depending on the actually parsed suboption.

The above schema is fragile, and syzbot managed to trigger a path where
a relevant bitfield is not cleared/initialized:

  BUG: KMSAN: uninit-value in __mptcp_expand_seq net/mptcp/options.c:1030 [inline]
  BUG: KMSAN: uninit-value in mptcp_expand_seq net/mptcp/protocol.h:864 [inline]
  BUG: KMSAN: uninit-value in ack_update_msk net/mptcp/options.c:1060 [inline]
  BUG: KMSAN: uninit-value in mptcp_incoming_options+0x2036/0x3d30 net/mptcp/options.c:1209
   __mptcp_expand_seq net/mptcp/options.c:1030 [inline]
   mptcp_expand_seq net/mptcp/protocol.h:864 [inline]
   ack_update_msk net/mptcp/options.c:1060 [inline]
   mptcp_incoming_options+0x2036/0x3d30 net/mptcp/options.c:1209
   tcp_data_queue+0xb4/0x7be0 net/ipv4/tcp_input.c:5233
   tcp_rcv_established+0x1061/0x2510 net/ipv4/tcp_input.c:6264
   tcp_v4_do_rcv+0x7f3/0x11a0 net/ipv4/tcp_ipv4.c:1916
   tcp_v4_rcv+0x51df/0x5750 net/ipv4/tcp_ipv4.c:2351
   ip_protocol_deliver_rcu+0x2a3/0x13d0 net/ipv4/ip_input.c:205
   ip_local_deliver_finish+0x336/0x500 net/ipv4/ip_input.c:233
   NF_HOOK include/linux/netfilter.h:314 [inline]
   ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254
   dst_input include/net/dst.h:460 [inline]
   ip_rcv_finish+0x4a2/0x520 net/ipv4/ip_input.c:447
   NF_HOOK include/linux/netfilter.h:314 [inline]
   ip_rcv+0xcd/0x380 net/ipv4/ip_input.c:567
   __netif_receive_skb_one_core net/core/dev.c:5704 [inline]
   __netif_receive_skb+0x319/0xa00 net/core/dev.c:5817
   process_backlog+0x4ad/0xa50 net/core/dev.c:6149
   __napi_poll+0xe7/0x980 net/core/dev.c:6902
   napi_poll net/core/dev.c:6971 [inline]
   net_rx_action+0xa5a/0x19b0 net/core/dev.c:7093
   handle_softirqs+0x1a0/0x7c0 kernel/softirq.c:561
   __do_softirq+0x14/0x1a kernel/softirq.c:595
   do_softirq+0x9a/0x100 kernel/softirq.c:462
   __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:389
   local_bh_enable include/linux/bottom_half.h:33 [inline]
   rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline]
   __dev_queue_xmit+0x2758/0x57d0 net/core/dev.c:4493
   dev_queue_xmit include/linux/netdevice.h:3168 [inline]
   neigh_hh_output include/net/neighbour.h:523 [inline]
   neigh_output include/net/neighbour.h:537 [inline]
   ip_finish_output2+0x187c/0x1b70 net/ipv4/ip_output.c:236
   __ip_finish_output+0x287/0x810
   ip_finish_output+0x4b/0x600 net/ipv4/ip_output.c:324
   NF_HOOK_COND include/linux/netfilter.h:303 [inline]
   ip_output+0x15f/0x3f0 net/ipv4/ip_output.c:434
   dst_output include/net/dst.h:450 [inline]
   ip_local_out net/ipv4/ip_output.c:130 [inline]
   __ip_queue_xmit+0x1f2a/0x20d0 net/ipv4/ip_output.c:536
   ip_queue_xmit+0x60/0x80 net/ipv4/ip_output.c:550
   __tcp_transmit_skb+0x3cea/0x4900 net/ipv4/tcp_output.c:1468
   tcp_transmit_skb net/ipv4/tcp_output.c:1486 [inline]
   tcp_write_xmit+0x3b90/0x9070 net/ipv4/tcp_output.c:2829
   __tcp_push_pending_frames+0xc4/0x380 net/ipv4/tcp_output.c:3012
   tcp_send_fin+0x9f6/0xf50 net/ipv4/tcp_output.c:3618
   __tcp_close+0x140c/0x1550 net/ipv4/tcp.c:3130
   __mptcp_close_ssk+0x74e/0x16f0 net/mptcp/protocol.c:2496
   mptcp_close_ssk+0x26b/0x2c0 net/mptcp/protocol.c:2550
   mptcp_pm_nl_rm_addr_or_subflow+0x635/0xd10 net/mptcp/pm_netlink.c:889
   mptcp_pm_nl_rm_subflow_received net/mptcp/pm_netlink.c:924 [inline]
   mptcp_pm_flush_addrs_and_subflows net/mptcp/pm_netlink.c:1688 [inline]
   mptcp_nl_flush_addrs_list net/mptcp/pm_netlink.c:1709 [inline]
   mptcp_pm_nl_flush_addrs_doit+0xe10/0x1630 net/mptcp/pm_netlink.c:1750
   genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]
 
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/3a7fda57b0f91f7ea34476b165f91a92feb17c96
  - https://git.kernel.org/stable/c/3b5332d416d151a15742d1b16e7319368e3cc5c6
  - https://git.kernel.org/stable/c/6169e942370b4b6f9442d35c51519bf6c346843b
  - https://git.kernel.org/stable/c/7f6c72b8ef8130760710e337dc8fbe7263954884
  - https://git.kernel.org/stable/c/ba0518f9e8688cd4fcb569e8df2a74874b4f3894
  - https://git.kernel.org/stable/c/c86b000782daba926c627d2fa00c3f60a75e7472

------------------------------------------------------------

CVE ID: CVE-2025-21708
Description: In the Linux kernel, the following vulnerability has been resolved:

net: usb: rtl8150: enable basic endpoint checking

Syzkaller reports [1] encountering a common issue of utilizing a wrong
usb endpoint type during URB submitting stage. This, in turn, triggers
a warning shown below.

For now, enable simple endpoint checking (specifically, bulk and
interrupt eps, testing control one is not essential) to mitigate
the issue with a view to do other related cosmetic changes later,
if they are necessary.

[1] Syzkaller report:
usb 1-1: BOGUS urb xfer, pipe 3 != type 1
WARNING: CPU: 1 PID: 2586 at drivers/usb/core/urb.c:503 usb_submit_urb+0xe4b/0x1730 driv>
Modules linked in:
CPU: 1 UID: 0 PID: 2586 Comm: dhcpcd Not tainted 6.11.0-rc4-syzkaller-00069-gfc88bb11617>
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024
RIP: 0010:usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503
Code: 84 3c 02 00 00 e8 05 e4 fc fc 4c 89 ef e8 fd 25 d7 fe 45 89 e0 89 e9 4c 89 f2 48 8>
RSP: 0018:ffffc9000441f740 EFLAGS: 00010282
RAX: 0000000000000000 RBX: ffff888112487a00 RCX: ffffffff811a99a9
RDX: ffff88810df6ba80 RSI: ffffffff811a99b6 RDI: 0000000000000001
RBP: 0000000000000003 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000001
R13: ffff8881023bf0a8 R14: ffff888112452a20 R15: ffff888112487a7c
FS:  00007fc04eea5740(0000) GS:ffff8881f6300000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f0a1de9f870 CR3: 000000010dbd0000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 rtl8150_open+0x300/0xe30 drivers/net/usb/rtl8150.c:733
 __dev_open+0x2d4/0x4e0 net/core/dev.c:1474
 __dev_change_flags+0x561/0x720 net/core/dev.c:8838
 dev_change_flags+0x8f/0x160 net/core/dev.c:8910
 devinet_ioctl+0x127a/0x1f10 net/ipv4/devinet.c:1177
 inet_ioctl+0x3aa/0x3f0 net/ipv4/af_inet.c:1003
 sock_do_ioctl+0x116/0x280 net/socket.c:1222
 sock_ioctl+0x22e/0x6c0 net/socket.c:1341
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:907 [inline]
 __se_sys_ioctl fs/ioctl.c:893 [inline]
 __x64_sys_ioctl+0x193/0x220 fs/ioctl.c:893
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7fc04ef73d49
...

This change has not been tested on real hardware.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3c706829ceb6e347bd4ddfd17f1d3048acd69da2
  - https://git.kernel.org/stable/c/431be4f78220d34ce21d67a6b843b7ca81bd82e9
  - https://git.kernel.org/stable/c/8f78a2b9ed4cb1e62c60d0a8905d9a37bc18c20d
  - https://git.kernel.org/stable/c/90b7f2961798793275b4844348619b622f983907
  - https://git.kernel.org/stable/c/c843515ad2be7349dd6b60e5fd299d0da0b8458b
  - https://git.kernel.org/stable/c/d42168f109f96b5d18812a789086015a435ee667
  - https://git.kernel.org/stable/c/e10b392a7495a5dbbb25247e2c17d380d9899263
  - https://git.kernel.org/stable/c/f395b7efcee8df54309eb2d4a624ef13f5d88b66

------------------------------------------------------------

CVE ID: CVE-2025-21709
Description: In the Linux kernel, the following vulnerability has been resolved:

kernel: be more careful about dup_mmap() failures and uprobe registering

If a memory allocation fails during dup_mmap(), the maple tree can be left
in an unsafe state for other iterators besides the exit path.  All the
locks are dropped before the exit_mmap() call (in mm/mmap.c), but the
incomplete mm_struct can be reached through (at least) the rmap finding
the vmas which have a pointer back to the mm_struct.

Up to this point, there have been no issues with being able to find an
mm_struct that was only partially initialised.  Syzbot was able to make
the incomplete mm_struct fail with recent forking changes, so it has been
proven unsafe to use the mm_struct that hasn't been initialised, as
referenced in the link below.

Although 8ac662f5da19f ("fork: avoid inappropriate uprobe access to
invalid mm") fixed the uprobe access, it does not completely remove the
race.

This patch sets the MMF_OOM_SKIP to avoid the iteration of the vmas on the
oom side (even though this is extremely unlikely to be selected as an oom
victim in the race window), and sets MMF_UNSTABLE to avoid other potential
users from using a partially initialised mm_struct.

When registering vmas for uprobe, skip the vmas in an mm that is marked
unstable.  Modifying a vma in an unstable mm may cause issues if the mm
isn't fully initialised.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/64c37e134b120fb462fb4a80694bfb8e7be77b14
  - https://git.kernel.org/stable/c/da139948aeda677ac09cc0e7d837f8a314de7d55

------------------------------------------------------------

CVE ID: CVE-2025-21710
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: correct handling of extreme memory squeeze

Testing with iperf3 using the "pasta" protocol splicer has revealed
a problem in the way tcp handles window advertising in extreme memory
squeeze situations.

Under memory pressure, a socket endpoint may temporarily advertise
a zero-sized window, but this is not stored as part of the socket data.
The reasoning behind this is that it is considered a temporary setting
which shouldn't influence any further calculations.

However, if we happen to stall at an unfortunate value of the current
window size, the algorithm selecting a new value will consistently fail
to advertise a non-zero window once we have freed up enough memory.
This means that this side's notion of the current window size is
different from the one last advertised to the peer, causing the latter
to not send any data to resolve the sitution.

The problem occurs on the iperf3 server side, and the socket in question
is a completely regular socket with the default settings for the
fedora40 kernel. We do not use SO_PEEK or SO_RCVBUF on the socket.

The following excerpt of a logging session, with own comments added,
shows more in detail what is happening:

//              tcp_v4_rcv(->)
//                tcp_rcv_established(->)
[5201<->39222]:     ==== Activating log @ net/ipv4/tcp_input.c/tcp_data_queue()/5257 ====
[5201<->39222]:     tcp_data_queue(->)
[5201<->39222]:        DROPPING skb [265600160..265665640], reason: SKB_DROP_REASON_PROTO_MEM
                       [rcv_nxt 265600160, rcv_wnd 262144, snt_ack 265469200, win_now 131184]
                       [copied_seq 259909392->260034360 (124968), unread 5565800, qlen 85, ofoq 0]
                       [OFO queue: gap: 65480, len: 0]
[5201<->39222]:     tcp_data_queue(<-)
[5201<->39222]:     __tcp_transmit_skb(->)
                        [tp->rcv_wup: 265469200, tp->rcv_wnd: 262144, tp->rcv_nxt 265600160]
[5201<->39222]:       tcp_select_window(->)
[5201<->39222]:         (inet_csk(sk)->icsk_ack.pending & ICSK_ACK_NOMEM) ? --> TRUE
                        [tp->rcv_wup: 265469200, tp->rcv_wnd: 262144, tp->rcv_nxt 265600160]
                        returning 0
[5201<->39222]:       tcp_select_window(<-)
[5201<->39222]:       ADVERTISING WIN 0, ACK_SEQ: 265600160
[5201<->39222]:     [__tcp_transmit_skb(<-)
[5201<->39222]:   tcp_rcv_established(<-)
[5201<->39222]: tcp_v4_rcv(<-)

// Receive queue is at 85 buffers and we are out of memory.
// We drop the incoming buffer, although it is in sequence, and decide
// to send an advertisement with a window of zero.
// We don't update tp->rcv_wnd and tp->rcv_wup accordingly, which means
// we unconditionally shrink the window.

[5201<->39222]: tcp_recvmsg_locked(->)
[5201<->39222]:   __tcp_cleanup_rbuf(->) tp->rcv_wup: 265469200, tp->rcv_wnd: 262144, tp->rcv_nxt 265600160
[5201<->39222]:     [new_win = 0, win_now = 131184, 2 * win_now = 262368]
[5201<->39222]:     [new_win >= (2 * win_now) ? --> time_to_ack = 0]
[5201<->39222]:     NOT calling tcp_send_ack()
                    [tp->rcv_wup: 265469200, tp->rcv_wnd: 262144, tp->rcv_nxt 265600160]
[5201<->39222]:   __tcp_cleanup_rbuf(<-)
                  [rcv_nxt 265600160, rcv_wnd 262144, snt_ack 265469200, win_now 131184]
                  [copied_seq 260040464->260040464 (0), unread 5559696, qlen 85, ofoq 0]
                  returning 6104 bytes
[5201<->39222]: tcp_recvmsg_locked(<-)

// After each read, the algorithm for calculating the new receive
// window in __tcp_cleanup_rbuf() finds it is too small to advertise
// or to update tp->rcv_wnd.
// Meanwhile, the peer thinks the window is zero, and will not send
// any more data to trigger an update from the interrupt mode side.

[5201<->39222]: tcp_recvmsg_locked(->)
[5201<->39222]:   __tcp_cleanup_rbuf(->) tp->rcv_wup: 265469200, tp->rcv_wnd: 262144, tp->rcv_nxt 265600160
[5201<->39222]:     [new_win = 262144, win_now = 131184, 2 * win_n
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1dd823a46e25ffde1492c391934f69a9e5eb574f
  - https://git.kernel.org/stable/c/8c670bdfa58e48abad1d5b6ca1ee843ca91f7303
  - https://git.kernel.org/stable/c/b01e7ceb35dcb7ffad413da657b78c3340a09039
  - https://git.kernel.org/stable/c/b4055e2fe96f4ef101d8af0feb056d78d77514ff

------------------------------------------------------------

CVE ID: CVE-2025-21711
Description: In the Linux kernel, the following vulnerability has been resolved:

net/rose: prevent integer overflows in rose_setsockopt()

In case of possible unpredictably large arguments passed to
rose_setsockopt() and multiplied by extra values on top of that,
integer overflows may occur.

Do the safest minimum and fix these issues by checking the
contents of 'opt' and returning -EINVAL if they are too large. Also,
switch to unsigned int and remove useless check for negative 'opt'
in ROSE_IDLE case.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/352daa50946c3bbb662432e8daf54d6760796589
  - https://git.kernel.org/stable/c/4bdd449977e2364a53d0b2a5427e71beb1cd702d
  - https://git.kernel.org/stable/c/9bdee49ad6bbd26ab5e13cc6731e54fb1b6c1dca
  - https://git.kernel.org/stable/c/b8583b54455cbec2fc038fa32b6700890b369815
  - https://git.kernel.org/stable/c/d08f4074f9c69f7e95502587eb1b258a965ba7f0
  - https://git.kernel.org/stable/c/d640627663bfe7d8963c7615316d7d4ef60f3b0b
  - https://git.kernel.org/stable/c/e5338930a29d0ab2a5af402f5f664aeba0d1a676

------------------------------------------------------------

CVE ID: CVE-2025-21712
Description: In the Linux kernel, the following vulnerability has been resolved:

md/md-bitmap: Synchronize bitmap_get_stats() with bitmap lifetime

After commit ec6bb299c7c3 ("md/md-bitmap: add 'sync_size' into struct
md_bitmap_stats"), following panic is reported:

Oops: general protection fault, probably for non-canonical address
RIP: 0010:bitmap_get_stats+0x2b/0xa0
Call Trace:
 <TASK>
 md_seq_show+0x2d2/0x5b0
 seq_read_iter+0x2b9/0x470
 seq_read+0x12f/0x180
 proc_reg_read+0x57/0xb0
 vfs_read+0xf6/0x380
 ksys_read+0x6c/0xf0
 do_syscall_64+0x82/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

Root cause is that bitmap_get_stats() can be called at anytime if mddev
is still there, even if bitmap is destroyed, or not fully initialized.
Deferenceing bitmap in this case can crash the kernel. Meanwhile, the
above commit start to deferencing bitmap->storage, make the problem
easier to trigger.

Fix the problem by protecting bitmap_get_stats() with bitmap_info.mutex.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/032fa54f486eac5507976e7e31f079a767bc13a8
  - https://git.kernel.org/stable/c/237e19519c8ff6949f0ef57c4a0243f5b2b0fa18
  - https://git.kernel.org/stable/c/4e9316eee3885bfb311b4759513f2ccf37891c09
  - https://git.kernel.org/stable/c/52848a095b55a302af92f52ca0de5b3112059bb8
  - https://git.kernel.org/stable/c/8d28d0ddb986f56920ac97ae704cc3340a699a30

------------------------------------------------------------

CVE ID: CVE-2025-21713
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/pseries/iommu: Don't unset window if it was never set

On pSeries, when user attempts to use the same vfio container used by
different iommu group, the spapr_tce_set_window() returns -EPERM
and the subsequent cleanup leads to the below crash.

   Kernel attempted to read user page (308) - exploit attempt?
   BUG: Kernel NULL pointer dereference on read at 0x00000308
   Faulting instruction address: 0xc0000000001ce358
   Oops: Kernel access of bad area, sig: 11 [#1]
   NIP:  c0000000001ce358 LR: c0000000001ce05c CTR: c00000000005add0
   <snip>
   NIP [c0000000001ce358] spapr_tce_unset_window+0x3b8/0x510
   LR [c0000000001ce05c] spapr_tce_unset_window+0xbc/0x510
   Call Trace:
     spapr_tce_unset_window+0xbc/0x510 (unreliable)
     tce_iommu_attach_group+0x24c/0x340 [vfio_iommu_spapr_tce]
     vfio_container_attach_group+0xec/0x240 [vfio]
     vfio_group_fops_unl_ioctl+0x548/0xb00 [vfio]
     sys_ioctl+0x754/0x1580
     system_call_exception+0x13c/0x330
     system_call_vectored_common+0x15c/0x2ec
   <snip>
   --- interrupt: 3000

Fix this by having null check for the tbl passed to the
spapr_tce_unset_window().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/17391cb2613b82f8c405570fea605af3255ff8d2
  - https://git.kernel.org/stable/c/ac12372a13dab3f7a2762db240bd180de8ef1e5e
  - https://git.kernel.org/stable/c/b853ff0b514c1df314246fcf94744005914b48cb

------------------------------------------------------------

CVE ID: CVE-2025-21714
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix implicit ODP use after free

Prevent double queueing of implicit ODP mr destroy work by using
__xa_cmpxchg() to make sure this is the only time we are destroying this
specific mr.

Without this change, we could try to invalidate this mr twice, which in
turn could result in queuing a MR work destroy twice, and eventually the
second work could execute after the MR was freed due to the first work,
causing a user after free and trace below.

   refcount_t: underflow; use-after-free.
   WARNING: CPU: 2 PID: 12178 at lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130
   Modules linked in: bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [last unloaded: ib_uverbs]
   CPU: 2 PID: 12178 Comm: kworker/u20:5 Not tainted 6.5.0-rc1_net_next_mlx5_58c644e #1
   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
   Workqueue: events_unbound free_implicit_child_mr_work [mlx5_ib]
   RIP: 0010:refcount_warn_saturate+0x12b/0x130
   Code: 48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ff
   RSP: 0018:ffff8881008e3e40 EFLAGS: 00010286
   RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000027
   RDX: ffff88852c91b5c8 RSI: 0000000000000001 RDI: ffff88852c91b5c0
   RBP: ffff8881dacd4e00 R08: 00000000ffffffff R09: 0000000000000019
   R10: 000000000000072e R11: 0000000063666572 R12: ffff88812bfd9e00
   R13: ffff8881c792d200 R14: ffff88810011c005 R15: ffff8881002099c0
   FS:  0000000000000000(0000) GS:ffff88852c900000(0000) knlGS:0000000000000000
   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
   CR2: 00007f5694b5e000 CR3: 00000001153f6003 CR4: 0000000000370ea0
   DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
   DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
   Call Trace:
    <TASK>
    ? refcount_warn_saturate+0x12b/0x130
    free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib]
    process_one_work+0x1cc/0x3c0
    worker_thread+0x218/0x3c0
    kthread+0xc6/0xf0
    ret_from_fork+0x1f/0x30
    </TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/7cc8f681f6d4ae4478ae0f60485fc768f2b450da
  - https://git.kernel.org/stable/c/d3d930411ce390e532470194296658a960887773
  - https://git.kernel.org/stable/c/edfb65dbb9ffd3102f3ff4dd21316158e56f1976

------------------------------------------------------------

CVE ID: CVE-2025-21715
Description: In the Linux kernel, the following vulnerability has been resolved:

net: davicom: fix UAF in dm9000_drv_remove

dm is netdev private data and it cannot be
used after free_netdev() call. Using dm after free_netdev()
can cause UAF bug. Fix it by moving free_netdev() at the end of the
function.

This is similar to the issue fixed in commit
ad297cd2db89 ("net: qcom/emac: fix UAF in emac_remove").

This bug is detected by our static analysis tool.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.262, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.262, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.226, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.181, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.106, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.24, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11.7, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/19e65c45a1507a1a2926649d2db3583ed9d55fd9
  - https://git.kernel.org/stable/c/2013c95df6752d9c88221d0f0f37b6f197969390
  - https://git.kernel.org/stable/c/5a54367a7c2378c65aaa4d3cfd952f26adef7aa7
  - https://git.kernel.org/stable/c/7d7d201eb3b766abe590ac0dda7a508b7db3e357
  - https://git.kernel.org/stable/c/a53cb72043443ac787ec0b5fa17bb3f8ff3d462b
  - https://git.kernel.org/stable/c/c411f9a5fdc9158e8f7c57eac961d3df3eb4d8ca
  - https://git.kernel.org/stable/c/c94ab07edc2843e2f3d46dbd82e5c681503aaadf
  - https://git.kernel.org/stable/c/db79e982c5f9e39ab710cbce55b05f2f5e6f1ca9

------------------------------------------------------------

CVE ID: CVE-2025-21716
Description: In the Linux kernel, the following vulnerability has been resolved:

vxlan: Fix uninit-value in vxlan_vnifilter_dump()

KMSAN reported an uninit-value access in vxlan_vnifilter_dump() [1].

If the length of the netlink message payload is less than
sizeof(struct tunnel_msg), vxlan_vnifilter_dump() accesses bytes
beyond the message. This can lead to uninit-value access. Fix this by
returning an error in such situations.

[1]
BUG: KMSAN: uninit-value in vxlan_vnifilter_dump+0x328/0x920 drivers/net/vxlan/vxlan_vnifilter.c:422
 vxlan_vnifilter_dump+0x328/0x920 drivers/net/vxlan/vxlan_vnifilter.c:422
 rtnl_dumpit+0xd5/0x2f0 net/core/rtnetlink.c:6786
 netlink_dump+0x93e/0x15f0 net/netlink/af_netlink.c:2317
 __netlink_dump_start+0x716/0xd60 net/netlink/af_netlink.c:2432
 netlink_dump_start include/linux/netlink.h:340 [inline]
 rtnetlink_dump_start net/core/rtnetlink.c:6815 [inline]
 rtnetlink_rcv_msg+0x1256/0x14a0 net/core/rtnetlink.c:6882
 netlink_rcv_skb+0x467/0x660 net/netlink/af_netlink.c:2542
 rtnetlink_rcv+0x35/0x40 net/core/rtnetlink.c:6944
 netlink_unicast_kernel net/netlink/af_netlink.c:1321 [inline]
 netlink_unicast+0xed6/0x1290 net/netlink/af_netlink.c:1347
 netlink_sendmsg+0x1092/0x1230 net/netlink/af_netlink.c:1891
 sock_sendmsg_nosec net/socket.c:711 [inline]
 __sock_sendmsg+0x330/0x3d0 net/socket.c:726
 ____sys_sendmsg+0x7f4/0xb50 net/socket.c:2583
 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2637
 __sys_sendmsg net/socket.c:2669 [inline]
 __do_sys_sendmsg net/socket.c:2674 [inline]
 __se_sys_sendmsg net/socket.c:2672 [inline]
 __x64_sys_sendmsg+0x211/0x3e0 net/socket.c:2672
 x64_sys_call+0x3878/0x3d90 arch/x86/include/generated/asm/syscalls_64.h:47
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xd9/0x1d0 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

Uninit was created at:
 slab_post_alloc_hook mm/slub.c:4110 [inline]
 slab_alloc_node mm/slub.c:4153 [inline]
 kmem_cache_alloc_node_noprof+0x800/0xe80 mm/slub.c:4205
 kmalloc_reserve+0x13b/0x4b0 net/core/skbuff.c:587
 __alloc_skb+0x347/0x7d0 net/core/skbuff.c:678
 alloc_skb include/linux/skbuff.h:1323 [inline]
 netlink_alloc_large_skb+0xa5/0x280 net/netlink/af_netlink.c:1196
 netlink_sendmsg+0xac9/0x1230 net/netlink/af_netlink.c:1866
 sock_sendmsg_nosec net/socket.c:711 [inline]
 __sock_sendmsg+0x330/0x3d0 net/socket.c:726
 ____sys_sendmsg+0x7f4/0xb50 net/socket.c:2583
 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2637
 __sys_sendmsg net/socket.c:2669 [inline]
 __do_sys_sendmsg net/socket.c:2674 [inline]
 __se_sys_sendmsg net/socket.c:2672 [inline]
 __x64_sys_sendmsg+0x211/0x3e0 net/socket.c:2672
 x64_sys_call+0x3878/0x3d90 arch/x86/include/generated/asm/syscalls_64.h:47
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xd9/0x1d0 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

CPU: 0 UID: 0 PID: 30991 Comm: syz.4.10630 Not tainted 6.12.0-10694-gc44daa7e3c73 #29
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/1693d1fade71646a0731b6b213298cb443d186ea
  - https://git.kernel.org/stable/c/5066293b9b7046a906eff60e3949a887ae185a43
  - https://git.kernel.org/stable/c/a84d511165d6ba7f331b90ae6b6ce180ec534daa
  - https://git.kernel.org/stable/c/cb1de9309a48cc5b771115781eec05075fd67039
  - https://git.kernel.org/stable/c/f554bce488605d2f70e06eeab5e4d2448c813713

------------------------------------------------------------

CVE ID: CVE-2025-21717
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: add missing cpu_to_node to kvzalloc_node in mlx5e_open_xdpredirect_sq

kvzalloc_node is not doing a runtime check on the node argument
(__alloc_pages_node_noprof does have a VM_BUG_ON, but it expands to
nothing on !CONFIG_DEBUG_VM builds), so doing any ethtool/netlink
operation that calls mlx5e_open on a CPU that's larger that MAX_NUMNODES
triggers OOB access and panic (see the trace below).

Add missing cpu_to_node call to convert cpu id to node id.

[  165.427394] mlx5_core 0000:5c:00.0 beth1: Link up
[  166.479327] BUG: unable to handle page fault for address: 0000000800000010
[  166.494592] #PF: supervisor read access in kernel mode
[  166.505995] #PF: error_code(0x0000) - not-present page
...
[  166.816958] Call Trace:
[  166.822380]  <TASK>
[  166.827034]  ? __die_body+0x64/0xb0
[  166.834774]  ? page_fault_oops+0x2cd/0x3f0
[  166.843862]  ? exc_page_fault+0x63/0x130
[  166.852564]  ? asm_exc_page_fault+0x22/0x30
[  166.861843]  ? __kvmalloc_node_noprof+0x43/0xd0
[  166.871897]  ? get_partial_node+0x1c/0x320
[  166.880983]  ? deactivate_slab+0x269/0x2b0
[  166.890069]  ___slab_alloc+0x521/0xa90
[  166.898389]  ? __kvmalloc_node_noprof+0x43/0xd0
[  166.908442]  __kmalloc_node_noprof+0x216/0x3f0
[  166.918302]  ? __kvmalloc_node_noprof+0x43/0xd0
[  166.928354]  __kvmalloc_node_noprof+0x43/0xd0
[  166.938021]  mlx5e_open_channels+0x5e2/0xc00
[  166.947496]  mlx5e_open_locked+0x3e/0xf0
[  166.956201]  mlx5e_open+0x23/0x50
[  166.963551]  __dev_open+0x114/0x1c0
[  166.971292]  __dev_change_flags+0xa2/0x1b0
[  166.980378]  dev_change_flags+0x21/0x60
[  166.988887]  do_setlink+0x38d/0xf20
[  166.996628]  ? ep_poll_callback+0x1b9/0x240
[  167.005910]  ? __nla_validate_parse.llvm.10713395753544950386+0x80/0xd70
[  167.020782]  ? __wake_up_sync_key+0x52/0x80
[  167.030066]  ? __mutex_lock+0xff/0x550
[  167.038382]  ? security_capable+0x50/0x90
[  167.047279]  rtnl_setlink+0x1c9/0x210
[  167.055403]  ? ep_poll_callback+0x1b9/0x240
[  167.064684]  ? security_capable+0x50/0x90
[  167.073579]  rtnetlink_rcv_msg+0x2f9/0x310
[  167.082667]  ? rtnetlink_bind+0x30/0x30
[  167.091173]  netlink_rcv_skb+0xb1/0xe0
[  167.099492]  netlink_unicast+0x20f/0x2e0
[  167.108191]  netlink_sendmsg+0x389/0x420
[  167.116896]  __sys_sendto+0x158/0x1c0
[  167.125024]  __x64_sys_sendto+0x22/0x30
[  167.133534]  do_syscall_64+0x63/0x130
[  167.141657]  ? __irq_exit_rcu.llvm.17843942359718260576+0x52/0xd0
[  167.155181]  entry_SYSCALL_64_after_hwframe+0x4b/0x53
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/979284535aaf12a287a2f43d9d5dfcbdc1dc4cac
  - https://git.kernel.org/stable/c/a275db45b4161d01716559dd7557db9ea0450952

------------------------------------------------------------

CVE ID: CVE-2025-21718
Description: In the Linux kernel, the following vulnerability has been resolved:

net: rose: fix timer races against user threads

Rose timers only acquire the socket spinlock, without
checking if the socket is owned by one user thread.

Add a check and rearm the timers if needed.

BUG: KASAN: slab-use-after-free in rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174
Read of size 2 at addr ffff88802f09b82a by task swapper/0/0

CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.13.0-rc5-syzkaller-00172-gd1bf27c4e176 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Call Trace:
 <IRQ>
  __dump_stack lib/dump_stack.c:94 [inline]
  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
  print_address_description mm/kasan/report.c:378 [inline]
  print_report+0x169/0x550 mm/kasan/report.c:489
  kasan_report+0x143/0x180 mm/kasan/report.c:602
  rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174
  call_timer_fn+0x187/0x650 kernel/time/timer.c:1793
  expire_timers kernel/time/timer.c:1844 [inline]
  __run_timers kernel/time/timer.c:2418 [inline]
  __run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2430
  run_timer_base kernel/time/timer.c:2439 [inline]
  run_timer_softirq+0xb7/0x170 kernel/time/timer.c:2449
  handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561
  __do_softirq kernel/softirq.c:595 [inline]
  invoke_softirq kernel/softirq.c:435 [inline]
  __irq_exit_rcu+0xf7/0x220 kernel/softirq.c:662
  irq_exit_rcu+0x9/0x30 kernel/softirq.c:678
  instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]
  sysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1049
 </IRQ>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.0
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0d5bca3be27bfcf8f980f2fed49b6cbb7dafe4a1
  - https://git.kernel.org/stable/c/1409b45d4690308c502c6caf22f01c3c205b4717
  - https://git.kernel.org/stable/c/1992fb261c90e9827cf5dc3115d89bb0853252c9
  - https://git.kernel.org/stable/c/51c128ba038cf1b79d605cbee325919b45ab95a5
  - https://git.kernel.org/stable/c/52f5aff33ca73b2c2fa93f40a3de308012e63cf4
  - https://git.kernel.org/stable/c/58051a284ac18a3bb815aac6289a679903ddcc3f
  - https://git.kernel.org/stable/c/5de7665e0a0746b5ad7943554b34db8f8614a196
  - https://git.kernel.org/stable/c/f55c88e3ca5939a6a8a329024aed8f3d98eea8e4

------------------------------------------------------------

CVE ID: CVE-2025-21719
Description: In the Linux kernel, the following vulnerability has been resolved:

ipmr: do not call mr_mfc_uses_dev() for unres entries

syzbot found that calling mr_mfc_uses_dev() for unres entries
would crash [1], because c->mfc_un.res.minvif / c->mfc_un.res.maxvif
alias to "struct sk_buff_head unresolved", which contain two pointers.

This code never worked, lets remove it.

[1]
Unable to handle kernel paging request at virtual address ffff5fff2d536613
KASAN: maybe wild-memory-access in range [0xfffefff96a9b3098-0xfffefff96a9b309f]
Modules linked in:
CPU: 1 UID: 0 PID: 7321 Comm: syz.0.16 Not tainted 6.13.0-rc7-syzkaller-g1950a0af2d55 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
 pc : mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline]
 pc : mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334
 lr : mr_mfc_uses_dev net/ipv4/ipmr_base.c:289 [inline]
 lr : mr_table_dump+0x694/0x8b0 net/ipv4/ipmr_base.c:334
Call trace:
  mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline] (P)
  mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334 (P)
  mr_rtm_dumproute+0x254/0x454 net/ipv4/ipmr_base.c:382
  ipmr_rtm_dumproute+0x248/0x4b4 net/ipv4/ipmr.c:2648
  rtnl_dump_all+0x2e4/0x4e8 net/core/rtnetlink.c:4327
  rtnl_dumpit+0x98/0x1d0 net/core/rtnetlink.c:6791
  netlink_dump+0x4f0/0xbc0 net/netlink/af_netlink.c:2317
  netlink_recvmsg+0x56c/0xe64 net/netlink/af_netlink.c:1973
  sock_recvmsg_nosec net/socket.c:1033 [inline]
  sock_recvmsg net/socket.c:1055 [inline]
  sock_read_iter+0x2d8/0x40c net/socket.c:1125
  new_sync_read fs/read_write.c:484 [inline]
  vfs_read+0x740/0x970 fs/read_write.c:565
  ksys_read+0x15c/0x26c fs/read_write.c:708
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/15a901361ec3fb1c393f91880e1cbf24ec0a88bd
  - https://git.kernel.org/stable/c/26bb7d991f04eeef47dfad23e533834995c26f7a
  - https://git.kernel.org/stable/c/53df27fd38f84bd3cd6b004eb4ff3c4903114f1d
  - https://git.kernel.org/stable/c/547ef7e8cbb98f966c8719a3e15d4e078aaa9b47
  - https://git.kernel.org/stable/c/57177c5f47a8da852f8d76cf6945cf803f8bb9e5
  - https://git.kernel.org/stable/c/71a0fcb68c0a5f3ec912b540cd5d72148e6ee5f1
  - https://git.kernel.org/stable/c/a099834a51ccf9bbba3de86a251b3433539abfde
  - https://git.kernel.org/stable/c/b379b3162ff55a70464c6a934ae9bf0497478a62

------------------------------------------------------------

CVE ID: CVE-2025-21720
Description: In the Linux kernel, the following vulnerability has been resolved:

xfrm: delete intermediate secpath entry in packet offload mode

Packets handled by hardware have added secpath as a way to inform XFRM
core code that this path was already handled. That secpath is not needed
at all after policy is checked and it is removed later in the stack.

However, in the case of IP forwarding is enabled (/proc/sys/net/ipv4/ip_forward),
that secpath is not removed and packets which already were handled are reentered
to the driver TX path with xfrm_offload set.

The following kernel panic is observed in mlx5 in such case:

 mlx5_core 0000:04:00.0 enp4s0f0np0: Link up
 mlx5_core 0000:04:00.1 enp4s0f1np1: Link up
 Initializing XFRM netlink socket
 IPsec XFRM device driver
 BUG: kernel NULL pointer dereference, address: 0000000000000000
 #PF: supervisor instruction fetch in kernel mode
 #PF: error_code(0x0010) - not-present page
 PGD 0 P4D 0
 Oops: Oops: 0010 [#1] PREEMPT SMP
 CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.13.0-rc1-alex #3
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-1ubuntu1.1 04/01/2014
 RIP: 0010:0x0
 Code: Unable to access opcode bytes at 0xffffffffffffffd6.
 RSP: 0018:ffffb87380003800 EFLAGS: 00010206
 RAX: ffff8df004e02600 RBX: ffffb873800038d8 RCX: 00000000ffff98cf
 RDX: ffff8df00733e108 RSI: ffff8df00521fb80 RDI: ffff8df001661f00
 RBP: ffffb87380003850 R08: ffff8df013980000 R09: 0000000000000010
 R10: 0000000000000002 R11: 0000000000000002 R12: ffff8df001661f00
 R13: ffff8df00521fb80 R14: ffff8df00733e108 R15: ffff8df011faf04e
 FS:  0000000000000000(0000) GS:ffff8df46b800000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: ffffffffffffffd6 CR3: 0000000106384000 CR4: 0000000000350ef0
 Call Trace:
  <IRQ>
  ? show_regs+0x63/0x70
  ? __die_body+0x20/0x60
  ? __die+0x2b/0x40
  ? page_fault_oops+0x15c/0x550
  ? do_user_addr_fault+0x3ed/0x870
  ? exc_page_fault+0x7f/0x190
  ? asm_exc_page_fault+0x27/0x30
  mlx5e_ipsec_handle_tx_skb+0xe7/0x2f0 [mlx5_core]
  mlx5e_xmit+0x58e/0x1980 [mlx5_core]
  ? __fib_lookup+0x6a/0xb0
  dev_hard_start_xmit+0x82/0x1d0
  sch_direct_xmit+0xfe/0x390
  __dev_queue_xmit+0x6d8/0xee0
  ? __fib_lookup+0x6a/0xb0
  ? internal_add_timer+0x48/0x70
  ? mod_timer+0xe2/0x2b0
  neigh_resolve_output+0x115/0x1b0
  __neigh_update+0x26a/0xc50
  neigh_update+0x14/0x20
  arp_process+0x2cb/0x8e0
  ? __napi_build_skb+0x5e/0x70
  arp_rcv+0x11e/0x1c0
  ? dev_gro_receive+0x574/0x820
  __netif_receive_skb_list_core+0x1cf/0x1f0
  netif_receive_skb_list_internal+0x183/0x2a0
  napi_complete_done+0x76/0x1c0
  mlx5e_napi_poll+0x234/0x7a0 [mlx5_core]
  __napi_poll+0x2d/0x1f0
  net_rx_action+0x1a6/0x370
  ? atomic_notifier_call_chain+0x3b/0x50
  ? irq_int_handler+0x15/0x20 [mlx5_core]
  handle_softirqs+0xb9/0x2f0
  ? handle_irq_event+0x44/0x60
  irq_exit_rcu+0xdb/0x100
  common_interrupt+0x98/0xc0
  </IRQ>
  <TASK>
  asm_common_interrupt+0x27/0x40
 RIP: 0010:pv_native_safe_halt+0xb/0x10
 Code: 09 c3 66 66 2e 0f 1f 84 00 00 00 00 00 66 90 0f 22
 0f 1f 84 00 00 00 00 00 90 eb 07 0f 00 2d 7f e9 36 00 fb
40 00 83 ff 07 77 21 89 ff ff 24 fd 88 3d a1 bd 0f 21 f8
 RSP: 0018:ffffffffbe603de8 EFLAGS: 00000202
 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000f92f46680
 RDX: 0000000000000037 RSI: 00000000ffffffff RDI: 00000000000518d4
 RBP: ffffffffbe603df0 R08: 000000cd42e4dffb R09: ffffffffbe603d70
 R10: 0000004d80d62680 R11: 0000000000000001 R12: ffffffffbe60bf40
 R13: 0000000000000000 R14: 0000000000000000 R15: ffffffffbe60aff8
  ? default_idle+0x9/0x20
  arch_cpu_idle+0x9/0x10
  default_idle_call+0x29/0xf0
  do_idle+0x1f2/0x240
  cpu_startup_entry+0x2c/0x30
  rest_init+0xe7/0x100
  start_kernel+0x76b/0xb90
  x86_64_start_reservations+0x18/0x30
  x86_64_start_kernel+0xc0/0x110
  ? setup_ghcb+0xe/0x130
  common_startup_64+0x13e/0x141
  </TASK>
 Modules linked in: esp4_offload esp4 xfrm_interface
xfrm6_tunnel tunnel4 tunnel6 xfrm_user xfrm_algo binf
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/600258d555f0710b9c47fb78d2d80a4aecd608cc
  - https://git.kernel.org/stable/c/6945701ca1572f81bc9bb46f624b02eabb3eaf3e
  - https://git.kernel.org/stable/c/981ad4c882096e7375b8c2181dd4c3ee58ea5bae
  - https://git.kernel.org/stable/c/c6e1b2cac24b2a4d1dd472071021bf00c26450eb

------------------------------------------------------------

CVE ID: CVE-2025-21721
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: handle errors that nilfs_prepare_chunk() may return

Patch series "nilfs2: fix issues with rename operations".

This series fixes BUG_ON check failures reported by syzbot around rename
operations, and a minor behavioral issue where the mtime of a child
directory changes when it is renamed instead of moved.


This patch (of 2):

The directory manipulation routines nilfs_set_link() and
nilfs_delete_entry() rewrite the directory entry in the folio/page
previously read by nilfs_find_entry(), so error handling is omitted on the
assumption that nilfs_prepare_chunk(), which prepares the buffer for
rewriting, will always succeed for these.  And if an error is returned, it
triggers the legacy BUG_ON() checks in each routine.

This assumption is wrong, as proven by syzbot: the buffer layer called by
nilfs_prepare_chunk() may call nilfs_get_block() if necessary, which may
fail due to metadata corruption or other reasons.  This has been there all
along, but improved sanity checks and error handling may have made it more
reproducible in fuzzing tests.

Fix this issue by adding missing error paths in nilfs_set_link(),
nilfs_delete_entry(), and their caller nilfs_rename().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1ee2d454baa361d2964e3e2f2cca9ee3f769d93c
  - https://git.kernel.org/stable/c/481136234dfe96c7f92770829bec6111c7c5f5dd
  - https://git.kernel.org/stable/c/607dc724b162f4452dc768865e578c1a509a1c8c
  - https://git.kernel.org/stable/c/7891ac3b0a5c56f7148af507306308ab841cdc31
  - https://git.kernel.org/stable/c/b38c6c260c2415c7f0968871305e7a093daabb4c
  - https://git.kernel.org/stable/c/eddd3176b8c4c83a46ab974574cda7c3dfe09388
  - https://git.kernel.org/stable/c/ee70999a988b8abc3490609142f50ebaa8344432
  - https://git.kernel.org/stable/c/f70bd2d8ca454e0ed78970f72147ca321dbaa015

------------------------------------------------------------

CVE ID: CVE-2025-21722
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: do not force clear folio if buffer is referenced

Patch series "nilfs2: protect busy buffer heads from being force-cleared".

This series fixes the buffer head state inconsistency issues reported by
syzbot that occurs when the filesystem is corrupted and falls back to
read-only, and the associated buffer head use-after-free issue.


This patch (of 2):

Syzbot has reported that after nilfs2 detects filesystem corruption and
falls back to read-only, inconsistencies in the buffer state may occur.

One of the inconsistencies is that when nilfs2 calls mark_buffer_dirty()
to set a data or metadata buffer as dirty, but it detects that the buffer
is not in the uptodate state:

 WARNING: CPU: 0 PID: 6049 at fs/buffer.c:1177 mark_buffer_dirty+0x2e5/0x520
  fs/buffer.c:1177
 ...
 Call Trace:
  <TASK>
  nilfs_palloc_commit_alloc_entry+0x4b/0x160 fs/nilfs2/alloc.c:598
  nilfs_ifile_create_inode+0x1dd/0x3a0 fs/nilfs2/ifile.c:73
  nilfs_new_inode+0x254/0x830 fs/nilfs2/inode.c:344
  nilfs_mkdir+0x10d/0x340 fs/nilfs2/namei.c:218
  vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257
  do_mkdirat+0x264/0x3a0 fs/namei.c:4280
  __do_sys_mkdirat fs/namei.c:4295 [inline]
  __se_sys_mkdirat fs/namei.c:4293 [inline]
  __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293
  do_syscall_x64 arch/x86/entry/common.c:52 [inline]
  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
  entry_SYSCALL_64_after_hwframe+0x77/0x7f

The other is when nilfs_btree_propagate(), which propagates the dirty
state to the ancestor nodes of a b-tree that point to a dirty buffer,
detects that the origin buffer is not dirty, even though it should be:

 WARNING: CPU: 0 PID: 5245 at fs/nilfs2/btree.c:2089
  nilfs_btree_propagate+0xc79/0xdf0 fs/nilfs2/btree.c:2089
 ...
 Call Trace:
  <TASK>
  nilfs_bmap_propagate+0x75/0x120 fs/nilfs2/bmap.c:345
  nilfs_collect_file_data+0x4d/0xd0 fs/nilfs2/segment.c:587
  nilfs_segctor_apply_buffers+0x184/0x340 fs/nilfs2/segment.c:1006
  nilfs_segctor_scan_file+0x28c/0xa50 fs/nilfs2/segment.c:1045
  nilfs_segctor_collect_blocks fs/nilfs2/segment.c:1216 [inline]
  nilfs_segctor_collect fs/nilfs2/segment.c:1540 [inline]
  nilfs_segctor_do_construct+0x1c28/0x6b90 fs/nilfs2/segment.c:2115
  nilfs_segctor_construct+0x181/0x6b0 fs/nilfs2/segment.c:2479
  nilfs_segctor_thread_construct fs/nilfs2/segment.c:2587 [inline]
  nilfs_segctor_thread+0x69e/0xe80 fs/nilfs2/segment.c:2701
  kthread+0x2f0/0x390 kernel/kthread.c:389
  ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
  </TASK>

Both of these issues are caused by the callbacks that handle the
page/folio write requests, forcibly clear various states, including the
working state of the buffers they hold, at unexpected times when they
detect read-only fallback.

Fix these issues by checking if the buffer is referenced before clearing
the page/folio state, and skipping the clear if it is.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.10, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/1098bb8d52419d262a3358d099a1598a920b730f
  - https://git.kernel.org/stable/c/19296737024cd220a1d6590bf4c092bca8c99497
  - https://git.kernel.org/stable/c/4d042811c72f71be7c14726db2c72b67025a7cb5
  - https://git.kernel.org/stable/c/557ccf5e49f1fb848a29698585bcab2e50a597ef
  - https://git.kernel.org/stable/c/7d0544bacc11d6aa26ecd7debf9353193c7a3328
  - https://git.kernel.org/stable/c/ca76bb226bf47ff04c782cacbd299f12ddee1ec1
  - https://git.kernel.org/stable/c/f51ff43c4c5a6c8e72d0aca89e4d5e688938412f

------------------------------------------------------------

CVE ID: CVE-2025-21723
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix possible crash when setting up bsg fails

If bsg_setup_queue() fails, the bsg_queue is assigned a non-NULL value.
Consequently, in mpi3mr_bsg_exit(), the condition "if(!mrioc->bsg_queue)"
will not be satisfied, preventing execution from entering
bsg_remove_queue(), which could lead to the following crash:

BUG: kernel NULL pointer dereference, address: 000000000000041c
Call Trace:
  <TASK>
  mpi3mr_bsg_exit+0x1f/0x50 [mpi3mr]
  mpi3mr_remove+0x6f/0x340 [mpi3mr]
  pci_device_remove+0x3f/0xb0
  device_release_driver_internal+0x19d/0x220
  unbind_store+0xa4/0xb0
  kernfs_fop_write_iter+0x11f/0x200
  vfs_write+0x1fc/0x3e0
  ksys_write+0x67/0xe0
  do_syscall_64+0x38/0x80
  entry_SYSCALL_64_after_hwframe+0x78/0xe2
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/19b248069d1b1424982723a2bf3941ad864d5204
  - https://git.kernel.org/stable/c/295006f6e8c17212d3098811166e29627d19e05c
  - https://git.kernel.org/stable/c/832b8f95a2832321b8200ae478ed988b25faaef4

------------------------------------------------------------

CVE ID: CVE-2025-21724
Description: In the Linux kernel, the following vulnerability has been resolved:

iommufd/iova_bitmap: Fix shift-out-of-bounds in iova_bitmap_offset_to_index()

Resolve a UBSAN shift-out-of-bounds issue in iova_bitmap_offset_to_index()
where shifting the constant "1" (of type int) by bitmap->mapped.pgshift
(an unsigned long value) could result in undefined behavior.

The constant "1" defaults to a 32-bit "int", and when "pgshift" exceeds
31 (e.g., pgshift = 63) the shift operation overflows, as the result
cannot be represented in a 32-bit type.

To resolve this, the constant is updated to "1UL", promoting it to an
unsigned long type to match the operand's type.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/38ac76fc06bc6826a3e4b12a98efbe98432380a9
  - https://git.kernel.org/stable/c/44d9c94b7a3f29a3e07c4753603a35e9b28842a3
  - https://git.kernel.org/stable/c/b1f8453b8ff1ab79a03820ef608256c499769cb6
  - https://git.kernel.org/stable/c/d5d33f01b86af44b23eea61ee309e4ef22c0cdfe
  - https://git.kernel.org/stable/c/e24c1551059268b37f6f40639883eafb281b8b9c

------------------------------------------------------------

CVE ID: CVE-2025-21725
Description: In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix oops due to unset link speed

It isn't guaranteed that NETWORK_INTERFACE_INFO::LinkSpeed will always
be set by the server, so the client must handle any values and then
prevent oopses like below from happening:

Oops: divide error: 0000 [#1] PREEMPT SMP KASAN NOPTI
CPU: 0 UID: 0 PID: 1323 Comm: cat Not tainted 6.13.0-rc7 #2
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-3.fc41
04/01/2014
RIP: 0010:cifs_debug_data_proc_show+0xa45/0x1460 [cifs] Code: 00 00 48
89 df e8 3b cd 1b c1 41 f6 44 24 2c 04 0f 84 50 01 00 00 48 89 ef e8
e7 d0 1b c1 49 8b 44 24 18 31 d2 49 8d 7c 24 28 <48> f7 74 24 18 48 89
c3 e8 6e cf 1b c1 41 8b 6c 24 28 49 8d 7c 24
RSP: 0018:ffffc90001817be0 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff88811230022c RCX: ffffffffc041bd99
RDX: 0000000000000000 RSI: 0000000000000567 RDI: ffff888112300228
RBP: ffff888112300218 R08: fffff52000302f5f R09: ffffed1022fa58ac
R10: ffff888117d2c566 R11: 00000000fffffffe R12: ffff888112300200
R13: 000000012a15343f R14: 0000000000000001 R15: ffff888113f2db58
FS: 00007fe27119e740(0000) GS:ffff888148600000(0000)
knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fe2633c5000 CR3: 0000000124da0000 CR4: 0000000000750ef0
PKRU: 55555554
Call Trace:
 <TASK>
 ? __die_body.cold+0x19/0x27
 ? die+0x2e/0x50
 ? do_trap+0x159/0x1b0
 ? cifs_debug_data_proc_show+0xa45/0x1460 [cifs]
 ? do_error_trap+0x90/0x130
 ? cifs_debug_data_proc_show+0xa45/0x1460 [cifs]
 ? exc_divide_error+0x39/0x50
 ? cifs_debug_data_proc_show+0xa45/0x1460 [cifs]
 ? asm_exc_divide_error+0x1a/0x20
 ? cifs_debug_data_proc_show+0xa39/0x1460 [cifs]
 ? cifs_debug_data_proc_show+0xa45/0x1460 [cifs]
 ? seq_read_iter+0x42e/0x790
 seq_read_iter+0x19a/0x790
 proc_reg_read_iter+0xbe/0x110
 ? __pfx_proc_reg_read_iter+0x10/0x10
 vfs_read+0x469/0x570
 ? do_user_addr_fault+0x398/0x760
 ? __pfx_vfs_read+0x10/0x10
 ? find_held_lock+0x8a/0xa0
 ? __pfx_lock_release+0x10/0x10
 ksys_read+0xd3/0x170
 ? __pfx_ksys_read+0x10/0x10
 ? __rcu_read_unlock+0x50/0x270
 ? mark_held_locks+0x1a/0x90
 do_syscall_64+0xbb/0x1d0
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7fe271288911
Code: 00 48 8b 15 01 25 10 00 f7 d8 64 89 02 b8 ff ff ff ff eb bd e8
20 ad 01 00 f3 0f 1e fa 80 3d b5 a7 10 00 00 74 13 31 c0 0f 05 <48> 3d
00 f0 ff ff 77 4f c3 66 0f 1f 44 00 00 55 48 89 e5 48 83 ec
RSP: 002b:00007ffe87c079d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
RAX: ffffffffffffffda RBX: 0000000000040000 RCX: 00007fe271288911
RDX: 0000000000040000 RSI: 00007fe2633c6000 RDI: 0000000000000003
RBP: 00007ffe87c07a00 R08: 0000000000000000 R09: 00007fe2713e6380
R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000040000
R13: 00007fe2633c6000 R14: 0000000000000003 R15: 0000000000000000
 </TASK>

Fix this by setting cifs_server_iface::speed to a sane value (1Gbps)
by default when link speed is unset.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/208e102a2fca44e40a6c3f7b9e2609cfd17a15aa
  - https://git.kernel.org/stable/c/3f901c35e1a1b3ed1b528a17ffdb941aa0294458
  - https://git.kernel.org/stable/c/699179dfc8d7da457b152ca5d18ae45f9ed9beaa
  - https://git.kernel.org/stable/c/ad3b49fbdb156aa8ee2026ba590642c9b5a410f2
  - https://git.kernel.org/stable/c/be7a6a77669588bfa5022a470989702bbbb11e7f

------------------------------------------------------------

CVE ID: CVE-2025-21726
Description: In the Linux kernel, the following vulnerability has been resolved:

padata: avoid UAF for reorder_work

Although the previous patch can avoid ps and ps UAF for _do_serial, it
can not avoid potential UAF issue for reorder_work. This issue can
happen just as below:

crypto_request			crypto_request		crypto_del_alg
padata_do_serial
  ...
  padata_reorder
    // processes all remaining
    // requests then breaks
    while (1) {
      if (!padata)
        break;
      ...
    }

				padata_do_serial
				  // new request added
				  list_add
    // sees the new request
    queue_work(reorder_work)
				  padata_reorder
				    queue_work_on(squeue->work)
...

				<kworker context>
				padata_serial_worker
				// completes new request,
				// no more outstanding
				// requests

							crypto_del_alg
							  // free pd

<kworker context>
invoke_padata_reorder
  // UAF of pd

To avoid UAF for 'reorder_work', get 'pd' ref before put 'reorder_work'
into the 'serial_wq' and put 'pd' ref until the 'serial_wq' finish.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.19, Last Version (Excluding): 5.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5.3, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/4c6209efea2208597dbd3e52dc87a0d1a8f2dbe1
  - https://git.kernel.org/stable/c/6f45ef616775b0ce7889b0f6077fc8d681ab30bc
  - https://git.kernel.org/stable/c/7000507bb0d2ceb545c0a690e0c707c897d102c2
  - https://git.kernel.org/stable/c/8ca38d0ca8c3d30dd18d311f1a7ec5cb56972cac
  - https://git.kernel.org/stable/c/a54091c24220a4cd847d5b4f36d678edacddbaf0
  - https://git.kernel.org/stable/c/dd7d37ccf6b11f3d95e797ebe4e9e886d0332600
  - https://git.kernel.org/stable/c/f4f1b1169fc3694f9bc3e28c6c68dbbf4cc744c0

------------------------------------------------------------

CVE ID: CVE-2025-21727
Description: In the Linux kernel, the following vulnerability has been resolved:

padata: fix UAF in padata_reorder

A bug was found when run ltp test:

BUG: KASAN: slab-use-after-free in padata_find_next+0x29/0x1a0
Read of size 4 at addr ffff88bbfe003524 by task kworker/u113:2/3039206

CPU: 0 PID: 3039206 Comm: kworker/u113:2 Kdump: loaded Not tainted 6.6.0+
Workqueue: pdecrypt_parallel padata_parallel_worker
Call Trace:
<TASK>
dump_stack_lvl+0x32/0x50
print_address_description.constprop.0+0x6b/0x3d0
print_report+0xdd/0x2c0
kasan_report+0xa5/0xd0
padata_find_next+0x29/0x1a0
padata_reorder+0x131/0x220
padata_parallel_worker+0x3d/0xc0
process_one_work+0x2ec/0x5a0

If 'mdelay(10)' is added before calling 'padata_find_next' in the
'padata_reorder' function, this issue could be reproduced easily with
ltp test (pcrypt_aead01).

This can be explained as bellow:

pcrypt_aead_encrypt
...
padata_do_parallel
refcount_inc(&pd->refcnt); // add refcnt
...
padata_do_serial
padata_reorder // pd
while (1) {
padata_find_next(pd, true); // using pd
queue_work_on
...
padata_serial_worker				crypto_del_alg
padata_put_pd_cnt // sub refcnt
						padata_free_shell
						padata_put_pd(ps->pd);
						// pd is freed
// loop again, but pd is freed
// call padata_find_next, UAF
}

In the padata_reorder function, when it loops in 'while', if the alg is
deleted, the refcnt may be decreased to 0 before entering
'padata_find_next', which leads to UAF.

As mentioned in [1], do_serial is supposed to be called with BHs disabled
and always happen under RCU protection, to address this issue, add
synchronize_rcu() in 'padata_free_shell' wait for all _do_serial calls
to finish.

[1] https://lore.kernel.org/all/20221028160401.cccypv4euxikusiq@parnassus.localdomain/
[2] https://lore.kernel.org/linux-kernel/jfjz5d7zwbytztackem7ibzalm5lnxldi2eofeiczqmqs2m7o6@fq426cwnjtkm/
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0ae2f332cfd2d74cf3ce344ec9938cf3e29c3ccd
  - https://git.kernel.org/stable/c/573ac9c70bf7885dc85d82fa44550581bfc3b738
  - https://git.kernel.org/stable/c/80231f069240d52e98b6a317456c67b2eafd0781
  - https://git.kernel.org/stable/c/bbccae982e9fa1d7abcb23a5ec81cb0ec883f7de
  - https://git.kernel.org/stable/c/e01780ea4661172734118d2a5f41bc9720765668
  - https://git.kernel.org/stable/c/f3e0b9f790f8e8065d59e67b565a83154d9f3079
  - https://git.kernel.org/stable/c/f78170bee51469734b1a306a74fc5f777bb22ba6

------------------------------------------------------------

CVE ID: CVE-2025-21728
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Send signals asynchronously if !preemptible

BPF programs can execute in all kinds of contexts and when a program
running in a non-preemptible context uses the bpf_send_signal() kfunc,
it will cause issues because this kfunc can sleep.
Change `irqs_disabled()` to `!preemptible()`.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/092fc76b7ab4163e008f9cde596a58dad2108260
  - https://git.kernel.org/stable/c/78b97783496b454435639937db3303e900a24d3f
  - https://git.kernel.org/stable/c/87c544108b612512b254c8f79aa5c0a8546e2cc4
  - https://git.kernel.org/stable/c/be42a09fe898635b0093c0c8dac1bfabe225c240
  - https://git.kernel.org/stable/c/ce51eab2070e295d298f42a2f1db269cd1b56d55
  - https://git.kernel.org/stable/c/e306eaaa3d78b462db5f5b11e0171f9d2b6ca3f4
  - https://git.kernel.org/stable/c/eeef8e65041a031bd8a747a392c14b76a123a12c
  - https://git.kernel.org/stable/c/feba1308bc5e8e04cee751d39fae8a9b407a9034

------------------------------------------------------------

CVE ID: CVE-2025-21729
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: fix race between cancel_hw_scan and hw_scan completion

The rtwdev->scanning flag isn't protected by mutex originally, so
cancel_hw_scan can pass the condition, but suddenly hw_scan completion
unset the flag and calls ieee80211_scan_completed() that will free
local->hw_scan_req. Then, cancel_hw_scan raises null-ptr-deref and
use-after-free. Fix it by moving the check condition to where
protected by mutex.

 KASAN: null-ptr-deref in range [0x0000000000000088-0x000000000000008f]
 CPU: 2 PID: 6922 Comm: kworker/2:2 Tainted: G           OE
 Hardware name: LENOVO 2356AD1/2356AD1, BIOS G7ETB6WW (2.76 ) 09/10/2019
 Workqueue: events cfg80211_conn_work [cfg80211]
 RIP: 0010:rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core]
 Code: 00 45 89 6c 24 1c 0f 85 23 01 00 00 48 8b 85 20 ff ff ff 48 8d
 RSP: 0018:ffff88811fd9f068 EFLAGS: 00010206
 RAX: dffffc0000000000 RBX: ffff88811fd9f258 RCX: 0000000000000001
 RDX: 0000000000000011 RSI: 0000000000000001 RDI: 0000000000000089
 RBP: ffff88811fd9f170 R08: 0000000000000000 R09: 0000000000000000
 R10: ffff88811fd9f108 R11: 0000000000000000 R12: ffff88810e47f960
 R13: 0000000000000000 R14: 000000000000ffff R15: 0000000000000000
 FS:  0000000000000000(0000) GS:ffff8881d6f00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007531dfca55b0 CR3: 00000001be296004 CR4: 00000000001706e0
 Call Trace:
  <TASK>
  ? show_regs+0x61/0x73
  ? __die_body+0x20/0x73
  ? die_addr+0x4f/0x7b
  ? exc_general_protection+0x191/0x1db
  ? asm_exc_general_protection+0x27/0x30
  ? rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core]
  ? rtw89_fw_h2c_scan_offload_be+0x458/0x13c3 [rtw89_core]
  ? __pfx_rtw89_fw_h2c_scan_offload_be+0x10/0x10 [rtw89_core]
  ? do_raw_spin_lock+0x75/0xdb
  ? __pfx_do_raw_spin_lock+0x10/0x10
  rtw89_hw_scan_offload+0xb5e/0xbf7 [rtw89_core]
  ? _raw_spin_unlock+0xe/0x24
  ? __mutex_lock.constprop.0+0x40c/0x471
  ? __pfx_rtw89_hw_scan_offload+0x10/0x10 [rtw89_core]
  ? __mutex_lock_slowpath+0x13/0x1f
  ? mutex_lock+0xa2/0xdc
  ? __pfx_mutex_lock+0x10/0x10
  rtw89_hw_scan_abort+0x58/0xb7 [rtw89_core]
  rtw89_ops_cancel_hw_scan+0x120/0x13b [rtw89_core]
  ieee80211_scan_cancel+0x468/0x4d0 [mac80211]
  ieee80211_prep_connection+0x858/0x899 [mac80211]
  ieee80211_mgd_auth+0xbea/0xdde [mac80211]
  ? __pfx_ieee80211_mgd_auth+0x10/0x10 [mac80211]
  ? cfg80211_find_elem+0x15/0x29 [cfg80211]
  ? is_bss+0x1b7/0x1d7 [cfg80211]
  ieee80211_auth+0x18/0x27 [mac80211]
  cfg80211_mlme_auth+0x3bb/0x3e7 [cfg80211]
  cfg80211_conn_do_work+0x410/0xb81 [cfg80211]
  ? __pfx_cfg80211_conn_do_work+0x10/0x10 [cfg80211]
  ? __kasan_check_read+0x11/0x1f
  ? psi_group_change+0x8bc/0x944
  ? __kasan_check_write+0x14/0x22
  ? mutex_lock+0x8e/0xdc
  ? __pfx_mutex_lock+0x10/0x10
  ? __pfx___radix_tree_lookup+0x10/0x10
  cfg80211_conn_work+0x245/0x34d [cfg80211]
  ? __pfx_cfg80211_conn_work+0x10/0x10 [cfg80211]
  ? update_cfs_rq_load_avg+0x3bc/0x3d7
  ? sched_clock_noinstr+0x9/0x1a
  ? sched_clock+0x10/0x24
  ? sched_clock_cpu+0x7e/0x42e
  ? newidle_balance+0x796/0x937
  ? __pfx_sched_clock_cpu+0x10/0x10
  ? __pfx_newidle_balance+0x10/0x10
  ? __kasan_check_read+0x11/0x1f
  ? psi_group_change+0x8bc/0x944
  ? _raw_spin_unlock+0xe/0x24
  ? raw_spin_rq_unlock+0x47/0x54
  ? raw_spin_rq_unlock_irq+0x9/0x1f
  ? finish_task_switch.isra.0+0x347/0x586
  ? __schedule+0x27bf/0x2892
  ? mutex_unlock+0x80/0xd0
  ? do_raw_spin_lock+0x75/0xdb
  ? __pfx___schedule+0x10/0x10
  process_scheduled_works+0x58c/0x821
  worker_thread+0x4c7/0x586
  ? __kasan_check_read+0x11/0x1f
  kthread+0x285/0x294
  ? __pfx_worker_thread+0x10/0x10
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x29/0x6f
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1b/0x30
  </TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2403cb3c235d5e339b580cc3a825493769fadca8
  - https://git.kernel.org/stable/c/5afcd6fcd1e1c1fd6bcc9a360c121d10eddade67
  - https://git.kernel.org/stable/c/ba4bb0402c60e945c4c396c51f0acac3c3e3ea5c

------------------------------------------------------------

CVE ID: CVE-2025-21730
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: avoid to init mgnt_entry list twice when WoWLAN failed

If WoWLAN failed in resume flow, the rtw89_ops_add_interface() triggered
without removing the interface first. Then the mgnt_entry list init again,
causing the list_empty() check in rtw89_chanctx_ops_assign_vif()
useless, and list_add_tail() again. Therefore, we have added a check to
prevent double adding of the list.

rtw89_8852ce 0000:01:00.0: failed to check wow status disabled
rtw89_8852ce 0000:01:00.0: wow: failed to check disable fw ready
rtw89_8852ce 0000:01:00.0: wow: failed to swap to normal fw
rtw89_8852ce 0000:01:00.0: failed to disable wow
rtw89_8852ce 0000:01:00.0: failed to resume for wow -110
rtw89_8852ce 0000:01:00.0: MAC has already powered on
i2c_hid_acpi i2c-ILTK0001:00: PM: acpi_subsys_resume+0x0/0x60 returned 0 after 284705 usecs
list_add corruption. prev->next should be next (ffff9d9719d82228), but was ffff9d9719f96030. (prev=ffff9d9719f96030).
------------[ cut here ]------------
kernel BUG at lib/list_debug.c:34!
invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
CPU: 2 PID: 6918 Comm: kworker/u8:19 Tainted: G     U     O
Hardware name: Google Anraggar/Anraggar, BIOS Google_Anraggar.15217.514.0 03/25/2024
Workqueue: events_unbound async_run_entry_fn
RIP: 0010:__list_add_valid_or_report+0x9f/0xb0
Code: e8 56 89 ff ff 0f 0b 48 c7 c7 3e fc e0 96 48 89 c6 e8 45 89 ff ...
RSP: 0018:ffffa51b42bbbaf0 EFLAGS: 00010246
RAX: 0000000000000075 RBX: ffff9d9719d82ab0 RCX: 13acb86e047a4400
RDX: 3fffffffffffffff RSI: 0000000000000000 RDI: 00000000ffffdfff
RBP: ffffa51b42bbbb28 R08: ffffffff9768e250 R09: 0000000000001fff
R10: ffffffff9765e250 R11: 0000000000005ffd R12: ffff9d9719f95c40
R13: ffff9d9719f95be8 R14: ffff9d97081bfd78 R15: ffff9d9719d82060
FS:  0000000000000000(0000) GS:ffff9d9a6fb00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007e7d029a4060 CR3: 0000000345e38000 CR4: 0000000000750ee0
PKRU: 55555554
Call Trace:
 <TASK>
 ? __die_body+0x68/0xb0
 ? die+0xaa/0xd0
 ? do_trap+0x9f/0x170
 ? __list_add_valid_or_report+0x9f/0xb0
 ? __list_add_valid_or_report+0x9f/0xb0
 ? handle_invalid_op+0x69/0x90
 ? __list_add_valid_or_report+0x9f/0xb0
 ? exc_invalid_op+0x3c/0x50
 ? asm_exc_invalid_op+0x16/0x20
 ? __list_add_valid_or_report+0x9f/0xb0
 rtw89_chanctx_ops_assign_vif+0x1f9/0x210 [rtw89_core cbb375c44bf28564ce479002bff66617a25d9ac1]
 ? __mutex_unlock_slowpath+0xa0/0xf0
 rtw89_ops_assign_vif_chanctx+0x4b/0x90 [rtw89_core cbb375c44bf28564ce479002bff66617a25d9ac1]
 drv_assign_vif_chanctx+0xa7/0x1f0 [mac80211 6efaad16237edaaea0868b132d4f93ecf918a8b6]
 ieee80211_reconfig+0x9cb/0x17b0 [mac80211 6efaad16237edaaea0868b132d4f93ecf918a8b6]
 ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed]
 ? dev_printk_emit+0x51/0x70
 ? _dev_info+0x6e/0x90
 wiphy_resume+0x89/0x180 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed]
 ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed]
 dpm_run_callback+0x37/0x1e0
 device_resume+0x26d/0x4b0
 ? __pfx_dpm_watchdog_handler+0x10/0x10
 async_resume+0x1d/0x30
 async_run_entry_fn+0x29/0xd0
 worker_thread+0x397/0x970
 kthread+0xed/0x110
 ? __pfx_worker_thread+0x10/0x10
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x38/0x50
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1b/0x30
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2f7667675df1b40b73ecc53b4b8c3189b1e5f2c1
  - https://git.kernel.org/stable/c/4ed5bf49819757303e657f3900725febf2f3926f
  - https://git.kernel.org/stable/c/7fc295fdd3992a9a07d12fd3f2e84dface23aedc

------------------------------------------------------------

CVE ID: CVE-2025-21731
Description: In the Linux kernel, the following vulnerability has been resolved:

nbd: don't allow reconnect after disconnect

Following process can cause nbd_config UAF:

1) grab nbd_config temporarily;

2) nbd_genl_disconnect() flush all recv_work() and release the
initial reference:

  nbd_genl_disconnect
   nbd_disconnect_and_put
    nbd_disconnect
     flush_workqueue(nbd->recv_workq)
    if (test_and_clear_bit(NBD_RT_HAS_CONFIG_REF, ...))
     nbd_config_put
     -> due to step 1), reference is still not zero

3) nbd_genl_reconfigure() queue recv_work() again;

  nbd_genl_reconfigure
   config = nbd_get_config_unlocked(nbd)
   if (!config)
   -> succeed
   if (!test_bit(NBD_RT_BOUND, ...))
   -> succeed
   nbd_reconnect_socket
    queue_work(nbd->recv_workq, &args->work)

4) step 1) release the reference;

5) Finially, recv_work() will trigger UAF:

  recv_work
   nbd_config_put(nbd)
   -> nbd_config is freed
   atomic_dec(&config->recv_threads)
   -> UAF

Fix the problem by clearing NBD_RT_BOUND in nbd_genl_disconnect(), so
that nbd_genl_reconfigure() will fail.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/6bef6222a3f6c7adb6396f77f25a3579d821b09a
  - https://git.kernel.org/stable/c/844b8cdc681612ff24df62cdefddeab5772fadf1
  - https://git.kernel.org/stable/c/9793bd5ae4bdbdb2dde401a3cab94a6bfd05e302
  - https://git.kernel.org/stable/c/a8ee6ecde2b7bfb58c8a3afe8a9d2b848f580739
  - https://git.kernel.org/stable/c/d208d2c52b652913b5eefc8ca434b0d6b757f68f
  - https://git.kernel.org/stable/c/e3be8862d73cac833e0fb7602636c19c6cb94b11
  - https://git.kernel.org/stable/c/e70a578487a47d7cf058904141e586684d1c3381
  - https://git.kernel.org/stable/c/e7343fa33751cb07c1c56b666bf37cfca357130e

------------------------------------------------------------

CVE ID: CVE-2024-49570
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe/tracing: Fix a potential TP_printk UAF

The commit
afd2627f727b ("tracing: Check "%s" dereference via the field and not the TP_printk format")
exposes potential UAFs in the xe_bo_move trace event.

Fix those by avoiding dereferencing the
xe_mem_type_to_name[] array at TP_printk time.

Since some code refactoring has taken place, explicit backporting may
be needed for kernels older than 6.10.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/07089083a526ea19daa72a1edf9d6e209615b77c
  - https://git.kernel.org/stable/c/62cd174616ae3bf8a6cf468718f1ae74e5a07727
  - https://git.kernel.org/stable/c/c9402da34611e1039ecccba3c1481c4866f7ca64

------------------------------------------------------------

CVE ID: CVE-2024-52557
Description: In the Linux kernel, the following vulnerability has been resolved:

drm: zynqmp_dp: Fix integer overflow in zynqmp_dp_rate_get()

This patch fixes a potential integer overflow in the zynqmp_dp_rate_get()

The issue comes up when the expression
drm_dp_bw_code_to_link_rate(dp->test.bw_code) * 10000 is evaluated using 32-bit
Now the constant is a compatible 64-bit type.

Resolves coverity issues: CID 1636340 and CID 1635811
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/325d889c5403ba20a24097f64c32d27ab993c2c3
  - https://git.kernel.org/stable/c/67a615c5cb6dc33ed35492dc0d67e496cbe8de68

------------------------------------------------------------

CVE ID: CVE-2024-52559
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/gem: prevent integer overflow in msm_ioctl_gem_submit()

The "submit->cmd[i].size" and "submit->cmd[i].offset" variables are u32
values that come from the user via the submit_lookup_cmds() function.
This addition could lead to an integer wrapping bug so use size_add()
to prevent that.

Patchwork: https://patchwork.freedesktop.org/patch/624696/
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.12, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/2b99b2c4621d13bd4374ef384e8f1fc188d0a5df
  - https://git.kernel.org/stable/c/2f1845e46c41ed500789d53dc45b383b7745c96c
  - https://git.kernel.org/stable/c/3a47f4b439beb98e955d501c609dfd12b7836d61
  - https://git.kernel.org/stable/c/e43a0f1327a1ee70754f8a0de6e0262cfa3e0b87

------------------------------------------------------------

CVE ID: CVE-2024-52560
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Mark inode as bad as soon as error detected in mi_enum_attr()

Extended the `mi_enum_attr()` function interface with an additional
parameter, `struct ntfs_inode *ni`, to allow marking the inode
as bad as soon as an error is detected.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2afd4d267e6dbaec8d3ccd4f5396cb84bc67aa2e
  - https://git.kernel.org/stable/c/d9c699f2c4dc174940ffe8600b20c267897da155

------------------------------------------------------------

CVE ID: CVE-2024-54456
Description: In the Linux kernel, the following vulnerability has been resolved:

NFS: Fix potential buffer overflowin nfs_sysfs_link_rpc_client()

name is char[64] where the size of clnt->cl_program->name remains
unknown. Invoking strcat() directly will also lead to potential buffer
overflow. Change them to strscpy() and strncat() to fix potential
issues.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/19b3ca651b4b473878c73539febe477905041442
  - https://git.kernel.org/stable/c/49fd4e34751e90e6df009b70cd0659dc839e7ca8
  - https://git.kernel.org/stable/c/dd8830779b77f4d1206d28d02ad56a03fc0e78f7
  - https://git.kernel.org/stable/c/e8e0eb5601d4a6c74c336e3710afe3a0348c469d

------------------------------------------------------------

CVE ID: CVE-2024-54458
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: bsg: Set bsg_queue to NULL after removal

Currently, this does not cause any issues, but I believe it is necessary to
set bsg_queue to NULL after removing it to prevent potential use-after-free
(UAF) access.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/1e95c798d8a7f70965f0f88d4657b682ff0ec75f
  - https://git.kernel.org/stable/c/22018622e1e9e371198dbd983af946a844d5924c
  - https://git.kernel.org/stable/c/5e7b6e44468c3242c21c2a8656d009fb3eb50a73
  - https://git.kernel.org/stable/c/5f782d4741bf558def60df192b858b0efc6a5f0a
  - https://git.kernel.org/stable/c/88a01e9c9ad40c075756ba93b47984461d4ff15d
  - https://git.kernel.org/stable/c/9193bdc170cc23fe98aca71d1a63c0bf6e1e853b
  - https://git.kernel.org/stable/c/bb4783c670180b922267222408e1c48d22dfbb46

------------------------------------------------------------

CVE ID: CVE-2024-57834
Description: In the Linux kernel, the following vulnerability has been resolved:

media: vidtv: Fix a null-ptr-deref in vidtv_mux_stop_thread

syzbot report a null-ptr-deref in vidtv_mux_stop_thread. [1]

If dvb->mux is not initialized successfully by vidtv_mux_init() in the
vidtv_start_streaming(), it will trigger null pointer dereference about mux
in vidtv_mux_stop_thread().

Adjust the timing of streaming initialization and check it before
stopping it.

[1]
KASAN: null-ptr-deref in range [0x0000000000000128-0x000000000000012f]
CPU: 0 UID: 0 PID: 5842 Comm: syz-executor248 Not tainted 6.13.0-rc4-syzkaller-00012-g9b2ffa6148b1 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
RIP: 0010:vidtv_mux_stop_thread+0x26/0x80 drivers/media/test-drivers/vidtv/vidtv_mux.c:471
Code: 90 90 90 90 66 0f 1f 00 55 53 48 89 fb e8 82 2e c8 f9 48 8d bb 28 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 02 7e 3b 0f b6 ab 28 01 00 00 31 ff 89 ee e8
RSP: 0018:ffffc90003f2faa8 EFLAGS: 00010202
RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff87cfb125
RDX: 0000000000000025 RSI: ffffffff87d120ce RDI: 0000000000000128
RBP: ffff888029b8d220 R08: 0000000000000005 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000003 R12: ffff888029b8d188
R13: ffffffff8f590aa0 R14: ffffc9000581c5c8 R15: ffff888029a17710
FS:  00007f7eef5156c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f7eef5e635c CR3: 0000000076ca6000 CR4: 00000000003526f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 vidtv_stop_streaming drivers/media/test-drivers/vidtv/vidtv_bridge.c:209 [inline]
 vidtv_stop_feed+0x151/0x250 drivers/media/test-drivers/vidtv/vidtv_bridge.c:252
 dmx_section_feed_stop_filtering+0x90/0x160 drivers/media/dvb-core/dvb_demux.c:1000
 dvb_dmxdev_feed_stop.isra.0+0x1ee/0x270 drivers/media/dvb-core/dmxdev.c:486
 dvb_dmxdev_filter_stop+0x22a/0x3a0 drivers/media/dvb-core/dmxdev.c:559
 dvb_dmxdev_filter_free drivers/media/dvb-core/dmxdev.c:840 [inline]
 dvb_demux_release+0x92/0x550 drivers/media/dvb-core/dmxdev.c:1246
 __fput+0x3f8/0xb60 fs/file_table.c:450
 task_work_run+0x14e/0x250 kernel/task_work.c:239
 get_signal+0x1d3/0x2610 kernel/signal.c:2790
 arch_do_signal_or_restart+0x90/0x7e0 arch/x86/kernel/signal.c:337
 exit_to_user_mode_loop kernel/entry/common.c:111 [inline]
 exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline]
 __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]
 syscall_exit_to_user_mode+0x150/0x2a0 kernel/entry/common.c:218
 do_syscall_64+0xda/0x250 arch/x86/entry/common.c:89
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/1221989555db711578a327a9367f1be46500cb48
  - https://git.kernel.org/stable/c/2c5601b99d79d196fe4a37159e3dfb38e778ea18
  - https://git.kernel.org/stable/c/52d3512f9a7a52ef92864679b1e8e8aa16202c6a
  - https://git.kernel.org/stable/c/59a707ad952eb2ea8d59457d662b6f4138f17b08
  - https://git.kernel.org/stable/c/86307e443c5844f38e1b98e2c51a4195c55576cd
  - https://git.kernel.org/stable/c/904a8323cc8afa7eb9ce3e67303a2b3f2f787306
  - https://git.kernel.org/stable/c/95432a37778c9c5dd105b7b9f19e9695c9e166cf

------------------------------------------------------------

CVE ID: CVE-2024-57852
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: qcom: scm: smc: Handle missing SCM device

Commit ca61d6836e6f ("firmware: qcom: scm: fix a NULL-pointer
dereference") makes it explicit that qcom_scm_get_tzmem_pool() can
return NULL, therefore its users should handle this.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/57a811c0886f3f3677bb4619502b35b5bb917f2e
  - https://git.kernel.org/stable/c/94f48ecf0a538019ca2025e0b0da391f8e7cc58c
  - https://git.kernel.org/stable/c/cd955b75849b58b650ca3f87b83bd78cde1da8bc

------------------------------------------------------------

CVE ID: CVE-2024-58001
Description: In the Linux kernel, the following vulnerability has been resolved:

ocfs2: handle a symlink read error correctly

Patch series "Convert ocfs2 to use folios".

Mark did a conversion of ocfs2 to use folios and sent it to me as a
giant patch for review ;-)

So I've redone it as individual patches, and credited Mark for the patches
where his code is substantially the same.  It's not a bad way to do it;
his patch had some bugs and my patches had some bugs.  Hopefully all our
bugs were different from each other.  And hopefully Mark likes all the
changes I made to his code!


This patch (of 23):

If we can't read the buffer, be sure to unlock the page before returning.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b4c2094da6d84e69b843dd3317902e977bf64bd
  - https://git.kernel.org/stable/c/52a326f93ceb9348264fddf7bab6e345db69e08c
  - https://git.kernel.org/stable/c/5e3b3ec7c3cb5ba5629a766e4f0926db72cf0a1f
  - https://git.kernel.org/stable/c/6e143eb4ab83c24e7ad3e3d8e7daa241d9c38377
  - https://git.kernel.org/stable/c/8aee4184c5b79e486598c15aa80687c77f6f6e6e
  - https://git.kernel.org/stable/c/afa8003f8db62e46c4b171cbf4cec2824148b4f7
  - https://git.kernel.org/stable/c/b6833b38984d1e9f20dd80f9ec9050c10d687f30
  - https://git.kernel.org/stable/c/cd3e22b206189cbb4a94229002141e1529f83746

------------------------------------------------------------

CVE ID: CVE-2024-58002
Description: In the Linux kernel, the following vulnerability has been resolved:

media: uvcvideo: Remove dangling pointers

When an async control is written, we copy a pointer to the file handle
that started the operation. That pointer will be used when the device is
done. Which could be anytime in the future.

If the user closes that file descriptor, its structure will be freed,
and there will be one dangling pointer per pending async control, that
the driver will try to use.

Clean all the dangling pointers during release().

To avoid adding a performance penalty in the most common case (no async
operation), a counter has been introduced with some logic to make sure
that it is properly handled.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/117f7a2975baa4b7d702d3f4830d5a4ebd0c6d50
  - https://git.kernel.org/stable/c/221cd51efe4565501a3dbf04cc011b537dcce7fb
  - https://git.kernel.org/stable/c/2a29413ace64627e178fd422dd8a5d95219a2c0b
  - https://git.kernel.org/stable/c/438bda062b2c40ddd7df23b932e29ffe0a448cac
  - https://git.kernel.org/stable/c/4dbaa738c583a0e947803c69e8996e88cf98d971
  - https://git.kernel.org/stable/c/653993f46861f2971e95e9a0e36a34b49dec542c
  - https://git.kernel.org/stable/c/9edc7d25f7e49c33a1ce7a5ffadea2222065516c
  - https://git.kernel.org/stable/c/ac18d781466252cd35a3e311e0a4b264260fd927

------------------------------------------------------------

CVE ID: CVE-2024-58003
Description: In the Linux kernel, the following vulnerability has been resolved:

media: i2c: ds90ub9x3: Fix extra fwnode_handle_put()

The ub913 and ub953 drivers call fwnode_handle_put(priv->sd.fwnode) as
part of their remove process, and if the driver is removed multiple
times, eventually leads to put "overflow", possibly causing memory
corruption or crash.

The fwnode_handle_put() is a leftover from commit 905f88ccebb1 ("media:
i2c: ds90ub9x3: Fix sub-device matching"), which changed the code
related to the sd.fwnode, but missed removing these fwnode_handle_put()
calls.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/474d7baf91d37bc411fa60de5bbf03c9dd82e18a
  - https://git.kernel.org/stable/c/60b45ece41c5632a3a3274115a401cb244180646
  - https://git.kernel.org/stable/c/70743d6a8b256225675711e7983825f1be86062d
  - https://git.kernel.org/stable/c/f4e4373322f8d4c19721831f7fb989e52d30dab0

------------------------------------------------------------

CVE ID: CVE-2024-58004
Description: In the Linux kernel, the following vulnerability has been resolved:

media: intel/ipu6: remove cpu latency qos request on error

Fix cpu latency qos list corruption like below. It happens when
we do not remove cpu latency request on error path and free
corresponding memory.

[   30.634378] l7 kernel: list_add corruption. prev->next should be next (ffffffff9645e960), but was 0000000100100001. (prev=ffff8e9e877e20a8).
[   30.634388] l7 kernel: WARNING: CPU: 2 PID: 2008 at lib/list_debug.c:32 __list_add_valid_or_report+0x83/0xa0
<snip>
[   30.634640] l7 kernel: Call Trace:
[   30.634650] l7 kernel:  <TASK>
[   30.634659] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
[   30.634669] l7 kernel:  ? __warn.cold+0x93/0xf6
[   30.634678] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
[   30.634690] l7 kernel:  ? report_bug+0xff/0x140
[   30.634702] l7 kernel:  ? handle_bug+0x58/0x90
[   30.634712] l7 kernel:  ? exc_invalid_op+0x17/0x70
[   30.634723] l7 kernel:  ? asm_exc_invalid_op+0x1a/0x20
[   30.634733] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
[   30.634742] l7 kernel:  plist_add+0xdd/0x140
[   30.634754] l7 kernel:  pm_qos_update_target+0xa0/0x1f0
[   30.634764] l7 kernel:  cpu_latency_qos_update_request+0x61/0xc0
[   30.634773] l7 kernel:  intel_dp_aux_xfer+0x4c7/0x6e0 [i915 1f824655ed04687c2b0d23dbce759fa785f6d033]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1496ec94bd38bdb25ca13b1dd4f8e7a6176ea89d
  - https://git.kernel.org/stable/c/95275736185ecb71dc97a71d8d9d19e4ffb0a9eb
  - https://git.kernel.org/stable/c/facb541ff0805314e0b56e508f7d3cbd07af513c

------------------------------------------------------------

CVE ID: CVE-2024-58005
Description: In the Linux kernel, the following vulnerability has been resolved:

tpm: Change to kvalloc() in eventlog/acpi.c

The following failure was reported on HPE ProLiant D320:

[   10.693310][    T1] tpm_tis STM0925:00: 2.0 TPM (device-id 0x3, rev-id 0)
[   10.848132][    T1] ------------[ cut here ]------------
[   10.853559][    T1] WARNING: CPU: 59 PID: 1 at mm/page_alloc.c:4727 __alloc_pages_noprof+0x2ca/0x330
[   10.862827][    T1] Modules linked in:
[   10.866671][    T1] CPU: 59 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-lp155.2.g52785e2-default #1 openSUSE Tumbleweed (unreleased) 588cd98293a7c9eba9013378d807364c088c9375
[   10.882741][    T1] Hardware name: HPE ProLiant DL320 Gen12/ProLiant DL320 Gen12, BIOS 1.20 10/28/2024
[   10.892170][    T1] RIP: 0010:__alloc_pages_noprof+0x2ca/0x330
[   10.898103][    T1] Code: 24 08 e9 4a fe ff ff e8 34 36 fa ff e9 88 fe ff ff 83 fe 0a 0f 86 b3 fd ff ff 80 3d 01 e7 ce 01 00 75 09 c6 05 f8 e6 ce 01 01 <0f> 0b 45 31 ff e9 e5 fe ff ff f7 c2 00 00 08 00 75 42 89 d9 80 e1
[   10.917750][    T1] RSP: 0000:ffffb7cf40077980 EFLAGS: 00010246
[   10.923777][    T1] RAX: 0000000000000000 RBX: 0000000000040cc0 RCX: 0000000000000000
[   10.931727][    T1] RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000040cc0

The above transcript shows that ACPI pointed a 16 MiB buffer for the log
events because RSI maps to the 'order' parameter of __alloc_pages_noprof().
Address the bug by moving from devm_kmalloc() to devm_add_action() and
kvmalloc() and devm_add_action().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.16, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/0621d2599d6e02d05c85d6bbd58eaea2f15b3503
  - https://git.kernel.org/stable/c/422d7f4e8d817be467986589c7968d3ea402f7da
  - https://git.kernel.org/stable/c/4c8bfe643bbd00b04ee8f9545ef33bf6a68c38db
  - https://git.kernel.org/stable/c/50365a6304a57266e8f4d3078060743c3b7a1e0d
  - https://git.kernel.org/stable/c/77779d1258a287f2c5c2c6aeae203e0996209c77
  - https://git.kernel.org/stable/c/a3a860bc0fd6c07332e4911cf9a238d20de90173
  - https://git.kernel.org/stable/c/a676c0401de59548a5bc1b7aaf98f556ae8ea6db

------------------------------------------------------------

CVE ID: CVE-2024-58006
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: dwc: ep: Prevent changing BAR size/flags in pci_epc_set_bar()

In commit 4284c88fff0e ("PCI: designware-ep: Allow pci_epc_set_bar() update
inbound map address") set_bar() was modified to support dynamically
changing the backing physical address of a BAR that was already configured.

This means that set_bar() can be called twice, without ever calling
clear_bar() (as calling clear_bar() would clear the BAR's PCI address
assigned by the host).

This can only be done if the new BAR size/flags does not differ from the
existing BAR configuration. Add these missing checks.

If we allow set_bar() to set e.g. a new BAR size that differs from the
existing BAR size, the new address translation range will be smaller than
the BAR size already determined by the host, which would mean that a read
past the new BAR size would pass the iATU untranslated, which could allow
the host to read memory not belonging to the new struct pci_epf_bar.

While at it, add comments which clarifies the support for dynamically
changing the physical address of a BAR. (Which was also missing.)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3229c15d6267de8e704b4085df8a82a5af2d63eb
  - https://git.kernel.org/stable/c/3708acbd5f169ebafe1faa519cb28adc56295546
  - https://git.kernel.org/stable/c/b5cacfd067060c75088363ed3e19779078be2755

------------------------------------------------------------

CVE ID: CVE-2024-58007
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: qcom: socinfo: Avoid out of bounds read of serial number

On MSM8916 devices, the serial number exposed in sysfs is constant and does
not change across individual devices. It's always:

  db410c:/sys/devices/soc0$ cat serial_number
  2644893864

The firmware used on MSM8916 exposes SOCINFO_VERSION(0, 8), which does not
have support for the serial_num field in the socinfo struct. There is an
existing check to avoid exposing the serial number in that case, but it's
not correct: When checking the item_size returned by SMEM, we need to make
sure the *end* of the serial_num is within bounds, instead of comparing
with the *start* offset. The serial_number currently exposed on MSM8916
devices is just an out of bounds read of whatever comes after the socinfo
struct in SMEM.

Fix this by changing offsetof() to offsetofend(), so that the size of the
field is also taken into account.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/0a92feddae0634a0b87c04b19d343f6af97af700
  - https://git.kernel.org/stable/c/22cf4fae6660b6e1a583a41cbf84e3046ca9ccd0
  - https://git.kernel.org/stable/c/2495c6598731b6d7f565140f2bd63ef4bc36ce7d
  - https://git.kernel.org/stable/c/2d09d3c9afa2fc422ac3df7c9b8534f350ee19dd
  - https://git.kernel.org/stable/c/407c928305c1a37232a63811c400ef616f85ccbc
  - https://git.kernel.org/stable/c/47470acd719d45c4c8c418c07962f74cc995652b
  - https://git.kernel.org/stable/c/7445fa05317534bbd8b373c0eff8319187916030
  - https://git.kernel.org/stable/c/9c88b3a3fae4d60641c3a45be66269d00eff33cd

------------------------------------------------------------

CVE ID: CVE-2024-58008
Description: In the Linux kernel, the following vulnerability has been resolved:

KEYS: trusted: dcp: fix improper sg use with CONFIG_VMAP_STACK=y

With vmalloc stack addresses enabled (CONFIG_VMAP_STACK=y) DCP trusted
keys can crash during en- and decryption of the blob encryption key via
the DCP crypto driver. This is caused by improperly using sg_init_one()
with vmalloc'd stack buffers (plain_key_blob).

Fix this by always using kmalloc() for buffers we give to the DCP crypto
driver.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3192f1c54dddb9b5820bf5e8677809949d8e9c66
  - https://git.kernel.org/stable/c/3355594de46fb1cba663f12b9644b664b8a609f4
  - https://git.kernel.org/stable/c/e8d9fab39d1f87b52932646b2f1e7877aa3fc0f4

------------------------------------------------------------

CVE ID: CVE-2024-58009
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: handle NULL sock pointer in l2cap_sock_alloc

A NULL sock pointer is passed into l2cap_sock_alloc() when it is called
from l2cap_sock_new_connection_cb() and the error handling paths should
also be aware of it.

Seemingly a more elegant solution would be to swap bt_sock_alloc() and
l2cap_chan_create() calls since they are not interdependent to that moment
but then l2cap_chan_create() adds the soon to be deallocated and still
dummy-initialized channel to the global list accessible by many L2CAP
paths. The channel would be removed from the list in short period of time
but be a bit more straight-forward here and just check for NULL instead of
changing the order of function calls.

Found by Linux Verification Center (linuxtesting.org) with SVACE static
analysis tool.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/245d48c1ba3e7a1779c2f4cbc6f581ddc8a78e22
  - https://git.kernel.org/stable/c/297ce7f544aa675b0d136d788cad0710cdfb0785
  - https://git.kernel.org/stable/c/49c0d55d59662430f1829ae85b969619573d0fa1
  - https://git.kernel.org/stable/c/5f397409f8ee5bc82901eeaf799e1cbc4f8edcf1
  - https://git.kernel.org/stable/c/691218a50c3139f7f57ffa79fb89d932eda9571e
  - https://git.kernel.org/stable/c/8e605f580a97530e5a3583beea458a3fa4cbefbd
  - https://git.kernel.org/stable/c/a9a7672fc1a0fe18502493936ccb06413ab89ea6
  - https://git.kernel.org/stable/c/cf601a24120c674cd7c907ea695f92617af6abd0

------------------------------------------------------------

CVE ID: CVE-2024-58010
Description: In the Linux kernel, the following vulnerability has been resolved:

binfmt_flat: Fix integer overflow bug on 32 bit systems

Most of these sizes and counts are capped at 256MB so the math doesn't
result in an integer overflow.  The "relocs" count needs to be checked
as well.  Otherwise on 32bit systems the calculation of "full_data"
could be wrong.

	full_data = data_len + relocs * sizeof(unsigned long);
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.8, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/0b6be54d7386b7addbf9e5947366f94aad046938
  - https://git.kernel.org/stable/c/55cf2f4b945f6a6416cc2524ba740b83cc9af25a
  - https://git.kernel.org/stable/c/6fb98e0576ea155267e206286413dcb3a3d55c12
  - https://git.kernel.org/stable/c/8e8cd712bb06a507b26efd2a56155076aa454345
  - https://git.kernel.org/stable/c/95506c7f33452450346fbe2975c1359100f854ca
  - https://git.kernel.org/stable/c/a009378af674b808efcca1e2e67916e79ce866b3
  - https://git.kernel.org/stable/c/bc8ca18b8ef4648532c001bd6c8151143b569275
  - https://git.kernel.org/stable/c/d17ca8f2dfcf423c439859995910a20e38b86f00

------------------------------------------------------------

CVE ID: CVE-2024-58011
Description: In the Linux kernel, the following vulnerability has been resolved:

platform/x86: int3472: Check for adev == NULL

Not all devices have an ACPI companion fwnode, so adev might be NULL. This
can e.g. (theoretically) happen when a user manually binds one of
the int3472 drivers to another i2c/platform device through sysfs.

Add a check for adev not being set and return -ENODEV in that case to
avoid a possible NULL pointer deref in skl_int3472_get_acpi_buffer().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/0a30353beca2693d30bde477024d755ffecea514
  - https://git.kernel.org/stable/c/4f8b210823cc2d1f9d967f089a6c00d025bb237f
  - https://git.kernel.org/stable/c/a808ecf878ad646ebc9c83d9fc4ce72fd9c49d3d
  - https://git.kernel.org/stable/c/cd2fd6eab480dfc247b737cf7a3d6b009c4d0f1c
  - https://git.kernel.org/stable/c/f9c7cc44758f4930b41285a6d54afa8cbd9762b4

------------------------------------------------------------

CVE ID: CVE-2024-58012
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: Intel: hda-dai: Ensure DAI widget is valid during params

Each cpu DAI should associate with a widget. However, the topology might
not create the right number of DAI widgets for aggregated amps. And it
will cause NULL pointer deference.
Check that the DAI widget associated with the CPU DAI is valid to prevent
NULL pointer deference due to missing DAI widgets in topologies with
aggregated amps.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/569922b82ca660f8b24e705f6cf674e6b1f99cc7
  - https://git.kernel.org/stable/c/789a2fbf0900982788408d3b0034e0e3f914fb3b
  - https://git.kernel.org/stable/c/e012a77e4d7632cf615ba9625b1600ed8985c3b5

------------------------------------------------------------

CVE ID: CVE-2024-58013
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: MGMT: Fix slab-use-after-free Read in mgmt_remove_adv_monitor_sync

This fixes the following crash:

==================================================================
BUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543
Read of size 8 at addr ffff88814128f898 by task kworker/u9:4/5961

CPU: 1 UID: 0 PID: 5961 Comm: kworker/u9:4 Not tainted 6.12.0-syzkaller-10684-gf1cd565ce577 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Workqueue: hci0 hci_cmd_sync_work
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:378 [inline]
 print_report+0x169/0x550 mm/kasan/report.c:489
 kasan_report+0x143/0x180 mm/kasan/report.c:602
 mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543
 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332
 process_one_work kernel/workqueue.c:3229 [inline]
 process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310
 worker_thread+0x870/0xd30 kernel/workqueue.c:3391
 kthread+0x2f0/0x390 kernel/kthread.c:389
 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
 </TASK>

Allocated by task 16026:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
 poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
 __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314
 kmalloc_noprof include/linux/slab.h:901 [inline]
 kzalloc_noprof include/linux/slab.h:1037 [inline]
 mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269
 mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296
 remove_adv_monitor+0x102/0x1b0 net/bluetooth/mgmt.c:5568
 hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712
 hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832
 sock_sendmsg_nosec net/socket.c:711 [inline]
 __sock_sendmsg+0x221/0x270 net/socket.c:726
 sock_write_iter+0x2d7/0x3f0 net/socket.c:1147
 new_sync_write fs/read_write.c:586 [inline]
 vfs_write+0xaeb/0xd30 fs/read_write.c:679
 ksys_write+0x18f/0x2b0 fs/read_write.c:731
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

Freed by task 16022:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582
 poison_slab_object mm/kasan/common.c:247 [inline]
 __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264
 kasan_slab_free include/linux/kasan.h:233 [inline]
 slab_free_hook mm/slub.c:2338 [inline]
 slab_free mm/slub.c:4598 [inline]
 kfree+0x196/0x420 mm/slub.c:4746
 mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259
 __mgmt_power_off+0x183/0x430 net/bluetooth/mgmt.c:9550
 hci_dev_close_sync+0x6c4/0x11c0 net/bluetooth/hci_sync.c:5208
 hci_dev_do_close net/bluetooth/hci_core.c:483 [inline]
 hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508
 sock_do_ioctl+0x158/0x460 net/socket.c:1209
 sock_ioctl+0x626/0x8e0 net/socket.c:1328
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:906 [inline]
 __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/0f3d05aacbfcf3584bbd9caaee34cb02508dab68
  - https://git.kernel.org/stable/c/26fbd3494a7dd26269cb0817c289267dbcfdec06
  - https://git.kernel.org/stable/c/4ebbcb9bc794e5be647ee28fdf14eb1ae0659405
  - https://git.kernel.org/stable/c/75e65b983c5e2ee51962bfada98a79d805f28827
  - https://git.kernel.org/stable/c/ebb90f23f0ac21044aacf4c61cc5d7841fe99987

------------------------------------------------------------

CVE ID: CVE-2024-58014
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: brcmsmac: add gain range check to wlc_phy_iqcal_gainparams_nphy()

In 'wlc_phy_iqcal_gainparams_nphy()', add gain range check to WARN()
instead of possible out-of-bounds 'tbl_iqcal_gainparams_nphy' access.
Compile tested only.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/093286c33409bf38896f2dab0c0bb6ca388afb33
  - https://git.kernel.org/stable/c/0a457223cb2b9ca46bae7de387d0f4c093b0220d
  - https://git.kernel.org/stable/c/13ef16c4fe384b1e70277bbe1d87934ee6c81e12
  - https://git.kernel.org/stable/c/3f4a0948c3524ae50f166dbc6572a3296b014e62
  - https://git.kernel.org/stable/c/6f6e293246dc1f5b2b6b3d0f2d757598489cda79
  - https://git.kernel.org/stable/c/ada9df08b3ef683507e75b92f522fb659260147f
  - https://git.kernel.org/stable/c/c27ce584d274f6ad3cba2294497de824a3c66646
  - https://git.kernel.org/stable/c/d280a12e9b87819a8a209639d600b48a2d6d65dc

------------------------------------------------------------

CVE ID: CVE-2024-58015
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath12k: Fix for out-of bound access error

Selfgen stats are placed in a buffer using print_array_to_buf_index() function.
Array length parameter passed to the function is too big, resulting in possible
out-of bound memory error.
Decreasing buffer size by one fixes faulty upper bound of passed array.

Discovered in coverity scan, CID 1600742 and CID 1600758
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8700c4bf8b7ed98037d2acf1eaf770ad6dd431d4
  - https://git.kernel.org/stable/c/eb8c0534713865d190856f10bfc97cf0b88475b1

------------------------------------------------------------

CVE ID: CVE-2024-58016
Description: In the Linux kernel, the following vulnerability has been resolved:

safesetid: check size of policy writes

syzbot attempts to write a buffer with a large size to a sysfs entry
with writes handled by handle_policy_update(), triggering a warning
in kmalloc.

Check the size specified for write buffers before allocating.

[PM: subject tweak]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/36b385d0f2b4c0bf41d491e19075ecd990d2bf94
  - https://git.kernel.org/stable/c/96fae5bd1589731592d30b3953a90a77ef3928a6
  - https://git.kernel.org/stable/c/976284b94f2021df09829e37a367e19b84d9e5f3
  - https://git.kernel.org/stable/c/a0dec65f88c8d9290dfa1d2ca1e897abe54c5881
  - https://git.kernel.org/stable/c/c71d35676d46090c891b6419f253fb92a1a9f4eb
  - https://git.kernel.org/stable/c/ecf6a4a558097920447a6fb84dfdb279e2ac749a
  - https://git.kernel.org/stable/c/f09ff307c7299392f1c88f763299e24bc99811c7

------------------------------------------------------------

CVE ID: CVE-2024-58017
Description: In the Linux kernel, the following vulnerability has been resolved:

printk: Fix signed integer overflow when defining LOG_BUF_LEN_MAX

Shifting 1 << 31 on a 32-bit int causes signed integer overflow, which
leads to undefined behavior. To prevent this, cast 1 to u32 before
performing the shift, ensuring well-defined behavior.

This change explicitly avoids any potential overflow by ensuring that
the shift occurs on an unsigned 32-bit integer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/3d6f83df8ff2d5de84b50377e4f0d45e25311c7a
  - https://git.kernel.org/stable/c/404e5fd918a0b14abec06c7eca128f04c9b98e41
  - https://git.kernel.org/stable/c/4a2c4e7265b8eed83c25d86d702cea06493cab18
  - https://git.kernel.org/stable/c/4acf6bab775dbd22a9a799030a808a7305e01d63
  - https://git.kernel.org/stable/c/54c14022fa2ba427dc543455c2cf9225903a7174
  - https://git.kernel.org/stable/c/9a6d43844de2479a3ff8d674c3e2a16172e01598
  - https://git.kernel.org/stable/c/bb8ff054e19fe27f4e5eaac1b05e462894cfe9b1
  - https://git.kernel.org/stable/c/dfb7b179741ee09506dc7719d92f9e1cea01f10e

------------------------------------------------------------

CVE ID: CVE-2024-58018
Description: In the Linux kernel, the following vulnerability has been resolved:

nvkm: correctly calculate the available space of the GSP cmdq buffer

r535_gsp_cmdq_push() waits for the available page in the GSP cmdq
buffer when handling a large RPC request. When it sees at least one
available page in the cmdq, it quits the waiting with the amount of
free buffer pages in the queue.

Unfortunately, it always takes the [write pointer, buf_size) as
available buffer pages before rolling back and wrongly calculates the
size of the data should be copied. Thus, it can overwrite the RPC
request that GSP is currently reading, which causes GSP hang due
to corrupted RPC request:

[  549.209389] ------------[ cut here ]------------
[  549.214010] WARNING: CPU: 8 PID: 6314 at drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c:116 r535_gsp_msgq_wait+0xd0/0x190 [nvkm]
[  549.225678] Modules linked in: nvkm(E+) gsp_log(E) snd_seq_dummy(E) snd_hrtimer(E) snd_seq(E) snd_timer(E) snd_seq_device(E) snd(E) soundcore(E) rfkill(E) qrtr(E) vfat(E) fat(E) ipmi_ssif(E) amd_atl(E) intel_rapl_msr(E) intel_rapl_common(E) mlx5_ib(E) amd64_edac(E) edac_mce_amd(E) kvm_amd(E) ib_uverbs(E) kvm(E) ib_core(E) acpi_ipmi(E) ipmi_si(E) mxm_wmi(E) ipmi_devintf(E) rapl(E) i2c_piix4(E) wmi_bmof(E) joydev(E) ptdma(E) acpi_cpufreq(E) k10temp(E) pcspkr(E) ipmi_msghandler(E) xfs(E) libcrc32c(E) ast(E) i2c_algo_bit(E) crct10dif_pclmul(E) drm_shmem_helper(E) nvme_tcp(E) crc32_pclmul(E) ahci(E) drm_kms_helper(E) libahci(E) nvme_fabrics(E) crc32c_intel(E) nvme(E) cdc_ether(E) mlx5_core(E) nvme_core(E) usbnet(E) drm(E) libata(E) ccp(E) ghash_clmulni_intel(E) mii(E) t10_pi(E) mlxfw(E) sp5100_tco(E) psample(E) pci_hyperv_intf(E) wmi(E) dm_multipath(E) sunrpc(E) dm_mirror(E) dm_region_hash(E) dm_log(E) dm_mod(E) be2iscsi(E) bnx2i(E) cnic(E) uio(E) cxgb4i(E) cxgb4(E) tls(E) libcxgbi(E) libcxgb(E) qla4xxx(E)
[  549.225752]  iscsi_boot_sysfs(E) iscsi_tcp(E) libiscsi_tcp(E) libiscsi(E) scsi_transport_iscsi(E) fuse(E) [last unloaded: gsp_log(E)]
[  549.326293] CPU: 8 PID: 6314 Comm: insmod Tainted: G            E      6.9.0-rc6+ #1
[  549.334039] Hardware name: ASRockRack 1U1G-MILAN/N/ROMED8-NL, BIOS L3.12E 09/06/2022
[  549.341781] RIP: 0010:r535_gsp_msgq_wait+0xd0/0x190 [nvkm]
[  549.347343] Code: 08 00 00 89 da c1 e2 0c 48 8d ac 11 00 10 00 00 48 8b 0c 24 48 85 c9 74 1f c1 e0 0c 4c 8d 6d 30 83 e8 30 89 01 e9 68 ff ff ff <0f> 0b 49 c7 c5 92 ff ff ff e9 5a ff ff ff ba ff ff ff ff be c0 0c
[  549.366090] RSP: 0018:ffffacbccaaeb7d0 EFLAGS: 00010246
[  549.371315] RAX: 0000000000000000 RBX: 0000000000000012 RCX: 0000000000923e28
[  549.378451] RDX: 0000000000000000 RSI: 0000000055555554 RDI: ffffacbccaaeb730
[  549.385590] RBP: 0000000000000001 R08: ffff8bd14d235f70 R09: ffff8bd14d235f70
[  549.392721] R10: 0000000000000002 R11: ffff8bd14d233864 R12: 0000000000000020
[  549.399854] R13: ffffacbccaaeb818 R14: 0000000000000020 R15: ffff8bb298c67000
[  549.406988] FS:  00007f5179244740(0000) GS:ffff8bd14d200000(0000) knlGS:0000000000000000
[  549.415076] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  549.420829] CR2: 00007fa844000010 CR3: 00000001567dc005 CR4: 0000000000770ef0
[  549.427963] PKRU: 55555554
[  549.430672] Call Trace:
[  549.433126]  <TASK>
[  549.435233]  ? __warn+0x7f/0x130
[  549.438473]  ? r535_gsp_msgq_wait+0xd0/0x190 [nvkm]
[  549.443426]  ? report_bug+0x18a/0x1a0
[  549.447098]  ? handle_bug+0x3c/0x70
[  549.450589]  ? exc_invalid_op+0x14/0x70
[  549.454430]  ? asm_exc_invalid_op+0x16/0x20
[  549.458619]  ? r535_gsp_msgq_wait+0xd0/0x190 [nvkm]
[  549.463565]  r535_gsp_msg_recv+0x46/0x230 [nvkm]
[  549.468257]  r535_gsp_rpc_push+0x106/0x160 [nvkm]
[  549.473033]  r535_gsp_rpc_rm_ctrl_push+0x40/0x130 [nvkm]
[  549.478422]  nvidia_grid_init_vgpu_types+0xbc/0xe0 [nvkm]
[  549.483899]  nvidia_grid_init+0xb1/0xd0 [nvkm]
[  549.488420]  ? srso_alias_return_thunk+0x5/0xfbef5
[  549.493213]  nvkm_device_pci_probe+0x305/0x420 [nvkm]
[  549.498338]  local_pci_probe+0x46/
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01ed662bdd6fce4f59c1804b334610d710d79fa0
  - https://git.kernel.org/stable/c/56e6c7f6d2a6b4e0aae0528c502e56825bb40598
  - https://git.kernel.org/stable/c/6b6b75728c86f60c1fc596f0d4542427d0e6065b

------------------------------------------------------------

CVE ID: CVE-2024-58019
Description: In the Linux kernel, the following vulnerability has been resolved:

nvkm/gsp: correctly advance the read pointer of GSP message queue

A GSP event message consists three parts: message header, RPC header,
message body. GSP calculates the number of pages to write from the
total size of a GSP message. This behavior can be observed from the
movement of the write pointer.

However, nvkm takes only the size of RPC header and message body as
the message size when advancing the read pointer. When handling a
two-page GSP message in the non rollback case, It wrongly takes the
message body of the previous message as the message header of the next
message. As the "message length" tends to be zero, in the calculation of
size needs to be copied (0 - size of (message header)), the size needs to
be copied will be "0xffffffxx". It also triggers a kernel panic due to a
NULL pointer error.

[  547.614102] msg: 00000f90: ff ff ff ff ff ff ff ff 40 d7 18 fb 8b 00 00 00  ........@.......
[  547.622533] msg: 00000fa0: 00 00 00 00 ff ff ff ff ff ff ff ff 00 00 00 00  ................
[  547.630965] msg: 00000fb0: ff ff ff ff ff ff ff ff 00 00 00 00 ff ff ff ff  ................
[  547.639397] msg: 00000fc0: ff ff ff ff 00 00 00 00 ff ff ff ff ff ff ff ff  ................
[  547.647832] nvkm 0000:c1:00.0: gsp: peek msg rpc fn:0 len:0x0/0xffffffffffffffe0
[  547.655225] nvkm 0000:c1:00.0: gsp: get msg rpc fn:0 len:0x0/0xffffffffffffffe0
[  547.662532] BUG: kernel NULL pointer dereference, address: 0000000000000020
[  547.669485] #PF: supervisor read access in kernel mode
[  547.674624] #PF: error_code(0x0000) - not-present page
[  547.679755] PGD 0 P4D 0
[  547.682294] Oops: 0000 [#1] PREEMPT SMP NOPTI
[  547.686643] CPU: 22 PID: 322 Comm: kworker/22:1 Tainted: G            E      6.9.0-rc6+ #1
[  547.694893] Hardware name: ASRockRack 1U1G-MILAN/N/ROMED8-NL, BIOS L3.12E 09/06/2022
[  547.702626] Workqueue: events r535_gsp_msgq_work [nvkm]
[  547.707921] RIP: 0010:r535_gsp_msg_recv+0x87/0x230 [nvkm]
[  547.713375] Code: 00 8b 70 08 48 89 e1 31 d2 4c 89 f7 e8 12 f5 ff ff 48 89 c5 48 85 c0 0f 84 cf 00 00 00 48 81 fd 00 f0 ff ff 0f 87 c4 00 00 00 <8b> 55 10 41 8b 46 30 85 d2 0f 85 f6 00 00 00 83 f8 04 76 10 ba 05
[  547.732119] RSP: 0018:ffffabe440f87e10 EFLAGS: 00010203
[  547.737335] RAX: 0000000000000010 RBX: 0000000000000008 RCX: 000000000000003f
[  547.744461] RDX: 0000000000000000 RSI: ffffabe4480a8030 RDI: 0000000000000010
[  547.751585] RBP: 0000000000000010 R08: 0000000000000000 R09: ffffabe440f87bb0
[  547.758707] R10: ffffabe440f87dc8 R11: 0000000000000010 R12: 0000000000000000
[  547.765834] R13: 0000000000000000 R14: ffff9351df1e5000 R15: 0000000000000000
[  547.772958] FS:  0000000000000000(0000) GS:ffff93708eb00000(0000) knlGS:0000000000000000
[  547.781035] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  547.786771] CR2: 0000000000000020 CR3: 00000003cc220002 CR4: 0000000000770ef0
[  547.793896] PKRU: 55555554
[  547.796600] Call Trace:
[  547.799046]  <TASK>
[  547.801152]  ? __die+0x20/0x70
[  547.804211]  ? page_fault_oops+0x75/0x170
[  547.808221]  ? print_hex_dump+0x100/0x160
[  547.812226]  ? exc_page_fault+0x64/0x150
[  547.816152]  ? asm_exc_page_fault+0x22/0x30
[  547.820341]  ? r535_gsp_msg_recv+0x87/0x230 [nvkm]
[  547.825184]  r535_gsp_msgq_work+0x42/0x50 [nvkm]
[  547.829845]  process_one_work+0x196/0x3d0
[  547.833861]  worker_thread+0x2fc/0x410
[  547.837613]  ? __pfx_worker_thread+0x10/0x10
[  547.841885]  kthread+0xdf/0x110
[  547.845031]  ? __pfx_kthread+0x10/0x10
[  547.848775]  ret_from_fork+0x30/0x50
[  547.852354]  ? __pfx_kthread+0x10/0x10
[  547.856097]  ret_from_fork_asm+0x1a/0x30
[  547.860019]  </TASK>
[  547.862208] Modules linked in: nvkm(E) gsp_log(E) snd_seq_dummy(E) snd_hrtimer(E) snd_seq(E) snd_timer(E) snd_seq_device(E) snd(E) soundcore(E) rfkill(E) qrtr(E) vfat(E) fat(E) ipmi_ssif(E) amd_atl(E) intel_rapl_msr(E) intel_rapl_common(E) amd64_edac(E) mlx5_ib(E) edac_mce_amd(E) kvm_amd
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5185e63b45ea39339ed83f269e2ddfafb07e70d9
  - https://git.kernel.org/stable/c/67c9cf82f50236d9c000333b26b4f95eb2c3e1b2
  - https://git.kernel.org/stable/c/8d9beb4aebc02c4bd09e1d39c9c5f1c68c786dbc

------------------------------------------------------------

CVE ID: CVE-2024-58020
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: multitouch: Add NULL check in mt_input_configured

devm_kasprintf() can return a NULL pointer on failure,but this
returned value in mt_input_configured() is not checked.
Add NULL check in mt_input_configured(), to handle kernel NULL
pointer dereference error.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.326, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.295, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.257, Last Version (Excluding): 5.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.195, Last Version (Excluding): 5.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.132, Last Version (Excluding): 5.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.53, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4.16, Last Version (Excluding): 6.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.5.3, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2052b44cd0a62b6fdbe3371e5ba6029c56c400ca
  - https://git.kernel.org/stable/c/4e7113f591163d99adc7cbcd7295030c8c5d3fc7
  - https://git.kernel.org/stable/c/62f8bf06262b6fc55c58f4c5256140f1382f3b01
  - https://git.kernel.org/stable/c/97c09cc2e72769edb6994b531edcfa313b96bade
  - https://git.kernel.org/stable/c/9b8e2220d3a052a690b1d1b23019673e612494c5
  - https://git.kernel.org/stable/c/a04d96ef67a42165f93194eef22a270acba4b74c
  - https://git.kernel.org/stable/c/a6bfd3856e9f3da083f177753c623d58ba935e0a
  - https://git.kernel.org/stable/c/aa879ef6d3acf96fa2c7122d0632061d4ea58d48

------------------------------------------------------------

CVE ID: CVE-2024-58021
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: winwing: Add NULL check in winwing_init_led()

devm_kasprintf() can return a NULL pointer on failure,but this
returned value in winwing_init_led() is not checked.
Add NULL check in winwing_init_led(), to handle kernel NULL
pointer dereference error.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4001f6f79183b8868d80dd2036dfb4ea3d325e8f
  - https://git.kernel.org/stable/c/45ab5166a82d038c898985b0ad43ead69c1f9573
  - https://git.kernel.org/stable/c/b99dbdee8a89c44d03ae9830ab19f31e124a3f32

------------------------------------------------------------

CVE ID: CVE-2025-21732
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix a race for an ODP MR which leads to CQE with error

This patch addresses a race condition for an ODP MR that can result in a
CQE with an error on the UMR QP.

During the __mlx5_ib_dereg_mr() flow, the following sequence of calls
occurs:

mlx5_revoke_mr()
 mlx5r_umr_revoke_mr()
 mlx5r_umr_post_send_wait()

At this point, the lkey is freed from the hardware's perspective.

However, concurrently, mlx5_ib_invalidate_range() might be triggered by
another task attempting to invalidate a range for the same freed lkey.

This task will:
 - Acquire the umem_odp->umem_mutex lock.
 - Call mlx5r_umr_update_xlt() on the UMR QP.
 - Since the lkey has already been freed, this can lead to a CQE error,
   causing the UMR QP to enter an error state [1].

To resolve this race condition, the umem_odp->umem_mutex lock is now also
acquired as part of the mlx5_revoke_mr() scope.  Upon successful revoke,
we set umem_odp->private which points to that MR to NULL, preventing any
further invalidation attempts on its lkey.

[1] From dmesg:

   infiniband rocep8s0f0: dump_cqe:277:(pid 0): WC error: 6, Message: memory bind operation error
   cqe_dump: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   cqe_dump: 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   cqe_dump: 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   cqe_dump: 00000030: 00 00 00 00 08 00 78 06 25 00 11 b9 00 0e dd d2

   WARNING: CPU: 15 PID: 1506 at drivers/infiniband/hw/mlx5/umr.c:394 mlx5r_umr_post_send_wait+0x15a/0x2b0 [mlx5_ib]
   Modules linked in: ip6table_mangle ip6table_natip6table_filter ip6_tables iptable_mangle xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_umad ib_ipoib ib_cm mlx5_ib ib_uverbs ib_core fuse mlx5_core
   CPU: 15 UID: 0 PID: 1506 Comm: ibv_rc_pingpong Not tainted 6.12.0-rc7+ #1626
   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
   RIP: 0010:mlx5r_umr_post_send_wait+0x15a/0x2b0 [mlx5_ib]
   [..]
   Call Trace:
   <TASK>
   mlx5r_umr_update_xlt+0x23c/0x3e0 [mlx5_ib]
   mlx5_ib_invalidate_range+0x2e1/0x330 [mlx5_ib]
   __mmu_notifier_invalidate_range_start+0x1e1/0x240
   zap_page_range_single+0xf1/0x1a0
   madvise_vma_behavior+0x677/0x6e0
   do_madvise+0x1a2/0x4b0
   __x64_sys_madvise+0x25/0x30
   do_syscall_64+0x6b/0x140
   entry_SYSCALL_64_after_hwframe+0x76/0x7e
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5297f5ddffef47b94172ab0d3d62270002a3dcc1
  - https://git.kernel.org/stable/c/abb604a1a9c87255c7a6f3b784410a9707baf467
  - https://git.kernel.org/stable/c/b13d32786acabf70a7b04ed24b7468fc3c82977c

------------------------------------------------------------

CVE ID: CVE-2025-21733
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing/osnoise: Fix resetting of tracepoints

If a timerlat tracer is started with the osnoise option OSNOISE_WORKLOAD
disabled, but then that option is enabled and timerlat is removed, the
tracepoints that were enabled on timerlat registration do not get
disabled. If the option is disabled again and timelat is started, then it
triggers a warning in the tracepoint code due to registering the
tracepoint again without ever disabling it.

Do not use the same user space defined options to know to disable the
tracepoints when timerlat is removed. Instead, set a global flag when it
is enabled and use that flag to know to disable the events.

 ~# echo NO_OSNOISE_WORKLOAD > /sys/kernel/tracing/osnoise/options
 ~# echo timerlat > /sys/kernel/tracing/current_tracer
 ~# echo OSNOISE_WORKLOAD > /sys/kernel/tracing/osnoise/options
 ~# echo nop > /sys/kernel/tracing/current_tracer
 ~# echo NO_OSNOISE_WORKLOAD > /sys/kernel/tracing/osnoise/options
 ~# echo timerlat > /sys/kernel/tracing/current_tracer

Triggers:

 ------------[ cut here ]------------
 WARNING: CPU: 6 PID: 1337 at kernel/tracepoint.c:294 tracepoint_add_func+0x3b6/0x3f0
 Modules linked in:
 CPU: 6 UID: 0 PID: 1337 Comm: rtla Not tainted 6.13.0-rc4-test-00018-ga867c441128e-dirty #73
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
 RIP: 0010:tracepoint_add_func+0x3b6/0x3f0
 Code: 48 8b 53 28 48 8b 73 20 4c 89 04 24 e8 23 59 11 00 4c 8b 04 24 e9 36 fe ff ff 0f 0b b8 ea ff ff ff 45 84 e4 0f 84 68 fe ff ff <0f> 0b e9 61 fe ff ff 48 8b 7b 18 48 85 ff 0f 84 4f ff ff ff 49 8b
 RSP: 0018:ffffb9b003a87ca0 EFLAGS: 00010202
 RAX: 00000000ffffffef RBX: ffffffff92f30860 RCX: 0000000000000000
 RDX: 0000000000000000 RSI: ffff9bf59e91ccd0 RDI: ffffffff913b6410
 RBP: 000000000000000a R08: 00000000000005c7 R09: 0000000000000002
 R10: ffffb9b003a87ce0 R11: 0000000000000002 R12: 0000000000000001
 R13: ffffb9b003a87ce0 R14: ffffffffffffffef R15: 0000000000000008
 FS:  00007fce81209240(0000) GS:ffff9bf6fdd00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 000055e99b728000 CR3: 00000001277c0002 CR4: 0000000000172ef0
 Call Trace:
  <TASK>
  ? __warn.cold+0xb7/0x14d
  ? tracepoint_add_func+0x3b6/0x3f0
  ? report_bug+0xea/0x170
  ? handle_bug+0x58/0x90
  ? exc_invalid_op+0x17/0x70
  ? asm_exc_invalid_op+0x1a/0x20
  ? __pfx_trace_sched_migrate_callback+0x10/0x10
  ? tracepoint_add_func+0x3b6/0x3f0
  ? __pfx_trace_sched_migrate_callback+0x10/0x10
  ? __pfx_trace_sched_migrate_callback+0x10/0x10
  tracepoint_probe_register+0x78/0xb0
  ? __pfx_trace_sched_migrate_callback+0x10/0x10
  osnoise_workload_start+0x2b5/0x370
  timerlat_tracer_init+0x76/0x1b0
  tracing_set_tracer+0x244/0x400
  tracing_set_trace_write+0xa0/0xe0
  vfs_write+0xfc/0x570
  ? do_sys_openat2+0x9c/0xe0
  ksys_write+0x72/0xf0
  do_syscall_64+0x79/0x1c0
  entry_SYSCALL_64_after_hwframe+0x76/0x7e
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/b45707c3c0671d9c49fa7b94c197a508aa55d16f
  - https://git.kernel.org/stable/c/e3ff4245928f948f3eb2e852aa350b870421c358
  - https://git.kernel.org/stable/c/e482cecd2305be1e3e6a8ee70c9b86c511484f7b
  - https://git.kernel.org/stable/c/ee8c4c39a8f97467d63adfe03bcd45139d8c8b53

------------------------------------------------------------

CVE ID: CVE-2025-21734
Description: In the Linux kernel, the following vulnerability has been resolved:

misc: fastrpc: Fix copy buffer page size

For non-registered buffer, fastrpc driver copies the buffer and
pass it to the remote subsystem. There is a problem with current
implementation of page size calculation which is not considering
the offset in the calculation. This might lead to passing of
improper and out-of-bounds page size which could result in
memory issue. Calculate page start and page end using the offset
adjusted address instead of absolute address.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/24a79c6bc8de763f7c50f4f84f8b0c183bc25a51
  - https://git.kernel.org/stable/c/c0464bad0e85fcd5d47e4297d1e410097c979e55
  - https://git.kernel.org/stable/c/c3f7161123fcbdc64e90119ccce292d8b66281c4
  - https://git.kernel.org/stable/c/c56ba3ea8e3c9a69a992aad18f7a65e43e51d623
  - https://git.kernel.org/stable/c/e966eae72762ecfdbdb82627e2cda48845b9dd66

------------------------------------------------------------

CVE ID: CVE-2025-21735
Description: In the Linux kernel, the following vulnerability has been resolved:

NFC: nci: Add bounds checking in nci_hci_create_pipe()

The "pipe" variable is a u8 which comes from the network.  If it's more
than 127, then it results in memory corruption in the caller,
nci_hci_connect_gate().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/10b3f947b609713e04022101f492d288a014ddfa
  - https://git.kernel.org/stable/c/110b43ef05342d5a11284cc8b21582b698b4ef1c
  - https://git.kernel.org/stable/c/172cdfc3a5ea20289c58fb73dadc6fd4a8784a4e
  - https://git.kernel.org/stable/c/2ae4bade5a64d126bd18eb66bd419005c5550218
  - https://git.kernel.org/stable/c/59c7ed20217c0939862fbf8145bc49d5b3a13f4f
  - https://git.kernel.org/stable/c/674e17c5933779a8bf5c15d596fdfcb5ccdebbc2
  - https://git.kernel.org/stable/c/bd249109d266f1d52548c46634a15b71656e0d44
  - https://git.kernel.org/stable/c/d5a461c315e5ff92657f84d8ba50caa5abf5c22a

------------------------------------------------------------

CVE ID: CVE-2025-21736
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: fix possible int overflows in nilfs_fiemap()

Since nilfs_bmap_lookup_contig() in nilfs_fiemap() calculates its result
by being prepared to go through potentially maxblocks == INT_MAX blocks,
the value in n may experience an overflow caused by left shift of blkbits.

While it is extremely unlikely to occur, play it safe and cast right hand
expression to wider type to mitigate the issue.

Found by Linux Verification Center (linuxtesting.org) with static analysis
tool SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.38, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/250423300b4b0335918be187ef3cade248c06e6a
  - https://git.kernel.org/stable/c/58b1c6881081f5ddfb9a14dc241a74732c0f855c
  - https://git.kernel.org/stable/c/6438ef381c183444f7f9d1de18f22661cba1e946
  - https://git.kernel.org/stable/c/7649937987fed51ed09985da4019d50189fc534e
  - https://git.kernel.org/stable/c/8f41df5fd4c11d26e929a85f7239799641f92da7
  - https://git.kernel.org/stable/c/b9495a9109abc31d3170f7aad7d48aa64610a1a2
  - https://git.kernel.org/stable/c/f2bd0f1ab47822fe5bd699c8458b896c4b2edea1
  - https://git.kernel.org/stable/c/f3d80f34f58445355fa27b9579a449fb186aa64e

------------------------------------------------------------

CVE ID: CVE-2025-21737
Description: In the Linux kernel, the following vulnerability has been resolved:

ceph: fix memory leak in ceph_mds_auth_match()

We now free the temporary target path substring allocation on every
possible branch, instead of omitting the default branch.  In some
cases, a memory leak occured, which could rapidly crash the system
(depending on how many file accesses were attempted).

This was detected in production because it caused a continuous memory
growth, eventually triggering kernel OOM and completely hard-locking
the kernel.

Relevant kmemleak stacktrace:

    unreferenced object 0xffff888131e69900 (size 128):
      comm "git", pid 66104, jiffies 4295435999
      hex dump (first 32 bytes):
        76 6f 6c 75 6d 65 73 2f 63 6f 6e 74 61 69 6e 65  volumes/containe
        72 73 2f 67 69 74 65 61 2f 67 69 74 65 61 2f 67  rs/gitea/gitea/g
      backtrace (crc 2f3bb450):
        [<ffffffffaa68fb49>] __kmalloc_noprof+0x359/0x510
        [<ffffffffc32bf1df>] ceph_mds_check_access+0x5bf/0x14e0 [ceph]
        [<ffffffffc3235722>] ceph_open+0x312/0xd80 [ceph]
        [<ffffffffaa7dd786>] do_dentry_open+0x456/0x1120
        [<ffffffffaa7e3729>] vfs_open+0x79/0x360
        [<ffffffffaa832875>] path_openat+0x1de5/0x4390
        [<ffffffffaa834fcc>] do_filp_open+0x19c/0x3c0
        [<ffffffffaa7e44a1>] do_sys_openat2+0x141/0x180
        [<ffffffffaa7e4945>] __x64_sys_open+0xe5/0x1a0
        [<ffffffffac2cc2f7>] do_syscall_64+0xb7/0x210
        [<ffffffffac400130>] entry_SYSCALL_64_after_hwframe+0x77/0x7f

It can be triggered by mouting a subdirectory of a CephFS filesystem,
and then trying to access files on this subdirectory with an auth token
using a path-scoped capability:

    $ ceph auth get client.services
    [client.services]
            key = REDACTED
            caps mds = "allow rw fsname=cephfs path=/volumes/"
            caps mon = "allow r fsname=cephfs"
            caps osd = "allow rw tag cephfs data=cephfs"

    $ cat /proc/self/mounts
    services@[REDACTED].cephfs=/volumes/containers /ceph/containers ceph rw,noatime,name=services,secret=<hidden>,ms_mode=prefer-crc,mount_timeout=300,acl,mon_addr=[REDACTED]:3300,recover_session=clean 0 0

    $ seq 1 1000000 | xargs -P32 --replace={} touch /ceph/containers/file-{} && \
    seq 1 1000000 | xargs -P32 --replace={} cat /ceph/containers/file-{}

[ idryomov: combine if statements, rename rc to path_matched and make
            it a bool, formatting ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/146109fe936ac07f8f60cd6267543688985b96bc
  - https://git.kernel.org/stable/c/2b6086c5efe5c7bd6e0eb440d96c26ca0d20d9d7
  - https://git.kernel.org/stable/c/3b7d93db450e9d8ead80d75e2a303248f1528c35

------------------------------------------------------------

CVE ID: CVE-2025-21738
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: libata-sff: Ensure that we cannot write outside the allocated buffer

reveliofuzzing reported that a SCSI_IOCTL_SEND_COMMAND ioctl with out_len
set to 0xd42, SCSI command set to ATA_16 PASS-THROUGH, ATA command set to
ATA_NOP, and protocol set to ATA_PROT_PIO, can cause ata_pio_sector() to
write outside the allocated buffer, overwriting random memory.

While a ATA device is supposed to abort a ATA_NOP command, there does seem
to be a bug either in libata-sff or QEMU, where either this status is not
set, or the status is cleared before read by ata_sff_hsm_move().
Anyway, that is most likely a separate bug.

Looking at __atapi_pio_bytes(), it already has a safety check to ensure
that __atapi_pio_bytes() cannot write outside the allocated buffer.

Add a similar check to ata_pio_sector(), such that also ata_pio_sector()
cannot write outside the allocated buffer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a17a9944b8d89ef03946121241870ac53ddaf45
  - https://git.kernel.org/stable/c/0dd5aade301a10f4b329fa7454fdcc2518741902
  - https://git.kernel.org/stable/c/6e74e53b34b6dec5a50e1404e2680852ec6768d2
  - https://git.kernel.org/stable/c/a8f8cf87059ed1905c2a5c72f8b39a4f57b11b4c
  - https://git.kernel.org/stable/c/d5e6e3000309359eae2a17117aa6e3c44897bf6c

------------------------------------------------------------

CVE ID: CVE-2025-21739
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: core: Fix use-after free in init error and remove paths

devm_blk_crypto_profile_init() registers a cleanup handler to run when
the associated (platform-) device is being released. For UFS, the
crypto private data and pointers are stored as part of the ufs_hba's
data structure 'struct ufs_hba::crypto_profile'. This structure is
allocated as part of the underlying ufshcd and therefore Scsi_host
allocation.

During driver release or during error handling in ufshcd_pltfrm_init(),
this structure is released as part of ufshcd_dealloc_host() before the
(platform-) device associated with the crypto call above is released.
Once this device is released, the crypto cleanup code will run, using
the just-released 'struct ufs_hba::crypto_profile'. This causes a
use-after-free situation:

  Call trace:
   kfree+0x60/0x2d8 (P)
   kvfree+0x44/0x60
   blk_crypto_profile_destroy_callback+0x28/0x70
   devm_action_release+0x1c/0x30
   release_nodes+0x6c/0x108
   devres_release_all+0x98/0x100
   device_unbind_cleanup+0x20/0x70
   really_probe+0x218/0x2d0

In other words, the initialisation code flow is:

  platform-device probe
    ufshcd_pltfrm_init()
      ufshcd_alloc_host()
        scsi_host_alloc()
          allocation of struct ufs_hba
          creation of scsi-host devices
    devm_blk_crypto_profile_init()
      devm registration of cleanup handler using platform-device

and during error handling of ufshcd_pltfrm_init() or during driver
removal:

  ufshcd_dealloc_host()
    scsi_host_put()
      put_device(scsi-host)
        release of struct ufs_hba
  put_device(platform-device)
    crypto cleanup handler

To fix this use-after free, change ufshcd_alloc_host() to register a
devres action to automatically cleanup the underlying SCSI device on
ufshcd destruction, without requiring explicit calls to
ufshcd_dealloc_host(). This way:

    * the crypto profile and all other ufs_hba-owned resources are
      destroyed before SCSI (as they've been registered after)
    * a memleak is plugged in tc-dwc-g210-pci.c remove() as a
      side-effect
    * EXPORT_SYMBOL_GPL(ufshcd_dealloc_host) can be removed fully as
      it's not needed anymore
    * no future drivers using ufshcd_alloc_host() could ever forget
      adding the cleanup
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0c77c0d754fe83cb154715fcfec6c3faef94f207
  - https://git.kernel.org/stable/c/9c185beae09a3eb85f54777edafa227f7e03075d
  - https://git.kernel.org/stable/c/f8fb2403ddebb5eea0033d90d9daae4c88749ada

------------------------------------------------------------

CVE ID: CVE-2025-21741
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet: ipheth: fix DPE OoB read

Fix an out-of-bounds DPE read, limit the number of processed DPEs to
the amount that fits into the fixed-size NDP16 header.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.5, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/22475242ddb70e35c9148234be9a3aa9fb8efff9
  - https://git.kernel.org/stable/c/5835bf66c50ac2b85ed28b282c2456c3516ef0a6
  - https://git.kernel.org/stable/c/971b8c572559e52d32a2b82f2d9e0685439a0117
  - https://git.kernel.org/stable/c/ee591f2b281721171896117f9946fced31441418

------------------------------------------------------------

CVE ID: CVE-2025-21742
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet: ipheth: use static NDP16 location in URB

Original code allowed for the start of NDP16 to be anywhere within the
URB based on the `wNdpIndex` value in NTH16. Only the start position of
NDP16 was checked, so it was possible for even the fixed-length part
of NDP16 to extend past the end of URB, leading to an out-of-bounds
read.

On iOS devices, the NDP16 header always directly follows NTH16. Rely on
and check for this specific format.

This, along with NCM-specific minimal URB length check that already
exists, will ensure that the fixed-length part of NDP16 plus a set
amount of DPEs fit within the URB.

Note that this commit alone does not fully address the OoB read.
The limit on the amount of DPEs needs to be enforced separately.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.5, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/2b619445dcb6dab97d8ed033fb57225aca1288c4
  - https://git.kernel.org/stable/c/86586dcb75cb8fd062a518aca8ee667938b91efb
  - https://git.kernel.org/stable/c/8fb062178e1ce180e2cfdc9abc83a1b9fea381ca
  - https://git.kernel.org/stable/c/cf1ac7f7cf601ac31d1580559c002b5e37b733b7

------------------------------------------------------------

CVE ID: CVE-2025-21743
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet: ipheth: fix possible overflow in DPE length check

Originally, it was possible for the DPE length check to overflow if
wDatagramIndex + wDatagramLength > U16_MAX. This could lead to an OoB
read.

Move the wDatagramIndex term to the other side of the inequality.

An existing condition ensures that wDatagramIndex < urb->actual_length.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.5, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/18bf6f5cce3172cb303c3f0551aa9443d5ed74f8
  - https://git.kernel.org/stable/c/c219427ed296f94bb4b91d08626776dc7719ee27
  - https://git.kernel.org/stable/c/d677e7dd59ad6837496f5a02d8e5d39824278dfd
  - https://git.kernel.org/stable/c/d824a964185910e317287f034c0a439c08b4fe49

------------------------------------------------------------

CVE ID: CVE-2025-21744
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: brcmfmac: fix NULL pointer dereference in brcmf_txfinalize()

On removal of the device or unloading of the kernel module a potential NULL
pointer dereference occurs.

The following sequence deletes the interface:

  brcmf_detach()
    brcmf_remove_interface()
      brcmf_del_if()

Inside the brcmf_del_if() function the drvr->if2bss[ifidx] is updated to
BRCMF_BSSIDX_INVALID (-1) if the bsscfgidx matches.

After brcmf_remove_interface() call the brcmf_proto_detach() function is
called providing the following sequence:

  brcmf_detach()
    brcmf_proto_detach()
      brcmf_proto_msgbuf_detach()
        brcmf_flowring_detach()
          brcmf_msgbuf_delete_flowring()
            brcmf_msgbuf_remove_flowring()
              brcmf_flowring_delete()
                brcmf_get_ifp()
                brcmf_txfinalize()

Since brcmf_get_ip() can and actually will return NULL in this case the
call to brcmf_txfinalize() will result in a NULL pointer dereference inside
brcmf_txfinalize() when trying to update ifp->ndev->stats.tx_errors.

This will only happen if a flowring still has an skb.

Although the NULL pointer dereference has only been seen when trying to
update the tx statistic, all other uses of the ifp pointer have been
guarded as well with an early return if ifp is NULL.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/2326e19190e176fd72bb542b837a9d2b7fcb8693
  - https://git.kernel.org/stable/c/3877fc67bd3d5566cc12763bce39710ceb74a97d
  - https://git.kernel.org/stable/c/4e51d6d093e763348916e69d06d87e0a5593661b
  - https://git.kernel.org/stable/c/59ff4fa653ff6db07c61152516ffba79c2a74bda
  - https://git.kernel.org/stable/c/61541d9b5a23df33934fcc620a3a81f246b1b240
  - https://git.kernel.org/stable/c/68abd0c4ebf24cd499841a488b97a6873d5efabb
  - https://git.kernel.org/stable/c/a2beefc4fa49ebc22e664dc6b39dbd054f8488f9
  - https://git.kernel.org/stable/c/fbbfef2a5b858eab55741a58b2ac9a0cc8d53c58

------------------------------------------------------------

CVE ID: CVE-2025-21745
Description: In the Linux kernel, the following vulnerability has been resolved:

blk-cgroup: Fix class @block_class's subsystem refcount leakage

blkcg_fill_root_iostats() iterates over @block_class's devices by
class_dev_iter_(init|next)(), but does not end iterating with
class_dev_iter_exit(), so causes the class's subsystem refcount leakage.

Fix by ending the iterating with class_dev_iter_exit().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.9, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/2ce09aabe009453d641a2ceb79e6461a2d4f3876
  - https://git.kernel.org/stable/c/38287f779b34dfe959b4b681e909f2d3d52b88be
  - https://git.kernel.org/stable/c/431b6ef2714be4d5babb802114987541a88b43b0
  - https://git.kernel.org/stable/c/67c7f213e052b1aa6caba4a7e25e303bc6997126
  - https://git.kernel.org/stable/c/993121481b5a87829f1e8163f47158b72679f309
  - https://git.kernel.org/stable/c/d1248436cbef1f924c04255367ff4845ccd9025e
  - https://git.kernel.org/stable/c/ffb494f1e7a047bd7a41b13796fcfb08fe5beafb

------------------------------------------------------------

CVE ID: CVE-2025-21746
Description: In the Linux kernel, the following vulnerability has been resolved:

Input: synaptics - fix crash when enabling pass-through port

When enabling a pass-through port an interrupt might come before psmouse
driver binds to the pass-through port. However synaptics sub-driver
tries to access psmouse instance presumably associated with the
pass-through port to figure out if only 1 byte of response or entire
protocol packet needs to be forwarded to the pass-through port and may
crash if psmouse instance has not been attached to the port yet.

Fix the crash by introducing open() and close() methods for the port and
check if the port is open before trying to access psmouse instance.
Because psmouse calls serio_open() only after attaching psmouse instance
to serio port instance this prevents the potential crash.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/08bd5b7c9a2401faabdaa1472d45c7de0755fd7e
  - https://git.kernel.org/stable/c/3e179d3f1ada963475395d81bfe91daef4d1a24c
  - https://git.kernel.org/stable/c/87da1ea93ec9f9f0004e5b12e78789bc94e360bf
  - https://git.kernel.org/stable/c/a2cbcd70133dc0d4d4c95ad4cd5412b935354c7c

------------------------------------------------------------

CVE ID: CVE-2025-21747
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/ast: astdp: Fix timeout for enabling video signal

The ASTDP transmitter sometimes takes up to 1 second for enabling the
video signal, while the timeout is only 200 msec. This results in a
kernel error message. Increase the timeout to 1 second. An example
of the error message is shown below.

[  697.084433] ------------[ cut here ]------------
[  697.091115] ast 0000:02:00.0: [drm] drm_WARN_ON(!__ast_dp_wait_enable(ast, enabled))
[  697.091233] WARNING: CPU: 1 PID: 160 at drivers/gpu/drm/ast/ast_dp.c:232 ast_dp_set_enable+0x123/0x140 [ast]
[...]
[  697.272469] RIP: 0010:ast_dp_set_enable+0x123/0x140 [ast]
[...]
[  697.415283] Call Trace:
[  697.420727]  <TASK>
[  697.425908]  ? show_trace_log_lvl+0x196/0x2c0
[  697.433304]  ? show_trace_log_lvl+0x196/0x2c0
[  697.440693]  ? drm_atomic_helper_commit_modeset_enables+0x30a/0x470
[  697.450115]  ? ast_dp_set_enable+0x123/0x140 [ast]
[  697.458059]  ? __warn.cold+0xaf/0xca
[  697.464713]  ? ast_dp_set_enable+0x123/0x140 [ast]
[  697.472633]  ? report_bug+0x134/0x1d0
[  697.479544]  ? handle_bug+0x58/0x90
[  697.486127]  ? exc_invalid_op+0x13/0x40
[  697.492975]  ? asm_exc_invalid_op+0x16/0x20
[  697.500224]  ? preempt_count_sub+0x14/0xc0
[  697.507473]  ? ast_dp_set_enable+0x123/0x140 [ast]
[  697.515377]  ? ast_dp_set_enable+0x123/0x140 [ast]
[  697.523227]  drm_atomic_helper_commit_modeset_enables+0x30a/0x470
[  697.532388]  drm_atomic_helper_commit_tail+0x58/0x90
[  697.540400]  ast_mode_config_helper_atomic_commit_tail+0x30/0x40 [ast]
[  697.550009]  commit_tail+0xfe/0x1d0
[  697.556547]  drm_atomic_helper_commit+0x198/0x1c0

This is a cosmetical problem. Enabling the video signal still works
even with the error message. The problem has always been present, but
only recent versions of the ast driver warn about missing the timeout.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/589839379031cce220c9cab9f27cb5477195067e
  - https://git.kernel.org/stable/c/fd39c41bcd82d5ebaaebadb944eab5598c668a90

------------------------------------------------------------

CVE ID: CVE-2025-21748
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix integer overflows on 32 bit systems

On 32bit systems the addition operations in ipc_msg_alloc() can
potentially overflow leading to memory corruption.
Add bounds checking using KSMBD_IPC_MAX_PAYLOAD to avoid overflow.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/760568c1f62ea874e8fb492f9cfa4f47b4b8391e
  - https://git.kernel.org/stable/c/82f59d64e6297f270311b16b5dcf65be406d1ea3
  - https://git.kernel.org/stable/c/aab98e2dbd648510f8f51b83fbf4721206ccae45
  - https://git.kernel.org/stable/c/b4b902737746c490258de5cb55cab39e79927a67
  - https://git.kernel.org/stable/c/ecb9947fa7c99a77b04d43404c6988a0d326e4a0
  - https://git.kernel.org/stable/c/f3b9fb2764591d792d160f375851013665a9e820

------------------------------------------------------------

CVE ID: CVE-2025-21749
Description: In the Linux kernel, the following vulnerability has been resolved:

net: rose: lock the socket in rose_bind()

syzbot reported a soft lockup in rose_loopback_timer(),
with a repro calling bind() from multiple threads.

rose_bind() must lock the socket to avoid this issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4c04b0ab3a647e76d0e752b013de8e404abafc63
  - https://git.kernel.org/stable/c/667f61b3498df751c8b3f0be1637e7226cbe3ed0
  - https://git.kernel.org/stable/c/970cd2ed26cdab2b0f15b6d90d7eaa36538244a5
  - https://git.kernel.org/stable/c/a1300691aed9ee852b0a9192e29e2bdc2411a7e6
  - https://git.kernel.org/stable/c/b8bf5c3fb778bbb1f3ff7d98ec577c969f687513
  - https://git.kernel.org/stable/c/d308661a0f4e7c8e86dfc7074a55ee5894c61538
  - https://git.kernel.org/stable/c/e0384efd45f615603e6869205b72040c209e69cc
  - https://git.kernel.org/stable/c/ed00c5f907d08a647b8bf987514ad8c6b17971a7

------------------------------------------------------------

CVE ID: CVE-2025-21750
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: brcmfmac: Check the return value of of_property_read_string_index()

Somewhen between 6.10 and 6.11 the driver started to crash on my
MacBookPro14,3. The property doesn't exist and 'tmp' remains
uninitialized, so we pass a random pointer to devm_kstrdup().

The crash I am getting looks like this:

BUG: unable to handle page fault for address: 00007f033c669379
PF: supervisor read access in kernel mode
PF: error_code(0x0001) - permissions violation
PGD 8000000101341067 P4D 8000000101341067 PUD 101340067 PMD 1013bb067 PTE 800000010aee9025
Oops: Oops: 0001 [#1] SMP PTI
CPU: 4 UID: 0 PID: 827 Comm: (udev-worker) Not tainted 6.11.8-gentoo #1
Hardware name: Apple Inc. MacBookPro14,3/Mac-551B86E5744E2388, BIOS 529.140.2.0.0 06/23/2024
RIP: 0010:strlen+0x4/0x30
Code: f7 75 ec 31 c0 c3 cc cc cc cc 48 89 f8 c3 cc cc cc cc 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa <80> 3f 00 74 14 48 89 f8 48 83 c0 01 80 38 00 75 f7 48 29 f8 c3 cc
RSP: 0018:ffffb4aac0683ad8 EFLAGS: 00010202
RAX: 00000000ffffffea RBX: 00007f033c669379 RCX: 0000000000000001
RDX: 0000000000000cc0 RSI: 00007f033c669379 RDI: 00007f033c669379
RBP: 00000000ffffffea R08: 0000000000000000 R09: 00000000c0ba916a
R10: ffffffffffffffff R11: ffffffffb61ea260 R12: ffff91f7815b50c8
R13: 0000000000000cc0 R14: ffff91fafefffe30 R15: ffffb4aac0683b30
FS:  00007f033ccbe8c0(0000) GS:ffff91faeed00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f033c669379 CR3: 0000000107b1e004 CR4: 00000000003706f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 ? __die+0x23/0x70
 ? page_fault_oops+0x149/0x4c0
 ? raw_spin_rq_lock_nested+0xe/0x20
 ? sched_balance_newidle+0x22b/0x3c0
 ? update_load_avg+0x78/0x770
 ? exc_page_fault+0x6f/0x150
 ? asm_exc_page_fault+0x26/0x30
 ? __pfx_pci_conf1_write+0x10/0x10
 ? strlen+0x4/0x30
 devm_kstrdup+0x25/0x70
 brcmf_of_probe+0x273/0x350 [brcmfmac]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/082d9e263af8de68f0c34f67b251818205160f6e
  - https://git.kernel.org/stable/c/7ef2ea1429684d5cef207519bdf6ce45e50e8ac5
  - https://git.kernel.org/stable/c/af525a8b2ab85291617e79a5bb18bcdcb529e80c
  - https://git.kernel.org/stable/c/bb8e35e33e79eb8e44396adbc8cb6c8c5f16b731
  - https://git.kernel.org/stable/c/c9480e9f2d10135476101619bcbd1c49c15d595f

------------------------------------------------------------

CVE ID: CVE-2025-21751
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: HWS, change error flow on matcher disconnect

Currently, when firmware failure occurs during matcher disconnect flow,
the error flow of the function reconnects the matcher back and returns
an error, which continues running the calling function and eventually
frees the matcher that is being disconnected.
This leads to a case where we have a freed matcher on the matchers list,
which in turn leads to use-after-free and eventual crash.

This patch fixes that by not trying to reconnect the matcher back when
some FW command fails during disconnect.

Note that we're dealing here with FW error. We can't overcome this
problem. This might lead to bad steering state (e.g. wrong connection
between matchers), and will also lead to resource leakage, as it is
the case with any other error handling during resource destruction.

However, the goal here is to allow the driver to continue and not crash
the machine with use-after-free error.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/1ce840c7a659aa53a31ef49f0271b4fd0dc10296
  - https://git.kernel.org/stable/c/23a86c76a1a197e8fbbbd0ce3e826eb58c471624

------------------------------------------------------------

CVE ID: CVE-2025-21752
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: don't use btrfs_set_item_key_safe on RAID stripe-extents

Don't use btrfs_set_item_key_safe() to modify the keys in the RAID
stripe-tree, as this can lead to corruption of the tree, which is caught
by the checks in btrfs_set_item_key_safe():

 BTRFS info (device nvme1n1): leaf 49168384 gen 15 total ptrs 194 free space 8329 owner 12
 BTRFS info (device nvme1n1): refs 2 lock_owner 1030 current 1030
  [ snip ]
  item 105 key (354549760 230 20480) itemoff 14587 itemsize 16
                  stride 0 devid 5 physical 67502080
  item 106 key (354631680 230 4096) itemoff 14571 itemsize 16
                  stride 0 devid 1 physical 88559616
  item 107 key (354631680 230 32768) itemoff 14555 itemsize 16
                  stride 0 devid 1 physical 88555520
  item 108 key (354717696 230 28672) itemoff 14539 itemsize 16
                  stride 0 devid 2 physical 67604480
  [ snip ]
 BTRFS critical (device nvme1n1): slot 106 key (354631680 230 32768) new key (354635776 230 4096)
 ------------[ cut here ]------------
 kernel BUG at fs/btrfs/ctree.c:2602!
 Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI
 CPU: 1 UID: 0 PID: 1055 Comm: fsstress Not tainted 6.13.0-rc1+ #1464
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014
 RIP: 0010:btrfs_set_item_key_safe+0xf7/0x270
 Code: <snip>
 RSP: 0018:ffffc90001337ab0 EFLAGS: 00010287
 RAX: 0000000000000000 RBX: ffff8881115fd000 RCX: 0000000000000000
 RDX: 0000000000000001 RSI: 0000000000000001 RDI: 00000000ffffffff
 RBP: ffff888110ed6f50 R08: 00000000ffffefff R09: ffffffff8244c500
 R10: 00000000ffffefff R11: 00000000ffffffff R12: ffff888100586000
 R13: 00000000000000c9 R14: ffffc90001337b1f R15: ffff888110f23b58
 FS:  00007f7d75c72740(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007fa811652c60 CR3: 0000000111398001 CR4: 0000000000370eb0
 Call Trace:
  <TASK>
  ? __die_body.cold+0x14/0x1a
  ? die+0x2e/0x50
  ? do_trap+0xca/0x110
  ? do_error_trap+0x65/0x80
  ? btrfs_set_item_key_safe+0xf7/0x270
  ? exc_invalid_op+0x50/0x70
  ? btrfs_set_item_key_safe+0xf7/0x270
  ? asm_exc_invalid_op+0x1a/0x20
  ? btrfs_set_item_key_safe+0xf7/0x270
  btrfs_partially_delete_raid_extent+0xc4/0xe0
  btrfs_delete_raid_extent+0x227/0x240
  __btrfs_free_extent.isra.0+0x57f/0x9c0
  ? exc_coproc_segment_overrun+0x40/0x40
  __btrfs_run_delayed_refs+0x2fa/0xe80
  btrfs_run_delayed_refs+0x81/0xe0
  btrfs_commit_transaction+0x2dd/0xbe0
  ? preempt_count_add+0x52/0xb0
  btrfs_sync_file+0x375/0x4c0
  do_fsync+0x39/0x70
  __x64_sys_fsync+0x13/0x20
  do_syscall_64+0x54/0x110
  entry_SYSCALL_64_after_hwframe+0x76/0x7e
 RIP: 0033:0x7f7d7550ef90
 Code: <snip>
 RSP: 002b:00007ffd70237248 EFLAGS: 00000202 ORIG_RAX: 000000000000004a
 RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f7d7550ef90
 RDX: 000000000000013a RSI: 000000000040eb28 RDI: 0000000000000004
 RBP: 000000000000001b R08: 0000000000000078 R09: 00007ffd7023725c
 R10: 00007f7d75400390 R11: 0000000000000202 R12: 028f5c28f5c28f5c
 R13: 8f5c28f5c28f5c29 R14: 000000000040b520 R15: 00007f7d75c726c8
  </TASK>

While the root cause of the tree order corruption isn't clear, using
btrfs_duplicate_item() to copy the item and then adjusting both the key
and the per-device physical addresses is a safe way to counter this
problem.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c25eff52ee5a02a2c4be659a44ae972d9989742
  - https://git.kernel.org/stable/c/dc14ba10781bd2629835696b7cc1febf914768e9

------------------------------------------------------------

CVE ID: CVE-2025-21753
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix use-after-free when attempting to join an aborted transaction

When we are trying to join the current transaction and if it's aborted,
we read its 'aborted' field after unlocking fs_info->trans_lock and
without holding any extra reference count on it. This means that a
concurrent task that is aborting the transaction may free the transaction
before we read its 'aborted' field, leading to a use-after-free.

Fix this by reading the 'aborted' field while holding fs_info->trans_lock
since any freeing task must first acquire that lock and set
fs_info->running_transaction to NULL before freeing the transaction.

This was reported by syzbot and Dmitry with the following stack traces
from KASAN:

   ==================================================================
   BUG: KASAN: slab-use-after-free in join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278
   Read of size 4 at addr ffff888011839024 by task kworker/u4:9/1128

   CPU: 0 UID: 0 PID: 1128 Comm: kworker/u4:9 Not tainted 6.13.0-rc7-syzkaller-00019-gc45323b7560e #0
   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
   Workqueue: events_unbound btrfs_async_reclaim_data_space
   Call Trace:
    <TASK>
    __dump_stack lib/dump_stack.c:94 [inline]
    dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
    print_address_description mm/kasan/report.c:378 [inline]
    print_report+0x169/0x550 mm/kasan/report.c:489
    kasan_report+0x143/0x180 mm/kasan/report.c:602
    join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278
    start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697
    flush_space+0x448/0xcf0 fs/btrfs/space-info.c:803
    btrfs_async_reclaim_data_space+0x159/0x510 fs/btrfs/space-info.c:1321
    process_one_work kernel/workqueue.c:3236 [inline]
    process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317
    worker_thread+0x870/0xd30 kernel/workqueue.c:3398
    kthread+0x2f0/0x390 kernel/kthread.c:389
    ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
    ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
    </TASK>

   Allocated by task 5315:
    kasan_save_stack mm/kasan/common.c:47 [inline]
    kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
    poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
    __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394
    kasan_kmalloc include/linux/kasan.h:260 [inline]
    __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329
    kmalloc_noprof include/linux/slab.h:901 [inline]
    join_transaction+0x144/0xda0 fs/btrfs/transaction.c:308
    start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697
    btrfs_create_common+0x1b2/0x2e0 fs/btrfs/inode.c:6572
    lookup_open fs/namei.c:3649 [inline]
    open_last_lookups fs/namei.c:3748 [inline]
    path_openat+0x1c03/0x3590 fs/namei.c:3984
    do_filp_open+0x27f/0x4e0 fs/namei.c:4014
    do_sys_openat2+0x13e/0x1d0 fs/open.c:1402
    do_sys_open fs/open.c:1417 [inline]
    __do_sys_creat fs/open.c:1495 [inline]
    __se_sys_creat fs/open.c:1489 [inline]
    __x64_sys_creat+0x123/0x170 fs/open.c:1489
    do_syscall_x64 arch/x86/entry/common.c:52 [inline]
    do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
    entry_SYSCALL_64_after_hwframe+0x77/0x7f

   Freed by task 5336:
    kasan_save_stack mm/kasan/common.c:47 [inline]
    kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
    kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582
    poison_slab_object mm/kasan/common.c:247 [inline]
    __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264
    kasan_slab_free include/linux/kasan.h:233 [inline]
    slab_free_hook mm/slub.c:2353 [inline]
    slab_free mm/slub.c:4613 [inline]
    kfree+0x196/0x430 mm/slub.c:4761
    cleanup_transaction fs/btrfs/transaction.c:2063 [inline]
    btrfs_commit_transaction+0x2c97/0x3720 fs/btrfs/transaction.c:2598
    insert_balance_item+0x1284/0x20b0 fs/btrfs/volumes.c:3757
    btrfs_balance+0x992/
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.4, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6ba4663ada6c6315af23a6669d386146634808ec
  - https://git.kernel.org/stable/c/7e954b6bb95d67ae4d1a20e9cfd83c182cf929bc
  - https://git.kernel.org/stable/c/86d71a026a7f63da905db9add845c8ee88801eca
  - https://git.kernel.org/stable/c/8f5cff471039caa2b088060c074c2bf2081bcb01
  - https://git.kernel.org/stable/c/c7a53757717e68af94a56929d57f1e6daff220ec
  - https://git.kernel.org/stable/c/ce628048390dad80320d5a1f74de6ca1e1be91e7
  - https://git.kernel.org/stable/c/cee55b1219568c80bf0d5dc55066e4a859baf753
  - https://git.kernel.org/stable/c/e2f0943cf37305dbdeaf9846e3c941451bcdef63

------------------------------------------------------------

CVE ID: CVE-2025-21754
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix assertion failure when splitting ordered extent after transaction abort

If while we are doing a direct IO write a transaction abort happens, we
mark all existing ordered extents with the BTRFS_ORDERED_IOERR flag (done
at btrfs_destroy_ordered_extents()), and then after that if we enter
btrfs_split_ordered_extent() and the ordered extent has bytes left
(meaning we have a bio that doesn't cover the whole ordered extent, see
details at btrfs_extract_ordered_extent()), we will fail on the following
assertion at btrfs_split_ordered_extent():

   ASSERT(!(flags & ~BTRFS_ORDERED_TYPE_FLAGS));

because the BTRFS_ORDERED_IOERR flag is set and the definition of
BTRFS_ORDERED_TYPE_FLAGS is just the union of all flags that identify the
type of write (regular, nocow, prealloc, compressed, direct IO, encoded).

Fix this by returning an error from btrfs_extract_ordered_extent() if we
find the BTRFS_ORDERED_IOERR flag in the ordered extent. The error will
be the error that resulted in the transaction abort or -EIO if no
transaction abort happened.

This was recently reported by syzbot with the following trace:

   FAULT_INJECTION: forcing a failure.
   name failslab, interval 1, probability 0, space 0, times 1
   CPU: 0 UID: 0 PID: 5321 Comm: syz.0.0 Not tainted 6.13.0-rc5-syzkaller #0
   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
   Call Trace:
    <TASK>
    __dump_stack lib/dump_stack.c:94 [inline]
    dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
    fail_dump lib/fault-inject.c:53 [inline]
    should_fail_ex+0x3b0/0x4e0 lib/fault-inject.c:154
    should_failslab+0xac/0x100 mm/failslab.c:46
    slab_pre_alloc_hook mm/slub.c:4072 [inline]
    slab_alloc_node mm/slub.c:4148 [inline]
    __do_kmalloc_node mm/slub.c:4297 [inline]
    __kmalloc_noprof+0xdd/0x4c0 mm/slub.c:4310
    kmalloc_noprof include/linux/slab.h:905 [inline]
    kzalloc_noprof include/linux/slab.h:1037 [inline]
    btrfs_chunk_alloc_add_chunk_item+0x244/0x1100 fs/btrfs/volumes.c:5742
    reserve_chunk_space+0x1ca/0x2c0 fs/btrfs/block-group.c:4292
    check_system_chunk fs/btrfs/block-group.c:4319 [inline]
    do_chunk_alloc fs/btrfs/block-group.c:3891 [inline]
    btrfs_chunk_alloc+0x77b/0xf80 fs/btrfs/block-group.c:4187
    find_free_extent_update_loop fs/btrfs/extent-tree.c:4166 [inline]
    find_free_extent+0x42d1/0x5810 fs/btrfs/extent-tree.c:4579
    btrfs_reserve_extent+0x422/0x810 fs/btrfs/extent-tree.c:4672
    btrfs_new_extent_direct fs/btrfs/direct-io.c:186 [inline]
    btrfs_get_blocks_direct_write+0x706/0xfa0 fs/btrfs/direct-io.c:321
    btrfs_dio_iomap_begin+0xbb7/0x1180 fs/btrfs/direct-io.c:525
    iomap_iter+0x697/0xf60 fs/iomap/iter.c:90
    __iomap_dio_rw+0xeb9/0x25b0 fs/iomap/direct-io.c:702
    btrfs_dio_write fs/btrfs/direct-io.c:775 [inline]
    btrfs_direct_write+0x610/0xa30 fs/btrfs/direct-io.c:880
    btrfs_do_write_iter+0x2a0/0x760 fs/btrfs/file.c:1397
    do_iter_readv_writev+0x600/0x880
    vfs_writev+0x376/0xba0 fs/read_write.c:1050
    do_pwritev fs/read_write.c:1146 [inline]
    __do_sys_pwritev2 fs/read_write.c:1204 [inline]
    __se_sys_pwritev2+0x196/0x2b0 fs/read_write.c:1195
    do_syscall_x64 arch/x86/entry/common.c:52 [inline]
    do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
    entry_SYSCALL_64_after_hwframe+0x77/0x7f
   RIP: 0033:0x7f1281f85d29
   RSP: 002b:00007f12819fe038 EFLAGS: 00000246 ORIG_RAX: 0000000000000148
   RAX: ffffffffffffffda RBX: 00007f1282176080 RCX: 00007f1281f85d29
   RDX: 0000000000000001 RSI: 0000000020000240 RDI: 0000000000000005
   RBP: 00007f12819fe090 R08: 0000000000000000 R09: 0000000000000003
   R10: 0000000000007000 R11: 0000000000000246 R12: 0000000000000002
   R13: 0000000000000000 R14: 00007f1282176080 R15: 00007ffcb9e23328
    </TASK>
   BTRFS error (device loop0 state A): Transaction aborted (error -12)
   BTRFS: error (device loop0 state A
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d85f5c2dd91df6b5da454406756f463ba923b69
  - https://git.kernel.org/stable/c/0ff88c2a742a7cbaa4d08507d864737d099b435a
  - https://git.kernel.org/stable/c/8ea8db4216d1029527ab4666f730650419451e32
  - https://git.kernel.org/stable/c/927b930f117bbae730a853c1dc43da8afe8380fa

------------------------------------------------------------

CVE ID: CVE-2025-21756
Description: In the Linux kernel, the following vulnerability has been resolved:

vsock: Keep the binding until socket destruction

Preserve sockets bindings; this includes both resulting from an explicit
bind() and those implicitly bound through autobind during connect().

Prevents socket unbinding during a transport reassignment, which fixes a
use-after-free:

    1. vsock_create() (refcnt=1) calls vsock_insert_unbound() (refcnt=2)
    2. transport->release() calls vsock_remove_bound() without checking if
       sk was bound and moved to bound list (refcnt=1)
    3. vsock_bind() assumes sk is in unbound list and before
       __vsock_insert_bound(vsock_bound_sockets()) calls
       __vsock_remove_bound() which does:
           list_del_init(&vsk->bound_table); // nop
           sock_put(&vsk->sk);               // refcnt=0

BUG: KASAN: slab-use-after-free in __vsock_bind+0x62e/0x730
Read of size 4 at addr ffff88816b46a74c by task a.out/2057
 dump_stack_lvl+0x68/0x90
 print_report+0x174/0x4f6
 kasan_report+0xb9/0x190
 __vsock_bind+0x62e/0x730
 vsock_bind+0x97/0xe0
 __sys_bind+0x154/0x1f0
 __x64_sys_bind+0x6e/0xb0
 do_syscall_64+0x93/0x1b0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

Allocated by task 2057:
 kasan_save_stack+0x1e/0x40
 kasan_save_track+0x10/0x30
 __kasan_slab_alloc+0x85/0x90
 kmem_cache_alloc_noprof+0x131/0x450
 sk_prot_alloc+0x5b/0x220
 sk_alloc+0x2c/0x870
 __vsock_create.constprop.0+0x2e/0xb60
 vsock_create+0xe4/0x420
 __sock_create+0x241/0x650
 __sys_socket+0xf2/0x1a0
 __x64_sys_socket+0x6e/0xb0
 do_syscall_64+0x93/0x1b0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

Freed by task 2057:
 kasan_save_stack+0x1e/0x40
 kasan_save_track+0x10/0x30
 kasan_save_free_info+0x37/0x60
 __kasan_slab_free+0x4b/0x70
 kmem_cache_free+0x1a1/0x590
 __sk_destruct+0x388/0x5a0
 __vsock_bind+0x5e1/0x730
 vsock_bind+0x97/0xe0
 __sys_bind+0x154/0x1f0
 __x64_sys_bind+0x6e/0xb0
 do_syscall_64+0x93/0x1b0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

refcount_t: addition on 0; use-after-free.
WARNING: CPU: 7 PID: 2057 at lib/refcount.c:25 refcount_warn_saturate+0xce/0x150
RIP: 0010:refcount_warn_saturate+0xce/0x150
 __vsock_bind+0x66d/0x730
 vsock_bind+0x97/0xe0
 __sys_bind+0x154/0x1f0
 __x64_sys_bind+0x6e/0xb0
 do_syscall_64+0x93/0x1b0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

refcount_t: underflow; use-after-free.
WARNING: CPU: 7 PID: 2057 at lib/refcount.c:28 refcount_warn_saturate+0xee/0x150
RIP: 0010:refcount_warn_saturate+0xee/0x150
 vsock_remove_bound+0x187/0x1e0
 __vsock_release+0x383/0x4a0
 vsock_release+0x90/0x120
 __sock_release+0xa3/0x250
 sock_close+0x14/0x20
 __fput+0x359/0xa80
 task_work_run+0x107/0x1d0
 do_exit+0x847/0x2560
 do_group_exit+0xb8/0x250
 __x64_sys_exit_group+0x3a/0x50
 x64_sys_call+0xfec/0x14f0
 do_syscall_64+0x93/0x1b0
 entry_SYSCALL_64_after_hwframe+0x76/0x7e
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/3f43540166128951cc1be7ab1ce6b7f05c670d8b
  - https://git.kernel.org/stable/c/42b33381e5e1f2b967dc4fb4221ddb9aaf10d197
  - https://git.kernel.org/stable/c/645ce25aa0e67895b11d89f27bb86c9d444c40f8
  - https://git.kernel.org/stable/c/b1afd40321f1c243cffbcf40ea7ca41aca87fa5e
  - https://git.kernel.org/stable/c/e48fcb403c2d0e574c19683f09399ab4cf67809c
  - https://git.kernel.org/stable/c/e7754d564579a5db9c5c9f74228df5d6dd6f1173
  - https://git.kernel.org/stable/c/fcdd2242c0231032fc84e1404315c245ae56322a
  - https://github.com/hoefler02/CVE-2025-21756/blob/main/x.c

------------------------------------------------------------

CVE ID: CVE-2025-21758
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: mcast: add RCU protection to mld_newpack()

mld_newpack() can be called without RTNL or RCU being held.

Note that we no longer can use sock_alloc_send_skb() because
ipv6.igmp_sk uses GFP_KERNEL allocations which can sleep.

Instead use alloc_skb() and charge the net->ipv6.igmp_sk
socket under RCU protection.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b91c597b0214b1b462eb627ec02658c944623f2
  - https://git.kernel.org/stable/c/25195f9d5ffcc8079ad743a50c0409dbdc48d98a
  - https://git.kernel.org/stable/c/29fa42197f26a97cde29fa8c40beddf44ea5c8f3
  - https://git.kernel.org/stable/c/a527750d877fd334de87eef81f1cb5f0f0ca3373
  - https://git.kernel.org/stable/c/d60d493b0e65647e0335e6a7c4547abcea7df8e9
  - https://git.kernel.org/stable/c/e8af3632a7f2da83e27b083f787bced1faba00b1

------------------------------------------------------------

CVE ID: CVE-2025-21759
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: mcast: extend RCU protection in igmp6_send()

igmp6_send() can be called without RTNL or RCU being held.

Extend RCU protection so that we can safely fetch the net pointer
and avoid a potential UAF.

Note that we no longer can use sock_alloc_send_skb() because
ipv6.igmp_sk uses GFP_KERNEL allocations which can sleep.

Instead use alloc_skb() and charge the net->ipv6.igmp_sk
socket under RCU protection.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.26, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/087c1faa594fa07a66933d750c0b2610aa1a2946
  - https://git.kernel.org/stable/c/0bf8e2f3768629d437a32cb824149e6e98254381
  - https://git.kernel.org/stable/c/81b25a07ebf53f9ef4ca8f3d96a8ddb94561dd5a
  - https://git.kernel.org/stable/c/8e92d6a413feaf968a33f0b439ecf27404407458

------------------------------------------------------------

CVE ID: CVE-2025-21760
Description: In the Linux kernel, the following vulnerability has been resolved:

ndisc: extend RCU protection in ndisc_send_skb()

ndisc_send_skb() can be called without RTNL or RCU held.

Acquire rcu_read_lock() earlier, so that we can use dev_net_rcu()
and avoid a potential UAF.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.26, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/04e05112f10354ffc3bb6cc796d553bab161594c
  - https://git.kernel.org/stable/c/10a1f3fece2f0d23a3a618b72b2b4e6f408ef7d1
  - https://git.kernel.org/stable/c/4d576202b90b1b95a7c428a80b536f91b8201bcc
  - https://git.kernel.org/stable/c/789230e5a8c1097301afc802e242c79bc8835c67
  - https://git.kernel.org/stable/c/a9319d800b5701e7f5e3fa71a5b7c4831fc20d6d
  - https://git.kernel.org/stable/c/ae38982f521621c216fc2f5182cd091f4734641d
  - https://git.kernel.org/stable/c/e24d225e4cb8cf108bde00b76594499b98f0a74d
  - https://git.kernel.org/stable/c/ed6ae1f325d3c43966ec1b62ac1459e2b8e45640

------------------------------------------------------------

CVE ID: CVE-2025-21761
Description: In the Linux kernel, the following vulnerability has been resolved:

openvswitch: use RCU protection in ovs_vport_cmd_fill_info()

ovs_vport_cmd_fill_info() can be called without RTNL or RCU.

Use RCU protection and dev_net_rcu() to avoid potential UAF.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5828937742af74666192835d657095d95c53dbd0
  - https://git.kernel.org/stable/c/7e01abc34e87abd091e619161a20f54ed4e3e2da
  - https://git.kernel.org/stable/c/8ec57509c36c8b9a23e50b7858dda0c520a2d074
  - https://git.kernel.org/stable/c/90b2f49a502fa71090d9f4fe29a2f51fe5dff76d
  - https://git.kernel.org/stable/c/a849a10de5e04d798f7f286a2f1ca174719a617a
  - https://git.kernel.org/stable/c/a8816b3f1f151373fd30f1996f00480126c8bb11
  - https://git.kernel.org/stable/c/a884f57600e463f69d7b279c4598b865260b62a1
  - https://git.kernel.org/stable/c/e85a25d1a9985645e796039e843d1de581d2de1e

------------------------------------------------------------

CVE ID: CVE-2025-21762
Description: In the Linux kernel, the following vulnerability has been resolved:

arp: use RCU protection in arp_xmit()

arp_xmit() can be called without RTNL or RCU protection.

Use RCU protection to avoid potential UAF.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/01d1b5c9abcaff29a43f1d17a19c33eec92c7dbe
  - https://git.kernel.org/stable/c/10f555e3f573d004ae9d89b3276abb58c4ede5c3
  - https://git.kernel.org/stable/c/2c331718d3389b6c5f6855078ab7171849e016bd
  - https://git.kernel.org/stable/c/307cd1e2d3cb1cbc6c40c679cada6d7168b18431
  - https://git.kernel.org/stable/c/a42b69f692165ec39db42d595f4f65a4c8f42e44
  - https://git.kernel.org/stable/c/d9366ac2f956a1948b68c0500f84a3462ff2ed8a
  - https://git.kernel.org/stable/c/e9f4dee534eb1b225b0a120395ad9bc2afe164d3
  - https://git.kernel.org/stable/c/f189654459423d4d48bef2d120b4bfba559e6039

------------------------------------------------------------

CVE ID: CVE-2025-21763
Description: In the Linux kernel, the following vulnerability has been resolved:

neighbour: use RCU protection in __neigh_notify()

__neigh_notify() can be called without RTNL or RCU protection.

Use RCU protection to avoid potential UAF.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.25, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1cbb2aa90cd3fba15ad7efb5cdda28f3d1082379
  - https://git.kernel.org/stable/c/40d8f2f2a373b6c294ffac394d2bb814b572ead1
  - https://git.kernel.org/stable/c/559307d25235e24b5424778c7332451b6c741159
  - https://git.kernel.org/stable/c/784eb2376270e086f7db136d154b8404edacf97b
  - https://git.kernel.org/stable/c/8666e9aab801328c1408a19fbf4070609dc0695a
  - https://git.kernel.org/stable/c/becbd5850c03ed33b232083dd66c6e38c0c0e569
  - https://git.kernel.org/stable/c/cdd5c2a12ddad8a77ce1838ff9f29aa587de82df
  - https://git.kernel.org/stable/c/e1aed6be381bcd7f46d4ca9d7ef0f5f3d6a1be32

------------------------------------------------------------

CVE ID: CVE-2025-21764
Description: In the Linux kernel, the following vulnerability has been resolved:

ndisc: use RCU protection in ndisc_alloc_skb()

ndisc_alloc_skb() can be called without RTNL or RCU being held.

Add RCU protection to avoid possible UAF.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.9, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3c2d705f5adf5d860aaef90cb4211c0fde2ba66d
  - https://git.kernel.org/stable/c/628e6d18930bbd21f2d4562228afe27694f66da9
  - https://git.kernel.org/stable/c/96fc896d0e5b37c12808df797397fb16f3080879
  - https://git.kernel.org/stable/c/9e0ec817eb41a55327a46cd3ce331a9868d60304
  - https://git.kernel.org/stable/c/b870256dd2a5648d5ed2f22316b3ac29a7e5ed63
  - https://git.kernel.org/stable/c/bbec88e4108e8d6fb468d3817fa652140a44ff28
  - https://git.kernel.org/stable/c/c30893ef3d9cde8e7e8e4fd06b53d2c935bbccb1
  - https://git.kernel.org/stable/c/cd1065f92eb7ff21b9ba5308a86f33d1670bf926

------------------------------------------------------------

CVE ID: CVE-2025-21765
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: use RCU protection in ip6_default_advmss()

ip6_default_advmss() needs rcu protection to make
sure the net structure it reads does not disappear.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28de355b63ad42309ed5a03ee7c436c90512265b
  - https://git.kernel.org/stable/c/3c8ffcd248da34fc41e52a46e51505900115fc2a
  - https://git.kernel.org/stable/c/4176a68b0db8fc74ac14fcd00ba8231371051dc2
  - https://git.kernel.org/stable/c/550ed693f47370502a71b85382e7f9e6417300b8
  - https://git.kernel.org/stable/c/713a40c892f40300d63691d9f85b2a23b48fe1e8
  - https://git.kernel.org/stable/c/78ad057472d8c76e0602402269222f9f9c698790
  - https://git.kernel.org/stable/c/84212387caadb211cd9dadd6fd5563bd37dc1f5e
  - https://git.kernel.org/stable/c/d02f30d220ef9511568a48dba8a9004c65f8d904

------------------------------------------------------------

CVE ID: CVE-2025-21766
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: use RCU protection in __ip_rt_update_pmtu()

__ip_rt_update_pmtu() must use RCU protection to make
sure the net structure it reads does not disappear.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/139512191bd06f1b496117c76372b2ce372c9a41
  - https://git.kernel.org/stable/c/4583748b65dee4d61bd50a2214715b4237bc152a
  - https://git.kernel.org/stable/c/9b1766d1ff5fe496aabe9fc5f4e34e53f35c11c4
  - https://git.kernel.org/stable/c/a39f61d212d822b3062d7f70fa0588e50e55664e
  - https://git.kernel.org/stable/c/ce3c6165fce0f06305c806696882a3ad4b90e33f
  - https://git.kernel.org/stable/c/ea07480b23225942208f1b754fea1e7ec486d37e

------------------------------------------------------------

CVE ID: CVE-2025-21767
Description: In the Linux kernel, the following vulnerability has been resolved:

clocksource: Use migrate_disable() to avoid calling get_random_u32() in atomic context

The following bug report happened with a PREEMPT_RT kernel:

  BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48
  in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2012, name: kwatchdog
  preempt_count: 1, expected: 0
  RCU nest depth: 0, expected: 0
  get_random_u32+0x4f/0x110
  clocksource_verify_choose_cpus+0xab/0x1a0
  clocksource_verify_percpu.part.0+0x6b/0x330
  clocksource_watchdog_kthread+0x193/0x1a0

It is due to the fact that clocksource_verify_choose_cpus() is invoked with
preemption disabled.  This function invokes get_random_u32() to obtain
random numbers for choosing CPUs.  The batched_entropy_32 local lock and/or
the base_crng.lock spinlock in driver/char/random.c will be acquired during
the call. In PREEMPT_RT kernel, they are both sleeping locks and so cannot
be acquired in atomic context.

Fix this problem by using migrate_disable() to allow smp_processor_id() to
be reliably used without introducing atomic context. preempt_disable() is
then called after clocksource_verify_choose_cpus() but before the
clocksource measurement is being run to avoid introducing unexpected
latency.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0fb534187d2355f6c8f995321e76d1ccd1262ac1
  - https://git.kernel.org/stable/c/60f54f0d4ea530950549a8263e6fdd70a40490a4
  - https://git.kernel.org/stable/c/6bb05a33337b2c842373857b63de5c9bf1ae2a09
  - https://git.kernel.org/stable/c/852805b6cbdb69c298a8fc9fbe79994c95106e04
  - https://git.kernel.org/stable/c/8783ceeee797d9aa9cfe150690fb9d0bac8cc459
  - https://git.kernel.org/stable/c/cc3d79e7c806cb57d71c28a4a35e7d7fb3265faa
  - https://git.kernel.org/stable/c/d9c217fadfcff7a8df58567517d1e4253f3fd243

------------------------------------------------------------

CVE ID: CVE-2025-21768
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ipv6: fix dst ref loops in rpl, seg6 and ioam6 lwtunnels

Some lwtunnels have a dst cache for post-transformation dst.
If the packet destination did not change we may end up recording
a reference to the lwtunnel in its own cache, and the lwtunnel
state will never be freed.

Discovered by the ioam6.sh test, kmemleak was recently fixed
to catch per-cpu memory leaks. I'm not sure if rpl and seg6
can actually hit this, but in principle I don't see why not.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4c0f200c7d06fedddde82209c099014d63f4a6c0
  - https://git.kernel.org/stable/c/5ab11a4e219e93b8b31a27f8ec98d42afadd8b7a
  - https://git.kernel.org/stable/c/92191dd1073088753821b862b791dcc83e558e07

------------------------------------------------------------

CVE ID: CVE-2025-21769
Description: In the Linux kernel, the following vulnerability has been resolved:

ptp: vmclock: Add .owner to vmclock_miscdev_fops

Without the .owner field, the module can be unloaded while /dev/vmclock0
is open, leading to an oops.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3b5709225b43ee33e1026dd1fc0949a7f19b5289
  - https://git.kernel.org/stable/c/7b07b040257c1b658ef3eca86e4b6ae02d65069c

------------------------------------------------------------

CVE ID: CVE-2025-21770
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu: Fix potential memory leak in iopf_queue_remove_device()

The iopf_queue_remove_device() helper removes a device from the per-iommu
iopf queue when PRI is disabled on the device. It responds to all
outstanding iopf's with an IOMMU_PAGE_RESP_INVALID code and detaches the
device from the queue.

However, it fails to release the group structure that represents a group
of iopf's awaiting for a response after responding to the hardware. This
can cause a memory leak if iopf_queue_remove_device() is called with
pending iopf's.

Fix it by calling iopf_free_group() after the iopf group is responded.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/90d5429cd2921ca2714684ed525898d431bb9283
  - https://git.kernel.org/stable/c/9759ae2cee7cd42b95f1c48aa3749bd02b5ddb08
  - https://git.kernel.org/stable/c/db60d2d896a17decd58d143eef92cf22eb0a0176

------------------------------------------------------------

CVE ID: CVE-2025-21771
Description: In the Linux kernel, the following vulnerability has been resolved:

sched_ext: Fix incorrect autogroup migration detection

scx_move_task() is called from sched_move_task() and tells the BPF scheduler
that cgroup migration is being committed. sched_move_task() is used by both
cgroup and autogroup migrations and scx_move_task() tried to filter out
autogroup migrations by testing the destination cgroup and PF_EXITING but
this is not enough. In fact, without explicitly tagging the thread which is
doing the cgroup migration, there is no good way to tell apart
scx_move_task() invocations for racing migration to the root cgroup and an
autogroup migration.

This led to scx_move_task() incorrectly ignoring a migration from non-root
cgroup to an autogroup of the root cgroup triggering the following warning:

  WARNING: CPU: 7 PID: 1 at kernel/sched/ext.c:3725 scx_cgroup_can_attach+0x196/0x340
  ...
  Call Trace:
  <TASK>
    cgroup_migrate_execute+0x5b1/0x700
    cgroup_attach_task+0x296/0x400
    __cgroup_procs_write+0x128/0x140
    cgroup_procs_write+0x17/0x30
    kernfs_fop_write_iter+0x141/0x1f0
    vfs_write+0x31d/0x4a0
    __x64_sys_write+0x72/0xf0
    do_syscall_64+0x82/0x160
    entry_SYSCALL_64_after_hwframe+0x76/0x7e

Fix it by adding an argument to sched_move_task() that indicates whether the
moving is for a cgroup or autogroup migration. After the change,
scx_move_task() is called only for cgroup migrations and renamed to
scx_cgroup_move_task().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/75bf2f80c046d2ec5a07455891ea0a9fb6d8b5f6
  - https://git.kernel.org/stable/c/d6f3e7d564b2309e1f17e709a70eca78d7ca2bb8
  - https://git.kernel.org/stable/c/d8b510d0ddc65d8a71e0f9a3acc9ed5f010fc514

------------------------------------------------------------

CVE ID: CVE-2025-21772
Description: In the Linux kernel, the following vulnerability has been resolved:

partitions: mac: fix handling of bogus partition table

Fix several issues in partition probing:

 - The bailout for a bad partoffset must use put_dev_sector(), since the
   preceding read_part_sector() succeeded.
 - If the partition table claims a silly sector size like 0xfff bytes
   (which results in partition table entries straddling sector boundaries),
   bail out instead of accessing out-of-bounds memory.
 - We must not assume that the partition table contains proper NUL
   termination - use strnlen() and strncmp() instead of strlen() and
   strcmp().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/213ba5bd81b7e97ac6e6190b8f3bc6ba76123625
  - https://git.kernel.org/stable/c/27a39d006f85e869be68c1d5d2ce05e5d6445bf5
  - https://git.kernel.org/stable/c/40a35d14f3c0dc72b689061ec72fc9b193f37d1f
  - https://git.kernel.org/stable/c/6578717ebca91678131d2b1f4ba4258e60536e9f
  - https://git.kernel.org/stable/c/7fa9706722882f634090bfc9af642bf9ed719e27
  - https://git.kernel.org/stable/c/80e648042e512d5a767da251d44132553fe04ae0
  - https://git.kernel.org/stable/c/92527100be38ede924768f4277450dfe8a40e16b
  - https://git.kernel.org/stable/c/a3e77da9f843e4ab93917d30c314f0283e28c124

------------------------------------------------------------

CVE ID: CVE-2025-21773
Description: In the Linux kernel, the following vulnerability has been resolved:

can: etas_es58x: fix potential NULL pointer dereference on udev->serial

The driver assumed that es58x_dev->udev->serial could never be NULL.
While this is true on commercially available devices, an attacker
could spoof the device identity providing a NULL USB serial number.
That would trigger a NULL pointer dereference.

Add a check on es58x_dev->udev->serial before accessing it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1590667a60753ee5a54871f2840ceefd4a7831fa
  - https://git.kernel.org/stable/c/5059ea98d7bc133903d3e47ab36df6ed11d0c95f
  - https://git.kernel.org/stable/c/722e8e1219c8b6ac2865011fe339315d6a8d0721
  - https://git.kernel.org/stable/c/a1ad2109ce41c9e3912dadd07ad8a9c640064ffb

------------------------------------------------------------

CVE ID: CVE-2025-21774
Description: In the Linux kernel, the following vulnerability has been resolved:

can: rockchip: rkcanfd_handle_rx_fifo_overflow_int(): bail out if skb cannot be allocated

Fix NULL pointer check in rkcanfd_handle_rx_fifo_overflow_int() to
bail out if skb cannot be allocated.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/118fb35681bd2c0d2afa22f7be0ef94bb4d06849
  - https://git.kernel.org/stable/c/946750e7865df2e70045071051abf768785dd570
  - https://git.kernel.org/stable/c/f7f0adfe64de08803990dc4cbecd2849c04e314a

------------------------------------------------------------

CVE ID: CVE-2025-21775
Description: In the Linux kernel, the following vulnerability has been resolved:

can: ctucanfd: handle skb allocation failure

If skb allocation fails, the pointer to struct can_frame is NULL. This
is actually handled everywhere inside ctucan_err_interrupt() except for
the only place.

Add the missed NULL check.

Found by Linux Verification Center (linuxtesting.org) with SVACE static
analysis tool.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/84b9ac59978a6a4e0812d1c938fad97306272cef
  - https://git.kernel.org/stable/c/9bd24927e3eeb85642c7baa3b28be8bea6c2a078
  - https://git.kernel.org/stable/c/b0e592dd46a0a952b41c3bf6c963afdd6a42b526
  - https://git.kernel.org/stable/c/e505b83b9ee6aa0ae2f4395f573a66579ae403fb
  - https://git.kernel.org/stable/c/e7e2e2318b1f085044126ba553a4e619842fc36d

------------------------------------------------------------

CVE ID: CVE-2025-21776
Description: In the Linux kernel, the following vulnerability has been resolved:

USB: hub: Ignore non-compliant devices with too many configs or interfaces

Robert Morris created a test program which can cause
usb_hub_to_struct_hub() to dereference a NULL or inappropriate
pointer:

Oops: general protection fault, probably for non-canonical address
0xcccccccccccccccc: 0000 [#1] SMP DEBUG_PAGEALLOC PTI
CPU: 7 UID: 0 PID: 117 Comm: kworker/7:1 Not tainted 6.13.0-rc3-00017-gf44d154d6e3d #14
Hardware name: FreeBSD BHYVE/BHYVE, BIOS 14.0 10/17/2021
Workqueue: usb_hub_wq hub_event
RIP: 0010:usb_hub_adjust_deviceremovable+0x78/0x110
...
Call Trace:
 <TASK>
 ? die_addr+0x31/0x80
 ? exc_general_protection+0x1b4/0x3c0
 ? asm_exc_general_protection+0x26/0x30
 ? usb_hub_adjust_deviceremovable+0x78/0x110
 hub_probe+0x7c7/0xab0
 usb_probe_interface+0x14b/0x350
 really_probe+0xd0/0x2d0
 ? __pfx___device_attach_driver+0x10/0x10
 __driver_probe_device+0x6e/0x110
 driver_probe_device+0x1a/0x90
 __device_attach_driver+0x7e/0xc0
 bus_for_each_drv+0x7f/0xd0
 __device_attach+0xaa/0x1a0
 bus_probe_device+0x8b/0xa0
 device_add+0x62e/0x810
 usb_set_configuration+0x65d/0x990
 usb_generic_driver_probe+0x4b/0x70
 usb_probe_device+0x36/0xd0

The cause of this error is that the device has two interfaces, and the
hub driver binds to interface 1 instead of interface 0, which is where
usb_hub_to_struct_hub() looks.

We can prevent the problem from occurring by refusing to accept hub
devices that violate the USB spec by having more than one
configuration or interface.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2240fed37afbcdb5e8b627bc7ad986891100e05d
  - https://git.kernel.org/stable/c/49f077106fa07919a6a6dda99bb490dd1d1a8218
  - https://git.kernel.org/stable/c/5b9778e1fe715700993ce436c152dc3b7df0b490
  - https://git.kernel.org/stable/c/62d8f4c5454dd39aded4f343720d1c5a1803cfef
  - https://git.kernel.org/stable/c/c3720b04df84b5459050ae4e03ec7d545652f897
  - https://git.kernel.org/stable/c/d343fe0fad5c1d689775f2dda24a85ce98e29566
  - https://git.kernel.org/stable/c/d3a67adb365cdfdac4620daf38a82e57ca45806c
  - https://git.kernel.org/stable/c/e905a0fca7bff0855d312c16f71e60e1773b393e

------------------------------------------------------------

CVE ID: CVE-2025-21777
Description: In the Linux kernel, the following vulnerability has been resolved:

ring-buffer: Validate the persistent meta data subbuf array

The meta data for a mapped ring buffer contains an array of indexes of all
the subbuffers. The first entry is the reader page, and the rest of the
entries lay out the order of the subbuffers in how the ring buffer link
list is to be created.

The validator currently makes sure that all the entries are within the
range of 0 and nr_subbufs. But it does not check if there are any
duplicates.

While working on the ring buffer, I corrupted this array, where I added
duplicates. The validator did not catch it and created the ring buffer
link list on top of it. Luckily, the corruption was only that the reader
page was also in the writer path and only presented corrupted data but did
not crash the kernel. But if there were duplicates in the writer side,
then it could corrupt the ring buffer link list and cause a crash.

Create a bitmask array with the size of the number of subbuffers. Then
clear it. When walking through the subbuf array checking to see if the
entries are within the range, test if its bit is already set in the
subbuf_mask. If it is, then there is duplicates and fail the validation.
If not, set the corresponding bit and continue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d547a6f5e8fad26ebc12f501d7d19fccdbad6bf
  - https://git.kernel.org/stable/c/3ec743d558f111d8999aea24577ba66c65ee2eeb
  - https://git.kernel.org/stable/c/f5b95f1fa2ef3a03f49eeec658ba97e721412b32

------------------------------------------------------------

CVE ID: CVE-2025-21778
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Do not allow mmap() of persistent ring buffer

When trying to mmap a trace instance buffer that is attached to
reserve_mem, it would crash:

 BUG: unable to handle page fault for address: ffffe97bd00025c8
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 2862f3067 P4D 2862f3067 PUD 0
 Oops: Oops: 0000 [#1] PREEMPT_RT SMP PTI
 CPU: 4 UID: 0 PID: 981 Comm: mmap-rb Not tainted 6.14.0-rc2-test-00003-g7f1a5e3fbf9e-dirty #233
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
 RIP: 0010:validate_page_before_insert+0x5/0xb0
 Code: e2 01 89 d0 c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 <48> 8b 46 08 a8 01 75 67 66 90 48 89 f0 8b 50 34 85 d2 74 76 48 89
 RSP: 0018:ffffb148c2f3f968 EFLAGS: 00010246
 RAX: ffff9fa5d3322000 RBX: ffff9fa5ccff9c08 RCX: 00000000b879ed29
 RDX: ffffe97bd00025c0 RSI: ffffe97bd00025c0 RDI: ffff9fa5ccff9c08
 RBP: ffffb148c2f3f9f0 R08: 0000000000000004 R09: 0000000000000004
 R10: 0000000000000000 R11: 0000000000000200 R12: 0000000000000000
 R13: 00007f16a18d5000 R14: ffff9fa5c48db6a8 R15: 0000000000000000
 FS:  00007f16a1b54740(0000) GS:ffff9fa73df00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: ffffe97bd00025c8 CR3: 00000001048c6006 CR4: 0000000000172ef0
 Call Trace:
  <TASK>
  ? __die_body.cold+0x19/0x1f
  ? __die+0x2e/0x40
  ? page_fault_oops+0x157/0x2b0
  ? search_module_extables+0x53/0x80
  ? validate_page_before_insert+0x5/0xb0
  ? kernelmode_fixup_or_oops.isra.0+0x5f/0x70
  ? __bad_area_nosemaphore+0x16e/0x1b0
  ? bad_area_nosemaphore+0x16/0x20
  ? do_kern_addr_fault+0x77/0x90
  ? exc_page_fault+0x22b/0x230
  ? asm_exc_page_fault+0x2b/0x30
  ? validate_page_before_insert+0x5/0xb0
  ? vm_insert_pages+0x151/0x400
  __rb_map_vma+0x21f/0x3f0
  ring_buffer_map+0x21b/0x2f0
  tracing_buffers_mmap+0x70/0xd0
  __mmap_region+0x6f0/0xbd0
  mmap_region+0x7f/0x130
  do_mmap+0x475/0x610
  vm_mmap_pgoff+0xf2/0x1d0
  ksys_mmap_pgoff+0x166/0x200
  __x64_sys_mmap+0x37/0x50
  x64_sys_call+0x1670/0x1d70
  do_syscall_64+0xbb/0x1d0
  entry_SYSCALL_64_after_hwframe+0x77/0x7f

The reason was that the code that maps the ring buffer pages to user space
has:

	page = virt_to_page((void *)cpu_buffer->subbuf_ids[s]);

And uses that in:

	vm_insert_pages(vma, vma->vm_start, pages, &nr_pages);

But virt_to_page() does not work with vmap()'d memory which is what the
persistent ring buffer has. It is rather trivial to allow this, but for
now just disable mmap() of instances that have their ring buffer from the
reserve_mem option.

If an mmap() is performed on a persistent buffer it will return -ENODEV
just like it would if the .mmap field wasn't defined in the
file_operations structure.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/129fe718819cc5e24ea2f489db9ccd4371f0c6f6
  - https://git.kernel.org/stable/c/cf5aa560e5c7628b57c928741d7e6a9a0f6f0e67
  - https://git.kernel.org/stable/c/e8dff5f73912513fc9b52ab992d861517c9a9975

------------------------------------------------------------

CVE ID: CVE-2025-21779
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Reject Hyper-V's SEND_IPI hypercalls if local APIC isn't in-kernel

Advertise support for Hyper-V's SEND_IPI and SEND_IPI_EX hypercalls if and
only if the local API is emulated/virtualized by KVM, and explicitly reject
said hypercalls if the local APIC is emulated in userspace, i.e. don't rely
on userspace to opt-in to KVM_CAP_HYPERV_ENFORCE_CPUID.

Rejecting SEND_IPI and SEND_IPI_EX fixes a NULL-pointer dereference if
Hyper-V enlightenments are exposed to the guest without an in-kernel local
APIC:

  dump_stack+0xbe/0xfd
  __kasan_report.cold+0x34/0x84
  kasan_report+0x3a/0x50
  __apic_accept_irq+0x3a/0x5c0
  kvm_hv_send_ipi.isra.0+0x34e/0x820
  kvm_hv_hypercall+0x8d9/0x9d0
  kvm_emulate_hypercall+0x506/0x7e0
  __vmx_handle_exit+0x283/0xb60
  vmx_handle_exit+0x1d/0xd0
  vcpu_enter_guest+0x16b0/0x24c0
  vcpu_run+0xc0/0x550
  kvm_arch_vcpu_ioctl_run+0x170/0x6d0
  kvm_vcpu_ioctl+0x413/0xb20
  __se_sys_ioctl+0x111/0x160
  do_syscal1_64+0x30/0x40
  entry_SYSCALL_64_after_hwframe+0x67/0xd1

Note, checking the sending vCPU is sufficient, as the per-VM irqchip_mode
can't be modified after vCPUs are created, i.e. if one vCPU has an
in-kernel local APIC, then all vCPUs have an in-kernel local APIC.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/45fa526b0f5a34492ed0536c3cdf88b78380e4de
  - https://git.kernel.org/stable/c/5393cf22312418262679eaadb130d608c75fe690
  - https://git.kernel.org/stable/c/61224533f2b61e252b03e214195d27d64b22989a
  - https://git.kernel.org/stable/c/874ff13c73c45ecb38cb82191e8c1d523f0dc81b
  - https://git.kernel.org/stable/c/a8de7f100bb5989d9c3627d3a223ee1c863f3b69
  - https://git.kernel.org/stable/c/aca8be4403fb90db7adaf63830e27ebe787a76e8
  - https://git.kernel.org/stable/c/ca29f58ca374c40a0e69c5306fc5c940a0069074

------------------------------------------------------------

CVE ID: CVE-2025-21780
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table()

It malicious user provides a small pptable through sysfs and then
a bigger pptable, it may cause buffer overflow attack in function
smu_sys_set_pp_table().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1abb2648698bf10783d2236a6b4a7ca5e8021699
  - https://git.kernel.org/stable/c/231075c5a8ea54f34b7c4794687baa980814e6de
  - https://git.kernel.org/stable/c/2498d2db1d35e88a2060ea191ae75dce853dd084
  - https://git.kernel.org/stable/c/3484ea33157bc7334f57e64826ec5a4bf992151a
  - https://git.kernel.org/stable/c/e43a8b9c4d700ffec819c5043a48769b3e7d9cab

------------------------------------------------------------

CVE ID: CVE-2025-21781
Description: In the Linux kernel, the following vulnerability has been resolved:

batman-adv: fix panic during interface removal

Reference counting is used to ensure that
batadv_hardif_neigh_node and batadv_hard_iface
are not freed before/during
batadv_v_elp_throughput_metric_update work is
finished.

But there isn't a guarantee that the hard if will
remain associated with a soft interface up until
the work is finished.

This fixes a crash triggered by reboot that looks
like this:

Call trace:
 batadv_v_mesh_free+0xd0/0x4dc [batman_adv]
 batadv_v_elp_throughput_metric_update+0x1c/0xa4
 process_one_work+0x178/0x398
 worker_thread+0x2e8/0x4d0
 kthread+0xd8/0xdc
 ret_from_fork+0x10/0x20

(the batadv_v_mesh_free call is misleading,
and does not actually happen)

I was able to make the issue happen more reliably
by changing hardif_neigh->bat_v.metric_work work
to be delayed work. This allowed me to track down
and confirm the fix.

[sven@narfation.org: prevent entering batadv_v_elp_get_throughput without
 soft_iface]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/072b2787321903287a126c148e8db87dd7ef96fe
  - https://git.kernel.org/stable/c/167422a07096a6006599067c8b55884064fa0b72
  - https://git.kernel.org/stable/c/2c3fb7df4cc6d043f70d4a8a10f8b915bbfb75e7
  - https://git.kernel.org/stable/c/522b1596ea19e327853804da2de60aeb9c5d6f42
  - https://git.kernel.org/stable/c/7eb5dd201695645af071592a50026eb780081a72
  - https://git.kernel.org/stable/c/ccb7276a6d26d6f8416e315b43b45e15ee7f29e2
  - https://git.kernel.org/stable/c/ce3f1545bf8fa28bd05ec113679e8e6cd23af577
  - https://git.kernel.org/stable/c/f0a16c6c79768180333f3e41ce63f32730e3c3af

------------------------------------------------------------

CVE ID: CVE-2025-21782
Description: In the Linux kernel, the following vulnerability has been resolved:

orangefs: fix a oob in orangefs_debug_write

I got a syzbot report: slab-out-of-bounds Read in
orangefs_debug_write... several people suggested fixes,
I tested Al Viro's suggestion and made this patch.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/09d472a18c0ee1d5b83612cb919e33a1610fea16
  - https://git.kernel.org/stable/c/18b7f841109f697840fe8633cf7ed7d32bd3f91b
  - https://git.kernel.org/stable/c/1c5244299241cf49d8ae7b5054e299cc8faa4e09
  - https://git.kernel.org/stable/c/1da2697307dad281dd690a19441b5ca4af92d786
  - https://git.kernel.org/stable/c/2b84a231910cef2e0a16d29294afabfb69112087
  - https://git.kernel.org/stable/c/8725882b0f691f8113b230aea9df0256030a63a6
  - https://git.kernel.org/stable/c/897f496b946fdcfab5983c983e4b513ab6682364
  - https://git.kernel.org/stable/c/f7c848431632598ff9bce57a659db6af60d75b39

------------------------------------------------------------

CVE ID: CVE-2025-21783
Description: In the Linux kernel, the following vulnerability has been resolved:

gpiolib: Fix crash on error in gpiochip_get_ngpios()

The gpiochip_get_ngpios() uses chip_*() macros to print messages.
However these macros rely on gpiodev to be initialised and set,
which is not the case when called via bgpio_init(). In such a case
the printing messages will crash on NULL pointer dereference.
Replace chip_*() macros by the respective dev_*() ones to avoid
such crash.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/189fb76215e479c10731baabb50f1a352d2078f5
  - https://git.kernel.org/stable/c/4d9b2b62e1136d10f661ec4c0c268140b6f74f4f
  - https://git.kernel.org/stable/c/7b4aebeecbbd5b5fe73e35fad3f62ed21aa7ef44
  - https://git.kernel.org/stable/c/a7052afa9eae2239e25943baa8817a6a56e8aa68

------------------------------------------------------------

CVE ID: CVE-2025-21784
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: bail out when failed to load fw in psp_init_cap_microcode()

In function psp_init_cap_microcode(), it should bail out when failed to
load firmware, otherwise it may cause invalid memory access.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3f40a7ff39d9f1d283d5aa9b13e2fb16200aff5f
  - https://git.kernel.org/stable/c/a0a455b4bc7483ad60e8b8a50330c1e05bb7bfcf
  - https://git.kernel.org/stable/c/d1d10bd595539ed82ab59b60249f9bdf0994f678
  - https://git.kernel.org/stable/c/e7eb84384335e2abf960c94ec0f8c5b835283777

------------------------------------------------------------

CVE ID: CVE-2025-21785
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: cacheinfo: Avoid out-of-bounds write to cacheinfo array

The loop that detects/populates cache information already has a bounds
check on the array size but does not account for cache levels with
separate data/instructions cache. Fix this by incrementing the index
for any populated leaf (instead of any populated level).
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4371ac7b494e933fffee2bd6265d18d73c4f05aa
  - https://git.kernel.org/stable/c/4ff25f0b18d1d0174c105e4620428bcdc1213860
  - https://git.kernel.org/stable/c/67b99a2b5811df4294c2ad50f9bff3b6a08bd618
  - https://git.kernel.org/stable/c/715eb1af64779e1b1aa0a7b2ffb81414d9f708e5
  - https://git.kernel.org/stable/c/875d742cf5327c93cba1f11e12b08d3cce7a88d2
  - https://git.kernel.org/stable/c/88a3e6afaf002250220793df99404977d343db14
  - https://git.kernel.org/stable/c/ab90894f33c15b14c1cee6959ab6c8dcb09127f8
  - https://git.kernel.org/stable/c/e4fde33107351ec33f1a64188612fbc6ca659284

------------------------------------------------------------

CVE ID: CVE-2025-21786
Description: In the Linux kernel, the following vulnerability has been resolved:

workqueue: Put the pwq after detaching the rescuer from the pool

The commit 68f83057b913("workqueue: Reap workers via kthread_stop() and
remove detach_completion") adds code to reap the normal workers but
mistakenly does not handle the rescuer and also removes the code waiting
for the rescuer in put_unbound_pool(), which caused a use-after-free bug
reported by Cheung Wall.

To avoid the use-after-free bug, the pool’s reference must be held until
the detachment is complete. Therefore, move the code that puts the pwq
after detaching the rescuer from the pool.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
References:
  - https://git.kernel.org/stable/c/835b69c868f53f959d4986bbecd561ba6f38e492
  - https://git.kernel.org/stable/c/e76946110137703c16423baf6ee177b751a34b7e
  - https://git.kernel.org/stable/c/e7c16028a424dd35be1064a68fa318be4359310f

------------------------------------------------------------

CVE ID: CVE-2025-21787
Description: In the Linux kernel, the following vulnerability has been resolved:

team: better TEAM_OPTION_TYPE_STRING validation

syzbot reported following splat [1]

Make sure user-provided data contains one nul byte.

[1]
 BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:633 [inline]
 BUG: KMSAN: uninit-value in string+0x3ec/0x5f0 lib/vsprintf.c:714
  string_nocheck lib/vsprintf.c:633 [inline]
  string+0x3ec/0x5f0 lib/vsprintf.c:714
  vsnprintf+0xa5d/0x1960 lib/vsprintf.c:2843
  __request_module+0x252/0x9f0 kernel/module/kmod.c:149
  team_mode_get drivers/net/team/team_core.c:480 [inline]
  team_change_mode drivers/net/team/team_core.c:607 [inline]
  team_mode_option_set+0x437/0x970 drivers/net/team/team_core.c:1401
  team_option_set drivers/net/team/team_core.c:375 [inline]
  team_nl_options_set_doit+0x1339/0x1f90 drivers/net/team/team_core.c:2662
  genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]
  genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
  genl_rcv_msg+0x1214/0x12c0 net/netlink/genetlink.c:1210
  netlink_rcv_skb+0x375/0x650 net/netlink/af_netlink.c:2543
  genl_rcv+0x40/0x60 net/netlink/genetlink.c:1219
  netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]
  netlink_unicast+0xf52/0x1260 net/netlink/af_netlink.c:1348
  netlink_sendmsg+0x10da/0x11e0 net/netlink/af_netlink.c:1892
  sock_sendmsg_nosec net/socket.c:718 [inline]
  __sock_sendmsg+0x30f/0x380 net/socket.c:733
  ____sys_sendmsg+0x877/0xb60 net/socket.c:2573
  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2627
  __sys_sendmsg net/socket.c:2659 [inline]
  __do_sys_sendmsg net/socket.c:2664 [inline]
  __se_sys_sendmsg net/socket.c:2662 [inline]
  __x64_sys_sendmsg+0x212/0x3c0 net/socket.c:2662
  x64_sys_call+0x2ed6/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:47
  do_syscall_x64 arch/x86/entry/common.c:52 [inline]
  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.3, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4236bf4716589558cc0f3c3612642b2c2141b04e
  - https://git.kernel.org/stable/c/4512482e4805dd30bc77dec511f2a2edba5cb868
  - https://git.kernel.org/stable/c/5bef3ac184b5626ea62385d6b82a1992b89d7940
  - https://git.kernel.org/stable/c/7c30483d0f6bdb2230e10e3e4be5167927eac7a0
  - https://git.kernel.org/stable/c/7f5af50f3aa0af8cbef9fb76fffeed69e8143f59
  - https://git.kernel.org/stable/c/8401cade1918281177974b32c925afdce750d292
  - https://git.kernel.org/stable/c/d071a91fa614ecdf760c29f61f6a7bfb7df796d6
  - https://git.kernel.org/stable/c/f443687ad20c70320d1248f35f57bf46cac8df0a

------------------------------------------------------------

CVE ID: CVE-2025-21788
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw: fix memleak in certain XDP cases

If the XDP program doesn't result in XDP_PASS then we leak the
memory allocated by am65_cpsw_build_skb().

It is pointless to allocate SKB memory before running the XDP
program as we would be wasting CPU cycles for cases other than XDP_PASS.
Move the SKB allocation after evaluating the XDP program result.

This fixes the memleak. A performance boost is seen for XDP_DROP test.

XDP_DROP test:
Before: 460256 rx/s                  0 err/s
After:  784130 rx/s                  0 err/s
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1bba1d042107167164a0ae3a843fdf650ab005d7
  - https://git.kernel.org/stable/c/5db843258de1e4e6b1ef1cbd1797923c9e3de548
  - https://git.kernel.org/stable/c/dc11f049612b9d926aca2e55f8dc9d82850d0da3

------------------------------------------------------------

CVE ID: CVE-2025-21789
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: csum: Fix OoB access in IP checksum code for negative lengths

Commit 69e3a6aa6be2 ("LoongArch: Add checksum optimization for 64-bit
system") would cause an undefined shift and an out-of-bounds read.

Commit 8bd795fedb84 ("arm64: csum: Fix OoB access in IP checksum code
for negative lengths") fixes the same issue on ARM64.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6287f1a8c16138c2ec750953e35039634018c84a
  - https://git.kernel.org/stable/c/964a8895704a22efc06a2a3276b624a5ae985a06
  - https://git.kernel.org/stable/c/9f15a8df542c0f08732a67d1a14ee7c22948fb97
  - https://git.kernel.org/stable/c/d6508ffff32b44b6d0de06704034e4eef1c307a7

------------------------------------------------------------

CVE ID: CVE-2025-21790
Description: In the Linux kernel, the following vulnerability has been resolved:

vxlan: check vxlan_vnigroup_init() return value

vxlan_init() must check vxlan_vnigroup_init() success
otherwise a crash happens later, spotted by syzbot.

Oops: general protection fault, probably for non-canonical address 0xdffffc000000002c: 0000 [#1] PREEMPT SMP KASAN NOPTI
KASAN: null-ptr-deref in range [0x0000000000000160-0x0000000000000167]
CPU: 0 UID: 0 PID: 7313 Comm: syz-executor147 Not tainted 6.14.0-rc1-syzkaller-00276-g69b54314c975 #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
 RIP: 0010:vxlan_vnigroup_uninit+0x89/0x500 drivers/net/vxlan/vxlan_vnifilter.c:912
Code: 00 48 8b 44 24 08 4c 8b b0 98 41 00 00 49 8d 86 60 01 00 00 48 89 c2 48 89 44 24 10 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 4d 04 00 00 49 8b 86 60 01 00 00 48 ba 00 00 00
RSP: 0018:ffffc9000cc1eea8 EFLAGS: 00010202
RAX: dffffc0000000000 RBX: 0000000000000001 RCX: ffffffff8672effb
RDX: 000000000000002c RSI: ffffffff8672ecb9 RDI: ffff8880461b4f18
RBP: ffff8880461b4ef4 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000020000
R13: ffff8880461b0d80 R14: 0000000000000000 R15: dffffc0000000000
FS:  00007fecfa95d6c0(0000) GS:ffff88806a600000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fecfa95cfb8 CR3: 000000004472c000 CR4: 0000000000352ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
  vxlan_uninit+0x1ab/0x200 drivers/net/vxlan/vxlan_core.c:2942
  unregister_netdevice_many_notify+0x12d6/0x1f30 net/core/dev.c:11824
  unregister_netdevice_many net/core/dev.c:11866 [inline]
  unregister_netdevice_queue+0x307/0x3f0 net/core/dev.c:11736
  register_netdevice+0x1829/0x1eb0 net/core/dev.c:10901
  __vxlan_dev_create+0x7c6/0xa30 drivers/net/vxlan/vxlan_core.c:3981
  vxlan_newlink+0xd1/0x130 drivers/net/vxlan/vxlan_core.c:4407
  rtnl_newlink_create net/core/rtnetlink.c:3795 [inline]
  __rtnl_newlink net/core/rtnetlink.c:3906 [inline]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3215f5aafc49aaa993991633833854694e73b439
  - https://git.kernel.org/stable/c/5805402dcc56241987bca674a1b4da79a249bab7
  - https://git.kernel.org/stable/c/79aea5e55156c87dc570e43fcd8bba01b9d6ab3f
  - https://git.kernel.org/stable/c/a303649b99b64858d62ce7428125d8e71675d2b6
  - https://git.kernel.org/stable/c/e860f847787fbbf0d8dacd638c019c7c3d4a9bd3

------------------------------------------------------------

CVE ID: CVE-2025-21791
Description: In the Linux kernel, the following vulnerability has been resolved:

vrf: use RCU protection in l3mdev_l3_out()

l3mdev_l3_out() can be called without RCU being held:

raw_sendmsg()
 ip_push_pending_frames()
  ip_send_skb()
   ip_local_out()
    __ip_local_out()
     l3mdev_ip_out()

Add rcu_read_lock() / rcu_read_unlock() pair to avoid
a potential UAF.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/022cac1c693add610ae76ede03adf4d9d5a2cf21
  - https://git.kernel.org/stable/c/20a3489b396764cc9376e32a9172bee26a89dc3b
  - https://git.kernel.org/stable/c/5bb4228c32261d06e4fbece37ec3828bcc005b6b
  - https://git.kernel.org/stable/c/6ccaa5797f5362a2aad6baa6ddaf4715ac2dd51e
  - https://git.kernel.org/stable/c/6d0ce46a93135d96b7fa075a94a88fe0da8e8773
  - https://git.kernel.org/stable/c/7b81425b517accefd46bee854d94954f5c57e019
  - https://git.kernel.org/stable/c/c40cb5c03e37552d6eff963187109e2c3f78ef6f
  - https://git.kernel.org/stable/c/c7574740be8ce68a57d0aece24987b9be2114c3c

------------------------------------------------------------

CVE ID: CVE-2025-21792
Description: In the Linux kernel, the following vulnerability has been resolved:

ax25: Fix refcount leak caused by setting SO_BINDTODEVICE sockopt

If an AX25 device is bound to a socket by setting the SO_BINDTODEVICE
socket option, a refcount leak will occur in ax25_release().

Commit 9fd75b66b8f6 ("ax25: Fix refcount leaks caused by ax25_cb_del()")
added decrement of device refcounts in ax25_release(). In order for that
to work correctly the refcounts must already be incremented when the
device is bound to the socket. An AX25 device can be bound to a socket
by either calling ax25_bind() or setting SO_BINDTODEVICE socket option.
In both cases the refcounts should be incremented, but in fact it is done
only in ax25_bind().

This bug leads to the following issue reported by Syzkaller:

================================================================
refcount_t: decrement hit 0; leaking memory.
WARNING: CPU: 1 PID: 5932 at lib/refcount.c:31 refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31
Modules linked in:
CPU: 1 UID: 0 PID: 5932 Comm: syz-executor424 Not tainted 6.13.0-rc4-syzkaller-00110-g4099a71718b0 #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
RIP: 0010:refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31
Call Trace:
 <TASK>
 __refcount_dec include/linux/refcount.h:336 [inline]
 refcount_dec include/linux/refcount.h:351 [inline]
 ref_tracker_free+0x710/0x820 lib/ref_tracker.c:236
 netdev_tracker_free include/linux/netdevice.h:4156 [inline]
 netdev_put include/linux/netdevice.h:4173 [inline]
 netdev_put include/linux/netdevice.h:4169 [inline]
 ax25_release+0x33f/0xa10 net/ax25/af_ax25.c:1069
 __sock_release+0xb0/0x270 net/socket.c:640
 sock_close+0x1c/0x30 net/socket.c:1408
 ...
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
 ...
 </TASK>
================================================================

Fix the implementation of ax25_setsockopt() by adding increment of
refcounts for the new device bound, and decrement of refcounts for
the old unbound device.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.277, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.240, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.190, Last Version (Excluding): 5.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.112, Last Version (Excluding): 5.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.35, Last Version (Excluding): 5.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17.2, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/470bda72fda0fcf54300466d70ce2de62f7835d2
  - https://git.kernel.org/stable/c/90056ece99966182dc0e367f3fd2afab46ada847
  - https://git.kernel.org/stable/c/94a0de224ed52eb2ecd4f4cb1b937b674c9fb955
  - https://git.kernel.org/stable/c/b58f7ca86a7b8e480c06e30c5163c5d2f4e24023
  - https://git.kernel.org/stable/c/bca0902e61731a75fc4860c8720168d9f1bae3b6

------------------------------------------------------------

CVE ID: CVE-2025-21793
Description: In the Linux kernel, the following vulnerability has been resolved:

spi: sn-f-ospi: Fix division by zero

When there is no dummy cycle in the spi-nor commands, both dummy bus cycle
bytes and width are zero. Because of the cpu's warning when divided by
zero, the warning should be avoided. Return just zero to avoid such
calculations.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3588b1c0fde2f58d166e3f94a5a58d64b893526c
  - https://git.kernel.org/stable/c/4df6f005bef04a3dd16c028124a1b5684db3922b
  - https://git.kernel.org/stable/c/7434135553bc03809a55803ee6a8dcaae6240d55
  - https://git.kernel.org/stable/c/966328191b4c389c0f2159fa242915f51cbc1679

------------------------------------------------------------

CVE ID: CVE-2025-21794
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: hid-thrustmaster: fix stack-out-of-bounds read in usb_check_int_endpoints()

Syzbot[1] has detected a stack-out-of-bounds read of the ep_addr array from
hid-thrustmaster driver. This array is passed to usb_check_int_endpoints
function from usb.c core driver, which executes a for loop that iterates
over the elements of the passed array. Not finding a null element at the end of
the array, it tries to read the next, non-existent element, crashing the kernel.

To fix this, a 0 element was added at the end of the array to break the for
loop.

[1] https://syzkaller.appspot.com/bug?extid=9c9179ac46169c56c1ad
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.76, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.13, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13.2, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0b43d98ff29be3144e86294486b1373b5df74c0e
  - https://git.kernel.org/stable/c/436f48c864186e9413d1b7c6e91767cc9e1a65b8
  - https://git.kernel.org/stable/c/73e36a699b9f46322ffb81f072a24e64f728dba7
  - https://git.kernel.org/stable/c/cdd9a1ea23ff1a272547217100663e8de4eada40
  - https://git.kernel.org/stable/c/f3ce05283f6cb6e19c220f5382def43dc5bd56b9

------------------------------------------------------------

CVE ID: CVE-2025-21795
Description: In the Linux kernel, the following vulnerability has been resolved:

NFSD: fix hang in nfsd4_shutdown_callback

If nfs4_client is in courtesy state then there is no point to send
the callback. This causes nfsd4_shutdown_callback to hang since
cl_cb_inflight is not 0. This hang lasts about 15 minutes until TCP
notifies NFSD that the connection was dropped.

This patch modifies nfsd4_run_cb_work to skip the RPC call if
nfs4_client is in courtesy state.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/036ac2778f7b28885814c6fbc07e156ad1624d03
  - https://git.kernel.org/stable/c/23ad7797c74cd8f7f90617f1e59a8703e2b43908
  - https://git.kernel.org/stable/c/38d345f612503b850c2973e5a879f88e441b34d7
  - https://git.kernel.org/stable/c/abed68027ea3ab893ac85cc46a00e2e64a324239
  - https://git.kernel.org/stable/c/cedfbb92cf97a6bff3d25633001d9c44442ee854
  - https://git.kernel.org/stable/c/e88d2451cd42e025465d6b51fd716a47b0b3800d
  - https://git.kernel.org/stable/c/efa8a261c575f816c7e79a87aeb3ef8a0bd6b221

------------------------------------------------------------

CVE ID: CVE-2025-21796
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: clear acl_access/acl_default after releasing them

If getting acl_default fails, acl_access and acl_default will be released
simultaneously. However, acl_access will still retain a pointer pointing
to the released posix_acl, which will trigger a WARNING in
nfs3svc_release_getacl like this:

------------[ cut here ]------------
refcount_t: underflow; use-after-free.
WARNING: CPU: 26 PID: 3199 at lib/refcount.c:28
refcount_warn_saturate+0xb5/0x170
Modules linked in:
CPU: 26 UID: 0 PID: 3199 Comm: nfsd Not tainted
6.12.0-rc6-00079-g04ae226af01f-dirty #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
1.16.1-2.fc37 04/01/2014
RIP: 0010:refcount_warn_saturate+0xb5/0x170
Code: cc cc 0f b6 1d b3 20 a5 03 80 fb 01 0f 87 65 48 d8 00 83 e3 01 75
e4 48 c7 c7 c0 3b 9b 85 c6 05 97 20 a5 03 01 e8 fb 3e 30 ff <0f> 0b eb
cd 0f b6 1d 8a3
RSP: 0018:ffffc90008637cd8 EFLAGS: 00010282
RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff83904fde
RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88871ed36380
RBP: ffff888158beeb40 R08: 0000000000000001 R09: fffff520010c6f56
R10: ffffc90008637ab7 R11: 0000000000000001 R12: 0000000000000001
R13: ffff888140e77400 R14: ffff888140e77408 R15: ffffffff858b42c0
FS:  0000000000000000(0000) GS:ffff88871ed00000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000562384d32158 CR3: 000000055cc6a000 CR4: 00000000000006f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 ? refcount_warn_saturate+0xb5/0x170
 ? __warn+0xa5/0x140
 ? refcount_warn_saturate+0xb5/0x170
 ? report_bug+0x1b1/0x1e0
 ? handle_bug+0x53/0xa0
 ? exc_invalid_op+0x17/0x40
 ? asm_exc_invalid_op+0x1a/0x20
 ? tick_nohz_tick_stopped+0x1e/0x40
 ? refcount_warn_saturate+0xb5/0x170
 ? refcount_warn_saturate+0xb5/0x170
 nfs3svc_release_getacl+0xc9/0xe0
 svc_process_common+0x5db/0xb60
 ? __pfx_svc_process_common+0x10/0x10
 ? __rcu_read_unlock+0x69/0xa0
 ? __pfx_nfsd_dispatch+0x10/0x10
 ? svc_xprt_received+0xa1/0x120
 ? xdr_init_decode+0x11d/0x190
 svc_process+0x2a7/0x330
 svc_handle_xprt+0x69d/0x940
 svc_recv+0x180/0x2d0
 nfsd+0x168/0x200
 ? __pfx_nfsd+0x10/0x10
 kthread+0x1a2/0x1e0
 ? kthread+0xf4/0x1e0
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x34/0x60
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK>
Kernel panic - not syncing: kernel: panic_on_warn set ...

Clear acl_access/acl_default after posix_acl_release is called to prevent
UAF from being triggered.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.13, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1fd94884174bd20beb1773990fd3b1aa877688d9
  - https://git.kernel.org/stable/c/2e59b2b68782519560b3d6a41dd66a3d01a01cd3
  - https://git.kernel.org/stable/c/55d947315fb5f67a35e4e1d3e01bb886b9c6decf
  - https://git.kernel.org/stable/c/6f7cfee1a316891890c505563aa54f3476db52fd
  - https://git.kernel.org/stable/c/7faf14a7b0366f153284db0ad3347c457ea70136
  - https://git.kernel.org/stable/c/8a1737ae42c928384ab6447f6ee1a882510e85fa
  - https://git.kernel.org/stable/c/f8d871523142f7895f250a856f8c4a4181614510

------------------------------------------------------------

CVE ID: CVE-2025-21797
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: corsair-void: Add missing delayed work cancel for headset status

The cancel_delayed_work_sync() call was missed, causing a use-after-free
in corsair_void_remove().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2dcb56a0a4da6946f6c18288da595c13e0d2af86
  - https://git.kernel.org/stable/c/48e487b002891eb0aeaec704c9bed51f028deff1

------------------------------------------------------------

CVE ID: CVE-2024-58022
Description: In the Linux kernel, the following vulnerability has been resolved:

mailbox: th1520: Fix a NULL vs IS_ERR() bug

The devm_ioremap() function doesn't return error pointers, it returns
NULL.  Update the error checking to match.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/d0f98e14c010bcf27898b635a54c1994ac4110a8
  - https://git.kernel.org/stable/c/ecbde88e544ff016fa08bbf2156dc431bb123e9b

------------------------------------------------------------

CVE ID: CVE-2024-58034
Description: In the Linux kernel, the following vulnerability has been resolved:

memory: tegra20-emc: fix an OF node reference bug in tegra_emc_find_node_by_ram_code()

As of_find_node_by_name() release the reference of the argument device
node, tegra_emc_find_node_by_ram_code() releases some device nodes while
still in use, resulting in possible UAFs. According to the bindings and
the in-tree DTS files, the "emc-tables" node is always device's child
node with the property "nvidia,use-ram-code", and the "lpddr2" node is a
child of the "emc-tables" node. Thus utilize the
for_each_child_of_node() macro and of_get_child_by_name() instead of
of_find_node_by_name() to simplify the code.

This bug was found by an experimental verification tool that I am
developing.

[krzysztof: applied v1, adjust the commit msg to incorporate v2 parts]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/3b02273446e23961d910b50cc12528faec649fb2
  - https://git.kernel.org/stable/c/755e44538c190c31de9090d8e8821d228fcfd416
  - https://git.kernel.org/stable/c/b9784e5cde1f9fb83661a70e580e381ae1264d12
  - https://git.kernel.org/stable/c/c144423cb07e4e227a8572d5742ca2b36ada770d
  - https://git.kernel.org/stable/c/c3def10c610ae046aaa61d00528e7bd15e4ad8d3
  - https://git.kernel.org/stable/c/e9d07e91de140679eeaf275f47ad154467cb9e05

------------------------------------------------------------

CVE ID: CVE-2024-58042
Description: In the Linux kernel, the following vulnerability has been resolved:

rhashtable: Fix potential deadlock by moving schedule_work outside lock

Move the hash table growth check and work scheduling outside the
rht lock to prevent a possible circular locking dependency.

The original implementation could trigger a lockdep warning due to
a potential deadlock scenario involving nested locks between
rhashtable bucket, rq lock, and dsq lock. By relocating the
growth check and work scheduling after releasing the rth lock, we break
this potential deadlock chain.

This change expands the flexibility of rhashtable by removing
restrictive locking that previously limited its use in scheduler
and workqueue contexts.

Import to say that this calls rht_grow_above_75(), which reads from
struct rhashtable without holding the lock, if this is a problem, we can
move the check to the lock, and schedule the workqueue after the lock.


Modified so that atomic_inc is also moved outside of the bucket
lock along with the growth above 75% check.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/ced8ce3c83a7150c5f5d371a8c332d7bc7f9b66d
  - https://git.kernel.org/stable/c/e1d3422c95f003eba241c176adfe593c33e8a8f6
  - https://git.kernel.org/stable/c/eb2e58484b838fb4e777ee9721bb9e20e6ca971d

------------------------------------------------------------

CVE ID: CVE-2025-21798
Description: In the Linux kernel, the following vulnerability has been resolved:

firewire: test: Fix potential null dereference in firewire kunit test

kunit_kzalloc() may return a NULL pointer, dereferencing it without
NULL check may lead to NULL dereference.
Add a NULL check for test_state.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/352fafe97784e81a10a7c74bd508f71a19b53c2a
  - https://git.kernel.org/stable/c/70fcb25472d90dd3b87cbee74b9eb68670b0c7b8
  - https://git.kernel.org/stable/c/c6896bf4c611c3dd126f3e03685f2360a18b3d6f

------------------------------------------------------------

CVE ID: CVE-2025-21799
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw: fix freeing IRQ in am65_cpsw_nuss_remove_tx_chns()

When getting the IRQ we use k3_udma_glue_tx_get_irq() which returns
negative error value on error. So not NULL check is not sufficient
to deteremine if IRQ is valid. Check that IRQ is greater then zero
to ensure it is valid.

There is no issue at probe time but at runtime user can invoke
.set_channels which results in the following call chain.
am65_cpsw_set_channels()
 am65_cpsw_nuss_update_tx_rx_chns()
  am65_cpsw_nuss_remove_tx_chns()
  am65_cpsw_nuss_init_tx_chns()

At this point if am65_cpsw_nuss_init_tx_chns() fails due to
k3_udma_glue_tx_get_irq() then tx_chn->irq will be set to a
negative value.

Then, at subsequent .set_channels with higher channel count we
will attempt to free an invalid IRQ in am65_cpsw_nuss_remove_tx_chns()
leading to a kernel warning.

The issue is present in the original commit that introduced this driver,
although there, am65_cpsw_nuss_update_tx_rx_chns() existed as
am65_cpsw_nuss_update_tx_chns().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/321990fdf4f1bb64e818c7140688bf33d129e48d
  - https://git.kernel.org/stable/c/4395a44acb15850e492dd1de9ec4b6479d96bc80
  - https://git.kernel.org/stable/c/8448c87b3af68bebca21e3136913f7f77e363515
  - https://git.kernel.org/stable/c/88fd5db8c0073bd91d18391feb5741aeb0a2b475
  - https://git.kernel.org/stable/c/8aae91ae1c65782a169ec070e023d4d269e5d6e6
  - https://git.kernel.org/stable/c/aea5cca681d268f794fa2385f9ec26a5cce025cd
  - https://git.kernel.org/stable/c/ed8c0300f302338c36edb06bca99051e5be6fb2f

------------------------------------------------------------

CVE ID: CVE-2025-21800
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: HWS, fix definer's HWS_SET32 macro for negative offset

When bit offset for HWS_SET32 macro is negative,
UBSAN complains about the shift-out-of-bounds:

  UBSAN: shift-out-of-bounds in
  drivers/net/ethernet/mellanox/mlx5/core/steering/hws/definer.c:177:2
  shift exponent -8 is negative
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/69c676c0ded472713e6d1b3a456b3c4f52f66f0e
  - https://git.kernel.org/stable/c/92cff996624c4757d5bbace3dfa3f1567ba94143
  - https://git.kernel.org/stable/c/be482f1d10da781db9445d2753c1e3f1fd82babf

------------------------------------------------------------

CVE ID: CVE-2025-21801
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ravb: Fix missing rtnl lock in suspend/resume path

Fix the suspend/resume path by ensuring the rtnl lock is held where
required. Calls to ravb_open, ravb_close and wol operations must be
performed under the rtnl lock to prevent conflicts with ongoing ndo
operations.

Without this fix, the following warning is triggered:
[   39.032969] =============================
[   39.032983] WARNING: suspicious RCU usage
[   39.033019] -----------------------------
[   39.033033] drivers/net/phy/phy_device.c:2004 suspicious
rcu_dereference_protected() usage!
...
[   39.033597] stack backtrace:
[   39.033613] CPU: 0 UID: 0 PID: 174 Comm: python3 Not tainted
6.13.0-rc7-next-20250116-arm64-renesas-00002-g35245dfdc62c #7
[   39.033623] Hardware name: Renesas SMARC EVK version 2 based on
r9a08g045s33 (DT)
[   39.033628] Call trace:
[   39.033633]  show_stack+0x14/0x1c (C)
[   39.033652]  dump_stack_lvl+0xb4/0xc4
[   39.033664]  dump_stack+0x14/0x1c
[   39.033671]  lockdep_rcu_suspicious+0x16c/0x22c
[   39.033682]  phy_detach+0x160/0x190
[   39.033694]  phy_disconnect+0x40/0x54
[   39.033703]  ravb_close+0x6c/0x1cc
[   39.033714]  ravb_suspend+0x48/0x120
[   39.033721]  dpm_run_callback+0x4c/0x14c
[   39.033731]  device_suspend+0x11c/0x4dc
[   39.033740]  dpm_suspend+0xdc/0x214
[   39.033748]  dpm_suspend_start+0x48/0x60
[   39.033758]  suspend_devices_and_enter+0x124/0x574
[   39.033769]  pm_suspend+0x1ac/0x274
[   39.033778]  state_store+0x88/0x124
[   39.033788]  kobj_attr_store+0x14/0x24
[   39.033798]  sysfs_kf_write+0x48/0x6c
[   39.033808]  kernfs_fop_write_iter+0x118/0x1a8
[   39.033817]  vfs_write+0x27c/0x378
[   39.033825]  ksys_write+0x64/0xf4
[   39.033833]  __arm64_sys_write+0x18/0x20
[   39.033841]  invoke_syscall+0x44/0x104
[   39.033852]  el0_svc_common.constprop.0+0xb4/0xd4
[   39.033862]  do_el0_svc+0x18/0x20
[   39.033870]  el0_svc+0x3c/0xf0
[   39.033880]  el0t_64_sync_handler+0xc0/0xc4
[   39.033888]  el0t_64_sync+0x154/0x158
[   39.041274] ravb 11c30000.ethernet eth0: Link is Down
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0296981941cf291edfbc318d3255a93439f368e4
  - https://git.kernel.org/stable/c/2c2ebb2b49573e5f8726112ad06b1dffc3c9ea03
  - https://git.kernel.org/stable/c/ad19522c007bb24ed874468f8baa1503c4662cf4

------------------------------------------------------------

CVE ID: CVE-2025-21802
Description: In the Linux kernel, the following vulnerability has been resolved:

net: hns3: fix oops when unload drivers paralleling

When unload hclge driver, it tries to disable sriov first for each
ae_dev node from hnae3_ae_dev_list. If user unloads hns3 driver at
the time, because it removes all the ae_dev nodes, and it may cause
oops.

But we can't simply use hnae3_common_lock for this. Because in the
process flow of pci_disable_sriov(), it will trigger the remove flow
of VF, which will also take hnae3_common_lock.

To fixes it, introduce a new mutex to protect the unload process.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/622d92a67656e5c4d2d6ccac02d688ed995418c6
  - https://git.kernel.org/stable/c/82736bb83fb0221319c85c2e9917d0189cd84e1e
  - https://git.kernel.org/stable/c/8c640dd3d900cc8988a39c007591f1deee776df4
  - https://git.kernel.org/stable/c/92e5995773774a3e70257e9c95ea03518268bea5
  - https://git.kernel.org/stable/c/b5a8bc47aa0a4aa8bca5466dfa2d12dbb5b3cd0c
  - https://git.kernel.org/stable/c/cafe9a27e22736d4a01b3933e36225f9857c7988
  - https://git.kernel.org/stable/c/e876522659012ef2e73834a0b9f1cbe3f74d5fad

------------------------------------------------------------

CVE ID: CVE-2025-21803
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Fix warnings during S3 suspend

The enable_gpe_wakeup() function calls acpi_enable_all_wakeup_gpes(),
and the later one may call the preempt_schedule_common() function,
resulting in a thread switch and causing the CPU to be in an interrupt
enabled state after the enable_gpe_wakeup() function returns, leading
to the warnings as follow.

[ C0] WARNING: ... at kernel/time/timekeeping.c:845 ktime_get+0xbc/0xc8
[ C0]          ...
[ C0] Call Trace:
[ C0] [<90000000002243b4>] show_stack+0x64/0x188
[ C0] [<900000000164673c>] dump_stack_lvl+0x60/0x88
[ C0] [<90000000002687e4>] __warn+0x8c/0x148
[ C0] [<90000000015e9978>] report_bug+0x1c0/0x2b0
[ C0] [<90000000016478e4>] do_bp+0x204/0x3b8
[ C0] [<90000000025b1924>] exception_handlers+0x1924/0x10000
[ C0] [<9000000000343bbc>] ktime_get+0xbc/0xc8
[ C0] [<9000000000354c08>] tick_sched_timer+0x30/0xb0
[ C0] [<90000000003408e0>] __hrtimer_run_queues+0x160/0x378
[ C0] [<9000000000341f14>] hrtimer_interrupt+0x144/0x388
[ C0] [<9000000000228348>] constant_timer_interrupt+0x38/0x48
[ C0] [<90000000002feba4>] __handle_irq_event_percpu+0x64/0x1e8
[ C0] [<90000000002fed48>] handle_irq_event_percpu+0x20/0x80
[ C0] [<9000000000306b9c>] handle_percpu_irq+0x5c/0x98
[ C0] [<90000000002fd4a0>] generic_handle_domain_irq+0x30/0x48
[ C0] [<9000000000d0c7b0>] handle_cpu_irq+0x70/0xa8
[ C0] [<9000000001646b30>] handle_loongarch_irq+0x30/0x48
[ C0] [<9000000001646bc8>] do_vint+0x80/0xe0
[ C0] [<90000000002aea1c>] finish_task_switch.isra.0+0x8c/0x2a8
[ C0] [<900000000164e34c>] __schedule+0x314/0xa48
[ C0] [<900000000164ead8>] schedule+0x58/0xf0
[ C0] [<9000000000294a2c>] worker_thread+0x224/0x498
[ C0] [<900000000029d2f0>] kthread+0xf8/0x108
[ C0] [<9000000000221f28>] ret_from_kernel_thread+0xc/0xa4
[ C0]
[ C0] ---[ end trace 0000000000000000 ]---

The root cause is acpi_enable_all_wakeup_gpes() uses a mutex to protect
acpi_hw_enable_all_wakeup_gpes(), and acpi_ut_acquire_mutex() may cause
a thread switch. Since there is no longer concurrent execution during
loongarch_acpi_suspend(), we can call acpi_hw_enable_all_wakeup_gpes()
directly in enable_gpe_wakeup().

The solution is similar to commit 22db06337f590d01 ("ACPI: sleep: Avoid
breaking S3 wakeup due to might_sleep()").
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/194d26a5a43c26dc98a9b4e2c1d521dcb84dd1bf
  - https://git.kernel.org/stable/c/26c0a2d93af55d30a46d5f45d3e9c42cde730168
  - https://git.kernel.org/stable/c/8682a71a7f6de7c683f31b4334b04e19685a05f9
  - https://git.kernel.org/stable/c/d49ab6857d98266010f3446c9c2063014db5b654

------------------------------------------------------------

CVE ID: CVE-2025-21804
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: rcar-ep: Fix incorrect variable used when calling devm_request_mem_region()

The rcar_pcie_parse_outbound_ranges() uses the devm_request_mem_region()
macro to request a needed resource. A string variable that lives on the
stack is then used to store a dynamically computed resource name, which
is then passed on as one of the macro arguments. This can lead to
undefined behavior.

Depending on the current contents of the memory, the manifestations of
errors may vary. One possible output may be as follows:

  $ cat /proc/iomem
  30000000-37ffffff :
  38000000-3fffffff :

Sometimes, garbage may appear after the colon.

In very rare cases, if no NULL-terminator is found in memory, the system
might crash because the string iterator will overrun which can lead to
access of unmapped memory above the stack.

Thus, fix this by replacing outbound_name with the name of the previously
requested resource. With the changes applied, the output will be as
follows:

  $ cat /proc/iomem
  30000000-37ffffff : memory2
  38000000-3fffffff : memory3

[kwilczynski: commit log]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/24576899c49509c0d533bcf569139f691d8f7af7
  - https://git.kernel.org/stable/c/2c54b9fca1755e80a343ccfde0652dc5ea4744b2
  - https://git.kernel.org/stable/c/2d2da5a4c1b4509f6f7e5a8db015cd420144beb4
  - https://git.kernel.org/stable/c/44708208c2a4b828a57a2abe7799c9d3962e7eaa
  - https://git.kernel.org/stable/c/6987e021b64cbb49981d140bb72d9d1466f191c4
  - https://git.kernel.org/stable/c/7a47e14c5fb0b6dba7073be7b0119fb8fe864e01
  - https://git.kernel.org/stable/c/9ff46b0bfeb6e0724a4ace015aa7a0b887cdb7c1

------------------------------------------------------------

CVE ID: CVE-2025-21805
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/rtrs: Add missing deinit() call

A warning is triggered when repeatedly connecting and disconnecting the
rnbd:
 list_add corruption. prev->next should be next (ffff88800b13e480), but was ffff88801ecd1338. (prev=ffff88801ecd1340).
 WARNING: CPU: 1 PID: 36562 at lib/list_debug.c:32 __list_add_valid_or_report+0x7f/0xa0
 Workqueue: ib_cm cm_work_handler [ib_cm]
 RIP: 0010:__list_add_valid_or_report+0x7f/0xa0
  ? __list_add_valid_or_report+0x7f/0xa0
  ib_register_event_handler+0x65/0x93 [ib_core]
  rtrs_srv_ib_dev_init+0x29/0x30 [rtrs_server]
  rtrs_ib_dev_find_or_add+0x124/0x1d0 [rtrs_core]
  __alloc_path+0x46c/0x680 [rtrs_server]
  ? rtrs_rdma_connect+0xa6/0x2d0 [rtrs_server]
  ? rcu_is_watching+0xd/0x40
  ? __mutex_lock+0x312/0xcf0
  ? get_or_create_srv+0xad/0x310 [rtrs_server]
  ? rtrs_rdma_connect+0xa6/0x2d0 [rtrs_server]
  rtrs_rdma_connect+0x23c/0x2d0 [rtrs_server]
  ? __lock_release+0x1b1/0x2d0
  cma_cm_event_handler+0x4a/0x1a0 [rdma_cm]
  cma_ib_req_handler+0x3a0/0x7e0 [rdma_cm]
  cm_process_work+0x28/0x1a0 [ib_cm]
  ? _raw_spin_unlock_irq+0x2f/0x50
  cm_req_handler+0x618/0xa60 [ib_cm]
  cm_work_handler+0x71/0x520 [ib_cm]

Commit 667db86bcbe8 ("RDMA/rtrs: Register ib event handler") introduced a
new element .deinit but never used it at all. Fix it by invoking the
`deinit()` to appropriately unregister the IB event handler.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1af2c769032b6b334cd2a867d7d8c7cbbc527b2d
  - https://git.kernel.org/stable/c/5a79cc9bc961fafe90787f86e8f53ba6fad8d63b
  - https://git.kernel.org/stable/c/81468c4058a62e84e475433b83b3edc613294f5e

------------------------------------------------------------

CVE ID: CVE-2025-21806
Description: In the Linux kernel, the following vulnerability has been resolved:

net: let net.core.dev_weight always be non-zero

The following problem was encountered during stability test:

(NULL net_device): NAPI poll function process_backlog+0x0/0x530 \
	returned 1, exceeding its budget of 0.
------------[ cut here ]------------
list_add double add: new=ffff88905f746f48, prev=ffff88905f746f48, \
	next=ffff88905f746e40.
WARNING: CPU: 18 PID: 5462 at lib/list_debug.c:35 \
	__list_add_valid_or_report+0xf3/0x130
CPU: 18 UID: 0 PID: 5462 Comm: ping Kdump: loaded Not tainted 6.13.0-rc7+
RIP: 0010:__list_add_valid_or_report+0xf3/0x130
Call Trace:
? __warn+0xcd/0x250
? __list_add_valid_or_report+0xf3/0x130
enqueue_to_backlog+0x923/0x1070
netif_rx_internal+0x92/0x2b0
__netif_rx+0x15/0x170
loopback_xmit+0x2ef/0x450
dev_hard_start_xmit+0x103/0x490
__dev_queue_xmit+0xeac/0x1950
ip_finish_output2+0x6cc/0x1620
ip_output+0x161/0x270
ip_push_pending_frames+0x155/0x1a0
raw_sendmsg+0xe13/0x1550
__sys_sendto+0x3bf/0x4e0
__x64_sys_sendto+0xdc/0x1b0
do_syscall_64+0x5b/0x170
entry_SYSCALL_64_after_hwframe+0x76/0x7e

The reproduction command is as follows:
  sysctl -w net.core.dev_weight=0
  ping 127.0.0.1

This is because when the napi's weight is set to 0, process_backlog() may
return 0 and clear the NAPI_STATE_SCHED bit of napi->state, causing this
napi to be re-polled in net_rx_action() until __do_softirq() times out.
Since the NAPI_STATE_SCHED bit has been cleared, napi_schedule_rps() can
be retriggered in enqueue_to_backlog(), causing this issue.

Making the napi's weight always non-zero solves this problem.

Triggering this issue requires system-wide admin (setting is
not namespaced).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e2f1d93d287d544d26f8ff293ea820a8079b9f8
  - https://git.kernel.org/stable/c/1489824e5226a26841c70639ebd2d1aed390764b
  - https://git.kernel.org/stable/c/33e2168788f8fb5cb8bd4f36cb1ef37d1d34dada
  - https://git.kernel.org/stable/c/5860abbf15eeb61838b5e32e721ba67b0aa84450
  - https://git.kernel.org/stable/c/6ce38b5a6a49e65bad163162a54cb3f104c40b48
  - https://git.kernel.org/stable/c/c337c08819a4ec49edfdcd8fc46fbee120d8a5b2
  - https://git.kernel.org/stable/c/d0e0f9c8218826926d7692980c98236d9f21fd3c
  - https://git.kernel.org/stable/c/d1f9f79fa2af8e3b45cffdeef66e05833480148a

------------------------------------------------------------

CVE ID: CVE-2025-21807
Description: In the Linux kernel, the following vulnerability has been resolved:

block: fix queue freeze vs limits lock order in sysfs store methods

queue_attr_store() always freezes a device queue before calling the
attribute store operation. For attributes that control queue limits, the
store operation will also lock the queue limits with a call to
queue_limits_start_update(). However, some drivers (e.g. SCSI sd) may
need to issue commands to a device to obtain limit values from the
hardware with the queue limits locked. This creates a potential ABBA
deadlock situation if a user attempts to modify a limit (thus freezing
the device queue) while the device driver starts a revalidation of the
device queue limits.

Avoid such deadlock by not freezing the queue before calling the
->store_limit() method in struct queue_sysfs_entry and instead use the
queue_limits_commit_update_frozen helper to freeze the queue after taking
the limits lock.

This also removes taking the sysfs lock for the store_limit method as
it doesn't protect anything here, but creates even more nesting.
Hopefully it will go away from the actual sysfs methods entirely soon.

(commit log adapted from a similar patch from  Damien Le Moal)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8985da5481562e96b95e94ed8e5cc9b6565eb82b
  - https://git.kernel.org/stable/c/c99f66e4084a62a2cc401c4704a84328aeddc9ec

------------------------------------------------------------

CVE ID: CVE-2025-21808
Description: In the Linux kernel, the following vulnerability has been resolved:

net: xdp: Disallow attaching device-bound programs in generic mode

Device-bound programs are used to support RX metadata kfuncs. These
kfuncs are driver-specific and rely on the driver context to read the
metadata. This means they can't work in generic XDP mode. However, there
is no check to disallow such programs from being attached in generic
mode, in which case the metadata kfuncs will be called in an invalid
context, leading to crashes.

Fix this by adding a check to disallow attaching device-bound programs
in generic mode.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3595599fa8360bb3c7afa7ee50c810b4a64106ea
  - https://git.kernel.org/stable/c/557707906dd3e34b8a8c265f664d19f95799937e
  - https://git.kernel.org/stable/c/5a9eae683d6c36e8a7aa31e5eb8b369e41aa66e1
  - https://git.kernel.org/stable/c/b1bc4a35a04cbeb85b6ef5911ec015baa424989f

------------------------------------------------------------

CVE ID: CVE-2025-21809
Description: In the Linux kernel, the following vulnerability has been resolved:

rxrpc, afs: Fix peer hash locking vs RCU callback

In its address list, afs now retains pointers to and refs on one or more
rxrpc_peer objects.  The address list is freed under RCU and at this time,
it puts the refs on those peers.

Now, when an rxrpc_peer object runs out of refs, it gets removed from the
peer hash table and, for that, rxrpc has to take a spinlock.  However, it
is now being called from afs's RCU cleanup, which takes place in BH
context - but it is just taking an ordinary spinlock.

The put may also be called from non-BH context, and so there exists the
possibility of deadlock if the BH-based RCU cleanup happens whilst the hash
spinlock is held.  This led to the attached lockdep complaint.

Fix this by changing spinlocks of rxnet->peer_hash_lock back to
BH-disabling locks.

    ================================
    WARNING: inconsistent lock state
    6.13.0-rc5-build2+ #1223 Tainted: G            E
    --------------------------------
    inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.
    swapper/1/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
    ffff88810babe228 (&rxnet->peer_hash_lock){+.?.}-{3:3}, at: rxrpc_put_peer+0xcb/0x180
    {SOFTIRQ-ON-W} state was registered at:
      mark_usage+0x164/0x180
      __lock_acquire+0x544/0x990
      lock_acquire.part.0+0x103/0x280
      _raw_spin_lock+0x2f/0x40
      rxrpc_peer_keepalive_worker+0x144/0x440
      process_one_work+0x486/0x7c0
      process_scheduled_works+0x73/0x90
      worker_thread+0x1c8/0x2a0
      kthread+0x19b/0x1b0
      ret_from_fork+0x24/0x40
      ret_from_fork_asm+0x1a/0x30
    irq event stamp: 972402
    hardirqs last  enabled at (972402): [<ffffffff8244360e>] _raw_spin_unlock_irqrestore+0x2e/0x50
    hardirqs last disabled at (972401): [<ffffffff82443328>] _raw_spin_lock_irqsave+0x18/0x60
    softirqs last  enabled at (972300): [<ffffffff810ffbbe>] handle_softirqs+0x3ee/0x430
    softirqs last disabled at (972313): [<ffffffff810ffc54>] __irq_exit_rcu+0x44/0x110

    other info that might help us debug this:
     Possible unsafe locking scenario:
           CPU0
           ----
      lock(&rxnet->peer_hash_lock);
      <Interrupt>
        lock(&rxnet->peer_hash_lock);

     *** DEADLOCK ***
    1 lock held by swapper/1/0:
     #0: ffffffff83576be0 (rcu_callback){....}-{0:0}, at: rcu_lock_acquire+0x7/0x30

    stack backtrace:
    CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Tainted: G            E      6.13.0-rc5-build2+ #1223
    Tainted: [E]=UNSIGNED_MODULE
    Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014
    Call Trace:
     <IRQ>
     dump_stack_lvl+0x57/0x80
     print_usage_bug.part.0+0x227/0x240
     valid_state+0x53/0x70
     mark_lock_irq+0xa5/0x2f0
     mark_lock+0xf7/0x170
     mark_usage+0xe1/0x180
     __lock_acquire+0x544/0x990
     lock_acquire.part.0+0x103/0x280
     _raw_spin_lock+0x2f/0x40
     rxrpc_put_peer+0xcb/0x180
     afs_free_addrlist+0x46/0x90 [kafs]
     rcu_do_batch+0x2d2/0x640
     rcu_core+0x2f7/0x350
     handle_softirqs+0x1ee/0x430
     __irq_exit_rcu+0x44/0x110
     irq_exit_rcu+0xa/0x30
     sysvec_apic_timer_interrupt+0x7f/0xa0
     </IRQ>
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7.3, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0e77dd41689637ac4e1b8fe0f27541f373640855
  - https://git.kernel.org/stable/c/10ba5a3d57af20e494e0d979d1894260989235dd
  - https://git.kernel.org/stable/c/79d458c13056559d49b5e41fbc4b6890e68cf65b

------------------------------------------------------------

CVE ID: CVE-2025-21810
Description: In the Linux kernel, the following vulnerability has been resolved:

driver core: class: Fix wild pointer dereferences in API class_dev_iter_next()

There are a potential wild pointer dereferences issue regarding APIs
class_dev_iter_(init|next|exit)(), as explained by below typical usage:

// All members of @iter are wild pointers.
struct class_dev_iter iter;

// class_dev_iter_init(@iter, @class, ...) checks parameter @class for
// potential class_to_subsys() error, and it returns void type and does
// not initialize its output parameter @iter, so caller can not detect
// the error and continues to invoke class_dev_iter_next(@iter) even if
// @iter still contains wild pointers.
class_dev_iter_init(&iter, ...);

// Dereference these wild pointers in @iter here once suffer the error.
while (dev = class_dev_iter_next(&iter)) { ... };

// Also dereference these wild pointers here.
class_dev_iter_exit(&iter);

Actually, all callers of these APIs have such usage pattern in kernel tree.
Fix by:
- Initialize output parameter @iter by memset() in class_dev_iter_init()
  and give callers prompt by pr_crit() for the error.
- Check if @iter is valid in class_dev_iter_next().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1614e75d1a1b63db6421c7a4bf37004720c7376c
  - https://git.kernel.org/stable/c/5c504e9767b947cf7d4e29b811c0c8b3c53242b7
  - https://git.kernel.org/stable/c/e128f82f7006991c99a58114f70ef61e937b1ac1
  - https://git.kernel.org/stable/c/f4b9bc823b0cfdebfed479c0e87d6939c7562e87

------------------------------------------------------------

CVE ID: CVE-2025-21811
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: protect access to buffers with no active references

nilfs_lookup_dirty_data_buffers(), which iterates through the buffers
attached to dirty data folios/pages, accesses the attached buffers without
locking the folios/pages.

For data cache, nilfs_clear_folio_dirty() may be called asynchronously
when the file system degenerates to read only, so
nilfs_lookup_dirty_data_buffers() still has the potential to cause use
after free issues when buffers lose the protection of their dirty state
midway due to this asynchronous clearing and are unintentionally freed by
try_to_free_buffers().

Eliminate this race issue by adjusting the lock section in this function.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.10, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/367a9bffabe08c04f6d725032cce3d891b2b9e1a
  - https://git.kernel.org/stable/c/4b08d23d7d1917bef4fbee8ad81372f49b006656
  - https://git.kernel.org/stable/c/58c27fa7a610b6e8d44e6220e7dbddfbaccaf439
  - https://git.kernel.org/stable/c/72cf688d0ce7e642b12ddc9b2a42524737ec1b4a
  - https://git.kernel.org/stable/c/8e1b9201c9a24638cf09c6e1c9f224157328010b
  - https://git.kernel.org/stable/c/c437dfac9f7a5a46ac2a5e6d6acd3059e9f68188
  - https://git.kernel.org/stable/c/d8ff250e085a4c4cdda4ad1cdd234ed110393143
  - https://git.kernel.org/stable/c/e1fc4a90a90ea8514246c45435662531975937d9

------------------------------------------------------------

CVE ID: CVE-2025-21812
Description: In the Linux kernel, the following vulnerability has been resolved:

ax25: rcu protect dev->ax25_ptr

syzbot found a lockdep issue [1].

We should remove ax25 RTNL dependency in ax25_setsockopt()

This should also fix a variety of possible UAF in ax25.

[1]

WARNING: possible circular locking dependency detected
6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted
------------------------------------------------------
syz.5.1818/12806 is trying to acquire lock:
 ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680

but task is already holding lock:
 ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]
 ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574

which lock already depends on the new lock.

the existing dependency chain (in reverse order) is:

-> #1 (sk_lock-AF_AX25){+.+.}-{0:0}:
        lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849
        lock_sock_nested+0x48/0x100 net/core/sock.c:3642
        lock_sock include/net/sock.h:1618 [inline]
        ax25_kill_by_device net/ax25/af_ax25.c:101 [inline]
        ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146
        notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85
       __dev_notify_flags+0x207/0x400
        dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026
        dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563
        dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820
        sock_do_ioctl+0x240/0x460 net/socket.c:1234
        sock_ioctl+0x626/0x8e0 net/socket.c:1339
        vfs_ioctl fs/ioctl.c:51 [inline]
        __do_sys_ioctl fs/ioctl.c:906 [inline]
        __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892
        do_syscall_x64 arch/x86/entry/common.c:52 [inline]
        do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
       entry_SYSCALL_64_after_hwframe+0x77/0x7f

-> #0 (rtnl_mutex){+.+.}-{4:4}:
        check_prev_add kernel/locking/lockdep.c:3161 [inline]
        check_prevs_add kernel/locking/lockdep.c:3280 [inline]
        validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904
        __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226
        lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849
        __mutex_lock_common kernel/locking/mutex.c:585 [inline]
        __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735
        ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680
        do_sock_setsockopt+0x3af/0x720 net/socket.c:2324
        __sys_setsockopt net/socket.c:2349 [inline]
        __do_sys_setsockopt net/socket.c:2355 [inline]
        __se_sys_setsockopt net/socket.c:2352 [inline]
        __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352
        do_syscall_x64 arch/x86/entry/common.c:52 [inline]
        do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
       entry_SYSCALL_64_after_hwframe+0x77/0x7f

other info that might help us debug this:

 Possible unsafe locking scenario:

       CPU0                    CPU1
       ----                    ----
  lock(sk_lock-AF_AX25);
                               lock(rtnl_mutex);
                               lock(sk_lock-AF_AX25);
  lock(rtnl_mutex);

 *** DEADLOCK ***

1 lock held by syz.5.1818/12806:
  #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]
  #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574

stack backtrace:
CPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Call Trace:
 <TASK>
  __dump_stack lib/dump_stack.c:94 [inline]
  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
  print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074
  check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206
  check_prev_add kernel/locking/lockdep.c:3161 [inline]
  check_prevs_add kernel/lockin
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18.132, Last Version (Excluding): 3.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.170, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.149, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.92, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.14, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20.1, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2802ed4ced27ebd474828fc67ffd7d66f11e3605
  - https://git.kernel.org/stable/c/7705d8a7f2c26c80973c81093db07c6022b2b30e
  - https://git.kernel.org/stable/c/8937f5e38a218531dce2a89fae60e3adcc2311e1
  - https://git.kernel.org/stable/c/95fc45d1dea8e1253f8ec58abc5befb71553d666
  - https://git.kernel.org/stable/c/c2531db6de3c95551be58878f859c6a053b7eb2e

------------------------------------------------------------

CVE ID: CVE-2025-21813
Description: In the Linux kernel, the following vulnerability has been resolved:

timers/migration: Fix off-by-one root mis-connection

Before attaching a new root to the old root, the children counter of the
new root is checked to verify that only the upcoming CPU's top group have
been connected to it. However since the recently added commit b729cc1ec21a
("timers/migration: Fix another race between hotplug and idle entry/exit")
this check is not valid anymore because the old root is pre-accounted
as a child to the new root. Therefore after connecting the upcoming
CPU's top group to the new root, the children count to be expected must
be 2 and not 1 anymore.

This omission results in the old root to not be connected to the new
root. Then eventually the system may run with more than one top level,
which defeats the purpose of a single idle migrator.

Also the old root is pre-accounted but not connected upon the new root
creation. But it can be connected to the new root later on. Therefore
the old root may be accounted twice to the new root. The propagation of
such overcommit can end up creating a double final top-level root with a
groupmask incorrectly initialized. Although harmless given that the final
top level roots will never have a parent to walk up to, this oddity
opportunistically reported the core issue:

  WARNING: CPU: 8 PID: 0 at kernel/time/timer_migration.c:543 tmigr_requires_handle_remote
  CPU: 8 UID: 0 PID: 0 Comm: swapper/8
  RIP: 0010:tmigr_requires_handle_remote
  Call Trace:
   <IRQ>
   ? tmigr_requires_handle_remote
   ? hrtimer_run_queues
   update_process_times
   tick_periodic
   tick_handle_periodic
   __sysvec_apic_timer_interrupt
   sysvec_apic_timer_interrupt
  </IRQ>

Fix the problem by taking the old root into account in the children count
of the new root so the connection is not omitted.

Also warn when more than one top level group exists to better detect
similar issues in the future.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6f449d8fa1808a7f9ee644866bbc079285dbefdd
  - https://git.kernel.org/stable/c/868c9037df626b3c245ee26a290a03ae1f9f58d3
  - https://git.kernel.org/stable/c/c6dd70e5b465a2b77c7a7c3d868736d302e29aec

------------------------------------------------------------

CVE ID: CVE-2025-21814
Description: In the Linux kernel, the following vulnerability has been resolved:

ptp: Ensure info->enable callback is always set

The ioctl and sysfs handlers unconditionally call the ->enable callback.
Not all drivers implement that callback, leading to NULL dereferences.
Example of affected drivers: ptp_s390.c, ptp_vclock.c and ptp_mock.c.

Instead use a dummy callback if no better was specified by the driver.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.0, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/1334c64a5d1de6666e0c9f984db6745083df1eb4
  - https://git.kernel.org/stable/c/5d1041c76de656f9f8d5a192218039a9acf9bd00
  - https://git.kernel.org/stable/c/755caf4ee1c615ee5717862e427124370f46b1f3
  - https://git.kernel.org/stable/c/81846070cba17125a866e8023c01d3465b153339
  - https://git.kernel.org/stable/c/8441aea46445252df5d2eed6deb6d5246fc24002
  - https://git.kernel.org/stable/c/9df3a9284f39bfd51a9f72a6a165c79e2aa5066b
  - https://git.kernel.org/stable/c/fd53aa40e65f518453115b6f56183b0c201db26b
  - https://git.kernel.org/stable/c/fdc1e72487781dd7705bcbe30878bee7d5d1f3e8

------------------------------------------------------------

CVE ID: CVE-2025-21815
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/compaction: fix UBSAN shift-out-of-bounds warning

syzkaller reported a UBSAN shift-out-of-bounds warning of (1UL << order)
in isolate_freepages_block().  The bogus compound_order can be any value
because it is union with flags.  Add back the MAX_PAGE_ORDER check to fix
the warning.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/10b7d3eb535098ccd4c82a182a33655d8a0e5c88
  - https://git.kernel.org/stable/c/4491159774d973a9e2e998d25d8fbb20fada6dfa
  - https://git.kernel.org/stable/c/d1366e74342e75555af2648a2964deb2d5c92200

------------------------------------------------------------

CVE ID: CVE-2025-21816
Description: In the Linux kernel, the following vulnerability has been resolved:

hrtimers: Force migrate away hrtimers queued after CPUHP_AP_HRTIMERS_DYING

hrtimers are migrated away from the dying CPU to any online target at
the CPUHP_AP_HRTIMERS_DYING stage in order not to delay bandwidth timers
handling tasks involved in the CPU hotplug forward progress.

However wakeups can still be performed by the outgoing CPU after
CPUHP_AP_HRTIMERS_DYING. Those can result again in bandwidth timers being
armed. Depending on several considerations (crystal ball power management
based election, earliest timer already enqueued, timer migration enabled or
not), the target may eventually be the current CPU even if offline. If that
happens, the timer is eventually ignored.

The most notable example is RCU which had to deal with each and every of
those wake-ups by deferring them to an online CPU, along with related
workarounds:

_ e787644caf76 (rcu: Defer RCU kthreads wakeup when CPU is dying)
_ 9139f93209d1 (rcu/nocb: Fix RT throttling hrtimer armed from offline CPU)
_ f7345ccc62a4 (rcu/nocb: Fix rcuog wake-up from offline softirq)

The problem isn't confined to RCU though as the stop machine kthread
(which runs CPUHP_AP_HRTIMERS_DYING) reports its completion at the end
of its work through cpu_stop_signal_done() and performs a wake up that
eventually arms the deadline server timer:

   WARNING: CPU: 94 PID: 588 at kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0
   CPU: 94 UID: 0 PID: 588 Comm: migration/94 Not tainted
   Stopper: multi_cpu_stop+0x0/0x120 <- stop_machine_cpuslocked+0x66/0xc0
   RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0
   Call Trace:
   <TASK>
     start_dl_timer
     enqueue_dl_entity
     dl_server_start
     enqueue_task_fair
     enqueue_task
     ttwu_do_activate
     try_to_wake_up
     complete
     cpu_stopper_thread

Instead of providing yet another bandaid to work around the situation, fix
it in the hrtimers infrastructure instead: always migrate away a timer to
an online target whenever it is enqueued from an offline CPU.

This will also allow to revert all the above RCU disgraceful hacks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2aecec58e9040ce3d2694707889f9914a2374955
  - https://git.kernel.org/stable/c/53dac345395c0d2493cbc2f4c85fe38aef5b63f5
  - https://git.kernel.org/stable/c/e456a88bddae4030ba962447bb84be6669f2a0c1

------------------------------------------------------------

CVE ID: CVE-2025-21817
Description: In the Linux kernel, the following vulnerability has been resolved:

block: mark GFP_NOIO around sysfs ->store()

sysfs ->store is called with queue freezed, meantime we have several
->store() callbacks(update_nr_requests, wbt, scheduler) to allocate
memory with GFP_KERNEL which may run into direct reclaim code path,
then potential deadlock can be caused.

Fix the issue by marking NOIO around sysfs ->store()
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2566ce907e5d5db8a039647208e029ce559baa31
  - https://git.kernel.org/stable/c/7c0be4ead1f8f5f8be0803f347de0de81e3b8e1c

------------------------------------------------------------

CVE ID: CVE-2025-21819
Description: In the Linux kernel, the following vulnerability has been resolved:

Revert "drm/amd/display: Use HW lock mgr for PSR1"

This reverts commit
a2b5a9956269 ("drm/amd/display: Use HW lock mgr for PSR1")

Because it may cause system hang while connect with two edp panel.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/915697c2e69ac8d14dad498e6d6f43dbb7de3787
  - https://git.kernel.org/stable/c/95c75578c420110c43791295985abb961d6dc033
  - https://git.kernel.org/stable/c/a978864653e45d2671f99b09afcc1110e45d3dd9
  - https://git.kernel.org/stable/c/dcc3f2c06d80da39eee742b51ddf0781affb260c
  - https://git.kernel.org/stable/c/f245b400a223a71d6d5f4c72a2cb9b573a7fc2b6

------------------------------------------------------------

CVE ID: CVE-2025-21820
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: xilinx_uartps: split sysrq handling

lockdep detects the following circular locking dependency:

CPU 0                      CPU 1
========================== ============================
cdns_uart_isr()            printk()
  uart_port_lock(port)       console_lock()
			     cdns_uart_console_write()
                               if (!port->sysrq)
                                 uart_port_lock(port)
  uart_handle_break()
    port->sysrq = ...
  uart_handle_sysrq_char()
    printk()
      console_lock()

The fixed commit attempts to avoid this situation by only taking the
port lock in cdns_uart_console_write if port->sysrq unset. However, if
(as shown above) cdns_uart_console_write runs before port->sysrq is set,
then it will try to take the port lock anyway. This may result in a
deadlock.

Fix this by splitting sysrq handling into two parts. We use the prepare
helper under the port lock and defer handling until we release the lock.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.6, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/4410dba9807a17a93f649a9f5870ceaf30a675a3
  - https://git.kernel.org/stable/c/8ea0e7b3d7b8f2f0fc9db491ff22a0abe120801c
  - https://git.kernel.org/stable/c/9b88a7c4584ba67267a051069b8abe44fc9595b2
  - https://git.kernel.org/stable/c/b06f388994500297bb91be60ffaf6825ecfd2afe
  - https://git.kernel.org/stable/c/de5bd24197bd9ee37ec1e379a3d882bbd15c5065
  - https://git.kernel.org/stable/c/e22a97700901ba5e8bf8db68056a0d50f9440cae

------------------------------------------------------------

CVE ID: CVE-2025-21821
Description: In the Linux kernel, the following vulnerability has been resolved:

fbdev: omap: use threaded IRQ for LCD DMA

When using touchscreen and framebuffer, Nokia 770 crashes easily with:

    BUG: scheduling while atomic: irq/144-ads7846/82/0x00010000
    Modules linked in: usb_f_ecm g_ether usb_f_rndis u_ether libcomposite configfs omap_udc ohci_omap ohci_hcd
    CPU: 0 UID: 0 PID: 82 Comm: irq/144-ads7846 Not tainted 6.12.7-770 #2
    Hardware name: Nokia 770
    Call trace:
     unwind_backtrace from show_stack+0x10/0x14
     show_stack from dump_stack_lvl+0x54/0x5c
     dump_stack_lvl from __schedule_bug+0x50/0x70
     __schedule_bug from __schedule+0x4d4/0x5bc
     __schedule from schedule+0x34/0xa0
     schedule from schedule_preempt_disabled+0xc/0x10
     schedule_preempt_disabled from __mutex_lock.constprop.0+0x218/0x3b4
     __mutex_lock.constprop.0 from clk_prepare_lock+0x38/0xe4
     clk_prepare_lock from clk_set_rate+0x18/0x154
     clk_set_rate from sossi_read_data+0x4c/0x168
     sossi_read_data from hwa742_read_reg+0x5c/0x8c
     hwa742_read_reg from send_frame_handler+0xfc/0x300
     send_frame_handler from process_pending_requests+0x74/0xd0
     process_pending_requests from lcd_dma_irq_handler+0x50/0x74
     lcd_dma_irq_handler from __handle_irq_event_percpu+0x44/0x130
     __handle_irq_event_percpu from handle_irq_event+0x28/0x68
     handle_irq_event from handle_level_irq+0x9c/0x170
     handle_level_irq from generic_handle_domain_irq+0x2c/0x3c
     generic_handle_domain_irq from omap1_handle_irq+0x40/0x8c
     omap1_handle_irq from generic_handle_arch_irq+0x28/0x3c
     generic_handle_arch_irq from call_with_stack+0x1c/0x24
     call_with_stack from __irq_svc+0x94/0xa8
    Exception stack(0xc5255da0 to 0xc5255de8)
    5da0: 00000001 c22fc620 00000000 00000000 c08384a8 c106fc00 00000000 c240c248
    5dc0: c113a600 c3f6ec30 00000001 00000000 c22fc620 c5255df0 c22fc620 c0279a94
    5de0: 60000013 ffffffff
     __irq_svc from clk_prepare_lock+0x4c/0xe4
     clk_prepare_lock from clk_get_rate+0x10/0x74
     clk_get_rate from uwire_setup_transfer+0x40/0x180
     uwire_setup_transfer from spi_bitbang_transfer_one+0x2c/0x9c
     spi_bitbang_transfer_one from spi_transfer_one_message+0x2d0/0x664
     spi_transfer_one_message from __spi_pump_transfer_message+0x29c/0x498
     __spi_pump_transfer_message from __spi_sync+0x1f8/0x2e8
     __spi_sync from spi_sync+0x24/0x40
     spi_sync from ads7846_halfd_read_state+0x5c/0x1c0
     ads7846_halfd_read_state from ads7846_irq+0x58/0x348
     ads7846_irq from irq_thread_fn+0x1c/0x78
     irq_thread_fn from irq_thread+0x120/0x228
     irq_thread from kthread+0xc8/0xe8
     kthread from ret_from_fork+0x14/0x28

As a quick fix, switch to a threaded IRQ which provides a stable system.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7bbbd311dd503653a2cc86d9226740883051dc92
  - https://git.kernel.org/stable/c/8392ea100f0b86c234c739c6662f39f0ccc0cefd
  - https://git.kernel.org/stable/c/aa8e22cbedeb626f2a6bda0aea362353d627cd0a
  - https://git.kernel.org/stable/c/e4b6b665df815b4841e71b72f06446884e8aad40
  - https://git.kernel.org/stable/c/fb6a5edb60921887d7d10619fcdcbee9759552cb

------------------------------------------------------------

CVE ID: CVE-2025-21822
Description: In the Linux kernel, the following vulnerability has been resolved:

ptp: vmclock: Set driver data before its usage

If vmclock_ptp_register() fails during probing, vmclock_remove() is
called to clean up the ptp clock and misc device.
It uses dev_get_drvdata() to access the vmclock state.
However the driver data is not yet set at this point.

Assign the driver data earlier.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6dbd8b91a065d1d8001446a28e72cd140f9acef0
  - https://git.kernel.org/stable/c/f7d07cd4f77d77f366c8ffbb8ba8b61f614e5fce

------------------------------------------------------------

CVE ID: CVE-2025-21823
Description: In the Linux kernel, the following vulnerability has been resolved:

batman-adv: Drop unmanaged ELP metric worker

The ELP worker needs to calculate new metric values for all neighbors
"reachable" over an interface. Some of the used metric sources require
locks which might need to sleep. This sleep is incompatible with the RCU
list iterator used for the recorded neighbors. The initial approach to work
around of this problem was to queue another work item per neighbor and then
run this in a new context.

Even when this solved the RCU vs might_sleep() conflict, it has a major
problems: Nothing was stopping the work item in case it is not needed
anymore - for example because one of the related interfaces was removed or
the batman-adv module was unloaded - resulting in potential invalid memory
accesses.

Directly canceling the metric worker also has various problems:

* cancel_work_sync for a to-be-deactivated interface is called with
  rtnl_lock held. But the code in the ELP metric worker also tries to use
  rtnl_lock() - which will never return in this case. This also means that
  cancel_work_sync would never return because it is waiting for the worker
  to finish.
* iterating over the neighbor list for the to-be-deactivated interface is
  currently done using the RCU specific methods. Which means that it is
  possible to miss items when iterating over it without the associated
  spinlock - a behaviour which is acceptable for a periodic metric check
  but not for a cleanup routine (which must "stop" all still running
  workers)

The better approch is to get rid of the per interface neighbor metric
worker and handle everything in the interface worker. The original problems
are solved by:

* creating a list of neighbors which require new metric information inside
  the RCU protected context, gathering the metric according to the new list
  outside the RCU protected context
* only use rcu_trylock inside metric gathering code to avoid a deadlock
  when the cancel_delayed_work_sync is called in the interface removal code
  (which is called with the rtnl_lock held)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0fdc3c166ac17b26014313fa2b93696354511b24
  - https://git.kernel.org/stable/c/1c334629176c2d644befc31a20d4bf75542f7631
  - https://git.kernel.org/stable/c/3c0e0aecb78cb2a2ca1dc701982d08fedb088dc6
  - https://git.kernel.org/stable/c/781a06fd265a8151f7601122d9c2e985663828ff
  - https://git.kernel.org/stable/c/8c8ecc98f5c65947b0070a24bac11e12e47cc65d
  - https://git.kernel.org/stable/c/a0019971f340ae02ba54cf1861f72da7e03e6b66
  - https://git.kernel.org/stable/c/a7aa2317285806640c844acd4cd2cd768e395264
  - https://git.kernel.org/stable/c/af264c2a9adc37f4bdf88ca7f3affa15d8c7de9e

------------------------------------------------------------

CVE ID: CVE-2025-21824
Description: In the Linux kernel, the following vulnerability has been resolved:

gpu: host1x: Fix a use of uninitialized mutex

commit c8347f915e67 ("gpu: host1x: Fix boot regression for Tegra")
caused a use of uninitialized mutex leading to below warning when
CONFIG_DEBUG_MUTEXES and CONFIG_DEBUG_LOCK_ALLOC are enabled.

[   41.662843] ------------[ cut here ]------------
[   41.663012] DEBUG_LOCKS_WARN_ON(lock->magic != lock)
[   41.663035] WARNING: CPU: 4 PID: 794 at kernel/locking/mutex.c:587 __mutex_lock+0x670/0x878
[   41.663458] Modules linked in: rtw88_8822c(+) bluetooth(+) rtw88_pci rtw88_core mac80211 aquantia libarc4 crc_itu_t cfg80211 tegra194_cpufreq dwmac_tegra(+) arm_dsu_pmu stmmac_platform stmmac pcs_xpcs rfkill at24 host1x(+) tegra_bpmp_thermal ramoops reed_solomon fuse loop nfnetlink xfs mmc_block rpmb_core ucsi_ccg ina3221 crct10dif_ce xhci_tegra ghash_ce lm90 sha2_ce sha256_arm64 sha1_ce sdhci_tegra pwm_fan sdhci_pltfm sdhci gpio_keys rtc_tegra cqhci mmc_core phy_tegra_xusb i2c_tegra tegra186_gpc_dma i2c_tegra_bpmp spi_tegra114 dm_mirror dm_region_hash dm_log dm_mod
[   41.665078] CPU: 4 UID: 0 PID: 794 Comm: (udev-worker) Not tainted 6.11.0-29.31_1538613708.el10.aarch64+debug #1
[   41.665838] Hardware name: NVIDIA NVIDIA Jetson AGX Orin Developer Kit/Jetson, BIOS 36.3.0-gcid-35594366 02/26/2024
[   41.672555] pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   41.679636] pc : __mutex_lock+0x670/0x878
[   41.683834] lr : __mutex_lock+0x670/0x878
[   41.688035] sp : ffff800084b77090
[   41.691446] x29: ffff800084b77160 x28: ffffdd4bebf7b000 x27: ffffdd4be96b1000
[   41.698799] x26: 1fffe0002308361c x25: 1ffff0001096ee18 x24: 0000000000000000
[   41.706149] x23: 0000000000000000 x22: 0000000000000002 x21: ffffdd4be6e3c7a0
[   41.713500] x20: ffff800084b770f0 x19: ffff00011841b1e8 x18: 0000000000000000
[   41.720675] x17: 0000000000000000 x16: 0000000000000000 x15: 0720072007200720
[   41.728023] x14: 0000000000000000 x13: 0000000000000001 x12: ffff6001a96eaab3
[   41.735375] x11: 1fffe001a96eaab2 x10: ffff6001a96eaab2 x9 : ffffdd4be4838bbc
[   41.742723] x8 : 00009ffe5691554e x7 : ffff000d4b755593 x6 : 0000000000000001
[   41.749985] x5 : ffff000d4b755590 x4 : 1fffe0001d88f001 x3 : dfff800000000000
[   41.756988] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0000ec478000
[   41.764251] Call trace:
[   41.766695]  __mutex_lock+0x670/0x878
[   41.770373]  mutex_lock_nested+0x2c/0x40
[   41.774134]  host1x_intr_start+0x54/0xf8 [host1x]
[   41.778863]  host1x_runtime_resume+0x150/0x228 [host1x]
[   41.783935]  pm_generic_runtime_resume+0x84/0xc8
[   41.788485]  __rpm_callback+0xa0/0x478
[   41.792422]  rpm_callback+0x15c/0x1a8
[   41.795922]  rpm_resume+0x698/0xc08
[   41.799597]  __pm_runtime_resume+0xa8/0x140
[   41.803621]  host1x_probe+0x810/0xbc0 [host1x]
[   41.807909]  platform_probe+0xcc/0x1a8
[   41.811845]  really_probe+0x188/0x800
[   41.815347]  __driver_probe_device+0x164/0x360
[   41.819810]  driver_probe_device+0x64/0x1a8
[   41.823834]  __driver_attach+0x180/0x490
[   41.827773]  bus_for_each_dev+0x104/0x1a0
[   41.831797]  driver_attach+0x44/0x68
[   41.835296]  bus_add_driver+0x23c/0x4e8
[   41.839235]  driver_register+0x15c/0x3a8
[   41.843170]  __platform_register_drivers+0xa4/0x208
[   41.848159]  tegra_host1x_init+0x4c/0xff8 [host1x]
[   41.853147]  do_one_initcall+0xd4/0x380
[   41.856997]  do_init_module+0x1dc/0x698
[   41.860758]  load_module+0xc70/0x1300
[   41.864435]  __do_sys_init_module+0x1a8/0x1d0
[   41.868721]  __arm64_sys_init_module+0x74/0xb0
[   41.873183]  invoke_syscall.constprop.0+0xdc/0x1e8
[   41.877997]  do_el0_svc+0x154/0x1d0
[   41.881671]  el0_svc+0x54/0x140
[   41.884820]  el0t_64_sync_handler+0x120/0x130
[   41.889285]  el0t_64_sync+0x1a4/0x1a8
[   41.892960] irq event stamp: 69737
[   41.896370] hardirqs last  enabled at (69737): [<ffffdd4be6d7768c>] _raw_spin_unlock_irqrestore+0x44/0xe8
[   41.905739] hardirqs last disabled at (69736):
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/02458fbfaa0170aabf8506f7d4ed054f02414251
  - https://git.kernel.org/stable/c/127e91638ddcd02b80de92fec2240609a9f90426
  - https://git.kernel.org/stable/c/396d8e5136b4476672bc15b83ba312486bb4bf76

------------------------------------------------------------

CVE ID: CVE-2022-49733
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: pcm: oss: Fix race at SNDCTL_DSP_SYNC

There is a small race window at snd_pcm_oss_sync() that is called from
OSS PCM SNDCTL_DSP_SYNC ioctl; namely the function calls
snd_pcm_oss_make_ready() at first, then takes the params_lock mutex
for the rest.  When the stream is set up again by another thread
between them, it leads to inconsistency, and may result in unexpected
results such as NULL dereference of OSS buffer as a fuzzer spotted
recently.

The fix is simply to cover snd_pcm_oss_make_ready() call into the same
params_lock mutex with snd_pcm_oss_make_ready_locked() variant.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.215
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.148
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.68
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 5.19.9
  - Vendor: linux, Product: linux_kernel, Version: 6.0, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.0, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.0, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.0, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4051324a6dafd7053c74c475e80b3ba10ae672b0
  - https://git.kernel.org/stable/c/723ac5ab2891b6c10dd6cc78ef5456af593490eb
  - https://git.kernel.org/stable/c/8015ef9e8a0ee5cecfd0cb6805834d007ab26f86
  - https://git.kernel.org/stable/c/8423f0b6d513b259fdab9c9bf4aaa6188d054c2d
  - https://git.kernel.org/stable/c/fce793a056c604b41a298317cf704dae255f1b36

------------------------------------------------------------

CVE ID: CVE-2025-27590
Description: In oxidized-web (aka Oxidized Web) before 0.15.0, the RANCID migration page allows an unauthenticated user to gain control over the Linux user account that is running oxidized-web.
Severity:
  - CVSS Version: 3.1
  - Base Score: 9.0
  - Base Severity: CRITICAL
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H
CPEs:
  - Vendor: oxidized_web_project, Product: oxidized_web, Version: *, First Version (Including): None, Last Version (Excluding): 0.15.0
References:
  - https://github.com/ytti/oxidized-web/commit/a5220a0ddc57b85cd122bffee228d3ed4901668e
  - https://github.com/ytti/oxidized-web/releases/tag/0.15.0

------------------------------------------------------------

CVE ID: CVE-2024-43057
Description: Memory corruption while processing command in Glink linux.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: qualcomm, Product: qcn6224_firmware, Version: -, First Version (Including): None, Last Version (Excluding): None
  - Vendor: qualcomm, Product: qcn6224, Version: *, First Version (Including): None, Last Version (Excluding): None
References:
  - https://docs.qualcomm.com/product/publicresources/securitybulletin/march-2025-bulletin.html

------------------------------------------------------------

CVE ID: CVE-2024-51954
Description: There is an improper access control issue in ArcGIS Server versions 11.3 and below on Windows and Linux, which under unique circumstances, could potentially allow a remote, low privileged authenticated attacker to access secure services published a standalone (Unfederated)

ArcGIS Server instance.  If successful this compromise would have a high impact on Confidentiality, low impact on integrity and no impact to availability of the software.
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.5
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N
CPEs:
  - Vendor: esri, Product: arcgis_server, Version: *, First Version (Including): 10.9.1, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: -, First Version (Including): None, Last Version (Excluding): None
  - Vendor: microsoft, Product: windows, Version: -, First Version (Including): None, Last Version (Excluding): None
References:
  - https://www.esri.com/arcgis-blog/products/trust-arcgis/administration/arcgis-server-security-2025-update-1-patch/

------------------------------------------------------------

CVE ID: CVE-2025-1425
Description: A Sudo privilege misconfiguration vulnerability in PocketBook InkPad Color 3 on Linux, ARM allows attackers to read file contents on the device.This issue affects InkPad Color 3: U743k3.6.8.3671.
Severity:
  - CVSS Version: 4.0
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:4.0/AV:P/AC:L/AT:N/PR:N/UI:N/VC:L/VI:N/VA:N/SC:H/SI:H/SA:H/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - No CPE data available.
References:
  - https://www.redguard.ch/blog/2025/03/04/security-advisory-pocketbook-inkpad-color-3/

------------------------------------------------------------

CVE ID: CVE-2024-12799
Description: Insufficiently Protected Credentials
vulnerability in OpenText Identity Manager Advanced Edition on Windows, Linux,
64 bit allows Privilege Abuse. This vulnerability could allow an
authenticated user to obtain higher privileged user’s sensitive information via
crafted payload.

This issue affects Identity Manager Advanced
Edition: from 4.8.0.0 through 4.8.7.0102, 4.9.0.0.
Severity:
  - CVSS Version: 4.0
  - Base Score: 10.0
  - Base Severity: CRITICAL
  - CVSS Vector: CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:H/VA:H/SC:H/SI:H/SA:H/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:P/AU:Y/R:U/V:C/RE:H/U:Red
CPEs:
  - No CPE data available.
References:
  - https://portal.microfocus.com/s/article/KM000037455

------------------------------------------------------------

CVE ID: CVE-2024-58051
Description: In the Linux kernel, the following vulnerability has been resolved:

ipmi: ipmb: Add check devm_kasprintf() returned value

devm_kasprintf() can return a NULL pointer on failure but this
returned value is not checked.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1a8a17c5ce9cb5a82797602bff9819ac732d2ff5
  - https://git.kernel.org/stable/c/2378bd0b264ad3a1f76bd957caf33ee0c7945351
  - https://git.kernel.org/stable/c/312a6445036d692bc5665307eeafa4508c33c4b5
  - https://git.kernel.org/stable/c/4c9caf86d04dcb10e9fd8cd9db8eb79b5bfcc4d8
  - https://git.kernel.org/stable/c/a63284d415d4d114abd8be6e66a9558f3ca0702d
  - https://git.kernel.org/stable/c/caac520350546e736894d14e051b64a9edb3600c
  - https://git.kernel.org/stable/c/e529fbcf1f35f5fc3c839df7f06c3e3d02579715
  - https://git.kernel.org/stable/c/eb288ab33fd87579789cb331209ff09e988ff4f7

------------------------------------------------------------

CVE ID: CVE-2024-58052
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix potential NULL pointer dereference in atomctrl_get_smc_sclk_range_table

The function atomctrl_get_smc_sclk_range_table() does not check the return
value of smu_atom_get_data_table(). If smu_atom_get_data_table() fails to
retrieve SMU_Info table, it returns NULL which is later dereferenced.

Found by Linux Verification Center (linuxtesting.org) with SVACE.

In practice this should never happen as this code only gets called
on polaris chips and the vbios data table will always be present on
those chips.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.7, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0b97cd8a61b2b40fd73cf92a4bb2256462d22adb
  - https://git.kernel.org/stable/c/2396bc91935c6da0588ce07850d07897974bd350
  - https://git.kernel.org/stable/c/357445e28ff004d7f10967aa93ddb4bffa5c3688
  - https://git.kernel.org/stable/c/396350adf0e5ad4bf05f01e4d79bfb82f0f6c41a
  - https://git.kernel.org/stable/c/6a30634a2e0f1dd3c6b39fd0f114c32893a9907a
  - https://git.kernel.org/stable/c/a713ba7167c2d74c477dd7764dbbdbe3199f17f4
  - https://git.kernel.org/stable/c/ae522ad211ec4b72eaf742b25f24b0a406afcba1
  - https://git.kernel.org/stable/c/c47066ed7c8f3b320ef87fa6217a2b8b24e127cc

------------------------------------------------------------

CVE ID: CVE-2024-58053
Description: In the Linux kernel, the following vulnerability has been resolved:

rxrpc: Fix handling of received connection abort

Fix the handling of a connection abort that we've received.  Though the
abort is at the connection level, it needs propagating to the calls on that
connection.  Whilst the propagation bit is performed, the calls aren't then
woken up to go and process their termination, and as no further input is
forthcoming, they just hang.

Also add some tracing for the logging of connection aborts.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e56ebde245e4799ce74d38419426f2a80d39950
  - https://git.kernel.org/stable/c/5842ce7b120c65624052a8da04460d35b26caac0
  - https://git.kernel.org/stable/c/96d1d927c4d03ee9dcee7640bca70b74e63504fc
  - https://git.kernel.org/stable/c/9c6702260557c0183d8417c79a37777a3d3e58e8

------------------------------------------------------------

CVE ID: CVE-2024-58054
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: media: max96712: fix kernel oops when removing module

The following kernel oops is thrown when trying to remove the max96712
module:

Unable to handle kernel paging request at virtual address 00007375746174db
Mem abort info:
  ESR = 0x0000000096000004
  EC = 0x25: DABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
  FSC = 0x04: level 0 translation fault
Data abort info:
  ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000
  CM = 0, WnR = 0, TnD = 0, TagAccess = 0
  GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
user pgtable: 4k pages, 48-bit VAs, pgdp=000000010af89000
[00007375746174db] pgd=0000000000000000, p4d=0000000000000000
Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
Modules linked in: crct10dif_ce polyval_ce mxc_jpeg_encdec flexcan
    snd_soc_fsl_sai snd_soc_fsl_asoc_card snd_soc_fsl_micfil dwc_mipi_csi2
    imx_csi_formatter polyval_generic v4l2_jpeg imx_pcm_dma can_dev
    snd_soc_imx_audmux snd_soc_wm8962 snd_soc_imx_card snd_soc_fsl_utils
    max96712(C-) rpmsg_ctrl rpmsg_char pwm_fan fuse
    [last unloaded: imx8_isi]
CPU: 0 UID: 0 PID: 754 Comm: rmmod
	    Tainted: G         C    6.12.0-rc6-06364-g327fec852c31 #17
Tainted: [C]=CRAP
Hardware name: NXP i.MX95 19X19 board (DT)
pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : led_put+0x1c/0x40
lr : v4l2_subdev_put_privacy_led+0x48/0x58
sp : ffff80008699bbb0
x29: ffff80008699bbb0 x28: ffff00008ac233c0 x27: 0000000000000000
x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
x23: ffff000080cf1170 x22: ffff00008b53bd00 x21: ffff8000822ad1c8
x20: ffff000080ff5c00 x19: ffff00008b53be40 x18: 0000000000000000
x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
x14: 0000000000000004 x13: ffff0000800f8010 x12: 0000000000000000
x11: ffff000082acf5c0 x10: ffff000082acf478 x9 : ffff0000800f8010
x8 : 0101010101010101 x7 : 7f7f7f7f7f7f7f7f x6 : fefefeff6364626d
x5 : 8080808000000000 x4 : 0000000000000020 x3 : 00000000553a3dc1
x2 : ffff00008ac233c0 x1 : ffff00008ac233c0 x0 : ff00737574617473
Call trace:
 led_put+0x1c/0x40
 v4l2_subdev_put_privacy_led+0x48/0x58
 v4l2_async_unregister_subdev+0x2c/0x1a4
 max96712_remove+0x1c/0x38 [max96712]
 i2c_device_remove+0x2c/0x9c
 device_remove+0x4c/0x80
 device_release_driver_internal+0x1cc/0x228
 driver_detach+0x4c/0x98
 bus_remove_driver+0x6c/0xbc
 driver_unregister+0x30/0x60
 i2c_del_driver+0x54/0x64
 max96712_i2c_driver_exit+0x18/0x1d0 [max96712]
 __arm64_sys_delete_module+0x1a4/0x290
 invoke_syscall+0x48/0x10c
 el0_svc_common.constprop.0+0xc0/0xe0
 do_el0_svc+0x1c/0x28
 el0_svc+0x34/0xd8
 el0t_64_sync_handler+0x120/0x12c
 el0t_64_sync+0x190/0x194
Code: f9000bf3 aa0003f3 f9402800 f9402000 (f9403400)
---[ end trace 0000000000000000 ]---

This happens because in v4l2_i2c_subdev_init(), the i2c_set_cliendata()
is called again and the data is overwritten to point to sd, instead of
priv. So, in remove(), the wrong pointer is passed to
v4l2_async_unregister_subdev(), leading to a crash.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1556b9149b81cc549c13f5e56e81e89404d8a666
  - https://git.kernel.org/stable/c/278a98f6d8a7bbe1110433b057333536e4490edf
  - https://git.kernel.org/stable/c/3311c5395e7322298b659b8addc704b39fb3a59c
  - https://git.kernel.org/stable/c/dfde3d63afbaae664c4d36e53cfb4045d5374561
  - https://git.kernel.org/stable/c/ee1b5046d5cd892a0754ab982aeaaad3702083a5

------------------------------------------------------------

CVE ID: CVE-2024-58055
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: f_tcm: Don't free command immediately

Don't prematurely free the command. Wait for the status completion of
the sense status. It can be freed then. Otherwise we will double-free
the command.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.6, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/16907219ad6763f401700e1b57b2da4f3e07f047
  - https://git.kernel.org/stable/c/38229c35a6d7875697dfb293356407330cfcd23e
  - https://git.kernel.org/stable/c/7cb72dc08ed8da60fd6d1f6adf13bf0e6ee0f694
  - https://git.kernel.org/stable/c/929b69810eec132b284ffd19047a85d961df9e4d
  - https://git.kernel.org/stable/c/bbb7f49839b57d66ccaf7b5752d9b63d3031dd0a
  - https://git.kernel.org/stable/c/c225d006a31949d673e646d585d9569bc28feeb9
  - https://git.kernel.org/stable/c/e6693595bd1b55af62d057a4136a89d5c2ddf0e9
  - https://git.kernel.org/stable/c/f0c33e7d387ccbb6870e73a43c558fefede06614

------------------------------------------------------------

CVE ID: CVE-2024-58056
Description: In the Linux kernel, the following vulnerability has been resolved:

remoteproc: core: Fix ida_free call while not allocated

In the rproc_alloc() function, on error, put_device(&rproc->dev) is
called, leading to the call of the rproc_type_release() function.
An error can occurs before ida_alloc is called.

In such case in rproc_type_release(), the condition (rproc->index >= 0) is
true as rproc->index has been  initialized to 0.
ida_free() is called reporting a warning:
[    4.181906] WARNING: CPU: 1 PID: 24 at lib/idr.c:525 ida_free+0x100/0x164
[    4.186378] stm32-display-dsi 5a000000.dsi: Fixed dependency cycle(s) with /soc/dsi@5a000000/panel@0
[    4.188854] ida_free called for id=0 which is not allocated.
[    4.198256] mipi-dsi 5a000000.dsi.0: Fixed dependency cycle(s) with /soc/dsi@5a000000
[    4.203556] Modules linked in: panel_orisetech_otm8009a dw_mipi_dsi_stm(+) gpu_sched dw_mipi_dsi stm32_rproc stm32_crc32 stm32_ipcc(+) optee(+)
[    4.224307] CPU: 1 UID: 0 PID: 24 Comm: kworker/u10:0 Not tainted 6.12.0 #442
[    4.231481] Hardware name: STM32 (Device Tree Support)
[    4.236627] Workqueue: events_unbound deferred_probe_work_func
[    4.242504] Call trace:
[    4.242522]  unwind_backtrace from show_stack+0x10/0x14
[    4.250218]  show_stack from dump_stack_lvl+0x50/0x64
[    4.255274]  dump_stack_lvl from __warn+0x80/0x12c
[    4.260134]  __warn from warn_slowpath_fmt+0x114/0x188
[    4.265199]  warn_slowpath_fmt from ida_free+0x100/0x164
[    4.270565]  ida_free from rproc_type_release+0x38/0x60
[    4.275832]  rproc_type_release from device_release+0x30/0xa0
[    4.281601]  device_release from kobject_put+0xc4/0x294
[    4.286762]  kobject_put from rproc_alloc.part.0+0x208/0x28c
[    4.292430]  rproc_alloc.part.0 from devm_rproc_alloc+0x80/0xc4
[    4.298393]  devm_rproc_alloc from stm32_rproc_probe+0xd0/0x844 [stm32_rproc]
[    4.305575]  stm32_rproc_probe [stm32_rproc] from platform_probe+0x5c/0xbc

Calling ida_alloc earlier in rproc_alloc ensures that the rproc->index is
properly set.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2cf54928e7e32362215c69b68a6a53d110323bf3
  - https://git.kernel.org/stable/c/7378aeb664e5ebc396950b36a1f2dedf5aabec20
  - https://git.kernel.org/stable/c/b32d60a852bb3952886625d0c3b1c9a88c3ceb7c
  - https://git.kernel.org/stable/c/e9efd9fa4679803fe23188d7b47119cf7bc2de6f
  - https://git.kernel.org/stable/c/f2013d19b7704cd723ab42664b8d9408ea8cc77c

------------------------------------------------------------

CVE ID: CVE-2024-58057
Description: In the Linux kernel, the following vulnerability has been resolved:

idpf: convert workqueues to unbound

When a workqueue is created with `WQ_UNBOUND`, its work items are
served by special worker-pools, whose host workers are not bound to
any specific CPU. In the default configuration (i.e. when
`queue_delayed_work` and friends do not specify which CPU to run the
work item on), `WQ_UNBOUND` allows the work item to be executed on any
CPU in the same node of the CPU it was enqueued on. While this
solution potentially sacrifices locality, it avoids contention with
other processes that might dominate the CPU time of the processor the
work item was scheduled on.

This is not just a theoretical problem: in a particular scenario
misconfigured process was hogging most of the time from CPU0, leaving
less than 0.5% of its CPU time to the kworker. The IDPF workqueues
that were using the kworker on CPU0 suffered large completion delays
as a result, causing performance degradation, timeouts and eventual
system crash.


* I have also run a manual test to gauge the performance
  improvement. The test consists of an antagonist process
  (`./stress --cpu 2`) consuming as much of CPU 0 as possible. This
  process is run under `taskset 01` to bind it to CPU0, and its
  priority is changed with `chrt -pQ 9900 10000 ${pid}` and
  `renice -n -20 ${pid}` after start.

  Then, the IDPF driver is forced to prefer CPU0 by editing all calls
  to `queue_delayed_work`, `mod_delayed_work`, etc... to use CPU 0.

  Finally, `ktraces` for the workqueue events are collected.

  Without the current patch, the antagonist process can force
  arbitrary delays between `workqueue_queue_work` and
  `workqueue_execute_start`, that in my tests were as high as
  `30ms`. With the current patch applied, the workqueue can be
  migrated to another unloaded CPU in the same node, and, keeping
  everything else equal, the maximum delay I could see was `6us`.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/66bf9b3d9e1658333741f075320dc8e7cd6f8d09
  - https://git.kernel.org/stable/c/868202ec3854e13de1164e4a3e25521194c5af72
  - https://git.kernel.org/stable/c/9a5b021cb8186f1854bac2812bd4f396bb1e881c

------------------------------------------------------------

CVE ID: CVE-2024-58058
Description: In the Linux kernel, the following vulnerability has been resolved:

ubifs: skip dumping tnc tree when zroot is null

Clearing slab cache will free all znode in memory and make
c->zroot.znode = NULL, then dumping tnc tree will access
c->zroot.znode which cause null pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.27, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/1787cd67bb94b106555ffe64f887f6aa24b47010
  - https://git.kernel.org/stable/c/2a987950df825d0144370e700dc5fb337684ffba
  - https://git.kernel.org/stable/c/40e25a3c0063935763717877bb2a814c081509ff
  - https://git.kernel.org/stable/c/428aff8f7cfb0d9a8854477648022cef96bcab28
  - https://git.kernel.org/stable/c/6211c11fc20424bbc6d79c835c7c212b553ae898
  - https://git.kernel.org/stable/c/77e5266e3d3faa6bdcf20d9c68a8972f6aa06522
  - https://git.kernel.org/stable/c/bdb0ca39e0acccf6771db49c3f94ed787d05f2d7
  - https://git.kernel.org/stable/c/e01b55f261ccc96e347eba4931e4429d080d879d

------------------------------------------------------------

CVE ID: CVE-2024-58059
Description: In the Linux kernel, the following vulnerability has been resolved:

media: uvcvideo: Fix deadlock during uvc_probe

If uvc_probe() fails, it can end up calling uvc_status_unregister() before
uvc_status_init() is called.

Fix this by checking if dev->status is NULL or not in
uvc_status_unregister().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/a67f75c2b5ecf534eab416ce16c11fe780c4f8f6
  - https://git.kernel.org/stable/c/db577ededf3a18b39567fc1a6209f12a0c4a3c52

------------------------------------------------------------

CVE ID: CVE-2024-58060
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Reject struct_ops registration that uses module ptr and the module btf_id is missing

There is a UAF report in the bpf_struct_ops when CONFIG_MODULES=n.
In particular, the report is on tcp_congestion_ops that has
a "struct module *owner" member.

For struct_ops that has a "struct module *owner" member,
it can be extended either by the regular kernel module or
by the bpf_struct_ops. bpf_try_module_get() will be used
to do the refcounting and different refcount is done
based on the owner pointer. When CONFIG_MODULES=n,
the btf_id of the "struct module" is missing:

WARN: resolve_btfids: unresolved symbol module

Thus, the bpf_try_module_get() cannot do the correct refcounting.

Not all subsystem's struct_ops requires the "struct module *owner" member.
e.g. the recent sched_ext_ops.

This patch is to disable bpf_struct_ops registration if
the struct_ops has the "struct module *" member and the
"struct module" btf_id is missing. The btf_type_is_fwd() helper
is moved to the btf.h header file for this test.

This has happened since the beginning of bpf_struct_ops which has gone
through many changes. The Fixes tag is set to a recent commit that this
patch can apply cleanly. Considering CONFIG_MODULES=n is not
common and the age of the issue, targeting for bpf-next also.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2324fb4e92092837ee278fdd8d60c48ee1a619ce
  - https://git.kernel.org/stable/c/96ea081ed52bf077cad6d00153b6fba68e510767
  - https://git.kernel.org/stable/c/b777b14c2a4a4e2322daf8e8ffd42d2b88831b17

------------------------------------------------------------

CVE ID: CVE-2024-58061
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: prohibit deactivating all links

In the internal API this calls this is a WARN_ON, but that
should remain since internally we want to know about bugs
that may cause this. Prevent deactivating all links in the
debugfs write directly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/18100796c11dfdea9101fdc95d2428b2093477ee
  - https://git.kernel.org/stable/c/270ad6776e7cf1be3b769e0447070f9d0e8269db
  - https://git.kernel.org/stable/c/7553477cbfd784b128297f9ed43751688415bbaa
  - https://git.kernel.org/stable/c/d36e48a4d81c647df8a76cc58fd4d2442ba10744
  - https://git.kernel.org/stable/c/dfe9a043300261afe5eadc07b867a6810c4e999a

------------------------------------------------------------

CVE ID: CVE-2024-58062
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: avoid NULL pointer dereference

When iterating over the links of a vif, we need to make sure that the
pointer is valid (in other words - that the link exists) before
dereferncing it.
Use for_each_vif_active_link that also does the check.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/7f6fb4b7611eb6371c493c42fefad84a1742bcbb
  - https://git.kernel.org/stable/c/cf704a7624f99eb2ffca1a16c69183e85544a613
  - https://git.kernel.org/stable/c/fbb563ad5032a07ac83c746ce5c8de5f25b5ffd0

------------------------------------------------------------

CVE ID: CVE-2024-58063
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: rtlwifi: fix memory leaks and invalid access at probe error path

Deinitialize at reverse order when probe fails.

When init_sw_vars fails, rtl_deinit_core should not be called, specially
now that it destroys the rtl_wq workqueue.

And call rtl_pci_deinit and deinit_sw_vars, otherwise, memory will be
leaked.

Remove pci_set_drvdata call as it will already be cleaned up by the core
driver code and could lead to memory leaks too. cf. commit 8d450935ae7f
("wireless: rtlwifi: remove unnecessary pci_set_drvdata()") and
commit 3d86b93064c7 ("rtlwifi: Fix PCI probe error path orphaned memory").
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.38, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/32acebca0a51f5e372536bfdc0d7d332ab749013
  - https://git.kernel.org/stable/c/455e0f40b5352186a9095f2135d5c89255e7c39a
  - https://git.kernel.org/stable/c/624cea89a0865a2bc3e00182a6b0f954a94328b4
  - https://git.kernel.org/stable/c/6b76bab5c257463302c9e97f5d84d524457468eb
  - https://git.kernel.org/stable/c/85b67b4c4a0f8a6fb20cf4ef7684ff2b0cf559df
  - https://git.kernel.org/stable/c/b96371339fd9cac90f5ee4ac17ee5c4cbbdfa6f7
  - https://git.kernel.org/stable/c/e7ceefbfd8d447abc8aca8ab993a942803522c06
  - https://git.kernel.org/stable/c/ee0b0d7baa8a6d42c7988f6e50c8f164cdf3fa47

------------------------------------------------------------

CVE ID: CVE-2024-58064
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: tests: Fix potential NULL dereference in test_cfg80211_parse_colocated_ap()

kunit_kzalloc() may return NULL, dereferencing it without NULL check may
lead to NULL dereference.
Add a NULL check for ies.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0d17d81143f5aa56ee87e60bb1000a2372a0ada8
  - https://git.kernel.org/stable/c/13c4f7714c6a1ecf748a2f22099447c14fe6ed8c
  - https://git.kernel.org/stable/c/886271409603956edd09df229dde7442c410a872

------------------------------------------------------------

CVE ID: CVE-2024-58065
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: mmp: pxa1908-apbc: Fix NULL vs IS_ERR() check

The devm_kzalloc() function returns NULL on error, not error pointers.
Fix the check.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/6628f7f88de5f65f01adef5a63c707cb49d0fddb
  - https://git.kernel.org/stable/c/e5ca5d7b4d7c29246d957dc45d63610584ae3a54

------------------------------------------------------------

CVE ID: CVE-2024-58066
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: mmp: pxa1908-apbcp: Fix a NULL vs IS_ERR() check

The devm_kzalloc() function doesn't return error pointers, it returns
NULL on error.  Update the check to match.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/2b3a36fb572caf9fb72f158be328395b1c938bf7
  - https://git.kernel.org/stable/c/3acea81be689b77b3ceac6ff345ff0366734d967

------------------------------------------------------------

CVE ID: CVE-2024-58067
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: mmp: pxa1908-mpmu: Fix a NULL vs IS_ERR() check

The devm_kzalloc() function returns NULL on error, not error pointers.
Update the check to match.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0869a7b2afdfcdd2beb0a5fb683119bcf39c0e9d
  - https://git.kernel.org/stable/c/7def56f841af22e07977e193eea002e085facbdb

------------------------------------------------------------

CVE ID: CVE-2024-58068
Description: In the Linux kernel, the following vulnerability has been resolved:

OPP: fix dev_pm_opp_find_bw_*() when bandwidth table not initialized

If a driver calls dev_pm_opp_find_bw_ceil/floor() the retrieve bandwidth
from the OPP table but the bandwidth table was not created because the
interconnect properties were missing in the OPP consumer node, the
kernel will crash with:

Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
...
pc : _read_bw+0x8/0x10
lr : _opp_table_find_key+0x9c/0x174
...
Call trace:
  _read_bw+0x8/0x10 (P)
  _opp_table_find_key+0x9c/0x174 (L)
  _find_key+0x98/0x168
  dev_pm_opp_find_bw_ceil+0x50/0x88
...

In order to fix the crash, create an assert function to check
if the bandwidth table was created before trying to get a
bandwidth with _read_bw().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/5165486681dbd67b61b975c63125f2a5cb7f96d1
  - https://git.kernel.org/stable/c/84ff05c9bd577157baed711a4f0b41206593978b
  - https://git.kernel.org/stable/c/8532fd078d2a5286915d03bb0a0893ee1955acef
  - https://git.kernel.org/stable/c/b44b9bc7cab2967c3d6a791b1cd542c89fc07f0e
  - https://git.kernel.org/stable/c/ff2def251849133be6076a7c2d427d8eb963c223

------------------------------------------------------------

CVE ID: CVE-2024-58069
Description: In the Linux kernel, the following vulnerability has been resolved:

rtc: pcf85063: fix potential OOB write in PCF85063 NVMEM read

The nvmem interface supports variable buffer sizes, while the regmap
interface operates with fixed-size storage. If an nvmem client uses a
buffer size less than 4 bytes, regmap_read will write out of bounds
as it expects the buffer to point at an unsigned int.

Fix this by using an intermediary unsigned int to hold the value.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/21cd59fcb9952eb7505da2bdfc1eb9c619df3ff4
  - https://git.kernel.org/stable/c/3ab8c5ed4f84fa20cd16794fe8dc31f633fbc70c
  - https://git.kernel.org/stable/c/517aedb365f2c94e2d7e0b908ac7127df76203a1
  - https://git.kernel.org/stable/c/6f2a8ca9a0a38589f52a7f0fb9425b9ba987ae7c
  - https://git.kernel.org/stable/c/9adefa7b9559d0f21034a5d5ec1b55840c9348b9
  - https://git.kernel.org/stable/c/c72b7a474d3f445bf0c5bcf8ffed332c78eb28a1
  - https://git.kernel.org/stable/c/e5536677da803ed54a29a446515c28dce7d3d574
  - https://git.kernel.org/stable/c/e5e06455760f2995b16a176033909347929d1128

------------------------------------------------------------

CVE ID: CVE-2024-58070
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: bpf_local_storage: Always use bpf_mem_alloc in PREEMPT_RT

In PREEMPT_RT, kmalloc(GFP_ATOMIC) is still not safe in non preemptible
context. bpf_mem_alloc must be used in PREEMPT_RT. This patch is
to enforce bpf_mem_alloc in the bpf_local_storage when CONFIG_PREEMPT_RT
is enabled.

[   35.118559] BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48
[   35.118566] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1832, name: test_progs
[   35.118569] preempt_count: 1, expected: 0
[   35.118571] RCU nest depth: 1, expected: 1
[   35.118577] INFO: lockdep is turned off.
    ...
[   35.118647]  __might_resched+0x433/0x5b0
[   35.118677]  rt_spin_lock+0xc3/0x290
[   35.118700]  ___slab_alloc+0x72/0xc40
[   35.118723]  __kmalloc_noprof+0x13f/0x4e0
[   35.118732]  bpf_map_kzalloc+0xe5/0x220
[   35.118740]  bpf_selem_alloc+0x1d2/0x7b0
[   35.118755]  bpf_local_storage_update+0x2fa/0x8b0
[   35.118784]  bpf_sk_storage_get_tracing+0x15a/0x1d0
[   35.118791]  bpf_prog_9a118d86fca78ebb_trace_inet_sock_set_state+0x44/0x66
[   35.118795]  bpf_trace_run3+0x222/0x400
[   35.118820]  __bpf_trace_inet_sock_set_state+0x11/0x20
[   35.118824]  trace_inet_sock_set_state+0x112/0x130
[   35.118830]  inet_sk_state_store+0x41/0x90
[   35.118836]  tcp_set_state+0x3b3/0x640

There is no need to adjust the gfp_flags passing to the
bpf_mem_cache_alloc_flags() which only honors the GFP_KERNEL.
The verifier has ensured GFP_KERNEL is passed only in sleepable context.

It has been an old issue since the first introduction of the
bpf_local_storage ~5 years ago, so this patch targets the bpf-next.

bpf_mem_alloc is needed to solve it, so the Fixes tag is set
to the commit when bpf_mem_alloc was first used in the bpf_local_storage.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/3392fa605d7c5708c5fbe02e4fbdac547c3b7352
  - https://git.kernel.org/stable/c/8eef6ac4d70eb1f0099fff93321d90ce8fa49ee1
  - https://git.kernel.org/stable/c/b0027500000dfcb8ee952557d565064cea22c43e
  - https://git.kernel.org/stable/c/c1d398a3af7e59d7fef351c84fed7ebb575d1f1a

------------------------------------------------------------

CVE ID: CVE-2024-58071
Description: In the Linux kernel, the following vulnerability has been resolved:

team: prevent adding a device which is already a team device lower

Prevent adding a device which is already a team device lower,
e.g. adding veth0 if vlan1 was already added and veth0 is a lower of
vlan1.

This is not useful in practice and can lead to recursive locking:

$ ip link add veth0 type veth peer name veth1
$ ip link set veth0 up
$ ip link set veth1 up
$ ip link add link veth0 name veth0.1 type vlan protocol 802.1Q id 1
$ ip link add team0 type team
$ ip link set veth0.1 down
$ ip link set veth0.1 master team0
team0: Port device veth0.1 added
$ ip link set veth0 down
$ ip link set veth0 master team0

============================================
WARNING: possible recursive locking detected
6.13.0-rc2-virtme-00441-ga14a429069bb #46 Not tainted
--------------------------------------------
ip/7684 is trying to acquire lock:
ffff888016848e00 (team->team_lock_key){+.+.}-{4:4}, at: team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)

but task is already holding lock:
ffff888016848e00 (team->team_lock_key){+.+.}-{4:4}, at: team_add_slave (drivers/net/team/team_core.c:1147 drivers/net/team/team_core.c:1977)

other info that might help us debug this:
Possible unsafe locking scenario:

CPU0
----
lock(team->team_lock_key);
lock(team->team_lock_key);

*** DEADLOCK ***

May be due to missing lock nesting notation

2 locks held by ip/7684:

stack backtrace:
CPU: 3 UID: 0 PID: 7684 Comm: ip Not tainted 6.13.0-rc2-virtme-00441-ga14a429069bb #46
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
Call Trace:
<TASK>
dump_stack_lvl (lib/dump_stack.c:122)
print_deadlock_bug.cold (kernel/locking/lockdep.c:3040)
__lock_acquire (kernel/locking/lockdep.c:3893 kernel/locking/lockdep.c:5226)
? netlink_broadcast_filtered (net/netlink/af_netlink.c:1548)
lock_acquire.part.0 (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5851)
? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
? trace_lock_acquire (./include/trace/events/lock.h:24 (discriminator 2))
? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
? lock_acquire (kernel/locking/lockdep.c:5822)
? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
__mutex_lock (kernel/locking/mutex.c:587 kernel/locking/mutex.c:735)
? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
? fib_sync_up (net/ipv4/fib_semantics.c:2167)
? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)
notifier_call_chain (kernel/notifier.c:85)
call_netdevice_notifiers_info (net/core/dev.c:1996)
__dev_notify_flags (net/core/dev.c:8993)
? __dev_change_flags (net/core/dev.c:8975)
dev_change_flags (net/core/dev.c:9027)
vlan_device_event (net/8021q/vlan.c:85 net/8021q/vlan.c:470)
? br_device_event (net/bridge/br.c:143)
notifier_call_chain (kernel/notifier.c:85)
call_netdevice_notifiers_info (net/core/dev.c:1996)
dev_open (net/core/dev.c:1519 net/core/dev.c:1505)
team_add_slave (drivers/net/team/team_core.c:1219 drivers/net/team/team_core.c:1977)
? __pfx_team_add_slave (drivers/net/team/team_core.c:1972)
do_set_master (net/core/rtnetlink.c:2917)
do_setlink.isra.0 (net/core/rtnetlink.c:3117)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.3, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.76
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/0a7794b9ca78c8e7d001c583bf05736169de3f20
  - https://git.kernel.org/stable/c/184a564e6000b41582f160a5be9a9b5aabe22ac1
  - https://git.kernel.org/stable/c/1bb06f919fa5bec77ad9b6002525c3dcc5c1fd6c
  - https://git.kernel.org/stable/c/3fff5da4ca2164bb4d0f1e6cd33f6eb8a0e73e50
  - https://git.kernel.org/stable/c/62ff1615815d565448c37cb8a7a2a076492ec471
  - https://git.kernel.org/stable/c/adff6ac889e16d97abd1e4543f533221127e978a
  - https://git.kernel.org/stable/c/bd099a2fa9be983ba0e90a57a59484fe9d520ba8
  - https://git.kernel.org/stable/c/d9bce1310c0e2a55888e3e08c9f69d8377b3a377

------------------------------------------------------------

CVE ID: CVE-2024-58072
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: rtlwifi: remove unused check_buddy_priv

Commit 2461c7d60f9f ("rtlwifi: Update header file") introduced a global
list of private data structures.

Later on, commit 26634c4b1868 ("rtlwifi Modify existing bits to match
vendor version 2013.02.07") started adding the private data to that list at
probe time and added a hook, check_buddy_priv to find the private data from
a similar device.

However, that function was never used.

Besides, though there is a lock for that list, it is never used. And when
the probe fails, the private data is never removed from the list. This
would cause a second probe to access freed memory.

Remove the unused hook, structures and members, which will prevent the
potential race condition on the list and its corruption during a second
probe when probe fails.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/006e803af7408c3fc815b0654fc5ab43d34f0154
  - https://git.kernel.org/stable/c/1b9cbd8a9ae68b32099fbb03b2d5ffa0c5e0dcc9
  - https://git.kernel.org/stable/c/1e39b0486cdb496cdfba3bc89886150e46acf6f4
  - https://git.kernel.org/stable/c/2fdac64c3c35858aa8ac5caa70b232e03456e120
  - https://git.kernel.org/stable/c/465d01ef6962b82b1f0ad1f3e58b398dbd35c1c1
  - https://git.kernel.org/stable/c/543e3e9f2e9e47ded774c74e680f28a0ca362aee
  - https://git.kernel.org/stable/c/8e2fcc68fbaab3ad9f5671fee2be0956134b740a
  - https://git.kernel.org/stable/c/f801e754efa21bd61b3cc15ec7565696165b272f

------------------------------------------------------------

CVE ID: CVE-2024-58073
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: check dpu_plane_atomic_print_state() for valid sspp

Similar to the r_pipe sspp protect, add a check to protect
the pipe state prints to avoid NULL ptr dereference for cases when
the state is dumped without a corresponding atomic_check() where the
pipe->sspp is assigned.

Patchwork: https://patchwork.freedesktop.org/patch/628404/
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.2
References:
  - https://git.kernel.org/stable/c/008af2074e4b91d34440102501b710c235a3b245
  - https://git.kernel.org/stable/c/789384eb1437aed94155dc0eac8a8a6ba1baf578

------------------------------------------------------------

CVE ID: CVE-2024-58074
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915: Grab intel_display from the encoder to avoid potential oopsies

Grab the intel_display from 'encoder' rather than 'state'
in the encoder hooks to avoid the massive footgun that is
intel_sanitize_encoder(), which passes NULL as the 'state'
argument to encoder .disable() and .post_disable().

TODO: figure out how to actually fix intel_sanitize_encoder()...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1885401569f24eb35c631bcc4e6543360dbe9292
  - https://git.kernel.org/stable/c/dc3806d9eb66d0105f8d55d462d4ef681d9eac59

------------------------------------------------------------

CVE ID: CVE-2024-58075
Description: In the Linux kernel, the following vulnerability has been resolved:

crypto: tegra - do not transfer req when tegra init fails

The tegra_cmac_init or tegra_sha_init function may return an error when
memory is exhausted. It should not transfer the request when they return
an error.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/15589bda46830695a3261518bb7627afac61f519
  - https://git.kernel.org/stable/c/1dbc270f9df7f0ae1e591323431869059cee1b7d
  - https://git.kernel.org/stable/c/5eaa7c916e1ec4b122a1c3a8a20e692d9d9e174e

------------------------------------------------------------

CVE ID: CVE-2025-21825
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Cancel the running bpf_timer through kworker for PREEMPT_RT

During the update procedure, when overwrite element in a pre-allocated
htab, the freeing of old_element is protected by the bucket lock. The
reason why the bucket lock is necessary is that the old_element has
already been stashed in htab->extra_elems after alloc_htab_elem()
returns. If freeing the old_element after the bucket lock is unlocked,
the stashed element may be reused by concurrent update procedure and the
freeing of old_element will run concurrently with the reuse of the
old_element. However, the invocation of check_and_free_fields() may
acquire a spin-lock which violates the lockdep rule because its caller
has already held a raw-spin-lock (bucket lock). The following warning
will be reported when such race happens:

  BUG: scheduling while atomic: test_progs/676/0x00000003
  3 locks held by test_progs/676:
  #0: ffffffff864b0240 (rcu_read_lock_trace){....}-{0:0}, at: bpf_prog_test_run_syscall+0x2c0/0x830
  #1: ffff88810e961188 (&htab->lockdep_key){....}-{2:2}, at: htab_map_update_elem+0x306/0x1500
  #2: ffff8881f4eac1b8 (&base->softirq_expiry_lock){....}-{2:2}, at: hrtimer_cancel_wait_running+0xe9/0x1b0
  Modules linked in: bpf_testmod(O)
  Preemption disabled at:
  [<ffffffff817837a3>] htab_map_update_elem+0x293/0x1500
  CPU: 0 UID: 0 PID: 676 Comm: test_progs Tainted: G ... 6.12.0+ #11
  Tainted: [W]=WARN, [O]=OOT_MODULE
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)...
  Call Trace:
  <TASK>
  dump_stack_lvl+0x57/0x70
  dump_stack+0x10/0x20
  __schedule_bug+0x120/0x170
  __schedule+0x300c/0x4800
  schedule_rtlock+0x37/0x60
  rtlock_slowlock_locked+0x6d9/0x54c0
  rt_spin_lock+0x168/0x230
  hrtimer_cancel_wait_running+0xe9/0x1b0
  hrtimer_cancel+0x24/0x30
  bpf_timer_delete_work+0x1d/0x40
  bpf_timer_cancel_and_free+0x5e/0x80
  bpf_obj_free_fields+0x262/0x4a0
  check_and_free_fields+0x1d0/0x280
  htab_map_update_elem+0x7fc/0x1500
  bpf_prog_9f90bc20768e0cb9_overwrite_cb+0x3f/0x43
  bpf_prog_ea601c4649694dbd_overwrite_timer+0x5d/0x7e
  bpf_prog_test_run_syscall+0x322/0x830
  __sys_bpf+0x135d/0x3ca0
  __x64_sys_bpf+0x75/0xb0
  x64_sys_call+0x1b5/0xa10
  do_syscall_64+0x3b/0xc0
  entry_SYSCALL_64_after_hwframe+0x4b/0x53
  ...
  </TASK>

It seems feasible to break the reuse and refill of per-cpu extra_elems
into two independent parts: reuse the per-cpu extra_elems with bucket
lock being held and refill the old_element as per-cpu extra_elems after
the bucket lock is unlocked. However, it will make the concurrent
overwrite procedures on the same CPU return unexpected -E2BIG error when
the map is full.

Therefore, the patch fixes the lock problem by breaking the cancelling
of bpf_timer into two steps for PREEMPT_RT:
1) use hrtimer_try_to_cancel() and check its return value
2) if the timer is running, use hrtimer_cancel() through a kworker to
   cancel it again
Considering that the current implementation of hrtimer_cancel() will try
to acquire a being held softirq_expiry_lock when the current timer is
running, these steps above are reasonable. However, it also has
downside. When the timer is running, the cancelling of the timer is
delayed when releasing the last map uref. The delay is also fixable
(e.g., break the cancelling of bpf timer into two parts: one part in
locked scope, another one in unlocked scope), it can be revised later if
necessary.

It is a bit hard to decide the right fix tag. One reason is that the
problem depends on PREEMPT_RT which is enabled in v6.12. Considering the
softirq_expiry_lock lock exists since v5.4 and bpf_timer is introduced
in v5.15, the bpf_timer commit is used in the fixes tag and an extra
depends-on tag is added to state the dependency on PREEMPT_RT.

Depends-on: v6.12+ with PREEMPT_RT enabled
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/33e47d9573075342a41783a55c8c67bc71246fc1
  - https://git.kernel.org/stable/c/58f038e6d209d2dd862fcf5de55407855856794d
  - https://git.kernel.org/stable/c/fbeda3d939ca10063aafa7a77cc0f409d82cda88

------------------------------------------------------------

CVE ID: CVE-2025-21826
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: reject mismatching sum of field_len with set key length

The field length description provides the length of each separated key
field in the concatenation, each field gets rounded up to 32-bits to
calculate the pipapo rule width from pipapo_init(). The set key length
provides the total size of the key aligned to 32-bits.

Register-based arithmetics still allows for combining mismatching set
key length and field length description, eg. set key length 10 and field
description [ 5, 4 ] leading to pipapo width of 12.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b9335a8000fb70742f7db10af314104b6ace220
  - https://git.kernel.org/stable/c/2ac254343d3cf228ae0738b2615fedf85d000752
  - https://git.kernel.org/stable/c/49b7182b97bafbd5645414aff054b4a65d05823d
  - https://git.kernel.org/stable/c/5083a7ae45003456c253e981b30a43f71230b4a3
  - https://git.kernel.org/stable/c/6b467c8feac759f4c5c86d708beca2aa2b29584f
  - https://git.kernel.org/stable/c/82e491e085719068179ff6a5466b7387cc4bbf32
  - https://git.kernel.org/stable/c/ab50d0eff4a939d20c37721fd9766347efcdb6f6

------------------------------------------------------------

CVE ID: CVE-2025-21827
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btusb: mediatek: Add locks for usb_driver_claim_interface()

The documentation for usb_driver_claim_interface() says that "the
device lock" is needed when the function is called from places other
than probe(). This appears to be the lock for the USB interface
device. The Mediatek btusb code gets called via this path:

  Workqueue: hci0 hci_power_on [bluetooth]
  Call trace:
   usb_driver_claim_interface
   btusb_mtk_claim_iso_intf
   btusb_mtk_setup
   hci_dev_open_sync
   hci_power_on
   process_scheduled_works
   worker_thread
   kthread

With the above call trace the device lock hasn't been claimed. Claim
it.

Without this fix, we'd sometimes see the error "Failed to claim iso
interface". Sometimes we'd even see worse errors, like a NULL pointer
dereference (where `intf->dev.driver` was NULL) with a trace like:

  Call trace:
   usb_suspend_both
   usb_runtime_suspend
   __rpm_callback
   rpm_suspend
   pm_runtime_work
   process_scheduled_works

Both errors appear to be fixed with the proper locking.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4194766ec8756f4f654d595ae49962acbac49490
  - https://git.kernel.org/stable/c/930e1790b99e5839e1af69d2f7fd808f1fba2df9
  - https://git.kernel.org/stable/c/e9087e828827e5a5c85e124ce77503f2b81c3491

------------------------------------------------------------

CVE ID: CVE-2025-21828
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: don't flush non-uploaded STAs

If STA state is pre-moved to AUTHORIZED (such as in IBSS
scenarios) and insertion fails, the station is freed.
In this case, the driver never knew about the station,
so trying to flush it is unexpected and may crash.

Check if the sta was uploaded to the driver before and
fix this.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9efb5531271fa7ebae993b2a33a705d9947c7ce6
  - https://git.kernel.org/stable/c/aa3ce3f8fafa0b8fb062f28024855ea8cb3f3450
  - https://git.kernel.org/stable/c/cd10b7fcb95a6a86c67adc54304c59a578ab16af
  - https://git.kernel.org/stable/c/cf21ef3d430847ba864bbc9b2774fffcc03ce321

------------------------------------------------------------

CVE ID: CVE-2024-58076
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: qcom: gcc-sm6350: Add missing parent_map for two clocks

If a clk_rcg2 has a parent, it should also have parent_map defined,
otherwise we'll get a NULL pointer dereference when calling clk_set_rate
like the following:

  [    3.388105] Call trace:
  [    3.390664]  qcom_find_src_index+0x3c/0x70 (P)
  [    3.395301]  qcom_find_src_index+0x1c/0x70 (L)
  [    3.399934]  _freq_tbl_determine_rate+0x48/0x100
  [    3.404753]  clk_rcg2_determine_rate+0x1c/0x28
  [    3.409387]  clk_core_determine_round_nolock+0x58/0xe4
  [    3.421414]  clk_core_round_rate_nolock+0x48/0xfc
  [    3.432974]  clk_core_round_rate_nolock+0xd0/0xfc
  [    3.444483]  clk_core_set_rate_nolock+0x8c/0x300
  [    3.455886]  clk_set_rate+0x38/0x14c

Add the parent_map property for two clocks where it's missing and also
un-inline the parent_data as well to keep the matching parent_map and
parent_data together.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/08b77ed7cfaac62bba51ac7a0487409ec9fcbc84
  - https://git.kernel.org/stable/c/175af15551ed5aa6af16ff97aff75cfffb42da21
  - https://git.kernel.org/stable/c/39336edd14a59dc086fb19957655e0f340bb28e8
  - https://git.kernel.org/stable/c/3e567032233a240b903dc11c9f18eeb3faa10ffa
  - https://git.kernel.org/stable/c/96fe1a7ee477d701cfc98ab9d3c730c35d966861
  - https://git.kernel.org/stable/c/b6fe13566bf5676b1e3b72d2a06d875733e93ee6

------------------------------------------------------------

CVE ID: CVE-2024-58077
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: soc-pcm: don't use soc_pcm_ret() on .prepare callback

commit 1f5664351410 ("ASoC: lower "no backend DAIs enabled for ... Port"
log severity") ignores -EINVAL error message on common soc_pcm_ret().
It is used from many functions, ignoring -EINVAL is over-kill.

The reason why -EINVAL was ignored was it really should only be used
upon invalid parameters coming from userspace and in that case we don't
want to log an error since we do not want to give userspace a way to do
a denial-of-service attack on the syslog / diskspace.

So don't use soc_pcm_ret() on .prepare callback is better idea.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/301c26a018acb94dd537a4418cefa0f654500c6f
  - https://git.kernel.org/stable/c/79b8c7c93beb4f5882c9ee5b9ba73354fa4bc9ee
  - https://git.kernel.org/stable/c/8ec4e8c8e142933eaa8e1ed87168831069250e4e
  - https://git.kernel.org/stable/c/90778f31efdf44622065ebbe8d228284104bd26f
  - https://git.kernel.org/stable/c/b65ba768302adc7ddc70811116cef80ca089af59

------------------------------------------------------------

CVE ID: CVE-2024-58078
Description: In the Linux kernel, the following vulnerability has been resolved:

misc: misc_minor_alloc to use ida for all dynamic/misc dynamic minors

misc_minor_alloc was allocating id using ida for minor only in case of
MISC_DYNAMIC_MINOR but misc_minor_free was always freeing ids
using ida_free causing a mismatch and following warn:
> > WARNING: CPU: 0 PID: 159 at lib/idr.c:525 ida_free+0x3e0/0x41f
> > ida_free called for id=127 which is not allocated.
> > <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
...
> > [<60941eb4>] ida_free+0x3e0/0x41f
> > [<605ac993>] misc_minor_free+0x3e/0xbc
> > [<605acb82>] misc_deregister+0x171/0x1b3

misc_minor_alloc is changed to allocate id from ida for all minors
falling in the range of dynamic/ misc dynamic minors
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3df72111c39f7e4c5029c9ff720b56ec2e05b764
  - https://git.kernel.org/stable/c/6635332d246d7db89b90e145f2bf937406cecaf0
  - https://git.kernel.org/stable/c/6d04d2b554b14ae6c428a9c60b6c85f1e5c89f68
  - https://git.kernel.org/stable/c/8b4120b3e060e137eaa8dc76a1c40401088336e5

------------------------------------------------------------

CVE ID: CVE-2024-58079
Description: In the Linux kernel, the following vulnerability has been resolved:

media: uvcvideo: Fix crash during unbind if gpio unit is in use

We used the wrong device for the device managed functions. We used the
usb device, when we should be using the interface device.

If we unbind the driver from the usb interface, the cleanup functions
are never called. In our case, the IRQ is never disabled.

If an IRQ is triggered, it will try to access memory sections that are
already free, causing an OOPS.

We cannot use the function devm_request_threaded_irq here. The devm_*
clean functions may be called after the main structure is released by
uvc_delete.

Luckily this bug has small impact, as it is only affected by devices
with gpio units and the user has to unbind the device, a disconnect will
not trigger this error.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b5e0445bc8384c18bd35cb9fe87f6258c6271d9
  - https://git.kernel.org/stable/c/0fdd7cc593385e46e92e180b71e264fc9c195298
  - https://git.kernel.org/stable/c/3c00e94d00ca079bef7906d6f39d1091bccfedd3
  - https://git.kernel.org/stable/c/5d2e65cbe53d0141ed095cf31c2dcf3d8668c11d
  - https://git.kernel.org/stable/c/a9ea1a3d88b7947ce8cadb2afceee7a54872bbc5
  - https://git.kernel.org/stable/c/d2eac8b14ac690aa73052aa6d4ba69005715367e

------------------------------------------------------------

CVE ID: CVE-2024-58080
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: qcom: dispcc-sm6350: Add missing parent_map for a clock

If a clk_rcg2 has a parent, it should also have parent_map defined,
otherwise we'll get a NULL pointer dereference when calling clk_set_rate
like the following:

  [    3.388105] Call trace:
  [    3.390664]  qcom_find_src_index+0x3c/0x70 (P)
  [    3.395301]  qcom_find_src_index+0x1c/0x70 (L)
  [    3.399934]  _freq_tbl_determine_rate+0x48/0x100
  [    3.404753]  clk_rcg2_determine_rate+0x1c/0x28
  [    3.409387]  clk_core_determine_round_nolock+0x58/0xe4
  [    3.421414]  clk_core_round_rate_nolock+0x48/0xfc
  [    3.432974]  clk_core_round_rate_nolock+0xd0/0xfc
  [    3.444483]  clk_core_set_rate_nolock+0x8c/0x300
  [    3.455886]  clk_set_rate+0x38/0x14c

Add the parent_map property for the clock where it's missing and also
un-inline the parent_data as well to keep the matching parent_map and
parent_data together.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/2dba8d5d423fa5f6f3a687aa6e0da5808f69091b
  - https://git.kernel.org/stable/c/3ad28517385e2821e8e43388d6a0b3e1ba0bc3ab
  - https://git.kernel.org/stable/c/3daca9050857220726732ad9d4a8512069386f46
  - https://git.kernel.org/stable/c/a1f15808adfd77268eac7fefce5378ad9fedbfba
  - https://git.kernel.org/stable/c/d4cdb196f182d2fbe336c968228be00d8c3fed05

------------------------------------------------------------

CVE ID: CVE-2024-58081
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: mmp2: call pm_genpd_init() only after genpd.name is set

Setting the genpd's struct device's name with dev_set_name() is
happening within pm_genpd_init(). If it remains NULL, things can blow up
later, such as when crafting the devfs hierarchy for the power domain:

  Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read
  ...
  Call trace:
   strlen from start_creating+0x90/0x138
   start_creating from debugfs_create_dir+0x20/0x178
   debugfs_create_dir from genpd_debug_add.part.0+0x4c/0x144
   genpd_debug_add.part.0 from genpd_debug_init+0x74/0x90
   genpd_debug_init from do_one_initcall+0x5c/0x244
   do_one_initcall from kernel_init_freeable+0x19c/0x1f4
   kernel_init_freeable from kernel_init+0x1c/0x12c
   kernel_init from ret_from_fork+0x14/0x28

Bisecting tracks this crash back to commit 899f44531fe6 ("pmdomain: core:
Add GENPD_FLAG_DEV_NAME_FW flag"), which exchanges use of genpd->name
with dev_name(&genpd->dev) in genpd_debug_add.part().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11.10, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/763517124e27b07fa300b486d7d13c5d563a215e
  - https://git.kernel.org/stable/c/e24b15d4704dcb73920c3d18a6157abd18df08c1
  - https://git.kernel.org/stable/c/eca01d5911fb34218d10a58d8d9534b758c8fd0a

------------------------------------------------------------

CVE ID: CVE-2024-58082
Description: In the Linux kernel, the following vulnerability has been resolved:

media: nuvoton: Fix an error check in npcm_video_ece_init()

When function of_find_device_by_node() fails, it returns NULL instead of
an error code. So the corresponding error check logic should be modified
to check whether the return value is NULL and set the error code to be
returned as -ENODEV.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/bdd823b9d068284e1d998b962cfef29236365df3
  - https://git.kernel.org/stable/c/c36b830754ae1dd1db41c27f57b29267878f9702
  - https://git.kernel.org/stable/c/c4b7779abc6633677e6edb79e2809f4f61fde157

------------------------------------------------------------

CVE ID: CVE-2024-58083
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: Explicitly verify target vCPU is online in kvm_get_vcpu()

Explicitly verify the target vCPU is fully online _prior_ to clamping the
index in kvm_get_vcpu().  If the index is "bad", the nospec clamping will
generate '0', i.e. KVM will return vCPU0 instead of NULL.

In practice, the bug is unlikely to cause problems, as it will only come
into play if userspace or the guest is buggy or misbehaving, e.g. KVM may
send interrupts to vCPU0 instead of dropping them on the floor.

However, returning vCPU0 when it shouldn't exist per online_vcpus is
problematic now that KVM uses an xarray for the vCPUs array, as KVM needs
to insert into the xarray before publishing the vCPU to userspace (see
commit c5b077549136 ("KVM: Convert the kvm->vcpus array to a xarray")),
i.e. before vCPU creation is guaranteed to succeed.

As a result, incorrectly providing access to vCPU0 will trigger a
use-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()
bails out of vCPU creation due to an error and frees vCPU0.  Commit
afb2acb2e3a3 ("KVM: Fix vcpu_array[0] races") papered over that issue, but
in doing so introduced an unsolvable teardown conundrum.  Preventing
accesses to vCPU0 before it's fully online will allow reverting commit
afb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.120, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.44, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0.17, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.129
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.14
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/09d50ccf0b2d739db4a485b08afe7520a4402a63
  - https://git.kernel.org/stable/c/125da53b3c0c9d7f58353aea0076e9efd6498ba7
  - https://git.kernel.org/stable/c/1e7381f3617d14b3c11da80ff5f8a93ab14cfc46
  - https://git.kernel.org/stable/c/5cce2ed69b00e022b5cdf0c49c82986abd2941a8
  - https://git.kernel.org/stable/c/7c4899239d0f70f88ac42665b3da51678d122480
  - https://git.kernel.org/stable/c/ca8da90ed1432ff3d000de4f1e2275d4e7d21b96
  - https://git.kernel.org/stable/c/d817e510662fd1c9797952408d94806f97a5fffd
  - https://git.kernel.org/stable/c/f2f805ada63b536bc192458a7098388286568ad4

------------------------------------------------------------

CVE ID: CVE-2024-58084
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: qcom: scm: Fix missing read barrier in qcom_scm_get_tzmem_pool()

Commit 2e4955167ec5 ("firmware: qcom: scm: Fix __scm and waitq
completion variable initialization") introduced a write barrier in probe
function to store global '__scm' variable.  We all known barriers are
paired (see memory-barriers.txt: "Note that write barriers should
normally be paired with read or address-dependency barriers"), therefore
accessing it from concurrent contexts requires read barrier.  Previous
commit added such barrier in qcom_scm_is_available(), so let's use that
directly.

Lack of this read barrier can result in fetching stale '__scm' variable
value, NULL, and dereferencing it.

Note that barrier in qcom_scm_is_available() satisfies here the control
dependency.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/b628510397b5cafa1f5d3e848a28affd1c635302
  - https://git.kernel.org/stable/c/e03db7c1255ebabba5e1a447754faeb138de15a2
  - https://git.kernel.org/stable/c/fee921e3c641f64185abee83f9a6e65f0b380682

------------------------------------------------------------

CVE ID: CVE-2024-58085
Description: In the Linux kernel, the following vulnerability has been resolved:

tomoyo: don't emit warning in tomoyo_write_control()

syzbot is reporting too large allocation warning at tomoyo_write_control(),
for one can write a very very long line without new line character. To fix
this warning, I use __GFP_NOWARN rather than checking for KMALLOC_MAX_SIZE,
for practically a valid line should be always shorter than 32KB where the
"too small to fail" memory-allocation rule applies.

One might try to write a valid line that is longer than 32KB, but such
request will likely fail with -ENOMEM. Therefore, I feel that separately
returning -EINVAL when a line is longer than KMALLOC_MAX_SIZE is redundant.
There is no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3df7546fc03b8f004eee0b9e3256369f7d096685
  - https://git.kernel.org/stable/c/414705c0303350d139b1dc18f329fe47dfb642dd
  - https://git.kernel.org/stable/c/a01c200fa7eb59da4d2dbbb48b61f4a0d196c09f
  - https://git.kernel.org/stable/c/b2bd5857a0d6973ebbcb4d9831ddcaebbd257be1
  - https://git.kernel.org/stable/c/c67efabddc73171c7771d3ffe4ffa1e503ee533e
  - https://git.kernel.org/stable/c/c9382f380e8d09209b8e5c0def0545852168be25
  - https://git.kernel.org/stable/c/f6b37b3e12de638753bce79a2858070b9c4a4ad3
  - https://git.kernel.org/stable/c/fe1c021eb03dae0dc9dce55e81f77a60e419a27a

------------------------------------------------------------

CVE ID: CVE-2024-58086
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/v3d: Stop active perfmon if it is being destroyed

If the active performance monitor (`v3d->active_perfmon`) is being
destroyed, stop it first. Currently, the active perfmon is not
stopped during destruction, leaving the `v3d->active_perfmon` pointer
stale. This can lead to undefined behavior and instability.

This patch ensures that the active perfmon is stopped before being
destroyed, aligning with the behavior introduced in commit
7d1fd3638ee3 ("drm/v3d: Stop the active perfmon before being destroyed").
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c5673a2c8926adbb61f340c779b28e18188a8cd
  - https://git.kernel.org/stable/c/21f1435b1e6b012a07c42f36b206d2b66fc8f13b
  - https://git.kernel.org/stable/c/22e19c8c5f6b709f4ae40227392a30d57bac187d
  - https://git.kernel.org/stable/c/95036d4c01167568166108d42c2b0e9f8dbd7d2b
  - https://git.kernel.org/stable/c/eb0e0eca0eab93f310c6c37b8564049366704691
  - https://git.kernel.org/stable/c/f8805b12f477bd964e2820a87921c7b58cc2dee3

------------------------------------------------------------

CVE ID: CVE-2025-21829
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/rxe: Fix the warning "__rxe_cleanup+0x12c/0x170 [rdma_rxe]"

The Call Trace is as below:
"
  <TASK>
  ? show_regs.cold+0x1a/0x1f
  ? __rxe_cleanup+0x12c/0x170 [rdma_rxe]
  ? __warn+0x84/0xd0
  ? __rxe_cleanup+0x12c/0x170 [rdma_rxe]
  ? report_bug+0x105/0x180
  ? handle_bug+0x46/0x80
  ? exc_invalid_op+0x19/0x70
  ? asm_exc_invalid_op+0x1b/0x20
  ? __rxe_cleanup+0x12c/0x170 [rdma_rxe]
  ? __rxe_cleanup+0x124/0x170 [rdma_rxe]
  rxe_destroy_qp.cold+0x24/0x29 [rdma_rxe]
  ib_destroy_qp_user+0x118/0x190 [ib_core]
  rdma_destroy_qp.cold+0x43/0x5e [rdma_cm]
  rtrs_cq_qp_destroy.cold+0x1d/0x2b [rtrs_core]
  rtrs_srv_close_work.cold+0x1b/0x31 [rtrs_server]
  process_one_work+0x21d/0x3f0
  worker_thread+0x4a/0x3c0
  ? process_one_work+0x3f0/0x3f0
  kthread+0xf0/0x120
  ? kthread_complete_and_exit+0x20/0x20
  ret_from_fork+0x22/0x30
  </TASK>
"
When too many rdma resources are allocated, rxe needs more time to
handle these rdma resources. Sometimes with the current timeout, rxe
can not release the rdma resources correctly.

Compared with other rdma drivers, a bigger timeout is used.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/45e567800492088bc52c9abac35524b4d332a8f8
  - https://git.kernel.org/stable/c/720653309dd31c8a927ef5d87964578ad544980f
  - https://git.kernel.org/stable/c/7a2de8126ed3801f2396720e10a03cd546a3cea1
  - https://git.kernel.org/stable/c/a7d15eaecf0d6e13226db629ae2401c8c02683e5
  - https://git.kernel.org/stable/c/edc4ef0e0154096d6c0cf5e06af6fc330dbad9d1

------------------------------------------------------------

CVE ID: CVE-2025-21830
Description: In the Linux kernel, the following vulnerability has been resolved:

landlock: Handle weird files

A corrupted filesystem (e.g. bcachefs) might return weird files.
Instead of throwing a warning and allowing access to such file, treat
them as regular files.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0fde195a373ab1267e60baa9e1a703a97e7464cd
  - https://git.kernel.org/stable/c/2569e65d2eb6ac1afe6cb6dfae476afee8b6771a
  - https://git.kernel.org/stable/c/39bb3d56f1c351e76bb18895d0e73796e653d5c1
  - https://git.kernel.org/stable/c/49440290a0935f428a1e43a5ac8dc275a647ff80
  - https://git.kernel.org/stable/c/7d6121228959ddf44a4b9b6a177384ac7854e2f9
  - https://git.kernel.org/stable/c/a1fccf6b72b56343dd4f2d96b008147f9951eebd

------------------------------------------------------------

CVE ID: CVE-2025-21831
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: Avoid putting some root ports into D3 on TUXEDO Sirius Gen1

commit 9d26d3a8f1b0 ("PCI: Put PCIe ports into D3 during suspend") sets the
policy that all PCIe ports are allowed to use D3.  When the system is
suspended if the port is not power manageable by the platform and won't be
used for wakeup via a PME this sets up the policy for these ports to go
into D3hot.

This policy generally makes sense from an OSPM perspective but it leads to
problems with wakeup from suspend on the TUXEDO Sirius 16 Gen 1 with a
specific old BIOS. This manifests as a system hang.

On the affected Device + BIOS combination, add a quirk for the root port of
the problematic controller to ensure that these root ports are not put into
D3hot at suspend.

This patch is based on

  https://lore.kernel.org/linux-pci/20230708214457.1229-2-mario.limonciello@amd.com

but with the added condition both in the documentation and in the code to
apply only to the TUXEDO Sirius 16 Gen 1 with a specific old BIOS and only
the affected root ports.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5ee3dd6e59b834e4d66e8b16fc684749ee40a257
  - https://git.kernel.org/stable/c/8852e056e297df1d8635ee7504e780d3184e45d0
  - https://git.kernel.org/stable/c/a78dfe50fffe6058afed2bb04c50c2c9a16664ee
  - https://git.kernel.org/stable/c/b1049f2d68693c80a576c4578d96774a68df2bad

------------------------------------------------------------

CVE ID: CVE-2025-21832
Description: In the Linux kernel, the following vulnerability has been resolved:

block: don't revert iter for -EIOCBQUEUED

blkdev_read_iter() has a few odd checks, like gating the position and
count adjustment on whether or not the result is bigger-than-or-equal to
zero (where bigger than makes more sense), and not checking the return
value of blkdev_direct_IO() before doing an iov_iter_revert(). The
latter can lead to attempting to revert with a negative value, which
when passed to iov_iter_revert() as an unsigned value will lead to
throwing a WARN_ON() because unroll is bigger than MAX_RW_COUNT.

Be sane and don't revert for -EIOCBQUEUED, like what is done in other
spots.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/68f16d3034a06661245ecd22f0d586a8b4e7c473
  - https://git.kernel.org/stable/c/6c26619effb1b4cb7d20b4e666ab8f71f6a53ccb
  - https://git.kernel.org/stable/c/84671b0630ccb46ae9f1f99a45c7d63ffcd6a474
  - https://git.kernel.org/stable/c/a58f136bad29f9ae721a29d98c042fddbee22f77
  - https://git.kernel.org/stable/c/b13ee668e8280ca5b07f8ce2846b9957a8a10853

------------------------------------------------------------

CVE ID: CVE-2025-21833
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/vt-d: Avoid use of NULL after WARN_ON_ONCE

There is a WARN_ON_ONCE to catch an unlikely situation when
domain_remove_dev_pasid can't find the `pasid`. In case it nevertheless
happens we must avoid using a NULL pointer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.13.3
References:
  - https://git.kernel.org/stable/c/60f030f7418d3f1d94f2fb207fe3080e1844630b
  - https://git.kernel.org/stable/c/df96876be3b064aefc493f760e0639765d13ed0d

------------------------------------------------------------

CVE ID: CVE-2025-21834
Description: In the Linux kernel, the following vulnerability has been resolved:

seccomp: passthrough uretprobe systemcall without filtering

When attaching uretprobes to processes running inside docker, the attached
process is segfaulted when encountering the retprobe.

The reason is that now that uretprobe is a system call the default seccomp
filters in docker block it as they only allow a specific set of known
syscalls. This is true for other userspace applications which use seccomp
to control their syscall surface.

Since uretprobe is a "kernel implementation detail" system call which is
not used by userspace application code directly, it is impractical and
there's very little point in forcing all userspace applications to
explicitly allow it in order to avoid crashing tracked processes.

Pass this systemcall through seccomp without depending on configuration.

Note: uretprobe is currently only x86_64 and isn't expected to ever be
supported in i386.

[kees: minimized changes for easier backporting, tweaked commit log]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5a262628f4cf2437d863fe41f9d427177b87664c
  - https://git.kernel.org/stable/c/cf6cb56ef24410fb5308f9655087f1eddf4452e6
  - https://git.kernel.org/stable/c/fa80018aa5be10c35e9fa896b7b4061a8dce3eed

------------------------------------------------------------

CVE ID: CVE-2025-21835
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: f_midi: fix MIDI Streaming descriptor lengths

While the MIDI jacks are configured correctly, and the MIDIStreaming
endpoint descriptors are filled with the correct information,
bNumEmbMIDIJack and bLength are set incorrectly in these descriptors.

This does not matter when the numbers of in and out ports are equal, but
when they differ the host will receive broken descriptors with
uninitialized stack memory leaking into the descriptor for whichever
value is smaller.

The precise meaning of "in" and "out" in the port counts is not clearly
defined and can be confusing.  But elsewhere the driver consistently
uses this to match the USB meaning of IN and OUT viewed from the host,
so that "in" ports send data to the host and "out" ports receive data
from it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a983390d14e8498f303fc5cb23ab7d696b815db
  - https://git.kernel.org/stable/c/6ae6dee9f005a2f3b739b85abb6f14a0935699e0
  - https://git.kernel.org/stable/c/6b16761a928796e4b49e89a0b1ac284155172726
  - https://git.kernel.org/stable/c/9f36a89dcb78cb7e37f487b04a16396ac18c0636
  - https://git.kernel.org/stable/c/9f6860a9c11301b052225ca8825f8d2b1a5825bf
  - https://git.kernel.org/stable/c/a2d0694e1f111379c1efdf439dadd3cfd959fe9d
  - https://git.kernel.org/stable/c/d8e86700c8a8cf415e300a0921acd6a8f9b494f8
  - https://git.kernel.org/stable/c/da1668997052ed1cb00322e1f3b63702615c9429

------------------------------------------------------------

CVE ID: CVE-2025-21836
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring/kbuf: reallocate buf lists on upgrade

IORING_REGISTER_PBUF_RING can reuse an old struct io_buffer_list if it
was created for legacy selected buffer and has been emptied. It violates
the requirement that most of the field should stay stable after publish.
Always reallocate it instead.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/146a185f6c05ee263db715f860620606303c4633
  - https://git.kernel.org/stable/c/2a5febbef40ce968e295a7aeaa5d5cbd9e3e5ad4
  - https://git.kernel.org/stable/c/7d0dc28dae836caf7645fef62a10befc624dd17b
  - https://git.kernel.org/stable/c/8802766324e1f5d414a81ac43365c20142e85603

------------------------------------------------------------

CVE ID: CVE-2025-21837
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring/uring_cmd: unconditionally copy SQEs at prep time

This isn't generally necessary, but conditions have been observed where
SQE data is accessed from the original SQE after prep has been done and
outside of the initial issue. Opcode prep handlers must ensure that any
SQE related data is stable beyond the prep phase, but uring_cmd is a bit
special in how it handles the SQE which makes it susceptible to reading
stale data. If the application has reused the SQE before the original
completes, then that can lead to data corruption.

Down the line we can relax this again once uring_cmd has been sanitized
a bit, and avoid unnecessarily copying the SQE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/87fe1d68842a308998b315c8ed0163a1d639017c
  - https://git.kernel.org/stable/c/d6211ebbdaa541af197b50b8dd8f22642ce0b87f

------------------------------------------------------------

CVE ID: CVE-2025-21838
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: core: flush gadget workqueue after device removal

device_del() can lead to new work being scheduled in gadget->work
workqueue. This is observed, for example, with the dwc3 driver with the
following call stack:
  device_del()
    gadget_unbind_driver()
      usb_gadget_disconnect_locked()
        dwc3_gadget_pullup()
	  dwc3_gadget_soft_disconnect()
	    usb_gadget_set_state()
	      schedule_work(&gadget->work)

Move flush_work() after device_del() to ensure the workqueue is cleaned
up.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/399a45e5237ca14037120b1b895bd38a3b4492ea
  - https://git.kernel.org/stable/c/859cb45aefa6de823b2fa7f229fe6d9562c9f3b7
  - https://git.kernel.org/stable/c/97695b5a1b5467a4f91194db12160f56da445dfe
  - https://git.kernel.org/stable/c/e3bc1a9a67ce33a2e761e6e7b7c2afc6cb9b7266
  - https://git.kernel.org/stable/c/f894448f3904d7ad66fecef8f01fe0172629e091

------------------------------------------------------------

CVE ID: CVE-2025-21839
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Load DR6 with guest value only before entering .vcpu_run() loop

Move the conditional loading of hardware DR6 with the guest's DR6 value
out of the core .vcpu_run() loop to fix a bug where KVM can load hardware
with a stale vcpu->arch.dr6.

When the guest accesses a DR and host userspace isn't debugging the guest,
KVM disables DR interception and loads the guest's values into hardware on
VM-Enter and saves them on VM-Exit.  This allows the guest to access DRs
at will, e.g. so that a sequence of DR accesses to configure a breakpoint
only generates one VM-Exit.

For DR0-DR3, the logic/behavior is identical between VMX and SVM, and also
identical between KVM_DEBUGREG_BP_ENABLED (userspace debugging the guest)
and KVM_DEBUGREG_WONT_EXIT (guest using DRs), and so KVM handles loading
DR0-DR3 in common code, _outside_ of the core kvm_x86_ops.vcpu_run() loop.

But for DR6, the guest's value doesn't need to be loaded into hardware for
KVM_DEBUGREG_BP_ENABLED, and SVM provides a dedicated VMCB field whereas
VMX requires software to manually load the guest value, and so loading the
guest's value into DR6 is handled by {svm,vmx}_vcpu_run(), i.e. is done
_inside_ the core run loop.

Unfortunately, saving the guest values on VM-Exit is initiated by common
x86, again outside of the core run loop.  If the guest modifies DR6 (in
hardware, when DR interception is disabled), and then the next VM-Exit is
a fastpath VM-Exit, KVM will reload hardware DR6 with vcpu->arch.dr6 and
clobber the guest's actual value.

The bug shows up primarily with nested VMX because KVM handles the VMX
preemption timer in the fastpath, and the window between hardware DR6
being modified (in guest context) and DR6 being read by guest software is
orders of magnitude larger in a nested setup.  E.g. in non-nested, the
VMX preemption timer would need to fire precisely between #DB injection
and the #DB handler's read of DR6, whereas with a KVM-on-KVM setup, the
window where hardware DR6 is "dirty" extends all the way from L1 writing
DR6 to VMRESUME (in L1).

    L1's view:
    ==========
    <L1 disables DR interception>
           CPU 0/KVM-7289    [023] d....  2925.640961: kvm_entry: vcpu 0
 A:  L1 Writes DR6
           CPU 0/KVM-7289    [023] d....  2925.640963: <hack>: Set DRs, DR6 = 0xffff0ff1

 B:        CPU 0/KVM-7289    [023] d....  2925.640967: kvm_exit: vcpu 0 reason EXTERNAL_INTERRUPT intr_info 0x800000ec

 D: L1 reads DR6, arch.dr6 = 0
           CPU 0/KVM-7289    [023] d....  2925.640969: <hack>: Sync DRs, DR6 = 0xffff0ff0

           CPU 0/KVM-7289    [023] d....  2925.640976: kvm_entry: vcpu 0
    L2 reads DR6, L1 disables DR interception
           CPU 0/KVM-7289    [023] d....  2925.640980: kvm_exit: vcpu 0 reason DR_ACCESS info1 0x0000000000000216
           CPU 0/KVM-7289    [023] d....  2925.640983: kvm_entry: vcpu 0

           CPU 0/KVM-7289    [023] d....  2925.640983: <hack>: Set DRs, DR6 = 0xffff0ff0

    L2 detects failure
           CPU 0/KVM-7289    [023] d....  2925.640987: kvm_exit: vcpu 0 reason HLT
    L1 reads DR6 (confirms failure)
           CPU 0/KVM-7289    [023] d....  2925.640990: <hack>: Sync DRs, DR6 = 0xffff0ff0

    L0's view:
    ==========
    L2 reads DR6, arch.dr6 = 0
          CPU 23/KVM-5046    [001] d....  3410.005610: kvm_exit: vcpu 23 reason DR_ACCESS info1 0x0000000000000216
          CPU 23/KVM-5046    [001] .....  3410.005610: kvm_nested_vmexit: vcpu 23 reason DR_ACCESS info1 0x0000000000000216

    L2 => L1 nested VM-Exit
          CPU 23/KVM-5046    [001] .....  3410.005610: kvm_nested_vmexit_inject: reason: DR_ACCESS ext_inf1: 0x0000000000000216

          CPU 23/KVM-5046    [001] d....  3410.005610: kvm_entry: vcpu 23
          CPU 23/KVM-5046    [001] d....  3410.005611: kvm_exit: vcpu 23 reason VMREAD
          CPU 23/KVM-5046    [001] d....  3410.005611: kvm_entry: vcpu 23
          CPU 23/KVM-5046    [001] d....  3410.
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4eb063de686bfcdfd03a8c801d1bbe87d2d5eb55
  - https://git.kernel.org/stable/c/93eeb6df1605b3a24f38afdba7ab903ba6b64133
  - https://git.kernel.org/stable/c/9efb2b99b96c86664bbdbdd2cdb354ac9627eb20
  - https://git.kernel.org/stable/c/a1723e9c53fe6431415be19302a56543daf503f5
  - https://git.kernel.org/stable/c/c2fee09fc167c74a64adb08656cb993ea475197e
  - https://git.kernel.org/stable/c/d456de38d9eb753a4e9fde053c18d4ef8e485339

------------------------------------------------------------

CVE ID: CVE-2025-21840
Description: In the Linux kernel, the following vulnerability has been resolved:

thermal/netlink: Prevent userspace segmentation fault by adjusting UAPI header

The intel-lpmd tool [1], which uses the THERMAL_GENL_ATTR_CPU_CAPABILITY
attribute to receive HFI events from kernel space, encounters a
segmentation fault after commit 1773572863c4 ("thermal: netlink: Add the
commands and the events for the thresholds").

The issue arises because the THERMAL_GENL_ATTR_CPU_CAPABILITY raw value
was changed while intel_lpmd still uses the old value.

Although intel_lpmd can be updated to check the THERMAL_GENL_VERSION and
use the appropriate THERMAL_GENL_ATTR_CPU_CAPABILITY value, the commit
itself is questionable.

The commit introduced a new element in the middle of enum thermal_genl_attr,
which affects many existing attributes and introduces potential risks
and unnecessary maintenance burdens for userspace thermal netlink event
users.

Solve the issue by moving the newly introduced
THERMAL_GENL_ATTR_TZ_PREV_TEMP attribute to the end of the
enum thermal_genl_attr. This ensures that all existing thermal generic
netlink attributes remain unaffected.

[ rjw: Subject edits ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a4ca365c51729143a2cab693cd40fe0bb585ef0
  - https://git.kernel.org/stable/c/c195b9c6ab9c383d7aa3f4a65879b3ca90cb378b

------------------------------------------------------------

CVE ID: CVE-2025-21841
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq/amd-pstate: Fix cpufreq_policy ref counting

amd_pstate_update_limits() takes a cpufreq_policy reference but doesn't
decrement the refcount in one of the exit paths, fix that.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28e4c515cf644c621800bd97841757fd49891ba4
  - https://git.kernel.org/stable/c/3ace20038e19f23fe73259513f1f08d4bf1a3c83
  - https://git.kernel.org/stable/c/56e6976793c0fcf1638aa534242408ab4e4ca705

------------------------------------------------------------

CVE ID: CVE-2025-21842
Description: In the Linux kernel, the following vulnerability has been resolved:

amdkfd: properly free gang_ctx_bo when failed to init user queue

The destructor of a gtt bo is declared as
void amdgpu_amdkfd_free_gtt_mem(struct amdgpu_device *adev, void **mem_obj);
Which takes void** as the second parameter.

GCC allows passing void* to the function because void* can be implicitly
casted to any other types, so it can pass compiling.

However, passing this void* parameter into the function's
execution process(which expects void** and dereferencing void**)
will result in errors.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/091a68c58c1bbd2ab7d05d1b32c1306394ec691d
  - https://git.kernel.org/stable/c/a33f7f9660705fb2ecf3467b2c48965564f392ce
  - https://git.kernel.org/stable/c/ae5ab1c1ae504f622cc1ff48830a9ed48428146d

------------------------------------------------------------

CVE ID: CVE-2025-21843
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: avoid garbage value in panthor_ioctl_dev_query()

'priorities_info' is uninitialized, and the uninitialized value is copied
to user object when calling PANTHOR_UOBJ_SET(). Using memset to initialize
'priorities_info' to avoid this garbage value problem.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.4
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3b32b7f638fe61e9d29290960172f4e360e38233
  - https://git.kernel.org/stable/c/64b95bbc08bacf3e4b05c8604e6a4fec43bb712a

------------------------------------------------------------

CVE ID: CVE-2025-27616
Description: Vela is a Pipeline Automation (CI/CD) framework built on Linux container technology written in Golang. Prior to versions 0.25.3 and 0.26.3, by spoofing a webhook payload with a specific set of headers and body data, an attacker could transfer ownership of a repository and its repo level secrets to a separate repository. These secrets could be exfiltrated by follow up builds to the repository. Users with an enabled repository with access to repo level CI secrets in Vela are vulnerable to the exploit, and any user with access to the CI instance and the linked source control manager can perform the exploit. Versions 0.25.3 and 0.26.3 fix the issue. No known workarounds are available.
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.5
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://github.com/go-vela/server/commit/257886e5a3eea518548387885894e239668584f5
  - https://github.com/go-vela/server/commit/67c1892e2464dc54b8d2588815dfb7819222500b
  - https://github.com/go-vela/server/releases/tag/v0.25.3
  - https://github.com/go-vela/server/releases/tag/v0.26.3
  - https://github.com/go-vela/server/security/advisories/GHSA-9m63-33q3-xq5x

------------------------------------------------------------

CVE ID: CVE-2025-24084
Description: Untrusted pointer dereference in Windows Subsystem for Linux allows an unauthorized attacker to execute code locally.
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.4
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-24084

------------------------------------------------------------

CVE ID: CVE-2024-58087
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix racy issue from session lookup and expire

Increment the session reference count within the lock for lookup to avoid
racy issue with session expire.
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.176
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.121
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.67
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.6
  - Vendor: linux, Product: linux_kernel, Version: 6.13, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.13, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2107ab40629aeabbec369cf34b8cf0f288c3eb1b
  - https://git.kernel.org/stable/c/37a0e2b362b3150317fb6e2139de67b1e29ae5ff
  - https://git.kernel.org/stable/c/450a844c045ff0895d41b05a1cbe8febd1acfcfd
  - https://git.kernel.org/stable/c/a39e31e22a535d47b14656a7d6a893c7f6cf758c
  - https://git.kernel.org/stable/c/b95629435b84b9ecc0c765995204a4d8a913ed52
  - https://www.zerodayinitiative.com/advisories/ZDI-25-100/

------------------------------------------------------------

CVE ID: CVE-2024-58088
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix deadlock when freeing cgroup storage

The following commit
bc235cdb423a ("bpf: Prevent deadlock from recursive bpf_task_storage_[get|delete]")
first introduced deadlock prevention for fentry/fexit programs attaching
on bpf_task_storage helpers. That commit also employed the logic in map
free path in its v6 version.

Later bpf_cgrp_storage was first introduced in
c4bcfb38a95e ("bpf: Implement cgroup storage available to non-cgroup-attached bpf progs")
which faces the same issue as bpf_task_storage, instead of its busy
counter, NULL was passed to bpf_local_storage_map_free() which opened
a window to cause deadlock:

	<TASK>
		(acquiring local_storage->lock)
	_raw_spin_lock_irqsave+0x3d/0x50
	bpf_local_storage_update+0xd1/0x460
	bpf_cgrp_storage_get+0x109/0x130
	bpf_prog_a4d4a370ba857314_cgrp_ptr+0x139/0x170
	? __bpf_prog_enter_recur+0x16/0x80
	bpf_trampoline_6442485186+0x43/0xa4
	cgroup_storage_ptr+0x9/0x20
		(holding local_storage->lock)
	bpf_selem_unlink_storage_nolock.constprop.0+0x135/0x160
	bpf_selem_unlink_storage+0x6f/0x110
	bpf_local_storage_map_free+0xa2/0x110
	bpf_map_free_deferred+0x5b/0x90
	process_one_work+0x17c/0x390
	worker_thread+0x251/0x360
	kthread+0xd2/0x100
	ret_from_fork+0x34/0x50
	ret_from_fork_asm+0x1a/0x30
	</TASK>

Progs:
 - A: SEC("fentry/cgroup_storage_ptr")
   - cgid (BPF_MAP_TYPE_HASH)
	Record the id of the cgroup the current task belonging
	to in this hash map, using the address of the cgroup
	as the map key.
   - cgrpa (BPF_MAP_TYPE_CGRP_STORAGE)
	If current task is a kworker, lookup the above hash
	map using function parameter @owner as the key to get
	its corresponding cgroup id which is then used to get
	a trusted pointer to the cgroup through
	bpf_cgroup_from_id(). This trusted pointer can then
	be passed to bpf_cgrp_storage_get() to finally trigger
	the deadlock issue.
 - B: SEC("tp_btf/sys_enter")
   - cgrpb (BPF_MAP_TYPE_CGRP_STORAGE)
	The only purpose of this prog is to fill Prog A's
	hash map by calling bpf_cgrp_storage_get() for as
	many userspace tasks as possible.

Steps to reproduce:
 - Run A;
 - while (true) { Run B; Destroy B; }

Fix this issue by passing its busy counter to the free procedure so
it can be properly incremented before storage/smap locking.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6ecb9fa14eec5f15d97c84c36896871335f6ddfb
  - https://git.kernel.org/stable/c/c78f4afbd962f43a3989f45f3ca04300252b19b5
  - https://git.kernel.org/stable/c/fac674d2bd68f3479f27328626b42d1eebd11fef
  - https://git.kernel.org/stable/c/fcec95b4ab3e7bc6b2f36e5d59f7e24104ea87f7

------------------------------------------------------------

CVE ID: CVE-2024-58089
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix double accounting race when btrfs_run_delalloc_range() failed

[BUG]
When running btrfs with block size (4K) smaller than page size (64K,
aarch64), there is a very high chance to crash the kernel at
generic/750, with the following messages:
(before the call traces, there are 3 extra debug messages added)

  BTRFS warning (device dm-3): read-write for sector size 4096 with page size 65536 is experimental
  BTRFS info (device dm-3): checking UUID tree
  hrtimer: interrupt took 5451385 ns
  BTRFS error (device dm-3): cow_file_range failed, root=4957 inode=257 start=1605632 len=69632: -28
  BTRFS error (device dm-3): run_delalloc_nocow failed, root=4957 inode=257 start=1605632 len=69632: -28
  BTRFS error (device dm-3): failed to run delalloc range, root=4957 ino=257 folio=1572864 submit_bitmap=8-15 start=1605632 len=69632: -28
  ------------[ cut here ]------------
  WARNING: CPU: 2 PID: 3020984 at ordered-data.c:360 can_finish_ordered_extent+0x370/0x3b8 [btrfs]
  CPU: 2 UID: 0 PID: 3020984 Comm: kworker/u24:1 Tainted: G           OE      6.13.0-rc1-custom+ #89
  Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022
  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]
  pc : can_finish_ordered_extent+0x370/0x3b8 [btrfs]
  lr : can_finish_ordered_extent+0x1ec/0x3b8 [btrfs]
  Call trace:
   can_finish_ordered_extent+0x370/0x3b8 [btrfs] (P)
   can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] (L)
   btrfs_mark_ordered_io_finished+0x130/0x2b8 [btrfs]
   extent_writepage+0x10c/0x3b8 [btrfs]
   extent_write_cache_pages+0x21c/0x4e8 [btrfs]
   btrfs_writepages+0x94/0x160 [btrfs]
   do_writepages+0x74/0x190
   filemap_fdatawrite_wbc+0x74/0xa0
   start_delalloc_inodes+0x17c/0x3b0 [btrfs]
   btrfs_start_delalloc_roots+0x17c/0x288 [btrfs]
   shrink_delalloc+0x11c/0x280 [btrfs]
   flush_space+0x288/0x328 [btrfs]
   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]
   process_one_work+0x228/0x680
   worker_thread+0x1bc/0x360
   kthread+0x100/0x118
   ret_from_fork+0x10/0x20
  ---[ end trace 0000000000000000 ]---
  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1605632 OE len=16384 to_dec=16384 left=0
  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1622016 OE len=12288 to_dec=12288 left=0
  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008
  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1634304 OE len=8192 to_dec=4096 left=0
  CPU: 1 UID: 0 PID: 3286940 Comm: kworker/u24:3 Tainted: G        W  OE      6.13.0-rc1-custom+ #89
  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022
  Workqueue:  btrfs_work_helper [btrfs] (btrfs-endio-write)
  pstate: 404000c5 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : process_one_work+0x110/0x680
  lr : worker_thread+0x1bc/0x360
  Call trace:
   process_one_work+0x110/0x680 (P)
   worker_thread+0x1bc/0x360 (L)
   worker_thread+0x1bc/0x360
   kthread+0x100/0x118
   ret_from_fork+0x10/0x20
  Code: f84086a1 f9000fe1 53041c21 b9003361 (f9400661)
  ---[ end trace 0000000000000000 ]---
  Kernel panic - not syncing: Oops: Fatal exception
  SMP: stopping secondary CPUs
  SMP: failed to stop secondary CPUs 2-3
  Dumping ftrace buffer:
     (ftrace buffer empty)
  Kernel Offset: 0x275bb9540000 from 0xffff800080000000
  PHYS_OFFSET: 0xffff8fbba0000000
  CPU features: 0x100,00000070,00801250,8201720b

[CAUSE]
The above warning is triggered immediately after the delalloc range
failure, this happens in the following sequence:

- Range [1568K, 1636K) is dirty

   1536K  1568K     1600K    1636K  1664K
   |      |/////////|////////|      |

  Where 1536K, 1600K and 1664K are page boundaries (64K page size)

- Enter extent_writepage() for page 1536K

- Enter run_delalloc_nocow() with locke
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 4.19.73, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0283ee1912c8e243c931f4ee5b3672e954fe0384
  - https://git.kernel.org/stable/c/21333148b5c9e52f41fafcedec3810b56a5e0e40
  - https://git.kernel.org/stable/c/72dad8e377afa50435940adfb697e070d3556670

------------------------------------------------------------

CVE ID: CVE-2025-21844
Description: In the Linux kernel, the following vulnerability has been resolved:

smb: client: Add check for next_buffer in receive_encrypted_standard()

Add check for the return value of cifs_buf_get() and cifs_small_buf_get()
in receive_encrypted_standard() to prevent null pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.69, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.8, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 5.10.211, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.15.150, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/24e8e4523d3071bc5143b0db9127d511489f7b3b
  - https://git.kernel.org/stable/c/554736b583f529ee159aa95af9a0cbc12b5ffc96
  - https://git.kernel.org/stable/c/860ca5e50f73c2a1cef7eefc9d39d04e275417f7
  - https://git.kernel.org/stable/c/9e5d99a4cf2e23c716b44862975548415fae5391
  - https://git.kernel.org/stable/c/a9b0b4b29877cb4dc5d0842b59b5ccbacddb85bd
  - https://git.kernel.org/stable/c/f277e479eea3d1aa18bc712abe1d2bf3dece2e30
  - https://git.kernel.org/stable/c/f618aeb6cad2307e48a641379db610abcf593edf

------------------------------------------------------------

CVE ID: CVE-2025-21845
Description: In the Linux kernel, the following vulnerability has been resolved:

mtd: spi-nor: sst: Fix SST write failure

'commit 18bcb4aa54ea ("mtd: spi-nor: sst: Factor out common write operation
to `sst_nor_write_data()`")' introduced a bug where only one byte of data
is written, regardless of the number of bytes passed to
sst_nor_write_data(), causing a kernel crash during the write operation.
Ensure the correct number of bytes are written as passed to
sst_nor_write_data().

Call trace:
[   57.400180] ------------[ cut here ]------------
[   57.404842] While writing 2 byte written 1 bytes
[   57.409493] WARNING: CPU: 0 PID: 737 at drivers/mtd/spi-nor/sst.c:187 sst_nor_write_data+0x6c/0x74
[   57.418464] Modules linked in:
[   57.421517] CPU: 0 UID: 0 PID: 737 Comm: mtd_debug Not tainted 6.12.0-g5ad04afd91f9 #30
[   57.429517] Hardware name: Xilinx Versal A2197 Processor board revA - x-prc-02 revA (DT)
[   57.437600] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   57.444557] pc : sst_nor_write_data+0x6c/0x74
[   57.448911] lr : sst_nor_write_data+0x6c/0x74
[   57.453264] sp : ffff80008232bb40
[   57.456570] x29: ffff80008232bb40 x28: 0000000000010000 x27: 0000000000000001
[   57.463708] x26: 000000000000ffff x25: 0000000000000000 x24: 0000000000000000
[   57.470843] x23: 0000000000010000 x22: ffff80008232bbf0 x21: ffff000816230000
[   57.477978] x20: ffff0008056c0080 x19: 0000000000000002 x18: 0000000000000006
[   57.485112] x17: 0000000000000000 x16: 0000000000000000 x15: ffff80008232b580
[   57.492246] x14: 0000000000000000 x13: ffff8000816d1530 x12: 00000000000004a4
[   57.499380] x11: 000000000000018c x10: ffff8000816fd530 x9 : ffff8000816d1530
[   57.506515] x8 : 00000000fffff7ff x7 : ffff8000816fd530 x6 : 0000000000000001
[   57.513649] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000
[   57.520782] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0008049b0000
[   57.527916] Call trace:
[   57.530354]  sst_nor_write_data+0x6c/0x74
[   57.534361]  sst_nor_write+0xb4/0x18c
[   57.538019]  mtd_write_oob_std+0x7c/0x88
[   57.541941]  mtd_write_oob+0x70/0xbc
[   57.545511]  mtd_write+0x68/0xa8
[   57.548733]  mtdchar_write+0x10c/0x290
[   57.552477]  vfs_write+0xb4/0x3a8
[   57.555791]  ksys_write+0x74/0x10c
[   57.559189]  __arm64_sys_write+0x1c/0x28
[   57.563109]  invoke_syscall+0x54/0x11c
[   57.566856]  el0_svc_common.constprop.0+0xc0/0xe0
[   57.571557]  do_el0_svc+0x1c/0x28
[   57.574868]  el0_svc+0x30/0xcc
[   57.577921]  el0t_64_sync_handler+0x120/0x12c
[   57.582276]  el0t_64_sync+0x190/0x194
[   57.585933] ---[ end trace 0000000000000000 ]---

[pratyush@kernel.org: add Cc stable tag]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/539bd20352832b9244238a055eb169ccf1c41ff6
  - https://git.kernel.org/stable/c/9553391f32f8c43e12fc7c04e1035160b5ea20bf
  - https://git.kernel.org/stable/c/bb1accc7e0f688886f0c634f2e878b8ac4ee6a58

------------------------------------------------------------

CVE ID: CVE-2025-21846
Description: In the Linux kernel, the following vulnerability has been resolved:

acct: perform last write from workqueue

In [1] it was reported that the acct(2) system call can be used to
trigger NULL deref in cases where it is set to write to a file that
triggers an internal lookup. This can e.g., happen when pointing acc(2)
to /sys/power/resume. At the point the where the write to this file
happens the calling task has already exited and called exit_fs(). A
lookup will thus trigger a NULL-deref when accessing current->fs.

Reorganize the code so that the the final write happens from the
workqueue but with the caller's credentials. This preserves the
(strange) permission model and has almost no regression risk.

This api should stop to exist though.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/56d5f3eba3f5de0efdd556de4ef381e109b973a9
  - https://git.kernel.org/stable/c/5a59ced8ffc71973d42c82484a719c8f6ac8f7f7
  - https://git.kernel.org/stable/c/5c928e14a2ccd99462f2351ead627b58075bb736
  - https://git.kernel.org/stable/c/5d5b936cfa4b0d5670ca7420ef165a074bc008eb
  - https://git.kernel.org/stable/c/5ee8da9bea70dda492d61f075658939af33d8410
  - https://git.kernel.org/stable/c/8acbf4a88c6a98c8ed00afd1a7d1abcca9b4735e
  - https://git.kernel.org/stable/c/a8136afca090412a36429cb6c2543c714d9c0f84
  - https://git.kernel.org/stable/c/b03782ae707cc45e65242c7cddd8e28f1c22cde5

------------------------------------------------------------

CVE ID: CVE-2025-21847
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: stream-ipc: Check for cstream nullity in sof_ipc_msg_data()

The nullity of sps->cstream should be checked similarly as it is done in
sof_set_stream_data_offset() function.
Assuming that it is not NULL if sps->stream is NULL is incorrect and can
lead to NULL pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.3, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2b3878baf90918a361a3dfd3513025100b1b40b6
  - https://git.kernel.org/stable/c/62ab1ae5511c59b5f0bf550136ff321331adca9f
  - https://git.kernel.org/stable/c/6c18f5eb2043ebf4674c08a9690218dc818a11ab
  - https://git.kernel.org/stable/c/d8d99c3b5c485f339864aeaa29f76269cc0ea975

------------------------------------------------------------

CVE ID: CVE-2025-21848
Description: In the Linux kernel, the following vulnerability has been resolved:

nfp: bpf: Add check for nfp_app_ctrl_msg_alloc()

Add check for the return value of nfp_app_ctrl_msg_alloc() in
nfp_bpf_cmsg_alloc() to prevent null pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.16, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1358d8e07afdf21d49ca6f00c56048442977e00a
  - https://git.kernel.org/stable/c/29ccb1e4040da6ff02b7e64efaa2f8e6bf06020d
  - https://git.kernel.org/stable/c/878e7b11736e062514e58f3b445ff343e6705537
  - https://git.kernel.org/stable/c/897c32cd763fd11d0b6ed024c52f44d2475bb820
  - https://git.kernel.org/stable/c/924b239f9704566e0d86abd894d2d64bd73c11eb
  - https://git.kernel.org/stable/c/bd97f60750bb581f07051f98e31dfda59d3a783b
  - https://git.kernel.org/stable/c/d64c6ca420019712e194fe095b55f87363e22a9a
  - https://git.kernel.org/stable/c/e976ea6c5e1b005c64467cbf94a8577aae9c7d81

------------------------------------------------------------

CVE ID: CVE-2025-21849
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915/gt: Use spin_lock_irqsave() in interruptible context

spin_lock/unlock() functions used in interrupt contexts could
result in a deadlock, as seen in GitLab issue #13399,
which occurs when interrupt comes in while holding a lock.

Try to remedy the problem by saving irq state before spin lock
acquisition.

v2: add irqs' state save/restore calls to all locks/unlocks in
 signal_irq_work() execution (Maciej)

v3: use with spin_lock_irqsave() in guc_lrc_desc_unpin() instead
 of other lock/unlock calls and add Fixes and Cc tags (Tvrtko);
 change title and commit message

(cherry picked from commit c088387ddd6482b40f21ccf23db1125e8fa4af7e)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2bf1f4c129db7a10920655b000f0292f1ee509c2
  - https://git.kernel.org/stable/c/47ae46ac5407646420e06b78e0dad331e56a4bb4
  - https://git.kernel.org/stable/c/e49477f7f78598295551d486ecc7f020d796432e

------------------------------------------------------------

CVE ID: CVE-2025-21850
Description: In the Linux kernel, the following vulnerability has been resolved:

nvmet: Fix crash when a namespace is disabled

The namespace percpu counter protects pending I/O, and we can
only safely diable the namespace once the counter drop to zero.
Otherwise we end up with a crash when running blktests/nvme/058
(eg for loop transport):

[ 2352.930426] [  T53909] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN PTI
[ 2352.930431] [  T53909] KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f]
[ 2352.930434] [  T53909] CPU: 3 UID: 0 PID: 53909 Comm: kworker/u16:5 Tainted: G        W          6.13.0-rc6 #232
[ 2352.930438] [  T53909] Tainted: [W]=WARN
[ 2352.930440] [  T53909] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014
[ 2352.930443] [  T53909] Workqueue: nvmet-wq nvme_loop_execute_work [nvme_loop]
[ 2352.930449] [  T53909] RIP: 0010:blkcg_set_ioprio+0x44/0x180

as the queue is already torn down when calling submit_bio();

So we need to init the percpu counter in nvmet_ns_enable(), and
wait for it to drop to zero in nvmet_ns_disable() to avoid having
I/O pending after the namespace has been disabled.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4082326807072b71496501b6a0c55ffe8d5092a5
  - https://git.kernel.org/stable/c/cc0607594f6813342b27c752c6fb6f6eb9980cb5

------------------------------------------------------------

CVE ID: CVE-2025-21851
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix softlockup in arena_map_free on 64k page kernel

On an aarch64 kernel with CONFIG_PAGE_SIZE_64KB=y,
arena_htab tests cause a segmentation fault and soft lockup.
The same failure is not observed with 4k pages on aarch64.

It turns out arena_map_free() is calling
apply_to_existing_page_range() with the address returned by
bpf_arena_get_kern_vm_start().  If this address is not page-aligned
the code ends up calling apply_to_pte_range() with that unaligned
address causing soft lockup.

Fix it by round up GUARD_SZ to PAGE_SIZE << 1 so that the
division by 2 in bpf_arena_get_kern_vm_start() returns
a page-aligned value.
Severity:
  - CVSS Version: 3.1
  - Base Score: 3.3
  - Base Severity: LOW
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.9, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/517e8a7835e8cfb398a0aeb0133de50e31cae32b
  - https://git.kernel.org/stable/c/787d556a3de447e70964a4bdeba9196f62a62b1e
  - https://git.kernel.org/stable/c/c1f3f3892d4526f18aaeffdb6068ce861e793ee3

------------------------------------------------------------

CVE ID: CVE-2025-21852
Description: In the Linux kernel, the following vulnerability has been resolved:

net: Add rx_skb of kfree_skb to raw_tp_null_args[].

Yan Zhai reported a BPF prog could trigger a null-ptr-deref [0]
in trace_kfree_skb if the prog does not check if rx_sk is NULL.

Commit c53795d48ee8 ("net: add rx_sk to trace_kfree_skb") added
rx_sk to trace_kfree_skb, but rx_sk is optional and could be NULL.

Let's add kfree_skb to raw_tp_null_args[] to let the BPF verifier
validate such a prog and prevent the issue.

Now we fail to load such a prog:

  libbpf: prog 'drop': -- BEGIN PROG LOAD LOG --
  0: R1=ctx() R10=fp0
  ; int BPF_PROG(drop, struct sk_buff *skb, void *location, @ kfree_skb_sk_null.bpf.c:21
  0: (79) r3 = *(u64 *)(r1 +24)
  func 'kfree_skb' arg3 has btf_id 5253 type STRUCT 'sock'
  1: R1=ctx() R3_w=trusted_ptr_or_null_sock(id=1)
  ; bpf_printk("sk: %d, %d\n", sk, sk->__sk_common.skc_family); @ kfree_skb_sk_null.bpf.c:24
  1: (69) r4 = *(u16 *)(r3 +16)
  R3 invalid mem access 'trusted_ptr_or_null_'
  processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
  -- END PROG LOAD LOG --

Note this fix requires commit 838a10bd2ebf ("bpf: Augment raw_tp
arguments with PTR_MAYBE_NULL").

[0]:
BUG: kernel NULL pointer dereference, address: 0000000000000010
 PF: supervisor read access in kernel mode
 PF: error_code(0x0000) - not-present page
PGD 0 P4D 0
PREEMPT SMP
RIP: 0010:bpf_prog_5e21a6db8fcff1aa_drop+0x10/0x2d
Call Trace:
 <TASK>
 ? __die+0x1f/0x60
 ? page_fault_oops+0x148/0x420
 ? search_bpf_extables+0x5b/0x70
 ? fixup_exception+0x27/0x2c0
 ? exc_page_fault+0x75/0x170
 ? asm_exc_page_fault+0x22/0x30
 ? bpf_prog_5e21a6db8fcff1aa_drop+0x10/0x2d
 bpf_trace_run4+0x68/0xd0
 ? unix_stream_connect+0x1f4/0x6f0
 sk_skb_reason_drop+0x90/0x120
 unix_stream_connect+0x1f4/0x6f0
 __sys_connect+0x7f/0xb0
 __x64_sys_connect+0x14/0x20
 do_syscall_64+0x47/0xc30
 entry_SYSCALL_64_after_hwframe+0x4b/0x53
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4dba79c1e7aad6620bbb707b6c4459380fd90860
  - https://git.kernel.org/stable/c/5da7e15fb5a12e78de974d8908f348e279922ce9
  - https://git.kernel.org/stable/c/f579afacd0a66971fc8481f30d2d377e230a8342

------------------------------------------------------------

CVE ID: CVE-2025-21853
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: avoid holding freeze_mutex during mmap operation

We use map->freeze_mutex to prevent races between map_freeze() and
memory mapping BPF map contents with writable permissions. The way we
naively do this means we'll hold freeze_mutex for entire duration of all
the mm and VMA manipulations, which is completely unnecessary. This can
potentially also lead to deadlocks, as reported by syzbot in [0].

So, instead, hold freeze_mutex only during writeability checks, bump
(proactively) "write active" count for the map, unlock the mutex and
proceed with mmap logic. And only if something went wrong during mmap
logic, then undo that "write active" counter increment.

  [0] https://lore.kernel.org/bpf/678dcbc9.050a0220.303755.0066.GAE@google.com/
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0d90d9e154144a3a80e9fc0eb9b21b7fc990f68f
  - https://git.kernel.org/stable/c/271e49f8a58edba65bc2b1250a0abaa98c4bfdbe
  - https://git.kernel.org/stable/c/29cfda62ab4d92ab94123813db49ab76c1e61b29
  - https://git.kernel.org/stable/c/2ce31c97c219b4fe797749f950274f246eb88c49
  - https://git.kernel.org/stable/c/4759acbd44d24a69b7b14848012ec4201d6c5501
  - https://git.kernel.org/stable/c/bc27c52eea189e8f7492d40739b7746d67b65beb
  - https://git.kernel.org/stable/c/d95607a5f2f9bb08194c9deaf4a5f3e8ba59a9d4

------------------------------------------------------------

CVE ID: CVE-2025-21854
Description: In the Linux kernel, the following vulnerability has been resolved:

sockmap, vsock: For connectible sockets allow only connected

sockmap expects all vsocks to have a transport assigned, which is expressed
in vsock_proto::psock_update_sk_prot(). However, there is an edge case
where an unconnected (connectible) socket may lose its previously assigned
transport. This is handled with a NULL check in the vsock/BPF recv path.

Another design detail is that listening vsocks are not supposed to have any
transport assigned at all. Which implies they are not supported by the
sockmap. But this is complicated by the fact that a socket, before
switching to TCP_LISTEN, may have had some transport assigned during a
failed connect() attempt. Hence, we may end up with a listening vsock in a
sockmap, which blows up quickly:

KASAN: null-ptr-deref in range [0x0000000000000120-0x0000000000000127]
CPU: 7 UID: 0 PID: 56 Comm: kworker/7:0 Not tainted 6.14.0-rc1+
Workqueue: vsock-loopback vsock_loopback_work
RIP: 0010:vsock_read_skb+0x4b/0x90
Call Trace:
 sk_psock_verdict_data_ready+0xa4/0x2e0
 virtio_transport_recv_pkt+0x1ca8/0x2acc
 vsock_loopback_work+0x27d/0x3f0
 process_one_work+0x846/0x1420
 worker_thread+0x5b3/0xf80
 kthread+0x35a/0x700
 ret_from_fork+0x2d/0x70
 ret_from_fork_asm+0x1a/0x30

For connectible sockets, instead of relying solely on the state of
vsk->transport, tell sockmap to only allow those representing established
connections. This aligns with the behaviour for AF_INET and AF_UNIX.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/22b683217ad2112791a708693cb236507abd637a
  - https://git.kernel.org/stable/c/8fb5bb169d17cdd12c2dcc2e96830ed487d77a0f
  - https://git.kernel.org/stable/c/cc9a7832ede53ade1ba9991f0e27314caa4029d8
  - https://git.kernel.org/stable/c/f7b473e35986835cc2813fef7b9d40336a09247e

------------------------------------------------------------

CVE ID: CVE-2025-21855
Description: In the Linux kernel, the following vulnerability has been resolved:

ibmvnic: Don't reference skb after sending to VIOS

Previously, after successfully flushing the xmit buffer to VIOS,
the tx_bytes stat was incremented by the length of the skb.

It is invalid to access the skb memory after sending the buffer to
the VIOS because, at any point after sending, the VIOS can trigger
an interrupt to free this memory. A race between reading skb->len
and freeing the skb is possible (especially during LPM) and will
result in use-after-free:
 ==================================================================
 BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic]
 Read of size 4 at addr c00000024eb48a70 by task hxecom/14495
 <...>
 Call Trace:
 [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable)
 [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0
 [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8
 [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0
 [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic]
 [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358
 <...>
 Freed by task 0:
 kasan_save_stack+0x34/0x68
 kasan_save_track+0x2c/0x50
 kasan_save_free_info+0x64/0x108
 __kasan_mempool_poison_object+0x148/0x2d4
 napi_skb_cache_put+0x5c/0x194
 net_tx_action+0x154/0x5b8
 handle_softirqs+0x20c/0x60c
 do_softirq_own_stack+0x6c/0x88
 <...>
 The buggy address belongs to the object at c00000024eb48a00 which
  belongs to the cache skbuff_head_cache of size 224
==================================================================
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.5, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/093b0e5c90592773863f300b908b741622eef597
  - https://git.kernel.org/stable/c/25dddd01dcc8ef3acff964dbb32eeb0d89f098e9
  - https://git.kernel.org/stable/c/501ac6a7e21b82e05207c6b4449812d82820f306
  - https://git.kernel.org/stable/c/abaff2717470e4b5b7c0c3a90e128b211a23da09
  - https://git.kernel.org/stable/c/bdf5d13aa05ec314d4385b31ac974d6c7e0997c9

------------------------------------------------------------

CVE ID: CVE-2025-21856
Description: In the Linux kernel, the following vulnerability has been resolved:

s390/ism: add release function for struct device

According to device_release() in /drivers/base/core.c,
a device without a release function is a broken device
and must be fixed.

The current code directly frees the device after calling device_add()
without waiting for other kernel parts to release their references.
Thus, a reference could still be held to a struct device,
e.g., by sysfs, leading to potential use-after-free
issues if a proper release function is not set.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.3, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0505ff2936f166405d81d0d454a81d9c14124344
  - https://git.kernel.org/stable/c/915e34d5ad35a6a9e56113f852ade4a730fb88f0
  - https://git.kernel.org/stable/c/940d15254d2216b585558bcf36312da50074e711
  - https://git.kernel.org/stable/c/e26e8ac27351f457091459a0a355bacd06d5bb2b

------------------------------------------------------------

CVE ID: CVE-2025-21857
Description: In the Linux kernel, the following vulnerability has been resolved:

net/sched: cls_api: fix error handling causing NULL dereference

tcf_exts_miss_cookie_base_alloc() calls xa_alloc_cyclic() which can
return 1 if the allocation succeeded after wrapping. This was treated as
an error, with value 1 returned to caller tcf_exts_init_ex() which sets
exts->actions to NULL and returns 1 to caller fl_change().

fl_change() treats err == 1 as success, calling tcf_exts_validate_ex()
which calls tcf_action_init() with exts->actions as argument, where it
is dereferenced.

Example trace:

BUG: kernel NULL pointer dereference, address: 0000000000000000
CPU: 114 PID: 16151 Comm: handler114 Kdump: loaded Not tainted 5.14.0-503.16.1.el9_5.x86_64 #1
RIP: 0010:tcf_action_init+0x1f8/0x2c0
Call Trace:
 tcf_action_init+0x1f8/0x2c0
 tcf_exts_validate_ex+0x175/0x190
 fl_change+0x537/0x1120 [cls_flower]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.3, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/071ed42cff4fcdd89025d966d48eabef59913bf2
  - https://git.kernel.org/stable/c/3c74b5787caf59bb1e9c5fe0a360643a71eb1e8a
  - https://git.kernel.org/stable/c/3e4c56cf41876ef2a82f0877fe2a67648f8632b8
  - https://git.kernel.org/stable/c/de4b679aa3b4da7ec34f639df068b914f20e3c3c

------------------------------------------------------------

CVE ID: CVE-2025-21858
Description: In the Linux kernel, the following vulnerability has been resolved:

geneve: Fix use-after-free in geneve_find_dev().

syzkaller reported a use-after-free in geneve_find_dev() [0]
without repro.

geneve_configure() links struct geneve_dev.next to
net_generic(net, geneve_net_id)->geneve_list.

The net here could differ from dev_net(dev) if IFLA_NET_NS_PID,
IFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set.

When dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally
calls unregister_netdevice_queue() for each dev in the netns,
and later the dev is freed.

However, its geneve_dev.next is still linked to the backend UDP
socket netns.

Then, use-after-free will occur when another geneve dev is created
in the netns.

Let's call geneve_dellink() instead in geneve_destroy_tunnels().

[0]:
BUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline]
BUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343
Read of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441

CPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d
Hardware name: linux,dummy-virt (DT)
Call trace:
 show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:378 [inline]
 print_report+0x16c/0x6f0 mm/kasan/report.c:489
 kasan_report+0xc0/0x120 mm/kasan/report.c:602
 __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379
 geneve_find_dev drivers/net/geneve.c:1295 [inline]
 geneve_configure+0x234/0x858 drivers/net/geneve.c:1343
 geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634
 rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795
 __rtnl_newlink net/core/rtnetlink.c:3906 [inline]
 rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021
 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911
 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543
 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938
 netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]
 netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348
 netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892
 sock_sendmsg_nosec net/socket.c:713 [inline]
 __sock_sendmsg net/socket.c:728 [inline]
 ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568
 ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622
 __sys_sendmsg net/socket.c:2654 [inline]
 __do_sys_sendmsg net/socket.c:2659 [inline]
 __se_sys_sendmsg net/socket.c:2657 [inline]
 __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657
 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]
 invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49
 el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132
 do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151
 el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744
 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762
 el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600

Allocated by task 13247:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x30/0x68 mm/kasan/common.c:68
 kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568
 poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
 __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __do_kmalloc_node mm/slub.c:4298 [inline]
 __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304
 __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645
 alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470
 rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604
 rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780
 __rtnl_newlink net/core/rtnetlink.c:3906 [inline]
 rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021
 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911
 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543
 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938
 netlink_unicast_kernel net/netlink/af_n
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.2, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3ce92ca990cfac88a87c61df3cc0b5880e688ecf
  - https://git.kernel.org/stable/c/5a0538ac6826807d6919f6aecbb8996c2865af2c
  - https://git.kernel.org/stable/c/788dbca056a8783ec063da3c9d49a3a71c76c283
  - https://git.kernel.org/stable/c/904e746b2e7fa952ab8801b303ce826a63153d78
  - https://git.kernel.org/stable/c/9593172d93b9f91c362baec4643003dc29802929
  - https://git.kernel.org/stable/c/d5e86e27de0936f3cb0a299ce519d993e9cf3886
  - https://git.kernel.org/stable/c/da9b0ae47f084014b1e4b3f31f70a0defd047ff3
  - https://git.kernel.org/stable/c/f74f6560146714241c6e167b03165ee77a86e316

------------------------------------------------------------

CVE ID: CVE-2025-21859
Description: In the Linux kernel, the following vulnerability has been resolved:

USB: gadget: f_midi: f_midi_complete to call queue_work

When using USB MIDI, a lock is attempted to be acquired twice through a
re-entrant call to f_midi_transmit, causing a deadlock.

Fix it by using queue_work() to schedule the inner f_midi_transmit() via
a high priority work queue from the completion handler.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.2, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1f10923404705a94891e612dff3b75e828a78368
  - https://git.kernel.org/stable/c/24a942610ee9bafb2692a456ae850c5b2e409b05
  - https://git.kernel.org/stable/c/4ab37fcb42832cdd3e9d5e50653285ca84d6686f
  - https://git.kernel.org/stable/c/727dee0857946b85232526de4f5a957fe163e89a
  - https://git.kernel.org/stable/c/8aa6b4be1f4efccbfc533e6ec8841d26e4fa8dba
  - https://git.kernel.org/stable/c/b09957657d7767d164b3432af2129bd72947553c
  - https://git.kernel.org/stable/c/deeee3adb2c01eedab32c3b4519337689ad02e8a
  - https://git.kernel.org/stable/c/e9fec6f42c45db2f62dc373fb1a10d2488c04e79

------------------------------------------------------------

CVE ID: CVE-2025-21860
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/zswap: fix inconsistency when zswap_store_page() fails

Commit b7c0ccdfbafd ("mm: zswap: support large folios in zswap_store()")
skips charging any zswap entries when it failed to zswap the entire folio.

However, when some base pages are zswapped but it failed to zswap the
entire folio, the zswap operation is rolled back.  When freeing zswap
entries for those pages, zswap_entry_free() uncharges the zswap entries
that were not previously charged, causing zswap charging to become
inconsistent.

This inconsistency triggers two warnings with following steps:
  # On a machine with 64GiB of RAM and 36GiB of zswap
  $ stress-ng --bigheap 2 # wait until the OOM-killer kills stress-ng
  $ sudo reboot

  The two warnings are:
    in mm/memcontrol.c:163, function obj_cgroup_release():
      WARN_ON_ONCE(nr_bytes & (PAGE_SIZE - 1));

    in mm/page_counter.c:60, function page_counter_cancel():
      if (WARN_ONCE(new < 0, "page_counter underflow: %ld nr_pages=%lu\n",
	  new, nr_pages))

zswap_stored_pages also becomes inconsistent in the same way.

As suggested by Kanchana, increment zswap_stored_pages and charge zswap
entries within zswap_store_page() when it succeeds.  This way,
zswap_entry_free() will decrement the counter and uncharge the entries
when it failed to zswap the entire folio.

While this could potentially be optimized by batching objcg charging and
incrementing the counter, let's focus on fixing the bug this time and
leave the optimization for later after some evaluation.

After resolving the inconsistency, the warnings disappear.

[42.hyeyoo@gmail.com: refactor zswap_store_page()]
Severity:
  - CVSS Version: 3.1
  - Base Score: 3.3
  - Base Severity: LOW
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/63895d20d63b446f5049a963983489319c2ea3e2
  - https://git.kernel.org/stable/c/a3652f5552b20903315612da487a7be2b95394d5

------------------------------------------------------------

CVE ID: CVE-2025-21861
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/migrate_device: don't add folio to be freed to LRU in migrate_device_finalize()

If migration succeeded, we called
folio_migrate_flags()->mem_cgroup_migrate() to migrate the memcg from the
old to the new folio.  This will set memcg_data of the old folio to 0.

Similarly, if migration failed, memcg_data of the dst folio is left unset.

If we call folio_putback_lru() on such folios (memcg_data == 0), we will
add the folio to be freed to the LRU, making memcg code unhappy.  Running
the hmm selftests:

  # ./hmm-tests
  ...
  #  RUN           hmm.hmm_device_private.migrate ...
  [  102.078007][T14893] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x7ff27d200 pfn:0x13cc00
  [  102.079974][T14893] anon flags: 0x17ff00000020018(uptodate|dirty|swapbacked|node=0|zone=2|lastcpupid=0x7ff)
  [  102.082037][T14893] raw: 017ff00000020018 dead000000000100 dead000000000122 ffff8881353896c9
  [  102.083687][T14893] raw: 00000007ff27d200 0000000000000000 00000001ffffffff 0000000000000000
  [  102.085331][T14893] page dumped because: VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled())
  [  102.087230][T14893] ------------[ cut here ]------------
  [  102.088279][T14893] WARNING: CPU: 0 PID: 14893 at ./include/linux/memcontrol.h:726 folio_lruvec_lock_irqsave+0x10e/0x170
  [  102.090478][T14893] Modules linked in:
  [  102.091244][T14893] CPU: 0 UID: 0 PID: 14893 Comm: hmm-tests Not tainted 6.13.0-09623-g6c216bc522fd #151
  [  102.093089][T14893] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014
  [  102.094848][T14893] RIP: 0010:folio_lruvec_lock_irqsave+0x10e/0x170
  [  102.096104][T14893] Code: ...
  [  102.099908][T14893] RSP: 0018:ffffc900236c37b0 EFLAGS: 00010293
  [  102.101152][T14893] RAX: 0000000000000000 RBX: ffffea0004f30000 RCX: ffffffff8183f426
  [  102.102684][T14893] RDX: ffff8881063cb880 RSI: ffffffff81b8117f RDI: ffff8881063cb880
  [  102.104227][T14893] RBP: 0000000000000000 R08: 0000000000000005 R09: 0000000000000000
  [  102.105757][T14893] R10: 0000000000000001 R11: 0000000000000002 R12: ffffc900236c37d8
  [  102.107296][T14893] R13: ffff888277a2bcb0 R14: 000000000000001f R15: 0000000000000000
  [  102.108830][T14893] FS:  00007ff27dbdd740(0000) GS:ffff888277a00000(0000) knlGS:0000000000000000
  [  102.110643][T14893] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  [  102.111924][T14893] CR2: 00007ff27d400000 CR3: 000000010866e000 CR4: 0000000000750ef0
  [  102.113478][T14893] PKRU: 55555554
  [  102.114172][T14893] Call Trace:
  [  102.114805][T14893]  <TASK>
  [  102.115397][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170
  [  102.116547][T14893]  ? __warn.cold+0x110/0x210
  [  102.117461][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170
  [  102.118667][T14893]  ? report_bug+0x1b9/0x320
  [  102.119571][T14893]  ? handle_bug+0x54/0x90
  [  102.120494][T14893]  ? exc_invalid_op+0x17/0x50
  [  102.121433][T14893]  ? asm_exc_invalid_op+0x1a/0x20
  [  102.122435][T14893]  ? __wake_up_klogd.part.0+0x76/0xd0
  [  102.123506][T14893]  ? dump_page+0x4f/0x60
  [  102.124352][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170
  [  102.125500][T14893]  folio_batch_move_lru+0xd4/0x200
  [  102.126577][T14893]  ? __pfx_lru_add+0x10/0x10
  [  102.127505][T14893]  __folio_batch_add_and_move+0x391/0x720
  [  102.128633][T14893]  ? __pfx_lru_add+0x10/0x10
  [  102.129550][T14893]  folio_putback_lru+0x16/0x80
  [  102.130564][T14893]  migrate_device_finalize+0x9b/0x530
  [  102.131640][T14893]  dmirror_migrate_to_device.constprop.0+0x7c5/0xad0
  [  102.133047][T14893]  dmirror_fops_unlocked_ioctl+0x89b/0xc80

Likely, nothing else goes wrong: putting the last folio reference will
remove the folio from the LRU again.  So besides memcg complaining, adding
the folio to be freed to the LRU is just an unnecessary step.

The new flow resembles what we have in migrate_folio_move(): add the dst
to the lru, rem
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/069dd21ea8262204f94737878389c2815a054a9e
  - https://git.kernel.org/stable/c/3f9240d59e9a95d19f06120bfd1d0e681c6c0ac7
  - https://git.kernel.org/stable/c/41cddf83d8b00f29fd105e7a0777366edc69a5cf

------------------------------------------------------------

CVE ID: CVE-2025-21862
Description: In the Linux kernel, the following vulnerability has been resolved:

drop_monitor: fix incorrect initialization order

Syzkaller reports the following bug:

BUG: spinlock bad magic on CPU#1, syz-executor.0/7995
 lock: 0xffff88805303f3e0, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0
CPU: 1 PID: 7995 Comm: syz-executor.0 Tainted: G            E     5.10.209+ #1
Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x119/0x179 lib/dump_stack.c:118
 debug_spin_lock_before kernel/locking/spinlock_debug.c:83 [inline]
 do_raw_spin_lock+0x1f6/0x270 kernel/locking/spinlock_debug.c:112
 __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:117 [inline]
 _raw_spin_lock_irqsave+0x50/0x70 kernel/locking/spinlock.c:159
 reset_per_cpu_data+0xe6/0x240 [drop_monitor]
 net_dm_cmd_trace+0x43d/0x17a0 [drop_monitor]
 genl_family_rcv_msg_doit+0x22f/0x330 net/netlink/genetlink.c:739
 genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]
 genl_rcv_msg+0x341/0x5a0 net/netlink/genetlink.c:800
 netlink_rcv_skb+0x14d/0x440 net/netlink/af_netlink.c:2497
 genl_rcv+0x29/0x40 net/netlink/genetlink.c:811
 netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]
 netlink_unicast+0x54b/0x800 net/netlink/af_netlink.c:1348
 netlink_sendmsg+0x914/0xe00 net/netlink/af_netlink.c:1916
 sock_sendmsg_nosec net/socket.c:651 [inline]
 __sock_sendmsg+0x157/0x190 net/socket.c:663
 ____sys_sendmsg+0x712/0x870 net/socket.c:2378
 ___sys_sendmsg+0xf8/0x170 net/socket.c:2432
 __sys_sendmsg+0xea/0x1b0 net/socket.c:2461
 do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46
 entry_SYSCALL_64_after_hwframe+0x62/0xc7
RIP: 0033:0x7f3f9815aee9
Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f3f972bf0c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
RAX: ffffffffffffffda RBX: 00007f3f9826d050 RCX: 00007f3f9815aee9
RDX: 0000000020000000 RSI: 0000000020001300 RDI: 0000000000000007
RBP: 00007f3f981b63bd R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
R13: 000000000000006e R14: 00007f3f9826d050 R15: 00007ffe01ee6768

If drop_monitor is built as a kernel module, syzkaller may have time
to send a netlink NET_DM_CMD_START message during the module loading.
This will call the net_dm_monitor_start() function that uses
a spinlock that has not yet been initialized.

To fix this, let's place resource initialization above the registration
of a generic netlink family.

Found by InfoTeCS on behalf of Linux Verification Center
(linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.30, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07b598c0e6f06a0f254c88dafb4ad50f8a8c6eea
  - https://git.kernel.org/stable/c/0efa6c42f81c60d8f72ba7f5ed8d4fec8c526282
  - https://git.kernel.org/stable/c/219a47d0e6195bd202f22855e35f25bd15bc4d58
  - https://git.kernel.org/stable/c/29f9cdcab3d96d5207a5c92b52c40ad75e5915d8
  - https://git.kernel.org/stable/c/6e9e0f224ffd8b819da3ea247dda404795fdd182
  - https://git.kernel.org/stable/c/872c7c7e57a746046796ddfead529c9d37b9f6b4
  - https://git.kernel.org/stable/c/b7859e8643e75619b2705b4fcac93ffd94d72b4a
  - https://git.kernel.org/stable/c/fcfc00bfec7bb6661074cb21356d05a4c9470a3c

------------------------------------------------------------

CVE ID: CVE-2025-21863
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring: prevent opcode speculation

sqe->opcode is used for different tables, make sure we santitise it
against speculations.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.6, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1e988c3fe1264708f4f92109203ac5b1d65de50b
  - https://git.kernel.org/stable/c/506b9b5e8c2d2a411ea8fe361333f5081c56d23a
  - https://git.kernel.org/stable/c/b9826e3b26ec031e9063f64a7c735449c43955e4
  - https://git.kernel.org/stable/c/fdbfd52bd8b85ed6783365ff54c82ab7067bd61b

------------------------------------------------------------

CVE ID: CVE-2025-21864
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: drop secpath at the same time as we currently drop dst

Xiumei reported hitting the WARN in xfrm6_tunnel_net_exit while
running tests that boil down to:
 - create a pair of netns
 - run a basic TCP test over ipcomp6
 - delete the pair of netns

The xfrm_state found on spi_byaddr was not deleted at the time we
delete the netns, because we still have a reference on it. This
lingering reference comes from a secpath (which holds a ref on the
xfrm_state), which is still attached to an skb. This skb is not
leaked, it ends up on sk_receive_queue and then gets defer-free'd by
skb_attempt_defer_free.

The problem happens when we defer freeing an skb (push it on one CPU's
defer_list), and don't flush that list before the netns is deleted. In
that case, we still have a reference on the xfrm_state that we don't
expect at this point.

We already drop the skb's dst in the TCP receive path when it's no
longer needed, so let's also drop the secpath. At this point,
tcp_filter has already called into the LSM hooks that may require the
secpath, so it should not be needed anymore. However, in some of those
places, the MPTCP extension has just been attached to the skb, so we
cannot simply drop all extensions.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/69cafd9413084cd5012cf5d7c7ec6f3d493726d9
  - https://git.kernel.org/stable/c/87858bbf21da239ace300d61dd209907995c0491
  - https://git.kernel.org/stable/c/9b6412e6979f6f9e0632075f8f008937b5cd4efd
  - https://git.kernel.org/stable/c/cd34a07f744451e2ecf9005bb7d24d0b2fb83656
  - https://git.kernel.org/stable/c/f1d5e6a5e468308af7759cf5276779d3155c5e98

------------------------------------------------------------

CVE ID: CVE-2025-21865
Description: In the Linux kernel, the following vulnerability has been resolved:

gtp: Suppress list corruption splat in gtp_net_exit_batch_rtnl().

Brad Spengler reported the list_del() corruption splat in
gtp_net_exit_batch_rtnl(). [0]

Commit eb28fd76c0a0 ("gtp: Destroy device along with udp socket's netns
dismantle.") added the for_each_netdev() loop in gtp_net_exit_batch_rtnl()
to destroy devices in each netns as done in geneve and ip tunnels.

However, this could trigger ->dellink() twice for the same device during
->exit_batch_rtnl().

Say we have two netns A & B and gtp device B that resides in netns B but
whose UDP socket is in netns A.

  1. cleanup_net() processes netns A and then B.

  2. gtp_net_exit_batch_rtnl() finds the device B while iterating
     netns A's gn->gtp_dev_list and calls ->dellink().

  [ device B is not yet unlinked from netns B
    as unregister_netdevice_many() has not been called. ]

  3. gtp_net_exit_batch_rtnl() finds the device B while iterating
     netns B's for_each_netdev() and calls ->dellink().

gtp_dellink() cleans up the device's hash table, unlinks the dev from
gn->gtp_dev_list, and calls unregister_netdevice_queue().

Basically, calling gtp_dellink() multiple times is fine unless
CONFIG_DEBUG_LIST is enabled.

Let's remove for_each_netdev() in gtp_net_exit_batch_rtnl() and
delegate the destruction to default_device_exit_batch() as done
in bareudp.

[0]:
list_del corruption, ffff8880aaa62c00->next (autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]) is LIST_POISON1 (ffffffffffffff02) (prev is 0xffffffffffffff04)
kernel BUG at lib/list_debug.c:58!
Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN
CPU: 1 UID: 0 PID: 1804 Comm: kworker/u8:7 Tainted: G                T   6.12.13-grsec-full-20250211091339 #1
Tainted: [T]=RANDSTRUCT
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
Workqueue: netns cleanup_net
RIP: 0010:[<ffffffff84947381>] __list_del_entry_valid_or_report+0x141/0x200 lib/list_debug.c:58
Code: c2 76 91 31 c0 e8 9f b1 f7 fc 0f 0b 4d 89 f0 48 c7 c1 02 ff ff ff 48 89 ea 48 89 ee 48 c7 c7 e0 c2 76 91 31 c0 e8 7f b1 f7 fc <0f> 0b 4d 89 e8 48 c7 c1 04 ff ff ff 48 89 ea 48 89 ee 48 c7 c7 60
RSP: 0018:fffffe8040b4fbd0 EFLAGS: 00010283
RAX: 00000000000000cc RBX: dffffc0000000000 RCX: ffffffff818c4054
RDX: ffffffff84947381 RSI: ffffffff818d1512 RDI: 0000000000000000
RBP: ffff8880aaa62c00 R08: 0000000000000001 R09: fffffbd008169f32
R10: fffffe8040b4f997 R11: 0000000000000001 R12: a1988d84f24943e4
R13: ffffffffffffff02 R14: ffffffffffffff04 R15: ffff8880aaa62c08
RBX: kasan shadow of 0x0
RCX: __wake_up_klogd.part.0+0x74/0xe0 kernel/printk/printk.c:4554
RDX: __list_del_entry_valid_or_report+0x141/0x200 lib/list_debug.c:58
RSI: vprintk+0x72/0x100 kernel/printk/printk_safe.c:71
RBP: autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]
RSP: process kstack fffffe8040b4fbd0+0x7bd0/0x8000 [kworker/u8:7+netns 1804 ]
R09: kasan shadow of process kstack fffffe8040b4f990+0x7990/0x8000 [kworker/u8:7+netns 1804 ]
R10: process kstack fffffe8040b4f997+0x7997/0x8000 [kworker/u8:7+netns 1804 ]
R15: autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc08/0x1000 [slab object]
FS:  0000000000000000(0000) GS:ffff888116000000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000748f5372c000 CR3: 0000000015408000 CR4: 00000000003406f0 shadow CR4: 00000000003406f0
Stack:
 0000000000000000 ffffffff8a0c35e7 ffffffff8a0c3603 ffff8880aaa62c00
 ffff8880aaa62c00 0000000000000004 ffff88811145311c 0000000000000005
 0000000000000001 ffff8880aaa62000 fffffe8040b4fd40 ffffffff8a0c360d
Call Trace:
 <TASK>
 [<ffffffff8a0c360d>] __list_del_entry_valid include/linux/list.h:131 [inline] fffffe8040b4fc28
 [<ffffffff8a0c360d>] __list_del_entry include/linux/list.h:248 [inline] fffffe8040b4fc28
 [<ffffffff8a0c360d>] list_del include/linux/list.h:262 [inl
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.127, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.74, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.11, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 5.4.290, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.10.234, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.15.177, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/33eb925c0c26e86ca540a08254806512bf911f22
  - https://git.kernel.org/stable/c/37e7644b961600ef0beb01d3970c3034a62913af
  - https://git.kernel.org/stable/c/4ccacf86491d33d2486b62d4d44864d7101b299d
  - https://git.kernel.org/stable/c/7f86fb07db65a470d0c11f79da551bd9466357dc
  - https://git.kernel.org/stable/c/9d03e7e37187ae140e716377599493987fb20c5b
  - https://git.kernel.org/stable/c/b70fa591b066d52b141fc430ffdee35b6cc87a66
  - https://git.kernel.org/stable/c/cb15bb1bde0ba97cbbed9508e45210dcafec3657
  - https://git.kernel.org/stable/c/ff81b14010362f6188ca26fec22ff05e4da45595

------------------------------------------------------------

CVE ID: CVE-2025-21866
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/code-patching: Fix KASAN hit by not flagging text patching area as VM_ALLOC

Erhard reported the following KASAN hit while booting his PowerMac G4
with a KASAN-enabled kernel 6.13-rc6:

  BUG: KASAN: vmalloc-out-of-bounds in copy_to_kernel_nofault+0xd8/0x1c8
  Write of size 8 at addr f1000000 by task chronyd/1293

  CPU: 0 UID: 123 PID: 1293 Comm: chronyd Tainted: G        W          6.13.0-rc6-PMacG4 #2
  Tainted: [W]=WARN
  Hardware name: PowerMac3,6 7455 0x80010303 PowerMac
  Call Trace:
  [c2437590] [c1631a84] dump_stack_lvl+0x70/0x8c (unreliable)
  [c24375b0] [c0504998] print_report+0xdc/0x504
  [c2437610] [c050475c] kasan_report+0xf8/0x108
  [c2437690] [c0505a3c] kasan_check_range+0x24/0x18c
  [c24376a0] [c03fb5e4] copy_to_kernel_nofault+0xd8/0x1c8
  [c24376c0] [c004c014] patch_instructions+0x15c/0x16c
  [c2437710] [c00731a8] bpf_arch_text_copy+0x60/0x7c
  [c2437730] [c0281168] bpf_jit_binary_pack_finalize+0x50/0xac
  [c2437750] [c0073cf4] bpf_int_jit_compile+0xb30/0xdec
  [c2437880] [c0280394] bpf_prog_select_runtime+0x15c/0x478
  [c24378d0] [c1263428] bpf_prepare_filter+0xbf8/0xc14
  [c2437990] [c12677ec] bpf_prog_create_from_user+0x258/0x2b4
  [c24379d0] [c027111c] do_seccomp+0x3dc/0x1890
  [c2437ac0] [c001d8e0] system_call_exception+0x2dc/0x420
  [c2437f30] [c00281ac] ret_from_syscall+0x0/0x2c
  --- interrupt: c00 at 0x5a1274
  NIP:  005a1274 LR: 006a3b3c CTR: 005296c8
  REGS: c2437f40 TRAP: 0c00   Tainted: G        W           (6.13.0-rc6-PMacG4)
  MSR:  0200f932 <VEC,EE,PR,FP,ME,IR,DR,RI>  CR: 24004422  XER: 00000000

  GPR00: 00000166 af8f3fa0 a7ee3540 00000001 00000000 013b6500 005a5858 0200f932
  GPR08: 00000000 00001fe9 013d5fc8 005296c8 2822244c 00b2fcd8 00000000 af8f4b57
  GPR16: 00000000 00000001 00000000 00000000 00000000 00000001 00000000 00000002
  GPR24: 00afdbb0 00000000 00000000 00000000 006e0004 013ce060 006e7c1c 00000001
  NIP [005a1274] 0x5a1274
  LR [006a3b3c] 0x6a3b3c
  --- interrupt: c00

  The buggy address belongs to the virtual mapping at
   [f1000000, f1002000) created by:
   text_area_cpu_up+0x20/0x190

  The buggy address belongs to the physical page:
  page: refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x76e30
  flags: 0x80000000(zone=2)
  raw: 80000000 00000000 00000122 00000000 00000000 00000000 ffffffff 00000001
  raw: 00000000
  page dumped because: kasan: bad access detected

  Memory state around the buggy address:
   f0ffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   f0ffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  >f1000000: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8
             ^
   f1000080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8
   f1000100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8
  ==================================================================

f8 corresponds to KASAN_VMALLOC_INVALID which means the area is not
initialised hence not supposed to be used yet.

Powerpc text patching infrastructure allocates a virtual memory area
using get_vm_area() and flags it as VM_ALLOC. But that flag is meant
to be used for vmalloc() and vmalloc() allocated memory is not
supposed to be used before a call to __vmalloc_node_range() which is
never called for that area.

That went undetected until commit e4137f08816b ("mm, kasan, kmsan:
instrument copy_from/to_kernel_nofault")

The area allocated by text_area_cpu_up() is not vmalloc memory, it is
mapped directly on demand when needed by map_kernel_page(). There is
no VM flag corresponding to such usage, so just pass no flag. That way
the area will be unpoisonned and usable immediately.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.13, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2d542f13d26344e3452eee77613026ce9b653065
  - https://git.kernel.org/stable/c/2e6c80423f201405fd65254e52decd21663896f3
  - https://git.kernel.org/stable/c/6847b3e40bb963e57b61d1cc6fe84cb37b9d3d4c
  - https://git.kernel.org/stable/c/8d06e9208184b2851fa79a3a39d6860320c8bdf8
  - https://git.kernel.org/stable/c/97de5852058a299ba447cd9782fe96488d30108b
  - https://git.kernel.org/stable/c/c905a3053518212a1017e50bd2be3bee59305bb0
  - https://git.kernel.org/stable/c/d262a192d38e527faa5984629aabda2e0d1c4f54
  - https://git.kernel.org/stable/c/f8d4c5b653c1bc0df56e15658bbf64fc359adc4e

------------------------------------------------------------

CVE ID: CVE-2025-20141
Description: A vulnerability in the handling of specific packets that are punted from a line card to a route processor in Cisco IOS XR Software Release 7.9.2 could allow an unauthenticated, adjacent attacker to cause control plane traffic to stop working on multiple Cisco IOS XR platforms.&nbsp;

This vulnerability is due to incorrect handling of packets that are punted to the route processor. An attacker could exploit this vulnerability by sending traffic, which must be handled by the Linux stack on the route processor, to an affected device. A successful exploit could allow the attacker to cause control plane traffic to stop working, resulting in a denial of service (DoS) condition.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.4
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://blog.apnic.net/2024/09/02/crafting-endless-as-paths-in-bgp/
  - https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-xr792-bWfVDPY

------------------------------------------------------------

CVE ID: CVE-2025-0117
Description: A reliance on untrusted input for a security decision in the GlobalProtect app on Windows devices potentially enables a locally authenticated non-administrative Windows user to escalate their privileges to NT AUTHORITY\SYSTEM.

GlobalProtect App on macOS, Linux, iOS, Android, Chrome OS and GlobalProtect UWP App are not affected.
Severity:
  - CVSS Version: 4.0
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:4.0/AV:L/AC:L/AT:N/PR:L/UI:P/VC:N/VI:H/VA:N/SC:H/SI:H/SA:H/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:N/R:U/V:D/RE:M/U:Amber
CPEs:
  - No CPE data available.
References:
  - https://security.paloaltonetworks.com/CVE-2025-0117

------------------------------------------------------------

CVE ID: CVE-2024-26290
Description: Improper Input Validation vulnerability in Avid Avid NEXIS E-series on Linux, Avid Avid NEXIS F-series on Linux, Avid Avid NEXIS PRO+ on Linux, Avid System Director Appliance (SDA+) on Linux allows code execution on underlying operating system with root permissions.This issue affects Avid NEXIS E-series: before 2024.6.0; Avid NEXIS F-series: before 2024.6.0; Avid NEXIS PRO+: before 2024.6.0; System Director Appliance (SDA+): before 2024.6.0.
Severity:
  - CVSS Version: 4.0
  - Base Score: 8.7
  - Base Severity: HIGH
  - CVSS Vector: CVSS:4.0/AV:N/AC:L/AT:N/PR:L/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - No CPE data available.
References:
  - https://kb.avid.com/pkb/articles/troubleshooting/en239659
  - https://www.drive-byte.de/en/blog/avid-nexis-agent-multiple-vulnerabilities
  - https://raeph123.github.io/BlogPosts/Avid_Nexis/Advisory_Avid_Nexus_Agent_Multiple_Vulnerabilities_en.html

------------------------------------------------------------

CVE ID: CVE-2023-52927
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: allow exp not to be removed in nf_ct_find_expectation

Currently nf_conntrack_in() calling nf_ct_find_expectation() will
remove the exp from the hash table. However, in some scenario, we
expect the exp not to be removed when the created ct will not be
confirmed, like in OVS and TC conntrack in the following patches.

This patch allows exp not to be removed by setting IPS_CONFIRMED
in the status of the tmpl.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3fa58a6fbd1e9e5682d09cdafb08fba004cb12ec
  - https://git.kernel.org/stable/c/4914109a8e1e494c6aa9852f9e84ec77a5fc643f

------------------------------------------------------------

CVE ID: CVE-2025-21867
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, test_run: Fix use-after-free issue in eth_skb_pkt_type()

KMSAN reported a use-after-free issue in eth_skb_pkt_type()[1]. The
cause of the issue was that eth_skb_pkt_type() accessed skb's data
that didn't contain an Ethernet header. This occurs when
bpf_prog_test_run_xdp() passes an invalid value as the user_data
argument to bpf_test_init().

Fix this by returning an error when user_data is less than ETH_HLEN in
bpf_test_init(). Additionally, remove the check for "if (user_size >
size)" as it is unnecessary.

[1]
BUG: KMSAN: use-after-free in eth_skb_pkt_type include/linux/etherdevice.h:627 [inline]
BUG: KMSAN: use-after-free in eth_type_trans+0x4ee/0x980 net/ethernet/eth.c:165
 eth_skb_pkt_type include/linux/etherdevice.h:627 [inline]
 eth_type_trans+0x4ee/0x980 net/ethernet/eth.c:165
 __xdp_build_skb_from_frame+0x5a8/0xa50 net/core/xdp.c:635
 xdp_recv_frames net/bpf/test_run.c:272 [inline]
 xdp_test_run_batch net/bpf/test_run.c:361 [inline]
 bpf_test_run_xdp_live+0x2954/0x3330 net/bpf/test_run.c:390
 bpf_prog_test_run_xdp+0x148e/0x1b10 net/bpf/test_run.c:1318
 bpf_prog_test_run+0x5b7/0xa30 kernel/bpf/syscall.c:4371
 __sys_bpf+0x6a6/0xe20 kernel/bpf/syscall.c:5777
 __do_sys_bpf kernel/bpf/syscall.c:5866 [inline]
 __se_sys_bpf kernel/bpf/syscall.c:5864 [inline]
 __x64_sys_bpf+0xa4/0xf0 kernel/bpf/syscall.c:5864
 x64_sys_call+0x2ea0/0x3d90 arch/x86/include/generated/asm/syscalls_64.h:322
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xd9/0x1d0 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

Uninit was created at:
 free_pages_prepare mm/page_alloc.c:1056 [inline]
 free_unref_page+0x156/0x1320 mm/page_alloc.c:2657
 __free_pages+0xa3/0x1b0 mm/page_alloc.c:4838
 bpf_ringbuf_free kernel/bpf/ringbuf.c:226 [inline]
 ringbuf_map_free+0xff/0x1e0 kernel/bpf/ringbuf.c:235
 bpf_map_free kernel/bpf/syscall.c:838 [inline]
 bpf_map_free_deferred+0x17c/0x310 kernel/bpf/syscall.c:862
 process_one_work kernel/workqueue.c:3229 [inline]
 process_scheduled_works+0xa2b/0x1b60 kernel/workqueue.c:3310
 worker_thread+0xedf/0x1550 kernel/workqueue.c:3391
 kthread+0x535/0x6b0 kernel/kthread.c:389
 ret_from_fork+0x6e/0x90 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

CPU: 1 UID: 0 PID: 17276 Comm: syz.1.16450 Not tainted 6.12.0-05490-g9bb88c659673 #8
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.5
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1a9e1284e87d59b1303b69d1808d310821d6e5f7
  - https://git.kernel.org/stable/c/6b3d638ca897e099fa99bd6d02189d3176f80a47
  - https://git.kernel.org/stable/c/972bafed67ca73ad9a56448384281eb5fd5c0ba3
  - https://git.kernel.org/stable/c/d56d8a23d95100b65f40438639dd82db2af81c11
  - https://git.kernel.org/stable/c/f615fccfc689cb48977d275ac2e391297b52392b

------------------------------------------------------------

CVE ID: CVE-2025-21868
Description: In the Linux kernel, the following vulnerability has been resolved:

net: allow small head cache usage with large MAX_SKB_FRAGS values

Sabrina reported the following splat:

    WARNING: CPU: 0 PID: 1 at net/core/dev.c:6935 netif_napi_add_weight_locked+0x8f2/0xba0
    Modules linked in:
    CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.14.0-rc1-net-00092-g011b03359038 #996
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014
    RIP: 0010:netif_napi_add_weight_locked+0x8f2/0xba0
    Code: e8 c3 e6 6a fe 48 83 c4 28 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc c7 44 24 10 ff ff ff ff e9 8f fb ff ff e8 9e e6 6a fe <0f> 0b e9 d3 fe ff ff e8 92 e6 6a fe 48 8b 04 24 be ff ff ff ff 48
    RSP: 0000:ffffc9000001fc60 EFLAGS: 00010293
    RAX: 0000000000000000 RBX: ffff88806ce48128 RCX: 1ffff11001664b9e
    RDX: ffff888008f00040 RSI: ffffffff8317ca42 RDI: ffff88800b325cb6
    RBP: ffff88800b325c40 R08: 0000000000000001 R09: ffffed100167502c
    R10: ffff88800b3a8163 R11: 0000000000000000 R12: ffff88800ac1c168
    R13: ffff88800ac1c168 R14: ffff88800ac1c168 R15: 0000000000000007
    FS:  0000000000000000(0000) GS:ffff88806ce00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: ffff888008201000 CR3: 0000000004c94001 CR4: 0000000000370ef0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
    <TASK>
    gro_cells_init+0x1ba/0x270
    xfrm_input_init+0x4b/0x2a0
    xfrm_init+0x38/0x50
    ip_rt_init+0x2d7/0x350
    ip_init+0xf/0x20
    inet_init+0x406/0x590
    do_one_initcall+0x9d/0x2e0
    do_initcalls+0x23b/0x280
    kernel_init_freeable+0x445/0x490
    kernel_init+0x20/0x1d0
    ret_from_fork+0x46/0x80
    ret_from_fork_asm+0x1a/0x30
    </TASK>
    irq event stamp: 584330
    hardirqs last  enabled at (584338): [<ffffffff8168bf87>] __up_console_sem+0x77/0xb0
    hardirqs last disabled at (584345): [<ffffffff8168bf6c>] __up_console_sem+0x5c/0xb0
    softirqs last  enabled at (583242): [<ffffffff833ee96d>] netlink_insert+0x14d/0x470
    softirqs last disabled at (583754): [<ffffffff8317c8cd>] netif_napi_add_weight_locked+0x77d/0xba0

on kernel built with MAX_SKB_FRAGS=45, where SKB_WITH_OVERHEAD(1024)
is smaller than GRO_MAX_HEAD.

Such built additionally contains the revert of the single page frag cache
so that napi_get_frags() ends up using the page frag allocator, triggering
the splat.

Note that the underlying issue is independent from the mentioned
revert; address it ensuring that the small head cache will fit either TCP
and GRO allocation and updating napi_alloc_skb() and __netdev_alloc_skb()
to select kmalloc() usage for any allocation fitting such cache.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/14ad6ed30a10afbe91b0749d6378285f4225d482
  - https://git.kernel.org/stable/c/648e440c98e260dec835e48a5d7a9993477b1f9d
  - https://git.kernel.org/stable/c/ed0ca7d2127c63991cfaf1932b827e3f4f8ee480

------------------------------------------------------------

CVE ID: CVE-2025-21869
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/code-patching: Disable KASAN report during patching via temporary mm

Erhard reports the following KASAN hit on Talos II (power9) with kernel 6.13:

[   12.028126] ==================================================================
[   12.028198] BUG: KASAN: user-memory-access in copy_to_kernel_nofault+0x8c/0x1a0
[   12.028260] Write of size 8 at addr 0000187e458f2000 by task systemd/1

[   12.028346] CPU: 87 UID: 0 PID: 1 Comm: systemd Tainted: G                T  6.13.0-P9-dirty #3
[   12.028408] Tainted: [T]=RANDSTRUCT
[   12.028446] Hardware name: T2P9D01 REV 1.01 POWER9 0x4e1202 opal:skiboot-bc106a0 PowerNV
[   12.028500] Call Trace:
[   12.028536] [c000000008dbf3b0] [c000000001656a48] dump_stack_lvl+0xbc/0x110 (unreliable)
[   12.028609] [c000000008dbf3f0] [c0000000006e2fc8] print_report+0x6b0/0x708
[   12.028666] [c000000008dbf4e0] [c0000000006e2454] kasan_report+0x164/0x300
[   12.028725] [c000000008dbf600] [c0000000006e54d4] kasan_check_range+0x314/0x370
[   12.028784] [c000000008dbf640] [c0000000006e6310] __kasan_check_write+0x20/0x40
[   12.028842] [c000000008dbf660] [c000000000578e8c] copy_to_kernel_nofault+0x8c/0x1a0
[   12.028902] [c000000008dbf6a0] [c0000000000acfe4] __patch_instructions+0x194/0x210
[   12.028965] [c000000008dbf6e0] [c0000000000ade80] patch_instructions+0x150/0x590
[   12.029026] [c000000008dbf7c0] [c0000000001159bc] bpf_arch_text_copy+0x6c/0xe0
[   12.029085] [c000000008dbf800] [c000000000424250] bpf_jit_binary_pack_finalize+0x40/0xc0
[   12.029147] [c000000008dbf830] [c000000000115dec] bpf_int_jit_compile+0x3bc/0x930
[   12.029206] [c000000008dbf990] [c000000000423720] bpf_prog_select_runtime+0x1f0/0x280
[   12.029266] [c000000008dbfa00] [c000000000434b18] bpf_prog_load+0xbb8/0x1370
[   12.029324] [c000000008dbfb70] [c000000000436ebc] __sys_bpf+0x5ac/0x2e00
[   12.029379] [c000000008dbfd00] [c00000000043a228] sys_bpf+0x28/0x40
[   12.029435] [c000000008dbfd20] [c000000000038eb4] system_call_exception+0x334/0x610
[   12.029497] [c000000008dbfe50] [c00000000000c270] system_call_vectored_common+0xf0/0x280
[   12.029561] --- interrupt: 3000 at 0x3fff82f5cfa8
[   12.029608] NIP:  00003fff82f5cfa8 LR: 00003fff82f5cfa8 CTR: 0000000000000000
[   12.029660] REGS: c000000008dbfe80 TRAP: 3000   Tainted: G                T   (6.13.0-P9-dirty)
[   12.029735] MSR:  900000000280f032 <SF,HV,VEC,VSX,EE,PR,FP,ME,IR,DR,RI>  CR: 42004848  XER: 00000000
[   12.029855] IRQMASK: 0
               GPR00: 0000000000000169 00003fffdcf789a0 00003fff83067100 0000000000000005
               GPR04: 00003fffdcf78a98 0000000000000090 0000000000000000 0000000000000008
               GPR08: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
               GPR12: 0000000000000000 00003fff836ff7e0 c000000000010678 0000000000000000
               GPR16: 0000000000000000 0000000000000000 00003fffdcf78f28 00003fffdcf78f90
               GPR20: 0000000000000000 0000000000000000 0000000000000000 00003fffdcf78f80
               GPR24: 00003fffdcf78f70 00003fffdcf78d10 00003fff835c7239 00003fffdcf78bd8
               GPR28: 00003fffdcf78a98 0000000000000000 0000000000000000 000000011f547580
[   12.030316] NIP [00003fff82f5cfa8] 0x3fff82f5cfa8
[   12.030361] LR [00003fff82f5cfa8] 0x3fff82f5cfa8
[   12.030405] --- interrupt: 3000
[   12.030444] ==================================================================

Commit c28c15b6d28a ("powerpc/code-patching: Use temporary mm for
Radix MMU") is inspired from x86 but unlike x86 is doesn't disable
KASAN reports during patching. This wasn't a problem at the begining
because __patch_mem() is not instrumented.

Commit 465cabc97b42 ("powerpc/code-patching: introduce
patch_instructions()") use copy_to_kernel_nofault() to copy several
instructions at once. But when using temporary mm the destination is
not regular kernel memory but a kind of kernel-like memory located
in user address space. 
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5980d4456dd66d1b6505d5ec15048bd87e8775e0
  - https://git.kernel.org/stable/c/dc9c5166c3cb044f8a001e397195242fd6796eee
  - https://git.kernel.org/stable/c/ea291447a4031f3dac5c23d55bc83fe833820d84

------------------------------------------------------------

CVE ID: CVE-2025-21870
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: ipc4-topology: Harden loops for looking up ALH copiers

Other, non DAI copier widgets could have the same  stream name (sname) as
the ALH copier and in that case the copier->data is NULL, no alh_data is
attached, which could lead to NULL pointer dereference.
We could check for this NULL pointer in sof_ipc4_prepare_copier_module()
and avoid the crash, but a similar loop in sof_ipc4_widget_setup_comp_dai()
will miscalculate the ALH device count, causing broken audio.

The correct fix is to harden the matching logic by making sure that the
1. widget is a DAI widget - so dai = w->private is valid
2. the dai (and thus the copier) is ALH copier
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6fd60136d256b3b948333ebdb3835f41a95ab7ef
  - https://git.kernel.org/stable/c/87c8768a96092ce75cd47fe076db5080db7ac515
  - https://git.kernel.org/stable/c/93c6c2e5801aab09ef1ef99f248f3cd323c3f152

------------------------------------------------------------

CVE ID: CVE-2025-21871
Description: In the Linux kernel, the following vulnerability has been resolved:

tee: optee: Fix supplicant wait loop

OP-TEE supplicant is a user-space daemon and it's possible for it
be hung or crashed or killed in the middle of processing an OP-TEE
RPC call. It becomes more complicated when there is incorrect shutdown
ordering of the supplicant process vs the OP-TEE client application which
can eventually lead to system hang-up waiting for the closure of the
client application.

Allow the client process waiting in kernel for supplicant response to
be killed rather than indefinitely waiting in an unkillable state. Also,
a normal uninterruptible wait should not have resulted in the hung-task
watchdog getting triggered, but the endless loop would.

This fixes issues observed during system reboot/shutdown when supplicant
got hung for some reason or gets crashed/killed which lead to client
getting hung in an unkillable state. It in turn lead to system being in
hung up state requiring hard power off/on to recover.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0180cf0373f84fff61b16f8c062553a13dd7cfca
  - https://git.kernel.org/stable/c/21234efe2a8474a6d2d01ea9573319de7858ce44
  - https://git.kernel.org/stable/c/3eb4911364c764572e9db4ab900a57689a54e8ce
  - https://git.kernel.org/stable/c/70b0d6b0a199c5a3ee6c72f5e61681ed6f759612
  - https://git.kernel.org/stable/c/c0a9a948159153be145f9471435695373904ee6d
  - https://git.kernel.org/stable/c/d61cc1a435e6894bfb0dd3370c6f765d2d12825d
  - https://git.kernel.org/stable/c/ec18520f5edc20a00c34a8c9fdd6507c355e880f
  - https://git.kernel.org/stable/c/fd9d2d6124c293e40797a080adf8a9c237efd8b8

------------------------------------------------------------

CVE ID: CVE-2024-58090
Description: In the Linux kernel, the following vulnerability has been resolved:

sched/core: Prevent rescheduling when interrupts are disabled

David reported a warning observed while loop testing kexec jump:

  Interrupts enabled after irqrouter_resume+0x0/0x50
  WARNING: CPU: 0 PID: 560 at drivers/base/syscore.c:103 syscore_resume+0x18a/0x220
   kernel_kexec+0xf6/0x180
   __do_sys_reboot+0x206/0x250
   do_syscall_64+0x95/0x180

The corresponding interrupt flag trace:

  hardirqs last  enabled at (15573): [<ffffffffa8281b8e>] __up_console_sem+0x7e/0x90
  hardirqs last disabled at (15580): [<ffffffffa8281b73>] __up_console_sem+0x63/0x90

That means __up_console_sem() was invoked with interrupts enabled. Further
instrumentation revealed that in the interrupt disabled section of kexec
jump one of the syscore_suspend() callbacks woke up a task, which set the
NEED_RESCHED flag. A later callback in the resume path invoked
cond_resched() which in turn led to the invocation of the scheduler:

  __cond_resched+0x21/0x60
  down_timeout+0x18/0x60
  acpi_os_wait_semaphore+0x4c/0x80
  acpi_ut_acquire_mutex+0x3d/0x100
  acpi_ns_get_node+0x27/0x60
  acpi_ns_evaluate+0x1cb/0x2d0
  acpi_rs_set_srs_method_data+0x156/0x190
  acpi_pci_link_set+0x11c/0x290
  irqrouter_resume+0x54/0x60
  syscore_resume+0x6a/0x200
  kernel_kexec+0x145/0x1c0
  __do_sys_reboot+0xeb/0x240
  do_syscall_64+0x95/0x180

This is a long standing problem, which probably got more visible with
the recent printk changes. Something does a task wakeup and the
scheduler sets the NEED_RESCHED flag. cond_resched() sees it set and
invokes schedule() from a completely bogus context. The scheduler
enables interrupts after context switching, which causes the above
warning at the end.

Quite some of the code paths in syscore_suspend()/resume() can result in
triggering a wakeup with the exactly same consequences. They might not
have done so yet, but as they share a lot of code with normal operations
it's just a question of time.

The problem only affects the PREEMPT_NONE and PREEMPT_VOLUNTARY scheduling
models. Full preemption is not affected as cond_resched() is disabled and
the preemption check preemptible() takes the interrupt disabled flag into
account.

Cure the problem by adding a corresponding check into cond_resched().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0362847c520747b44b574d363705d8af0621727a
  - https://git.kernel.org/stable/c/1651f5731b378616565534eb9cda30e258cebebc
  - https://git.kernel.org/stable/c/288fdb8dcb71ec77b76ab8b8a06bc10f595ea504
  - https://git.kernel.org/stable/c/321794b75ac968f0bb6b9c913581949452a8d992
  - https://git.kernel.org/stable/c/68786ab0935ccd5721283b7eb7f4d2f2942c7a52
  - https://git.kernel.org/stable/c/82c387ef7568c0d96a918a5a78d9cad6256cfa15
  - https://git.kernel.org/stable/c/84586322e010164eedddfcd0a0894206ae7d9317
  - https://git.kernel.org/stable/c/b927c8539f692fb1f9c2f42e6c8ea2d94956f921

------------------------------------------------------------

CVE ID: CVE-2024-58091
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/fbdev-dma: Add shadow buffering for deferred I/O

DMA areas are not necessarily backed by struct page, so we cannot
rely on it for deferred I/O. Allocate a shadow buffer for drivers
that require deferred I/O and use it as framebuffer memory.

Fixes driver errors about being "Unable to handle kernel NULL pointer
dereference at virtual address" or "Unable to handle kernel paging
request at virtual address".

The patch splits drm_fbdev_dma_driver_fbdev_probe() in an initial
allocation, which creates the DMA-backed buffer object, and a tail
that sets up the fbdev data structures. There is a tail function for
direct memory mappings and a tail function for deferred I/O with
the shadow buffer.

It is no longer possible to use deferred I/O without shadow buffer.
It can be re-added if there exists a reliably test for usable struct
page in the allocated DMA-backed buffer object.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3603996432997f7c88da37a97062a46cda01ac9d
  - https://git.kernel.org/stable/c/cdc581169942de3b9e2648cfbd98c5ff9111c2c8

------------------------------------------------------------

CVE ID: CVE-2025-21872
Description: In the Linux kernel, the following vulnerability has been resolved:

efi: Don't map the entire mokvar table to determine its size

Currently, when validating the mokvar table, we (re)map the entire table
on each iteration of the loop, adding space as we discover new entries.
If the table grows over a certain size, this fails due to limitations of
early_memmap(), and we get a failure and traceback:

  ------------[ cut here ]------------
  WARNING: CPU: 0 PID: 0 at mm/early_ioremap.c:139 __early_ioremap+0xef/0x220
  ...
  Call Trace:
   <TASK>
   ? __early_ioremap+0xef/0x220
   ? __warn.cold+0x93/0xfa
   ? __early_ioremap+0xef/0x220
   ? report_bug+0xff/0x140
   ? early_fixup_exception+0x5d/0xb0
   ? early_idt_handler_common+0x2f/0x3a
   ? __early_ioremap+0xef/0x220
   ? efi_mokvar_table_init+0xce/0x1d0
   ? setup_arch+0x864/0xc10
   ? start_kernel+0x6b/0xa10
   ? x86_64_start_reservations+0x24/0x30
   ? x86_64_start_kernel+0xed/0xf0
   ? common_startup_64+0x13e/0x141
   </TASK>
  ---[ end trace 0000000000000000 ]---
  mokvar: Failed to map EFI MOKvar config table pa=0x7c4c3000, size=265187.

Mapping the entire structure isn't actually necessary, as we don't ever
need more than one entry header mapped at once.

Changes efi_mokvar_table_init() to only map each entry header, not the
entire table, when determining the table size.  Since we're not mapping
any data past the variable name, it also changes the code to enforce
that each variable name is NUL terminated, rather than attempting to
verify it in place.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b90e7ace79774a3540ce569e000388f8d22c9e0
  - https://git.kernel.org/stable/c/46c0454ffb78ce9d3355a3cccac86383ea8ddd55
  - https://git.kernel.org/stable/c/65f4aebb8127708ba668dd938e83b8558abfc5cd
  - https://git.kernel.org/stable/c/97bd560b6cc4c26386a53b4881bf03e96f9ba03a
  - https://git.kernel.org/stable/c/ea3f0b362dfe4ef885ef812bfaf4088176422c91

------------------------------------------------------------

CVE ID: CVE-2025-21873
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: core: bsg: Fix crash when arpmb command fails

If the device doesn't support arpmb we'll crash due to copying user data in
bsg_transport_sg_io_fn().

In the case where ufs_bsg_exec_advanced_rpmb_req() returns an error, do not
set the job's reply_len.

Memory crash backtrace:
3,1290,531166405,-;ufshcd 0000:00:12.5: ARPMB OP failed: error code -22

4,1308,531166555,-;Call Trace:

4,1309,531166559,-; <TASK>

4,1310,531166565,-; ? show_regs+0x6d/0x80

4,1311,531166575,-; ? die+0x37/0xa0

4,1312,531166583,-; ? do_trap+0xd4/0xf0

4,1313,531166593,-; ? do_error_trap+0x71/0xb0

4,1314,531166601,-; ? usercopy_abort+0x6c/0x80

4,1315,531166610,-; ? exc_invalid_op+0x52/0x80

4,1316,531166622,-; ? usercopy_abort+0x6c/0x80

4,1317,531166630,-; ? asm_exc_invalid_op+0x1b/0x20

4,1318,531166643,-; ? usercopy_abort+0x6c/0x80

4,1319,531166652,-; __check_heap_object+0xe3/0x120

4,1320,531166661,-; check_heap_object+0x185/0x1d0

4,1321,531166670,-; __check_object_size.part.0+0x72/0x150

4,1322,531166679,-; __check_object_size+0x23/0x30

4,1323,531166688,-; bsg_transport_sg_io_fn+0x314/0x3b0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/32fb5ec825f6f76bc28902181c65429a904a07fe
  - https://git.kernel.org/stable/c/59455f968c1004ed897ba873237657745d81ce0f
  - https://git.kernel.org/stable/c/7e3c96ff5c5f3206984ed077b2aa8c9b7c4e0327
  - https://git.kernel.org/stable/c/f27a95845b01e86d67c8b014b4f41bd3327daa63

------------------------------------------------------------

CVE ID: CVE-2025-21874
Description: In the Linux kernel, the following vulnerability has been resolved:

dm-integrity: Avoid divide by zero in table status in Inline mode

In Inline mode, the journal is unused, and journal_sectors is zero.

Calculating the journal watermark requires dividing by journal_sectors,
which should be done only if the journal is configured.

Otherwise, a simple table query (dmsetup table) can cause OOPS.

This bug did not show on some systems, perhaps only due to
compiler optimization.

On my 32-bit testing machine, this reliably crashes with the following:

 : Oops: divide error: 0000 [#1] PREEMPT SMP
 : CPU: 0 UID: 0 PID: 2450 Comm: dmsetup Not tainted 6.14.0-rc2+ #959
 : EIP: dm_integrity_status+0x2f8/0xab0 [dm_integrity]
 ...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/06d9895f265282e939a8933bb18de82eba2b4dda
  - https://git.kernel.org/stable/c/22c6f577b3cb184857b440ae5e5916f6c9e7021d
  - https://git.kernel.org/stable/c/7fb39882b20c98a9a393c244c86b56ef6933cff8

------------------------------------------------------------

CVE ID: CVE-2025-21875
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: always handle address removal under msk socket lock

Syzkaller reported a lockdep splat in the PM control path:

  WARNING: CPU: 0 PID: 6693 at ./include/net/sock.h:1711 sock_owned_by_me include/net/sock.h:1711 [inline]
  WARNING: CPU: 0 PID: 6693 at ./include/net/sock.h:1711 msk_owned_by_me net/mptcp/protocol.h:363 [inline]
  WARNING: CPU: 0 PID: 6693 at ./include/net/sock.h:1711 mptcp_pm_nl_addr_send_ack+0x57c/0x610 net/mptcp/pm_netlink.c:788
  Modules linked in:
  CPU: 0 UID: 0 PID: 6693 Comm: syz.0.205 Not tainted 6.14.0-rc2-syzkaller-00303-gad1b832bf1cf #0
  Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 12/27/2024
  RIP: 0010:sock_owned_by_me include/net/sock.h:1711 [inline]
  RIP: 0010:msk_owned_by_me net/mptcp/protocol.h:363 [inline]
  RIP: 0010:mptcp_pm_nl_addr_send_ack+0x57c/0x610 net/mptcp/pm_netlink.c:788
  Code: 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc e8 ca 7b d3 f5 eb b9 e8 c3 7b d3 f5 90 0f 0b 90 e9 dd fb ff ff e8 b5 7b d3 f5 90 <0f> 0b 90 e9 3e fb ff ff 44 89 f1 80 e1 07 38 c1 0f 8c eb fb ff ff
  RSP: 0000:ffffc900034f6f60 EFLAGS: 00010283
  RAX: ffffffff8bee3c2b RBX: 0000000000000001 RCX: 0000000000080000
  RDX: ffffc90004d42000 RSI: 000000000000a407 RDI: 000000000000a408
  RBP: ffffc900034f7030 R08: ffffffff8bee37f6 R09: 0100000000000000
  R10: dffffc0000000000 R11: ffffed100bcc62e4 R12: ffff88805e6316e0
  R13: ffff88805e630c00 R14: dffffc0000000000 R15: ffff88805e630c00
  FS:  00007f7e9a7e96c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 0000001b2fd18ff8 CR3: 0000000032c24000 CR4: 00000000003526f0
  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
  Call Trace:
   <TASK>
   mptcp_pm_remove_addr+0x103/0x1d0 net/mptcp/pm.c:59
   mptcp_pm_remove_anno_addr+0x1f4/0x2f0 net/mptcp/pm_netlink.c:1486
   mptcp_nl_remove_subflow_and_signal_addr net/mptcp/pm_netlink.c:1518 [inline]
   mptcp_pm_nl_del_addr_doit+0x118d/0x1af0 net/mptcp/pm_netlink.c:1629
   genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]
   genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
   genl_rcv_msg+0xb1f/0xec0 net/netlink/genetlink.c:1210
   netlink_rcv_skb+0x206/0x480 net/netlink/af_netlink.c:2543
   genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219
   netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]
   netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1348
   netlink_sendmsg+0x8de/0xcb0 net/netlink/af_netlink.c:1892
   sock_sendmsg_nosec net/socket.c:718 [inline]
   __sock_sendmsg+0x221/0x270 net/socket.c:733
   ____sys_sendmsg+0x53a/0x860 net/socket.c:2573
   ___sys_sendmsg net/socket.c:2627 [inline]
   __sys_sendmsg+0x269/0x350 net/socket.c:2659
   do_syscall_x64 arch/x86/entry/common.c:52 [inline]
   do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
   entry_SYSCALL_64_after_hwframe+0x77/0x7f
  RIP: 0033:0x7f7e9998cde9
  Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48
  RSP: 002b:00007f7e9a7e9038 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
  RAX: ffffffffffffffda RBX: 00007f7e99ba5fa0 RCX: 00007f7e9998cde9
  RDX: 000000002000c094 RSI: 0000400000000000 RDI: 0000000000000007
  RBP: 00007f7e99a0e2a0 R08: 0000000000000000 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
  R13: 0000000000000000 R14: 00007f7e99ba5fa0 R15: 00007fff49231088

Indeed the PM can try to send a RM_ADDR over a msk without acquiring
first the msk socket lock.

The bugged code-path comes from an early optimization: when there
are no subflows, the PM should (usually) not send RM_ADDR
notifications.

The above statement is incorrect, as without locks another process
could concur
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2c3de6dff4373f1036e003f49a32629359530bdb
  - https://git.kernel.org/stable/c/4124b782ec2b1e2e490cf0bbf10f53dfd3479890
  - https://git.kernel.org/stable/c/494ec285535632732eaa5786297a9ae4f731b5ff
  - https://git.kernel.org/stable/c/7cca31035c05819643ffb5d7518e9a331b3f6651
  - https://git.kernel.org/stable/c/8116fb4acd5d3f06cd37f84887dbe962b6703b1c
  - https://git.kernel.org/stable/c/a05da2be18aae7e82572f8d795f41bb49f5dfc7d
  - https://git.kernel.org/stable/c/f865c24bc55158313d5779fc81116023a6940ca3

------------------------------------------------------------

CVE ID: CVE-2025-21876
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/vt-d: Fix suspicious RCU usage

Commit <d74169ceb0d2> ("iommu/vt-d: Allocate DMAR fault interrupts
locally") moved the call to enable_drhd_fault_handling() to a code
path that does not hold any lock while traversing the drhd list. Fix
it by ensuring the dmar_global_lock lock is held when traversing the
drhd list.

Without this fix, the following warning is triggered:
 =============================
 WARNING: suspicious RCU usage
 6.14.0-rc3 #55 Not tainted
 -----------------------------
 drivers/iommu/intel/dmar.c:2046 RCU-list traversed in non-reader section!!
               other info that might help us debug this:
               rcu_scheduler_active = 1, debug_locks = 1
 2 locks held by cpuhp/1/23:
 #0: ffffffff84a67c50 (cpu_hotplug_lock){++++}-{0:0}, at: cpuhp_thread_fun+0x87/0x2c0
 #1: ffffffff84a6a380 (cpuhp_state-up){+.+.}-{0:0}, at: cpuhp_thread_fun+0x87/0x2c0
 stack backtrace:
 CPU: 1 UID: 0 PID: 23 Comm: cpuhp/1 Not tainted 6.14.0-rc3 #55
 Call Trace:
  <TASK>
  dump_stack_lvl+0xb7/0xd0
  lockdep_rcu_suspicious+0x159/0x1f0
  ? __pfx_enable_drhd_fault_handling+0x10/0x10
  enable_drhd_fault_handling+0x151/0x180
  cpuhp_invoke_callback+0x1df/0x990
  cpuhp_thread_fun+0x1ea/0x2c0
  smpboot_thread_fn+0x1f5/0x2e0
  ? __pfx_smpboot_thread_fn+0x10/0x10
  kthread+0x12a/0x2d0
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x4a/0x60
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1a/0x30
  </TASK>

Holding the lock in enable_drhd_fault_handling() triggers a lockdep splat
about a possible deadlock between dmar_global_lock and cpu_hotplug_lock.
This is avoided by not holding dmar_global_lock when calling
iommu_device_register(), which initiates the device probe process.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4117c72938493a77ab53cc4b8284be8fb6ec8065
  - https://git.kernel.org/stable/c/b150654f74bf0df8e6a7936d5ec51400d9ec06d8
  - https://git.kernel.org/stable/c/c603ccbe91d189849e1439134598ec567088dcec

------------------------------------------------------------

CVE ID: CVE-2025-21877
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet: gl620a: fix endpoint checking in genelink_bind()

Syzbot reports [1] a warning in usb_submit_urb() triggered by
inconsistencies between expected and actually present endpoints
in gl620a driver. Since genelink_bind() does not properly
verify whether specified eps are in fact provided by the device,
in this case, an artificially manufactured one, one may get a
mismatch.

Fix the issue by resorting to a usbnet utility function
usbnet_get_endpoints(), usually reserved for this very problem.
Check for endpoints and return early before proceeding further if
any are missing.

[1] Syzbot report:
usb 5-1: Manufacturer: syz
usb 5-1: SerialNumber: syz
usb 5-1: config 0 descriptor??
gl620a 5-1:0.23 usb0: register 'gl620a' at usb-dummy_hcd.0-1, ...
------------[ cut here ]------------
usb 5-1: BOGUS urb xfer, pipe 3 != type 1
WARNING: CPU: 2 PID: 1841 at drivers/usb/core/urb.c:503 usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503
Modules linked in:
CPU: 2 UID: 0 PID: 1841 Comm: kworker/2:2 Not tainted 6.12.0-syzkaller-07834-g06afb0f36106 #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
Workqueue: mld mld_ifc_work
RIP: 0010:usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503
...
Call Trace:
 <TASK>
 usbnet_start_xmit+0x6be/0x2780 drivers/net/usb/usbnet.c:1467
 __netdev_start_xmit include/linux/netdevice.h:5002 [inline]
 netdev_start_xmit include/linux/netdevice.h:5011 [inline]
 xmit_one net/core/dev.c:3590 [inline]
 dev_hard_start_xmit+0x9a/0x7b0 net/core/dev.c:3606
 sch_direct_xmit+0x1ae/0xc30 net/sched/sch_generic.c:343
 __dev_xmit_skb net/core/dev.c:3827 [inline]
 __dev_queue_xmit+0x13d4/0x43e0 net/core/dev.c:4400
 dev_queue_xmit include/linux/netdevice.h:3168 [inline]
 neigh_resolve_output net/core/neighbour.c:1514 [inline]
 neigh_resolve_output+0x5bc/0x950 net/core/neighbour.c:1494
 neigh_output include/net/neighbour.h:539 [inline]
 ip6_finish_output2+0xb1b/0x2070 net/ipv6/ip6_output.c:141
 __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]
 ip6_finish_output+0x3f9/0x1360 net/ipv6/ip6_output.c:226
 NF_HOOK_COND include/linux/netfilter.h:303 [inline]
 ip6_output+0x1f8/0x540 net/ipv6/ip6_output.c:247
 dst_output include/net/dst.h:450 [inline]
 NF_HOOK include/linux/netfilter.h:314 [inline]
 NF_HOOK include/linux/netfilter.h:308 [inline]
 mld_sendpack+0x9f0/0x11d0 net/ipv6/mcast.c:1819
 mld_send_cr net/ipv6/mcast.c:2120 [inline]
 mld_ifc_work+0x740/0xca0 net/ipv6/mcast.c:2651
 process_one_work+0x9c5/0x1ba0 kernel/workqueue.c:3229
 process_scheduled_works kernel/workqueue.c:3310 [inline]
 worker_thread+0x6c8/0xf00 kernel/workqueue.c:3391
 kthread+0x2c1/0x3a0 kernel/kthread.c:389
 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1cf9631d836b289bd5490776551961c883ae8a4f
  - https://git.kernel.org/stable/c/24dd971104057c8828d420a48e0a5af6e6f30d3e
  - https://git.kernel.org/stable/c/4e8b8d43373bf837be159366f0192502f97ec7a5
  - https://git.kernel.org/stable/c/5f2dbabbce04b1ffcd6d8d07564adb94db577536
  - https://git.kernel.org/stable/c/67ebc3391c8377738e97a43374054d9718fdb6e4
  - https://git.kernel.org/stable/c/9bcb8cbc3e5d67eb223bfb7e2291a270dbb699dc
  - https://git.kernel.org/stable/c/a2ee5e55b50a97d13617c8653482c0ad4decff8c
  - https://git.kernel.org/stable/c/ded25730c96949cb8b048b29c557e38569124943

------------------------------------------------------------

CVE ID: CVE-2025-21878
Description: In the Linux kernel, the following vulnerability has been resolved:

i2c: npcm: disable interrupt enable bit before devm_request_irq

The customer reports that there is a soft lockup issue related to
the i2c driver. After checking, the i2c module was doing a tx transfer
and the bmc machine reboots in the middle of the i2c transaction, the i2c
module keeps the status without being reset.

Due to such an i2c module status, the i2c irq handler keeps getting
triggered since the i2c irq handler is registered in the kernel booting
process after the bmc machine is doing a warm rebooting.
The continuous triggering is stopped by the soft lockup watchdog timer.

Disable the interrupt enable bit in the i2c module before calling
devm_request_irq to fix this issue since the i2c relative status bit
is read-only.

Here is the soft lockup log.
[   28.176395] watchdog: BUG: soft lockup - CPU#0 stuck for 26s! [swapper/0:1]
[   28.183351] Modules linked in:
[   28.186407] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.15.120-yocto-s-dirty-bbebc78 #1
[   28.201174] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   28.208128] pc : __do_softirq+0xb0/0x368
[   28.212055] lr : __do_softirq+0x70/0x368
[   28.215972] sp : ffffff8035ebca00
[   28.219278] x29: ffffff8035ebca00 x28: 0000000000000002 x27: ffffff80071a3780
[   28.226412] x26: ffffffc008bdc000 x25: ffffffc008bcc640 x24: ffffffc008be50c0
[   28.233546] x23: ffffffc00800200c x22: 0000000000000000 x21: 000000000000001b
[   28.240679] x20: 0000000000000000 x19: ffffff80001c3200 x18: ffffffffffffffff
[   28.247812] x17: ffffffc02d2e0000 x16: ffffff8035eb8b40 x15: 00001e8480000000
[   28.254945] x14: 02c3647e37dbfcb6 x13: 02c364f2ab14200c x12: 0000000002c364f2
[   28.262078] x11: 00000000fa83b2da x10: 000000000000b67e x9 : ffffffc008010250
[   28.269211] x8 : 000000009d983d00 x7 : 7fffffffffffffff x6 : 0000036d74732434
[   28.276344] x5 : 00ffffffffffffff x4 : 0000000000000015 x3 : 0000000000000198
[   28.283476] x2 : ffffffc02d2e0000 x1 : 00000000000000e0 x0 : ffffffc008bdcb40
[   28.290611] Call trace:
[   28.293052]  __do_softirq+0xb0/0x368
[   28.296625]  __irq_exit_rcu+0xe0/0x100
[   28.300374]  irq_exit+0x14/0x20
[   28.303513]  handle_domain_irq+0x68/0x90
[   28.307440]  gic_handle_irq+0x78/0xb0
[   28.311098]  call_on_irq_stack+0x20/0x38
[   28.315019]  do_interrupt_handler+0x54/0x5c
[   28.319199]  el1_interrupt+0x2c/0x4c
[   28.322777]  el1h_64_irq_handler+0x14/0x20
[   28.326872]  el1h_64_irq+0x74/0x78
[   28.330269]  __setup_irq+0x454/0x780
[   28.333841]  request_threaded_irq+0xd0/0x1b4
[   28.338107]  devm_request_threaded_irq+0x84/0x100
[   28.342809]  npcm_i2c_probe_bus+0x188/0x3d0
[   28.346990]  platform_probe+0x6c/0xc4
[   28.350653]  really_probe+0xcc/0x45c
[   28.354227]  __driver_probe_device+0x8c/0x160
[   28.358578]  driver_probe_device+0x44/0xe0
[   28.362670]  __driver_attach+0x124/0x1d0
[   28.366589]  bus_for_each_dev+0x7c/0xe0
[   28.370426]  driver_attach+0x28/0x30
[   28.373997]  bus_add_driver+0x124/0x240
[   28.377830]  driver_register+0x7c/0x124
[   28.381662]  __platform_driver_register+0x2c/0x34
[   28.386362]  npcm_i2c_init+0x3c/0x5c
[   28.389937]  do_one_initcall+0x74/0x230
[   28.393768]  kernel_init_freeable+0x24c/0x2b4
[   28.398126]  kernel_init+0x28/0x130
[   28.401614]  ret_from_fork+0x10/0x20
[   28.405189] Kernel panic - not syncing: softlockup: hung tasks
[   28.411011] SMP: stopping secondary CPUs
[   28.414933] Kernel Offset: disabled
[   28.418412] CPU features: 0x00000000,00000802
[   28.427644] Rebooting in 20 seconds..
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/12d0e39916705b68d2d8ba20a8e35d1d27afc260
  - https://git.kernel.org/stable/c/1b267e1b87d52b16e7dfcc7ab2ab760f6f8f9ca9
  - https://git.kernel.org/stable/c/545b563eb00d0576775da4011b3f7ffefc9e8c60
  - https://git.kernel.org/stable/c/846e371631c57365eeb89e5db1ab0f344169af93
  - https://git.kernel.org/stable/c/dd1998e243f5fa25d348a384ba0b6c84d980f2b2
  - https://git.kernel.org/stable/c/e3aea1dba97d31eceed7b622000af0406988b9c8
  - https://git.kernel.org/stable/c/f32d7b4dc6e791523c70e83049645dcba2a2aa33

------------------------------------------------------------

CVE ID: CVE-2025-21879
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix use-after-free on inode when scanning root during em shrinking

At btrfs_scan_root() we are accessing the inode's root (and fs_info) in a
call to btrfs_fs_closing() after we have scheduled the inode for a delayed
iput, and that can result in a use-after-free on the inode in case the
cleaner kthread does the iput before we dereference the inode in the call
to btrfs_fs_closing().

Fix this by using the fs_info stored already in a local variable instead
of doing inode->root->fs_info.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.6
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/59f37036bb7ab3d554c24abc856aabca01126414
  - https://git.kernel.org/stable/c/5e79d26014f9386387575b9ed60d342057cee49b

------------------------------------------------------------

CVE ID: CVE-2025-21880
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe/userptr: fix EFAULT handling

Currently we treat EFAULT from hmm_range_fault() as a non-fatal error
when called from xe_vm_userptr_pin() with the idea that we want to avoid
killing the entire vm and chucking an error, under the assumption that
the user just did an unmap or something, and has no intention of
actually touching that memory from the GPU.  At this point we have
already zapped the PTEs so any access should generate a page fault, and
if the pin fails there also it will then become fatal.

However it looks like it's possible for the userptr vma to still be on
the rebind list in preempt_rebind_work_func(), if we had to retry the
pin again due to something happening in the caller before we did the
rebind step, but in the meantime needing to re-validate the userptr and
this time hitting the EFAULT.

This explains an internal user report of hitting:

[  191.738349] WARNING: CPU: 1 PID: 157 at drivers/gpu/drm/xe/xe_res_cursor.h:158 xe_pt_stage_bind.constprop.0+0x60a/0x6b0 [xe]
[  191.738551] Workqueue: xe-ordered-wq preempt_rebind_work_func [xe]
[  191.738616] RIP: 0010:xe_pt_stage_bind.constprop.0+0x60a/0x6b0 [xe]
[  191.738690] Call Trace:
[  191.738692]  <TASK>
[  191.738694]  ? show_regs+0x69/0x80
[  191.738698]  ? __warn+0x93/0x1a0
[  191.738703]  ? xe_pt_stage_bind.constprop.0+0x60a/0x6b0 [xe]
[  191.738759]  ? report_bug+0x18f/0x1a0
[  191.738764]  ? handle_bug+0x63/0xa0
[  191.738767]  ? exc_invalid_op+0x19/0x70
[  191.738770]  ? asm_exc_invalid_op+0x1b/0x20
[  191.738777]  ? xe_pt_stage_bind.constprop.0+0x60a/0x6b0 [xe]
[  191.738834]  ? ret_from_fork_asm+0x1a/0x30
[  191.738849]  bind_op_prepare+0x105/0x7b0 [xe]
[  191.738906]  ? dma_resv_reserve_fences+0x301/0x380
[  191.738912]  xe_pt_update_ops_prepare+0x28c/0x4b0 [xe]
[  191.738966]  ? kmemleak_alloc+0x4b/0x80
[  191.738973]  ops_execute+0x188/0x9d0 [xe]
[  191.739036]  xe_vm_rebind+0x4ce/0x5a0 [xe]
[  191.739098]  ? trace_hardirqs_on+0x4d/0x60
[  191.739112]  preempt_rebind_work_func+0x76f/0xd00 [xe]

Followed by NPD, when running some workload, since the sg was never
actually populated but the vma is still marked for rebind when it should
be skipped for this special EFAULT case. This is confirmed to fix the
user report.

v2 (MattB):
 - Move earlier.
v3 (MattB):
 - Update the commit message to make it clear that this indeed fixes the
   issue.

(cherry picked from commit 6b93cb98910c826c2e2004942f8b060311e43618)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/51cc278f8ffacd5f9dc7d13191b81b912829db59
  - https://git.kernel.org/stable/c/a9f4fa3a7efa65615ff7db13023ac84516e99e21
  - https://git.kernel.org/stable/c/daad16d0a538fa938e344fd83927bbcfcd8a66ec

------------------------------------------------------------

CVE ID: CVE-2025-21881
Description: In the Linux kernel, the following vulnerability has been resolved:

uprobes: Reject the shared zeropage in uprobe_write_opcode()

We triggered the following crash in syzkaller tests:

  BUG: Bad page state in process syz.7.38  pfn:1eff3
  page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1eff3
  flags: 0x3fffff00004004(referenced|reserved|node=0|zone=1|lastcpupid=0x1fffff)
  raw: 003fffff00004004 ffffe6c6c07bfcc8 ffffe6c6c07bfcc8 0000000000000000
  raw: 0000000000000000 0000000000000000 00000000fffffffe 0000000000000000
  page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
  Call Trace:
   <TASK>
   dump_stack_lvl+0x32/0x50
   bad_page+0x69/0xf0
   free_unref_page_prepare+0x401/0x500
   free_unref_page+0x6d/0x1b0
   uprobe_write_opcode+0x460/0x8e0
   install_breakpoint.part.0+0x51/0x80
   register_for_each_vma+0x1d9/0x2b0
   __uprobe_register+0x245/0x300
   bpf_uprobe_multi_link_attach+0x29b/0x4f0
   link_create+0x1e2/0x280
   __sys_bpf+0x75f/0xac0
   __x64_sys_bpf+0x1a/0x30
   do_syscall_64+0x56/0x100
   entry_SYSCALL_64_after_hwframe+0x78/0xe2

   BUG: Bad rss-counter state mm:00000000452453e0 type:MM_FILEPAGES val:-1

The following syzkaller test case can be used to reproduce:

  r2 = creat(&(0x7f0000000000)='./file0\x00', 0x8)
  write$nbd(r2, &(0x7f0000000580)=ANY=[], 0x10)
  r4 = openat(0xffffffffffffff9c, &(0x7f0000000040)='./file0\x00', 0x42, 0x0)
  mmap$IORING_OFF_SQ_RING(&(0x7f0000ffd000/0x3000)=nil, 0x3000, 0x0, 0x12, r4, 0x0)
  r5 = userfaultfd(0x80801)
  ioctl$UFFDIO_API(r5, 0xc018aa3f, &(0x7f0000000040)={0xaa, 0x20})
  r6 = userfaultfd(0x80801)
  ioctl$UFFDIO_API(r6, 0xc018aa3f, &(0x7f0000000140))
  ioctl$UFFDIO_REGISTER(r6, 0xc020aa00, &(0x7f0000000100)={{&(0x7f0000ffc000/0x4000)=nil, 0x4000}, 0x2})
  ioctl$UFFDIO_ZEROPAGE(r5, 0xc020aa04, &(0x7f0000000000)={{&(0x7f0000ffd000/0x1000)=nil, 0x1000}})
  r7 = bpf$PROG_LOAD(0x5, &(0x7f0000000140)={0x2, 0x3, &(0x7f0000000200)=ANY=[@ANYBLOB="1800000000120000000000000000000095"], &(0x7f0000000000)='GPL\x00', 0x7, 0x0, 0x0, 0x0, 0x0, '\x00', 0x0, @fallback=0x30, 0xffffffffffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, @void, @value}, 0x94)
  bpf$BPF_LINK_CREATE_XDP(0x1c, &(0x7f0000000040)={r7, 0x0, 0x30, 0x1e, @val=@uprobe_multi={&(0x7f0000000080)='./file0\x00', &(0x7f0000000100)=[0x2], 0x0, 0x0, 0x1}}, 0x40)

The cause is that zero pfn is set to the PTE without increasing the RSS
count in mfill_atomic_pte_zeropage() and the refcount of zero folio does
not increase accordingly. Then, the operation on the same pfn is performed
in uprobe_write_opcode()->__replace_page() to unconditional decrease the
RSS count and old_folio's refcount.

Therefore, two bugs are introduced:

 1. The RSS count is incorrect, when process exit, the check_mm() report
    error "Bad rss-count".

 2. The reserved folio (zero folio) is freed when folio->refcount is zero,
    then free_pages_prepare->free_page_is_bad() report error
    "Bad page state".

There is more, the following warning could also theoretically be triggered:

  __replace_page()
    -> ...
      -> folio_remove_rmap_pte()
        -> VM_WARN_ON_FOLIO(is_zero_folio(folio), folio)

Considering that uprobe hit on the zero folio is a very rare case, just
reject zero old folio immediately after get_user_page_vma_remote().

[ mingo: Cleaned up the changelog ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b6f19714588cf2366b0364234f97ba963688f63
  - https://git.kernel.org/stable/c/13cca2b73e2b0ec3ea6d6615d615395621d22752
  - https://git.kernel.org/stable/c/54011fc94422f094eaf47555284de70a4bc32bb9
  - https://git.kernel.org/stable/c/bddf10d26e6e5114e7415a0e442ec6f51a559468
  - https://git.kernel.org/stable/c/c4cb2bfa99513311886c1eb5c1c2ac26f3338a6e

------------------------------------------------------------

CVE ID: CVE-2025-21882
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Fix vport QoS cleanup on error

When enabling vport QoS fails, the scheduling node was never freed,
causing a leak.

Add the missing free and reset the vport scheduling node pointer to
NULL.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7f3528f7d2f98b70e19a6bb7b130fc82c079ac54
  - https://git.kernel.org/stable/c/fead368502bce0e10bea7c0d2895b2fa0c6c10aa

------------------------------------------------------------

CVE ID: CVE-2025-21883
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: Fix deinitializing VF in error path

If ice_ena_vfs() fails after calling ice_create_vf_entries(), it frees
all VFs without removing them from snapshot PF-VF mailbox list, leading
to list corruption.

Reproducer:
  devlink dev eswitch set $PF1_PCI mode switchdev
  ip l s $PF1 up
  ip l s $PF1 promisc on
  sleep 1
  echo 1 > /sys/class/net/$PF1/device/sriov_numvfs
  sleep 1
  echo 1 > /sys/class/net/$PF1/device/sriov_numvfs

Trace (minimized):
  list_add corruption. next->prev should be prev (ffff8882e241c6f0), but was 0000000000000000. (next=ffff888455da1330).
  kernel BUG at lib/list_debug.c:29!
  RIP: 0010:__list_add_valid_or_report+0xa6/0x100
   ice_mbx_init_vf_info+0xa7/0x180 [ice]
   ice_initialize_vf_entry+0x1fa/0x250 [ice]
   ice_sriov_configure+0x8d7/0x1520 [ice]
   ? __percpu_ref_switch_mode+0x1b1/0x5d0
   ? __pfx_ice_sriov_configure+0x10/0x10 [ice]

Sometimes a KASAN report can be seen instead with a similar stack trace:
  BUG: KASAN: use-after-free in __list_add_valid_or_report+0xf1/0x100

VFs are added to this list in ice_mbx_init_vf_info(), but only removed
in ice_free_vfs(). Move the removing to ice_free_vf_entries(), which is
also being called in other places where VFs are being removed (including
ice_free_vfs() itself).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/34393fd78d7183a007eaf0090966ebedcc29bd57
  - https://git.kernel.org/stable/c/3c01102bec9592928e6b155da41cfcd5d25a2066
  - https://git.kernel.org/stable/c/79990cf5e7aded76d0c092c9f5ed31eb1c75e02c
  - https://git.kernel.org/stable/c/a4880583f88deba63504ce1c8287a70d39c01378

------------------------------------------------------------

CVE ID: CVE-2025-21884
Description: In the Linux kernel, the following vulnerability has been resolved:

net: better track kernel sockets lifetime

While kernel sockets are dismantled during pernet_operations->exit(),
their freeing can be delayed by any tx packets still held in qdisc
or device queues, due to skb_set_owner_w() prior calls.

This then trigger the following warning from ref_tracker_dir_exit() [1]

To fix this, make sure that kernel sockets own a reference on net->passive.

Add sk_net_refcnt_upgrade() helper, used whenever a kernel socket
is converted to a refcounted one.

[1]

[  136.263918][   T35] ref_tracker: net notrefcnt@ffff8880638f01e0 has 1/2 users at
[  136.263918][   T35]      sk_alloc+0x2b3/0x370
[  136.263918][   T35]      inet6_create+0x6ce/0x10f0
[  136.263918][   T35]      __sock_create+0x4c0/0xa30
[  136.263918][   T35]      inet_ctl_sock_create+0xc2/0x250
[  136.263918][   T35]      igmp6_net_init+0x39/0x390
[  136.263918][   T35]      ops_init+0x31e/0x590
[  136.263918][   T35]      setup_net+0x287/0x9e0
[  136.263918][   T35]      copy_net_ns+0x33f/0x570
[  136.263918][   T35]      create_new_namespaces+0x425/0x7b0
[  136.263918][   T35]      unshare_nsproxy_namespaces+0x124/0x180
[  136.263918][   T35]      ksys_unshare+0x57d/0xa70
[  136.263918][   T35]      __x64_sys_unshare+0x38/0x40
[  136.263918][   T35]      do_syscall_64+0xf3/0x230
[  136.263918][   T35]      entry_SYSCALL_64_after_hwframe+0x77/0x7f
[  136.263918][   T35]
[  136.343488][   T35] ref_tracker: net notrefcnt@ffff8880638f01e0 has 1/2 users at
[  136.343488][   T35]      sk_alloc+0x2b3/0x370
[  136.343488][   T35]      inet6_create+0x6ce/0x10f0
[  136.343488][   T35]      __sock_create+0x4c0/0xa30
[  136.343488][   T35]      inet_ctl_sock_create+0xc2/0x250
[  136.343488][   T35]      ndisc_net_init+0xa7/0x2b0
[  136.343488][   T35]      ops_init+0x31e/0x590
[  136.343488][   T35]      setup_net+0x287/0x9e0
[  136.343488][   T35]      copy_net_ns+0x33f/0x570
[  136.343488][   T35]      create_new_namespaces+0x425/0x7b0
[  136.343488][   T35]      unshare_nsproxy_namespaces+0x124/0x180
[  136.343488][   T35]      ksys_unshare+0x57d/0xa70
[  136.343488][   T35]      __x64_sys_unshare+0x38/0x40
[  136.343488][   T35]      do_syscall_64+0xf3/0x230
[  136.343488][   T35]      entry_SYSCALL_64_after_hwframe+0x77/0x7f
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5c70eb5c593d64d93b178905da215a9fd288a4b5
  - https://git.kernel.org/stable/c/c31a732fac46b00b95b78fcc9c37cb48dd6f2e0c

------------------------------------------------------------

CVE ID: CVE-2025-21885
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/bnxt_re: Fix the page details for the srq created by kernel consumers

While using nvme target with use_srq on, below kernel panic is noticed.

[  549.698111] bnxt_en 0000:41:00.0 enp65s0np0: FEC autoneg off encoding: Clause 91 RS(544,514)
[  566.393619] Oops: divide error: 0000 [#1] PREEMPT SMP NOPTI
..
[  566.393799]  <TASK>
[  566.393807]  ? __die_body+0x1a/0x60
[  566.393823]  ? die+0x38/0x60
[  566.393835]  ? do_trap+0xe4/0x110
[  566.393847]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]
[  566.393867]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]
[  566.393881]  ? do_error_trap+0x7c/0x120
[  566.393890]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]
[  566.393911]  ? exc_divide_error+0x34/0x50
[  566.393923]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]
[  566.393939]  ? asm_exc_divide_error+0x16/0x20
[  566.393966]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]
[  566.393997]  bnxt_qplib_create_srq+0xc9/0x340 [bnxt_re]
[  566.394040]  bnxt_re_create_srq+0x335/0x3b0 [bnxt_re]
[  566.394057]  ? srso_return_thunk+0x5/0x5f
[  566.394068]  ? __init_swait_queue_head+0x4a/0x60
[  566.394090]  ib_create_srq_user+0xa7/0x150 [ib_core]
[  566.394147]  nvmet_rdma_queue_connect+0x7d0/0xbe0 [nvmet_rdma]
[  566.394174]  ? lock_release+0x22c/0x3f0
[  566.394187]  ? srso_return_thunk+0x5/0x5f

Page size and shift info is set only for the user space SRQs.
Set page size and page shift for kernel space SRQs also.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2cf8e6b52aecb8fbb71c41fe5add3212814031a2
  - https://git.kernel.org/stable/c/722c3db62bf60cd23acbdc8c4f445bfedae4498e
  - https://git.kernel.org/stable/c/b66535356a4834a234f99e16a97eb51f2c6c5a7d

------------------------------------------------------------

CVE ID: CVE-2025-21886
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix implicit ODP hang on parent deregistration

Fix the destroy_unused_implicit_child_mr() to prevent hanging during
parent deregistration as of below [1].

Upon entering destroy_unused_implicit_child_mr(), the reference count
for the implicit MR parent is incremented using:
refcount_inc_not_zero().

A corresponding decrement must be performed if
free_implicit_child_mr_work() is not called.

The code has been updated to properly manage the reference count that
was incremented.

[1]
INFO: task python3:2157 blocked for more than 120 seconds.
Not tainted 6.12.0-rc7+ #1633
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
task:python3         state:D stack:0     pid:2157 tgid:2157  ppid:1685   flags:0x00000000
Call Trace:
<TASK>
__schedule+0x420/0xd30
schedule+0x47/0x130
__mlx5_ib_dereg_mr+0x379/0x5d0 [mlx5_ib]
? __pfx_autoremove_wake_function+0x10/0x10
ib_dereg_mr_user+0x5f/0x120 [ib_core]
? lock_release+0xc6/0x280
destroy_hw_idr_uobject+0x1d/0x60 [ib_uverbs]
uverbs_destroy_uobject+0x58/0x1d0 [ib_uverbs]
uobj_destroy+0x3f/0x70 [ib_uverbs]
ib_uverbs_cmd_verbs+0x3e4/0xbb0 [ib_uverbs]
? __pfx_uverbs_destroy_def_handler+0x10/0x10 [ib_uverbs]
? lock_acquire+0xc1/0x2f0
? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]
? ib_uverbs_ioctl+0x116/0x170 [ib_uverbs]
? lock_release+0xc6/0x280
ib_uverbs_ioctl+0xe7/0x170 [ib_uverbs]
? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]
 __x64_sys_ioctl+0x1b0/0xa70
? kmem_cache_free+0x221/0x400
do_syscall_64+0x6b/0x140
entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7f20f21f017b
RSP: 002b:00007ffcfc4a77c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007ffcfc4a78d8 RCX: 00007f20f21f017b
RDX: 00007ffcfc4a78c0 RSI: 00000000c0181b01 RDI: 0000000000000003
RBP: 00007ffcfc4a78a0 R08: 000056147d125190 R09: 00007f20f1f14c60
R10: 0000000000000001 R11: 0000000000000246 R12: 00007ffcfc4a7890
R13: 000000000000001c R14: 000056147d100fc0 R15: 00007f20e365c9d0
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3d8c6f26893d55fab218ad086719de1fc9bb86ba
  - https://git.kernel.org/stable/c/a095ede2daca49d15e74d66d014883f2fa8bb924
  - https://git.kernel.org/stable/c/cb96ae783e7249e8e5a50c22952c0bb2983133df

------------------------------------------------------------

CVE ID: CVE-2025-21887
Description: In the Linux kernel, the following vulnerability has been resolved:

ovl: fix UAF in ovl_dentry_update_reval by moving dput() in ovl_link_up

The issue was caused by dput(upper) being called before
ovl_dentry_update_reval(), while upper->d_flags was still
accessed in ovl_dentry_remote().

Move dput(upper) after its last use to prevent use-after-free.

BUG: KASAN: slab-use-after-free in ovl_dentry_remote fs/overlayfs/util.c:162 [inline]
BUG: KASAN: slab-use-after-free in ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167

Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114
 print_address_description mm/kasan/report.c:377 [inline]
 print_report+0xc3/0x620 mm/kasan/report.c:488
 kasan_report+0xd9/0x110 mm/kasan/report.c:601
 ovl_dentry_remote fs/overlayfs/util.c:162 [inline]
 ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167
 ovl_link_up fs/overlayfs/copy_up.c:610 [inline]
 ovl_copy_up_one+0x2105/0x3490 fs/overlayfs/copy_up.c:1170
 ovl_copy_up_flags+0x18d/0x200 fs/overlayfs/copy_up.c:1223
 ovl_rename+0x39e/0x18c0 fs/overlayfs/dir.c:1136
 vfs_rename+0xf84/0x20a0 fs/namei.c:4893
...
 </TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.188, Last Version (Excluding): 5.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.121, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.39, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.3.13, Last Version (Excluding): 6.4
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4.4, Last Version (Excluding): 6.6.81
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.18
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.6
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3594aad97e7be2557ca9fa9c931b206b604028c8
  - https://git.kernel.org/stable/c/4b49d939b5a79117f939b77cc67efae2694d9799
  - https://git.kernel.org/stable/c/60b4b5c1277fc491da9e1e7abab307bfa39c2db7
  - https://git.kernel.org/stable/c/64455c8051c3aedc71abb7ec8d47c80301f99f00
  - https://git.kernel.org/stable/c/a7c41830ffcd17b2177a95a9b99b270302090c35
  - https://git.kernel.org/stable/c/c84e125fff2615b4d9c259e762596134eddd2f27

------------------------------------------------------------

CVE ID: CVE-2025-21888
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix a WARN during dereg_mr for DM type

Memory regions (MR) of type DM (device memory) do not have an associated
umem.

In the __mlx5_ib_dereg_mr() -> mlx5_free_priv_descs() flow, the code
incorrectly takes the wrong branch, attempting to call
dma_unmap_single() on a DMA address that is not mapped.

This results in a WARN [1], as shown below.

The issue is resolved by properly accounting for the DM type and
ensuring the correct branch is selected in mlx5_free_priv_descs().

[1]
WARNING: CPU: 12 PID: 1346 at drivers/iommu/dma-iommu.c:1230 iommu_dma_unmap_page+0x79/0x90
Modules linked in: ip6table_mangle ip6table_nat ip6table_filter ip6_tables iptable_mangle xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry ovelay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core fuse mlx5_core
CPU: 12 UID: 0 PID: 1346 Comm: ibv_rc_pingpong Not tainted 6.12.0-rc7+ #1631
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
RIP: 0010:iommu_dma_unmap_page+0x79/0x90
Code: 2b 49 3b 29 72 26 49 3b 69 08 73 20 4d 89 f0 44 89 e9 4c 89 e2 48 89 ee 48 89 df 5b 5d 41 5c 41 5d 41 5e 41 5f e9 07 b8 88 ff <0f> 0b 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 66 0f 1f 44 00
RSP: 0018:ffffc90001913a10 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff88810194b0a8 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000001
RBP: ffff88810194b0a8 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000
R13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000000
FS:  00007f537abdd740(0000) GS:ffff88885fb00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f537aeb8000 CR3: 000000010c248001 CR4: 0000000000372eb0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
? __warn+0x84/0x190
? iommu_dma_unmap_page+0x79/0x90
? report_bug+0xf8/0x1c0
? handle_bug+0x55/0x90
? exc_invalid_op+0x13/0x60
? asm_exc_invalid_op+0x16/0x20
? iommu_dma_unmap_page+0x79/0x90
dma_unmap_page_attrs+0xe6/0x290
mlx5_free_priv_descs+0xb0/0xe0 [mlx5_ib]
__mlx5_ib_dereg_mr+0x37e/0x520 [mlx5_ib]
? _raw_spin_unlock_irq+0x24/0x40
? wait_for_completion+0xfe/0x130
? rdma_restrack_put+0x63/0xe0 [ib_core]
ib_dereg_mr_user+0x5f/0x120 [ib_core]
? lock_release+0xc6/0x280
destroy_hw_idr_uobject+0x1d/0x60 [ib_uverbs]
uverbs_destroy_uobject+0x58/0x1d0 [ib_uverbs]
uobj_destroy+0x3f/0x70 [ib_uverbs]
ib_uverbs_cmd_verbs+0x3e4/0xbb0 [ib_uverbs]
? __pfx_uverbs_destroy_def_handler+0x10/0x10 [ib_uverbs]
? lock_acquire+0xc1/0x2f0
? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]
? ib_uverbs_ioctl+0x116/0x170 [ib_uverbs]
? lock_release+0xc6/0x280
ib_uverbs_ioctl+0xe7/0x170 [ib_uverbs]
? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]
__x64_sys_ioctl+0x1b0/0xa70
do_syscall_64+0x6b/0x140
entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7f537adaf17b
Code: 0f 1e fa 48 8b 05 1d ad 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d ed ac 0c 00 f7 d8 64 89 01 48
RSP: 002b:00007ffff218f0b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007ffff218f1d8 RCX: 00007f537adaf17b
RDX: 00007ffff218f1c0 RSI: 00000000c0181b01 RDI: 0000000000000003
RBP: 00007ffff218f1a0 R08: 00007f537aa8d010 R09: 0000561ee2e4f270
R10: 00007f537aace3a8 R11: 0000000000000246 R12: 00007ffff218f190
R13: 000000000000001c R14: 0000561ee2e4d7c0 R15: 00007ffff218f450
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0bd34bdd468e93a779c403de3cf7d43ee633b3e0
  - https://git.kernel.org/stable/c/abc7b3f1f056d69a8f11d6dceecc0c9549ace770
  - https://git.kernel.org/stable/c/f1298cad47ae29828c5c5be77e733ccfcaef6a7f

------------------------------------------------------------

CVE ID: CVE-2025-21889
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/core: Add RCU read lock protection to perf_iterate_ctx()

The perf_iterate_ctx() function performs RCU list traversal but
currently lacks RCU read lock protection. This causes lockdep warnings
when running perf probe with unshare(1) under CONFIG_PROVE_RCU_LIST=y:

	WARNING: suspicious RCU usage
	kernel/events/core.c:8168 RCU-list traversed in non-reader section!!

	 Call Trace:
	  lockdep_rcu_suspicious
	  ? perf_event_addr_filters_apply
	  perf_iterate_ctx
	  perf_event_exec
	  begin_new_exec
	  ? load_elf_phdrs
	  load_elf_binary
	  ? lock_acquire
	  ? find_held_lock
	  ? bprm_execve
	  bprm_execve
	  do_execveat_common.isra.0
	  __x64_sys_execve
	  do_syscall_64
	  entry_SYSCALL_64_after_hwframe

This protection was previously present but was removed in commit
bd2756811766 ("perf: Rewrite core context handling"). Add back the
necessary rcu_read_lock()/rcu_read_unlock() pair around
perf_iterate_ctx() call in perf_event_exec().

[ mingo: Use scoped_guard() as suggested by Peter ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0fe8813baf4b2e865d3b2c735ce1a15b86002c74
  - https://git.kernel.org/stable/c/a2475ccad6120546ea45dbcd6cd1f74dc565ef6b
  - https://git.kernel.org/stable/c/dd536566dda9a551fc2a2acfab5313a5bb13ed02
  - https://git.kernel.org/stable/c/f390c2eea571945f357a2d3b9fcb1c015767132e

------------------------------------------------------------

CVE ID: CVE-2025-21890
Description: In the Linux kernel, the following vulnerability has been resolved:

idpf: fix checksums set in idpf_rx_rsc()

idpf_rx_rsc() uses skb_transport_offset(skb) while the transport header
is not set yet.

This triggers the following warning for CONFIG_DEBUG_NET=y builds.

DEBUG_NET_WARN_ON_ONCE(!skb_transport_header_was_set(skb))

[   69.261620] WARNING: CPU: 7 PID: 0 at ./include/linux/skbuff.h:3020 idpf_vport_splitq_napi_poll (include/linux/skbuff.h:3020) idpf
[   69.261629] Modules linked in: vfat fat dummy bridge intel_uncore_frequency_tpmi intel_uncore_frequency_common intel_vsec_tpmi idpf intel_vsec cdc_ncm cdc_eem cdc_ether usbnet mii xhci_pci xhci_hcd ehci_pci ehci_hcd libeth
[   69.261644] CPU: 7 UID: 0 PID: 0 Comm: swapper/7 Tainted: G S      W          6.14.0-smp-DEV #1697
[   69.261648] Tainted: [S]=CPU_OUT_OF_SPEC, [W]=WARN
[   69.261650] RIP: 0010:idpf_vport_splitq_napi_poll (include/linux/skbuff.h:3020) idpf
[   69.261677] ? __warn (kernel/panic.c:242 kernel/panic.c:748)
[   69.261682] ? idpf_vport_splitq_napi_poll (include/linux/skbuff.h:3020) idpf
[   69.261687] ? report_bug (lib/bug.c:?)
[   69.261690] ? handle_bug (arch/x86/kernel/traps.c:285)
[   69.261694] ? exc_invalid_op (arch/x86/kernel/traps.c:309)
[   69.261697] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h:621)
[   69.261700] ? __pfx_idpf_vport_splitq_napi_poll (drivers/net/ethernet/intel/idpf/idpf_txrx.c:4011) idpf
[   69.261704] ? idpf_vport_splitq_napi_poll (include/linux/skbuff.h:3020) idpf
[   69.261708] ? idpf_vport_splitq_napi_poll (drivers/net/ethernet/intel/idpf/idpf_txrx.c:3072) idpf
[   69.261712] __napi_poll (net/core/dev.c:7194)
[   69.261716] net_rx_action (net/core/dev.c:7265)
[   69.261718] ? __qdisc_run (net/sched/sch_generic.c:293)
[   69.261721] ? sched_clock (arch/x86/include/asm/preempt.h:84 arch/x86/kernel/tsc.c:288)
[   69.261726] handle_softirqs (kernel/softirq.c:561)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4279bbebe00ffdbfd1a77567961886e35465cbdc
  - https://git.kernel.org/stable/c/57e68f256911f3ab4b997141975561646ccbbb8c
  - https://git.kernel.org/stable/c/674fcb4f4a7e3e277417a01788cc6daae47c3804

------------------------------------------------------------

CVE ID: CVE-2025-21891
Description: In the Linux kernel, the following vulnerability has been resolved:

ipvlan: ensure network headers are in skb linear part

syzbot found that ipvlan_process_v6_outbound() was assuming
the IPv6 network header isis present in skb->head [1]

Add the needed pskb_network_may_pull() calls for both
IPv4 and IPv6 handlers.

[1]
BUG: KMSAN: uninit-value in __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47
  __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47
  ipv6_addr_type include/net/ipv6.h:555 [inline]
  ip6_route_output_flags_noref net/ipv6/route.c:2616 [inline]
  ip6_route_output_flags+0x51/0x720 net/ipv6/route.c:2651
  ip6_route_output include/net/ip6_route.h:93 [inline]
  ipvlan_route_v6_outbound+0x24e/0x520 drivers/net/ipvlan/ipvlan_core.c:476
  ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:491 [inline]
  ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:541 [inline]
  ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:605 [inline]
  ipvlan_queue_xmit+0xd72/0x1780 drivers/net/ipvlan/ipvlan_core.c:671
  ipvlan_start_xmit+0x5b/0x210 drivers/net/ipvlan/ipvlan_main.c:223
  __netdev_start_xmit include/linux/netdevice.h:5150 [inline]
  netdev_start_xmit include/linux/netdevice.h:5159 [inline]
  xmit_one net/core/dev.c:3735 [inline]
  dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3751
  sch_direct_xmit+0x399/0xd40 net/sched/sch_generic.c:343
  qdisc_restart net/sched/sch_generic.c:408 [inline]
  __qdisc_run+0x14da/0x35d0 net/sched/sch_generic.c:416
  qdisc_run+0x141/0x4d0 include/net/pkt_sched.h:127
  net_tx_action+0x78b/0x940 net/core/dev.c:5484
  handle_softirqs+0x1a0/0x7c0 kernel/softirq.c:561
  __do_softirq+0x14/0x1a kernel/softirq.c:595
  do_softirq+0x9a/0x100 kernel/softirq.c:462
  __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:389
  local_bh_enable include/linux/bottom_half.h:33 [inline]
  rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline]
  __dev_queue_xmit+0x2758/0x57d0 net/core/dev.c:4611
  dev_queue_xmit include/linux/netdevice.h:3311 [inline]
  packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276
  packet_snd net/packet/af_packet.c:3132 [inline]
  packet_sendmsg+0x93e0/0xa7e0 net/packet/af_packet.c:3164
  sock_sendmsg_nosec net/socket.c:718 [inline]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.19, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.81
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.18
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.6
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/27843ce6ba3d3122b65066550fe33fb8839f8aef
  - https://git.kernel.org/stable/c/4ec48f812804f370f622e0874e6dd8fcc58241cd
  - https://git.kernel.org/stable/c/5353fd89663c48f56bdff975c562cfe78b1a2e4c
  - https://git.kernel.org/stable/c/5b8dea8d1612dc7151d2457d7d2e6a69820309bf
  - https://git.kernel.org/stable/c/e2a4f76a2d8a44816ecd25bcbdb47b786d621974

------------------------------------------------------------

CVE ID: CVE-2025-21892
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix the recovery flow of the UMR QP

This patch addresses an issue in the recovery flow of the UMR QP,
ensuring tasks do not get stuck, as highlighted by the call trace [1].

During recovery, before transitioning the QP to the RESET state, the
software must wait for all outstanding WRs to complete.

Failing to do so can cause the firmware to skip sending some flushed
CQEs with errors and simply discard them upon the RESET, as per the IB
specification.

This race condition can result in lost CQEs and tasks becoming stuck.

To resolve this, the patch sends a final WR which serves only as a
barrier before moving the QP state to RESET.

Once a CQE is received for that final WR, it guarantees that no
outstanding WRs remain, making it safe to transition the QP to RESET and
subsequently back to RTS, restoring proper functionality.

Note:
For the barrier WR, we simply reuse the failed and ready WR.
Since the QP is in an error state, it will only receive
IB_WC_WR_FLUSH_ERR. However, as it serves only as a barrier we don't
care about its status.

[1]
INFO: task rdma_resource_l:1922 blocked for more than 120 seconds.
Tainted: G        W          6.12.0-rc7+ #1626
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
task:rdma_resource_l state:D stack:0  pid:1922 tgid:1922  ppid:1369
     flags:0x00004004
Call Trace:
<TASK>
__schedule+0x420/0xd30
schedule+0x47/0x130
schedule_timeout+0x280/0x300
? mark_held_locks+0x48/0x80
? lockdep_hardirqs_on_prepare+0xe5/0x1a0
wait_for_completion+0x75/0x130
mlx5r_umr_post_send_wait+0x3c2/0x5b0 [mlx5_ib]
? __pfx_mlx5r_umr_done+0x10/0x10 [mlx5_ib]
mlx5r_umr_revoke_mr+0x93/0xc0 [mlx5_ib]
__mlx5_ib_dereg_mr+0x299/0x520 [mlx5_ib]
? _raw_spin_unlock_irq+0x24/0x40
? wait_for_completion+0xfe/0x130
? rdma_restrack_put+0x63/0xe0 [ib_core]
ib_dereg_mr_user+0x5f/0x120 [ib_core]
? lock_release+0xc6/0x280
destroy_hw_idr_uobject+0x1d/0x60 [ib_uverbs]
uverbs_destroy_uobject+0x58/0x1d0 [ib_uverbs]
uobj_destroy+0x3f/0x70 [ib_uverbs]
ib_uverbs_cmd_verbs+0x3e4/0xbb0 [ib_uverbs]
? __pfx_uverbs_destroy_def_handler+0x10/0x10 [ib_uverbs]
? __lock_acquire+0x64e/0x2080
? mark_held_locks+0x48/0x80
? find_held_lock+0x2d/0xa0
? lock_acquire+0xc1/0x2f0
? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]
? __fget_files+0xc3/0x1b0
ib_uverbs_ioctl+0xe7/0x170 [ib_uverbs]
? ib_uverbs_ioctl+0xcb/0x170 [ib_uverbs]
__x64_sys_ioctl+0x1b0/0xa70
do_syscall_64+0x6b/0x140
entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7f99c918b17b
RSP: 002b:00007ffc766d0468 EFLAGS: 00000246 ORIG_RAX:
     0000000000000010
RAX: ffffffffffffffda RBX: 00007ffc766d0578 RCX:
     00007f99c918b17b
RDX: 00007ffc766d0560 RSI: 00000000c0181b01 RDI:
     0000000000000003
RBP: 00007ffc766d0540 R08: 00007f99c8f99010 R09:
     000000000000bd7e
R10: 00007f99c94c1c70 R11: 0000000000000246 R12:
     00007ffc766d0530
R13: 000000000000001c R14: 0000000040246a80 R15:
     0000000000000000
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d2b84d8d054313deed2b2fcafe1168bbcb9e99f
  - https://git.kernel.org/stable/c/3e3bf255992cc02404e9d209b127c1c9944239cf
  - https://git.kernel.org/stable/c/d97505baea64d93538b16baf14ce7b8c1fbad746

------------------------------------------------------------

CVE ID: CVE-2021-4454
Description: In the Linux kernel, the following vulnerability has been resolved:

can: j1939: fix errant WARN_ON_ONCE in j1939_session_deactivate

The conclusion "j1939_session_deactivate() should be called with a
session ref-count of at least 2" is incorrect. In some concurrent
scenarios, j1939_session_deactivate can be called with the session
ref-count less than 2. But there is not any problem because it
will check the session active state before session putting in
j1939_session_deactivate_locked().

Here is the concurrent scenario of the problem reported by syzbot
and my reproduction log.

        cpu0                            cpu1
                                j1939_xtp_rx_eoma
j1939_xtp_rx_abort_one
                                j1939_session_get_by_addr [kref == 2]
j1939_session_get_by_addr [kref == 3]
j1939_session_deactivate [kref == 2]
j1939_session_put [kref == 1]
				j1939_session_completed
				j1939_session_deactivate
				WARN_ON_ONCE(kref < 2)

=====================================================
WARNING: CPU: 1 PID: 21 at net/can/j1939/transport.c:1088 j1939_session_deactivate+0x5f/0x70
CPU: 1 PID: 21 Comm: ksoftirqd/1 Not tainted 5.14.0-rc7+ #32
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04/01/2014
RIP: 0010:j1939_session_deactivate+0x5f/0x70
Call Trace:
 j1939_session_deactivate_activate_next+0x11/0x28
 j1939_xtp_rx_eoma+0x12a/0x180
 j1939_tp_recv+0x4a2/0x510
 j1939_can_recv+0x226/0x380
 can_rcv_filter+0xf8/0x220
 can_receive+0x102/0x220
 ? process_backlog+0xf0/0x2c0
 can_rcv+0x53/0xf0
 __netif_receive_skb_one_core+0x67/0x90
 ? process_backlog+0x97/0x2c0
 __netif_receive_skb+0x22/0x80
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1740a1e45eee65099a92fb502e1e67e63aad277d
  - https://git.kernel.org/stable/c/6950df42a03c9ac9290503ced3f371199cb68fa9
  - https://git.kernel.org/stable/c/9ab896775f98ff54b68512f345eed178bf961084
  - https://git.kernel.org/stable/c/b6d44072117bba057d50f7a2f96e5d070c65926d
  - https://git.kernel.org/stable/c/d0553680f94c49bbe0e39eb50d033ba563b4212d

------------------------------------------------------------

CVE ID: CVE-2022-49738
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check on i_extra_isize in is_alive()

syzbot found a f2fs bug:

BUG: KASAN: slab-out-of-bounds in data_blkaddr fs/f2fs/f2fs.h:2891 [inline]
BUG: KASAN: slab-out-of-bounds in is_alive fs/f2fs/gc.c:1117 [inline]
BUG: KASAN: slab-out-of-bounds in gc_data_segment fs/f2fs/gc.c:1520 [inline]
BUG: KASAN: slab-out-of-bounds in do_garbage_collect+0x386a/0x3df0 fs/f2fs/gc.c:1734
Read of size 4 at addr ffff888076557568 by task kworker/u4:3/52

CPU: 1 PID: 52 Comm: kworker/u4:3 Not tainted 6.1.0-rc4-syzkaller-00362-gfef7fd48922d #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
Workqueue: writeback wb_workfn (flush-7:0)
Call Trace:
<TASK>
__dump_stack lib/dump_stack.c:88 [inline]
dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
print_address_description mm/kasan/report.c:284 [inline]
print_report+0x15e/0x45d mm/kasan/report.c:395
kasan_report+0xbb/0x1f0 mm/kasan/report.c:495
data_blkaddr fs/f2fs/f2fs.h:2891 [inline]
is_alive fs/f2fs/gc.c:1117 [inline]
gc_data_segment fs/f2fs/gc.c:1520 [inline]
do_garbage_collect+0x386a/0x3df0 fs/f2fs/gc.c:1734
f2fs_gc+0x88c/0x20a0 fs/f2fs/gc.c:1831
f2fs_balance_fs+0x544/0x6b0 fs/f2fs/segment.c:410
f2fs_write_inode+0x57e/0xe20 fs/f2fs/inode.c:753
write_inode fs/fs-writeback.c:1440 [inline]
__writeback_single_inode+0xcfc/0x1440 fs/fs-writeback.c:1652
writeback_sb_inodes+0x54d/0xf90 fs/fs-writeback.c:1870
wb_writeback+0x2c5/0xd70 fs/fs-writeback.c:2044
wb_do_writeback fs/fs-writeback.c:2187 [inline]
wb_workfn+0x2dc/0x12f0 fs/fs-writeback.c:2227
process_one_work+0x9bf/0x1710 kernel/workqueue.c:2289
worker_thread+0x665/0x1080 kernel/workqueue.c:2436
kthread+0x2e4/0x3a0 kernel/kthread.c:376
ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306

The root cause is that we forgot to do sanity check on .i_extra_isize
in below path, result in accessing invalid address later, fix it.
- gc_data_segment
 - is_alive
  - data_blkaddr
   - offset_in_addr
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
References:
  - https://git.kernel.org/stable/c/5b25035fb888cb2f78bf0b9c9f95b1dc54480d36
  - https://git.kernel.org/stable/c/914e38f02a490dafd980ff0f39cccedc074deb29
  - https://git.kernel.org/stable/c/97ccfffcc061e54ce87e4a51a40e2e9cb0b7076a
  - https://git.kernel.org/stable/c/d3b7b4afd6b2c344eabf9cc26b8bfa903c164c7c
  - https://git.kernel.org/stable/c/e5142a4935c1f15841d06047b8130078fc4d7b8f

------------------------------------------------------------

CVE ID: CVE-2022-49739
Description: In the Linux kernel, the following vulnerability has been resolved:

gfs2: Always check inode size of inline inodes

Check if the inode size of stuffed (inline) inodes is within the allowed
range when reading inodes from disk (gfs2_dinode_in()).  This prevents
us from on-disk corruption.

The two checks in stuffed_readpage() and gfs2_unstuffer_page() that just
truncate inline data to the maximum allowed size don't actually make
sense, and they can be removed now as well.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/45df749f827c286adbc951f2a4865b67f0442ba9
  - https://git.kernel.org/stable/c/46c9088cabd4d0469fdb61ac2a9c5003057fe94d
  - https://git.kernel.org/stable/c/4d4cb76636134bf9a0c9c3432dae936f99954586
  - https://git.kernel.org/stable/c/70376c7ff31221f1d21db5611d8209e677781d3a
  - https://git.kernel.org/stable/c/7c414f6f06e9a3934901b6edc3177ae5a1e07094
  - https://git.kernel.org/stable/c/d458a0984429c2d47e60254f5bc4119cbafe83a2

------------------------------------------------------------

CVE ID: CVE-2022-49740
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: brcmfmac: Check the count value of channel spec to prevent out-of-bounds reads

This patch fixes slab-out-of-bounds reads in brcmfmac that occur in
brcmf_construct_chaninfo() and brcmf_enable_bw40_2g() when the count
value of channel specifications provided by the device is greater than
the length of 'list->element[]', decided by the size of the 'list'
allocated with kzalloc(). The patch adds checks that make the functions
free the buffer and return -EINVAL if that is the case. Note that the
negative return is handled by the caller, brcmf_setup_wiphybands() or
brcmf_cfg80211_attach().

Found by a modified version of syzkaller.

Crash Report from brcmf_construct_chaninfo():
==================================================================
BUG: KASAN: slab-out-of-bounds in brcmf_setup_wiphybands+0x1238/0x1430
Read of size 4 at addr ffff888115f24600 by task kworker/0:2/1896

CPU: 0 PID: 1896 Comm: kworker/0:2 Tainted: G        W  O      5.14.0+ #132
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014
Workqueue: usb_hub_wq hub_event
Call Trace:
 dump_stack_lvl+0x57/0x7d
 print_address_description.constprop.0.cold+0x93/0x334
 kasan_report.cold+0x83/0xdf
 brcmf_setup_wiphybands+0x1238/0x1430
 brcmf_cfg80211_attach+0x2118/0x3fd0
 brcmf_attach+0x389/0xd40
 brcmf_usb_probe+0x12de/0x1690
 usb_probe_interface+0x25f/0x710
 really_probe+0x1be/0xa90
 __driver_probe_device+0x2ab/0x460
 driver_probe_device+0x49/0x120
 __device_attach_driver+0x18a/0x250
 bus_for_each_drv+0x123/0x1a0
 __device_attach+0x207/0x330
 bus_probe_device+0x1a2/0x260
 device_add+0xa61/0x1ce0
 usb_set_configuration+0x984/0x1770
 usb_generic_driver_probe+0x69/0x90
 usb_probe_device+0x9c/0x220
 really_probe+0x1be/0xa90
 __driver_probe_device+0x2ab/0x460
 driver_probe_device+0x49/0x120
 __device_attach_driver+0x18a/0x250
 bus_for_each_drv+0x123/0x1a0
 __device_attach+0x207/0x330
 bus_probe_device+0x1a2/0x260
 device_add+0xa61/0x1ce0
 usb_new_device.cold+0x463/0xf66
 hub_event+0x10d5/0x3330
 process_one_work+0x873/0x13e0
 worker_thread+0x8b/0xd10
 kthread+0x379/0x450
 ret_from_fork+0x1f/0x30

Allocated by task 1896:
 kasan_save_stack+0x1b/0x40
 __kasan_kmalloc+0x7c/0x90
 kmem_cache_alloc_trace+0x19e/0x330
 brcmf_setup_wiphybands+0x290/0x1430
 brcmf_cfg80211_attach+0x2118/0x3fd0
 brcmf_attach+0x389/0xd40
 brcmf_usb_probe+0x12de/0x1690
 usb_probe_interface+0x25f/0x710
 really_probe+0x1be/0xa90
 __driver_probe_device+0x2ab/0x460
 driver_probe_device+0x49/0x120
 __device_attach_driver+0x18a/0x250
 bus_for_each_drv+0x123/0x1a0
 __device_attach+0x207/0x330
 bus_probe_device+0x1a2/0x260
 device_add+0xa61/0x1ce0
 usb_set_configuration+0x984/0x1770
 usb_generic_driver_probe+0x69/0x90
 usb_probe_device+0x9c/0x220
 really_probe+0x1be/0xa90
 __driver_probe_device+0x2ab/0x460
 driver_probe_device+0x49/0x120
 __device_attach_driver+0x18a/0x250
 bus_for_each_drv+0x123/0x1a0
 __device_attach+0x207/0x330
 bus_probe_device+0x1a2/0x260
 device_add+0xa61/0x1ce0
 usb_new_device.cold+0x463/0xf66
 hub_event+0x10d5/0x3330
 process_one_work+0x873/0x13e0
 worker_thread+0x8b/0xd10
 kthread+0x379/0x450
 ret_from_fork+0x1f/0x30

The buggy address belongs to the object at ffff888115f24000
 which belongs to the cache kmalloc-2k of size 2048
The buggy address is located 1536 bytes inside of
 2048-byte region [ffff888115f24000, ffff888115f24800)

Memory state around the buggy address:
 ffff888115f24500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 ffff888115f24580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>ffff888115f24600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
                   ^
 ffff888115f24680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff888115f24700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
==================================================================

Crash Report from brcmf_enable_bw40_2g():
==========
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
References:
  - https://git.kernel.org/stable/c/4920ab131b2dbae7464b72bdcac465d070254209
  - https://git.kernel.org/stable/c/9cf5e99c1ae1a85286a76c9a970202750538394c
  - https://git.kernel.org/stable/c/b2e412879595821ff1b5545cbed5f108fba7f5b6
  - https://git.kernel.org/stable/c/e4991910f15013db72f6ec0db7038ea67a57052e
  - https://git.kernel.org/stable/c/f06de1bb6d61f0c18b0213bbc6298960037f9d42

------------------------------------------------------------

CVE ID: CVE-2022-49741
Description: In the Linux kernel, the following vulnerability has been resolved:

fbdev: smscufx: fix error handling code in ufx_usb_probe

The current error handling code in ufx_usb_probe have many unmatching
issues, e.g., missing ufx_free_usb_list, destroy_modedb label should
only include framebuffer_release, fb_dealloc_cmap only matches
fb_alloc_cmap.

My local syzkaller reports a memory leak bug:

memory leak in ufx_usb_probe

BUG: memory leak
unreferenced object 0xffff88802f879580 (size 128):
  comm "kworker/0:7", pid 17416, jiffies 4295067474 (age 46.710s)
  hex dump (first 32 bytes):
    80 21 7c 2e 80 88 ff ff 18 d0 d0 0c 80 88 ff ff  .!|.............
    00 d0 d0 0c 80 88 ff ff e0 ff ff ff 0f 00 00 00  ................
  backtrace:
    [<ffffffff814c99a0>] kmalloc_trace+0x20/0x90 mm/slab_common.c:1045
    [<ffffffff824d219c>] kmalloc include/linux/slab.h:553 [inline]
    [<ffffffff824d219c>] kzalloc include/linux/slab.h:689 [inline]
    [<ffffffff824d219c>] ufx_alloc_urb_list drivers/video/fbdev/smscufx.c:1873 [inline]
    [<ffffffff824d219c>] ufx_usb_probe+0x11c/0x15a0 drivers/video/fbdev/smscufx.c:1655
    [<ffffffff82d17927>] usb_probe_interface+0x177/0x370 drivers/usb/core/driver.c:396
    [<ffffffff82712f0d>] call_driver_probe drivers/base/dd.c:560 [inline]
    [<ffffffff82712f0d>] really_probe+0x12d/0x390 drivers/base/dd.c:639
    [<ffffffff8271322f>] __driver_probe_device+0xbf/0x140 drivers/base/dd.c:778
    [<ffffffff827132da>] driver_probe_device+0x2a/0x120 drivers/base/dd.c:808
    [<ffffffff82713c27>] __device_attach_driver+0xf7/0x150 drivers/base/dd.c:936
    [<ffffffff82710137>] bus_for_each_drv+0xb7/0x100 drivers/base/bus.c:427
    [<ffffffff827136b5>] __device_attach+0x105/0x2d0 drivers/base/dd.c:1008
    [<ffffffff82711d36>] bus_probe_device+0xc6/0xe0 drivers/base/bus.c:487
    [<ffffffff8270e242>] device_add+0x642/0xdc0 drivers/base/core.c:3517
    [<ffffffff82d14d5f>] usb_set_configuration+0x8ef/0xb80 drivers/usb/core/message.c:2170
    [<ffffffff82d2576c>] usb_generic_driver_probe+0x8c/0xc0 drivers/usb/core/generic.c:238
    [<ffffffff82d16ffc>] usb_probe_device+0x5c/0x140 drivers/usb/core/driver.c:293
    [<ffffffff82712f0d>] call_driver_probe drivers/base/dd.c:560 [inline]
    [<ffffffff82712f0d>] really_probe+0x12d/0x390 drivers/base/dd.c:639
    [<ffffffff8271322f>] __driver_probe_device+0xbf/0x140 drivers/base/dd.c:778

Fix this bug by rewriting the error handling code in ufx_usb_probe.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
References:
  - https://git.kernel.org/stable/c/1b4c08844628dfc8d72d3f51b657f2a5e63b7b4b
  - https://git.kernel.org/stable/c/3931014367ef31d26af65386a4ca496f50f0cfdf
  - https://git.kernel.org/stable/c/3b3d3127f5b4291ae4caaf50f7b66089ad600480
  - https://git.kernel.org/stable/c/64fa364ad3245508d393e16ed4886f92d7eb423c
  - https://git.kernel.org/stable/c/b76449ee75e21acfe9fa4c653d8598f191ed7d68

------------------------------------------------------------

CVE ID: CVE-2022-49742
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: initialize locks earlier in f2fs_fill_super()

syzbot is reporting lockdep warning at f2fs_handle_error() [1], for
spin_lock(&sbi->error_lock) is called before spin_lock_init() is called.
For safe locking in error handling, move initialization of locks (and
obvious structures) in f2fs_fill_super() to immediately after memory
allocation.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.11
References:
  - https://git.kernel.org/stable/c/92b4cf5b48955a4bdd15fe4e2067db8ebd87f04c
  - https://git.kernel.org/stable/c/ddeff03bb33810fcf2f0c18e03d099cf0aacda62

------------------------------------------------------------

CVE ID: CVE-2022-49743
Description: In the Linux kernel, the following vulnerability has been resolved:

ovl: Use "buf" flexible array for memcpy() destination

The "buf" flexible array needs to be the memcpy() destination to avoid
false positive run-time warning from the recent FORTIFY_SOURCE
hardening:

  memcpy: detected field-spanning write (size 93) of single field "&fh->fb"
  at fs/overlayfs/export.c:799 (size 21)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/07a96977b2f462337a9121302de64277b8747ab1
  - https://git.kernel.org/stable/c/a77141a06367825d639ac51b04703d551163e36c
  - https://git.kernel.org/stable/c/cf8aa9bf97cadf85745506c6a3e244b22c268d63

------------------------------------------------------------

CVE ID: CVE-2022-49744
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/uffd: fix pte marker when fork() without fork event

Patch series "mm: Fixes on pte markers".

Patch 1 resolves the syzkiller report from Pengfei.

Patch 2 further harden pte markers when used with the recent swapin error
markers.  The major case is we should persist a swapin error marker after
fork(), so child shouldn't read a corrupted page.


This patch (of 2):

When fork(), dst_vma is not guaranteed to have VM_UFFD_WP even if src may
have it and has pte marker installed.  The warning is improper along with
the comment.  The right thing is to inherit the pte marker when needed, or
keep the dst pte empty.

A vague guess is this happened by an accident when there's the prior patch
to introduce src/dst vma into this helper during the uffd-wp feature got
developed and I probably messed up in the rebase, since if we replace
dst_vma with src_vma the warning & comment it all makes sense too.

Hugetlb did exactly the right here (copy_hugetlb_page_range()).  Fix the
general path.

Reproducer:

https://github.com/xupengfe/syzkaller_logs/blob/main/221208_115556_copy_page_range/repro.c

Bugzilla report: https://bugzilla.kernel.org/show_bug.cgi?id=216808
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d11727655bf931776fb541f5862daf04bd5bf02
  - https://git.kernel.org/stable/c/49d6d7fb631345b0f2957a7c4be24ad63903150f

------------------------------------------------------------

CVE ID: CVE-2022-49745
Description: In the Linux kernel, the following vulnerability has been resolved:

fpga: m10bmc-sec: Fix probe rollback

Handle probe error rollbacks properly to avoid leaks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/60ce26d10e5850f33cc76fce52f5377045e75a15
  - https://git.kernel.org/stable/c/74cff472d3d66db13b5ef64f40dfa42383f71ff7

------------------------------------------------------------

CVE ID: CVE-2022-49746
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: imx-sdma: Fix a possible memory leak in sdma_transfer_init

If the function sdma_load_context() fails, the sdma_desc will be
freed, but the allocated desc->bd is forgot to be freed.

We already met the sdma_load_context() failure case and the log as
below:
[ 450.699064] imx-sdma 30bd0000.dma-controller: Timeout waiting for CH0 ready
...

In this case, the desc->bd will not be freed without this change.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.167
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.92
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.10
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1417f59ac0b02130ee56c0c50794b9b257be3d17
  - https://git.kernel.org/stable/c/43acd767bd90c5d4172ce7fee5d9007a9a08dea9
  - https://git.kernel.org/stable/c/80ee99e52936b2c04cc37b17a14b2ae2f9d282ac
  - https://git.kernel.org/stable/c/bd0050b7ffa87c7b260d563646af612f4112a778
  - https://git.kernel.org/stable/c/ce4745a6b8016fae74c95dcd457d4ceef7d98af1
  - https://git.kernel.org/stable/c/dbe634ce824329d8f14079c3e9f8f11670894bec

------------------------------------------------------------

CVE ID: CVE-2022-49747
Description: In the Linux kernel, the following vulnerability has been resolved:

erofs/zmap.c: Fix incorrect offset calculation

Effective offset to add to length was being incorrectly calculated,
which resulted in iomap->length being set to 0, triggering a WARN_ON
in iomap_iter_done().

Fix that, and describe it in comments.

This was reported as a crash by syzbot under an issue about a warning
encountered in iomap_iter_done(), but unrelated to erofs.

C reproducer: https://syzkaller.appspot.com/text?tag=ReproC&x=1037a6b2880000
Kernel config: https://syzkaller.appspot.com/text?tag=KernelConfig&x=e2021a61197ebe02
Dashboard link: https://syzkaller.appspot.com/bug?extid=a8e049cd3abd342936b6
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2144859229c1e74f52d3ea067338d314a83a8afb
  - https://git.kernel.org/stable/c/6acd87d50998ef0afafc441613aeaf5a8f5c9eff
  - https://git.kernel.org/stable/c/9f31d8c889d9a4e47bfcc6c4537d0c9f89fe582c

------------------------------------------------------------

CVE ID: CVE-2022-49748
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/x86/amd: fix potential integer overflow on shift of a int

The left shift of int 32 bit integer constant 1 is evaluated using 32 bit
arithmetic and then passed as a 64 bit function argument. In the case where
i is 32 or more this can lead to an overflow.  Avoid this by shifting
using the BIT_ULL macro instead.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.22, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5.6, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/08245672cdc6505550d1a5020603b0a8d4a6dcc7
  - https://git.kernel.org/stable/c/14cc13e433e1067557435b1adbf05608d7d47a93
  - https://git.kernel.org/stable/c/a4d01fb87ece45d4164fd725890211ccf9a307a9
  - https://git.kernel.org/stable/c/f84c9b72fb200633774704d8020f769c88a4b249
  - https://git.kernel.org/stable/c/fbf7b0e4cef3b5470b610f14fb9faa5ee7f63954

------------------------------------------------------------

CVE ID: CVE-2022-49749
Description: In the Linux kernel, the following vulnerability has been resolved:

i2c: designware: use casting of u64 in clock multiplication to avoid overflow

In functions i2c_dw_scl_lcnt() and i2c_dw_scl_hcnt() may have overflow
by depending on the values of the given parameters including the ic_clk.
For example in our use case where ic_clk is larger than one million,
multiplication of ic_clk * 4700 will result in 32 bit overflow.

Add cast of u64 to the calculation to avoid multiplication overflow, and
use the corresponding define for divide.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.2, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2f29d780bd691d20e89e5b35d5e6568607115e94
  - https://git.kernel.org/stable/c/9f36aae9e80e79b7a6d62227eaa96935166be9fe
  - https://git.kernel.org/stable/c/c8c37bc514514999e62a17e95160ed9ebf75ca8d
  - https://git.kernel.org/stable/c/ed173f77fd28a3e4fffc13b3f28687b9eba61157

------------------------------------------------------------

CVE ID: CVE-2022-49750
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: CPPC: Add u64 casts to avoid overflowing

The fields of the _CPC object are unsigned 32-bits values.
To avoid overflows while using _CPC's values, add 'u64' casts.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/7d596bbc66a52ff2c7a83d7e0ee840cb07e2a045
  - https://git.kernel.org/stable/c/f5f94b9c8b805d87ff185caf9779c3a4d07819e3

------------------------------------------------------------

CVE ID: CVE-2022-49751
Description: In the Linux kernel, the following vulnerability has been resolved:

w1: fix WARNING after calling w1_process()

I got the following WARNING message while removing driver(ds2482):

------------[ cut here ]------------
do not call blocking ops when !TASK_RUNNING; state=1 set at [<000000002d50bfb6>] w1_process+0x9e/0x1d0 [wire]
WARNING: CPU: 0 PID: 262 at kernel/sched/core.c:9817 __might_sleep+0x98/0xa0
CPU: 0 PID: 262 Comm: w1_bus_master1 Tainted: G                 N 6.1.0-rc3+ #307
RIP: 0010:__might_sleep+0x98/0xa0
Call Trace:
 exit_signals+0x6c/0x550
 do_exit+0x2b4/0x17e0
 kthread_exit+0x52/0x60
 kthread+0x16d/0x1e0
 ret_from_fork+0x1f/0x30

The state of task is set to TASK_INTERRUPTIBLE in loop in w1_process(),
set it to TASK_RUNNING when it breaks out of the loop to avoid the
warning.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.28, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/190b5c3bbd5df685bb1063bda048831d72b8f1d4
  - https://git.kernel.org/stable/c/216f35db6ec6a667cd9db4838d657c1d2f4684da
  - https://git.kernel.org/stable/c/276052159ba94d4d9f5b453fb4707d6798c6b845
  - https://git.kernel.org/stable/c/36225a7c72e9e3e1ce4001b6ce72849f5c9a2d3b
  - https://git.kernel.org/stable/c/89c62cee5d4d65ac75d99b5f986f7f94290e888f
  - https://git.kernel.org/stable/c/bccd6df4c177b1ad766f16565ccc298653d027d0
  - https://git.kernel.org/stable/c/cfc7462ff824ed6718ed0272ee9aae88e20d469a

------------------------------------------------------------

CVE ID: CVE-2022-49752
Description: In the Linux kernel, the following vulnerability has been resolved:

device property: fix of node refcount leak in fwnode_graph_get_next_endpoint()

The 'parent' returned by fwnode_graph_get_port_parent()
with refcount incremented when 'prev' is not NULL, it
needs be put when finish using it.

Because the parent is const, introduce a new variable to
store the returned fwnode, then put it before returning
from fwnode_graph_get_next_endpoint().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/39af728649b05e88a2b40e714feeee6451c3f18e
  - https://git.kernel.org/stable/c/7701a4bd45c11f9a289d8f262fad05705a012339
  - https://git.kernel.org/stable/c/e75485fc589ec729cc182aa9b41dfb6c15ae6f6e

------------------------------------------------------------

CVE ID: CVE-2022-49753
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: Fix double increment of client_count in dma_chan_get()

The first time dma_chan_get() is called for a channel the channel
client_count is incorrectly incremented twice for public channels,
first in balance_ref_count(), and again prior to returning. This
results in an incorrect client count which will lead to the
channel resources not being freed when they should be. A simple
 test of repeated module load and unload of async_tx on a Dell
 Power Edge R7425 also shows this resulting in a kref underflow
 warning.

[  124.329662] async_tx: api initialized (async)
[  129.000627] async_tx: api initialized (async)
[  130.047839] ------------[ cut here ]------------
[  130.052472] refcount_t: underflow; use-after-free.
[  130.057279] WARNING: CPU: 3 PID: 19364 at lib/refcount.c:28
refcount_warn_saturate+0xba/0x110
[  130.065811] Modules linked in: async_tx(-) rfkill intel_rapl_msr
intel_rapl_common amd64_edac edac_mce_amd ipmi_ssif kvm_amd dcdbas kvm
mgag200 drm_shmem_helper acpi_ipmi irqbypass drm_kms_helper ipmi_si
syscopyarea sysfillrect rapl pcspkr ipmi_devintf sysimgblt fb_sys_fops
k10temp i2c_piix4 ipmi_msghandler acpi_power_meter acpi_cpufreq vfat
fat drm fuse xfs libcrc32c sd_mod t10_pi sg ahci crct10dif_pclmul
libahci crc32_pclmul crc32c_intel ghash_clmulni_intel igb megaraid_sas
i40e libata i2c_algo_bit ccp sp5100_tco dca dm_mirror dm_region_hash
dm_log dm_mod [last unloaded: async_tx]
[  130.117361] CPU: 3 PID: 19364 Comm: modprobe Kdump: loaded Not
tainted 5.14.0-185.el9.x86_64 #1
[  130.126091] Hardware name: Dell Inc. PowerEdge R7425/02MJ3T, BIOS
1.18.0 01/17/2022
[  130.133806] RIP: 0010:refcount_warn_saturate+0xba/0x110
[  130.139041] Code: 01 01 e8 6d bd 55 00 0f 0b e9 72 9d 8a 00 80 3d
26 18 9c 01 00 75 85 48 c7 c7 f8 a3 03 9d c6 05 16 18 9c 01 01 e8 4a
bd 55 00 <0f> 0b e9 4f 9d 8a 00 80 3d 01 18 9c 01 00 0f 85 5e ff ff ff
48 c7
[  130.157807] RSP: 0018:ffffbf98898afe68 EFLAGS: 00010286
[  130.163036] RAX: 0000000000000000 RBX: ffff9da06028e598 RCX: 0000000000000000
[  130.170172] RDX: ffff9daf9de26480 RSI: ffff9daf9de198a0 RDI: ffff9daf9de198a0
[  130.177316] RBP: ffff9da7cddf3970 R08: 0000000000000000 R09: 00000000ffff7fff
[  130.184459] R10: ffffbf98898afd00 R11: ffffffff9d9e8c28 R12: ffff9da7cddf1970
[  130.191596] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[  130.198739] FS:  00007f646435c740(0000) GS:ffff9daf9de00000(0000)
knlGS:0000000000000000
[  130.206832] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  130.212586] CR2: 00007f6463b214f0 CR3: 00000008ab98c000 CR4: 00000000003506e0
[  130.219729] Call Trace:
[  130.222192]  <TASK>
[  130.224305]  dma_chan_put+0x10d/0x110
[  130.227988]  dmaengine_put+0x7a/0xa0
[  130.231575]  __do_sys_delete_module.constprop.0+0x178/0x280
[  130.237157]  ? syscall_trace_enter.constprop.0+0x145/0x1d0
[  130.242652]  do_syscall_64+0x5c/0x90
[  130.246240]  ? exc_page_fault+0x62/0x150
[  130.250178]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  130.255243] RIP: 0033:0x7f6463a3f5ab
[  130.258830] Code: 73 01 c3 48 8b 0d 75 a8 1b 00 f7 d8 64 89 01 48
83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 b0 00 00
00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 45 a8 1b 00 f7 d8 64 89
01 48
[  130.277591] RSP: 002b:00007fff22f972c8 EFLAGS: 00000206 ORIG_RAX:
00000000000000b0
[  130.285164] RAX: ffffffffffffffda RBX: 000055b6786edd40 RCX: 00007f6463a3f5ab
[  130.292303] RDX: 0000000000000000 RSI: 0000000000000800 RDI: 000055b6786edda8
[  130.299443] RBP: 000055b6786edd40 R08: 0000000000000000 R09: 0000000000000000
[  130.306584] R10: 00007f6463b9eac0 R11: 0000000000000206 R12: 000055b6786edda8
[  130.313731] R13: 0000000000000000 R14: 000055b6786edda8 R15: 00007fff22f995f8
[  130.320875]  </TASK>
[  130.323081] ---[ end trace eff7156d56b5cf25 ]---

cat /sys/class/dma/dma0chan*/in_use would get the wrong result.
2
2
2

Test-by: Jie Hai <haijie1@huawei.com>
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/142d644fd2cc059ffa042fbfb68e766433ef3afd
  - https://git.kernel.org/stable/c/18dd3b30d4c7e8440c63118c7a7b687372b9567f
  - https://git.kernel.org/stable/c/1b409e14b4b7af034e0450f95c165b6c5c87dbc1
  - https://git.kernel.org/stable/c/42ecd72f02cd657b00b559621e7ef7d2c4d3e5f1
  - https://git.kernel.org/stable/c/71c601965532c38030133535f7cd93c1efa75af1
  - https://git.kernel.org/stable/c/c6221afe573413fd2981e291f7df4a58283e0654
  - https://git.kernel.org/stable/c/f3dc1b3b4750851a94212dba249703dd0e50bb20

------------------------------------------------------------

CVE ID: CVE-2022-49754
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: Fix a buffer overflow in mgmt_mesh_add()

Smatch Warning:
net/bluetooth/mgmt_util.c:375 mgmt_mesh_add() error: __memcpy()
'mesh_tx->param' too small (48 vs 50)

Analysis:

'mesh_tx->param' is array of size 48. This is the destination.
u8 param[sizeof(struct mgmt_cp_mesh_send) + 29]; // 19 + 29 = 48.

But in the caller 'mesh_send' we reject only when len > 50.
len > (MGMT_MESH_SEND_SIZE + 31) // 19 + 31 = 50.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2185e0fdbb2137f22a9dd9fcbf6481400d56299b
  - https://git.kernel.org/stable/c/ed818fd8c531abf561b379995ee7cc4c68029464

------------------------------------------------------------

CVE ID: CVE-2022-49755
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: f_fs: Prevent race during ffs_ep0_queue_wait

While performing fast composition switch, there is a possibility that the
process of ffs_ep0_write/ffs_ep0_read get into a race condition
due to ep0req being freed up from functionfs_unbind.

Consider the scenario that the ffs_ep0_write calls the ffs_ep0_queue_wait
by taking a lock &ffs->ev.waitq.lock. However, the functionfs_unbind isn't
bounded so it can go ahead and mark the ep0req to NULL, and since there
is no NULL check in ffs_ep0_queue_wait we will end up in use-after-free.

Fix this by making a serialized execution between the two functions using
a mutex_lock(ffs->mutex).
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.35, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6a19da111057f69214b97c62fb0ac59023970850
  - https://git.kernel.org/stable/c/6aee197b7fbcd61596a78b47d553f2f99111f217
  - https://git.kernel.org/stable/c/6dd9ea05534f323668db94fcc2726c7a84547e78
  - https://git.kernel.org/stable/c/a8d40942df074f4ebcb9bd3413596d92f323b064
  - https://git.kernel.org/stable/c/ae8e136bcaae96163b5821984de1036efc9abb1a
  - https://git.kernel.org/stable/c/e9036e951f93fb8d7b5e9d6e2c7f94a4da312ae4
  - https://git.kernel.org/stable/c/facf353c9e8d7885b686d9a4b173d4e0af6441d2

------------------------------------------------------------

CVE ID: CVE-2022-49756
Description: In the Linux kernel, the following vulnerability has been resolved:

phy: usb: sunplus: Fix potential null-ptr-deref in sp_usb_phy_probe()

sp_usb_phy_probe() will call platform_get_resource_byname() that may fail
and return NULL. devm_ioremap() will use usbphy->moon4_res_mem->start as
input, which may causes null-ptr-deref. Check the ret value of
platform_get_resource_byname() to avoid the null-ptr-deref.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/17eee264ef386ef30a69dd70e36f29893b85c170
  - https://git.kernel.org/stable/c/d838b5c99bcecd593b4710a93fce8fdbf122395b

------------------------------------------------------------

CVE ID: CVE-2022-49757
Description: In the Linux kernel, the following vulnerability has been resolved:

EDAC/highbank: Fix memory leak in highbank_mc_probe()

When devres_open_group() fails, it returns -ENOMEM without freeing memory
allocated by edac_mc_alloc().

Call edac_mc_free() on the error handling path to avoid a memory leak.

  [ bp: Massage commit message. ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.6, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0db40e23b56d217eebd385bebb64057ef764b2c7
  - https://git.kernel.org/stable/c/329fbd260352a7b9a83781d8b8bd96f95844a51f
  - https://git.kernel.org/stable/c/8d23f5d25264beb223ee79cdb530b88c237719fc
  - https://git.kernel.org/stable/c/b7863ef8a8f0fee96b4eb41211f4918c0e047253
  - https://git.kernel.org/stable/c/caffa7fed1397d1395052272c93900176de86557
  - https://git.kernel.org/stable/c/e7a293658c20a7945014570e1921bf7d25d68a36
  - https://git.kernel.org/stable/c/f1b3e23ed8df87d779ee86ac37f379e79a24169a

------------------------------------------------------------

CVE ID: CVE-2022-49758
Description: In the Linux kernel, the following vulnerability has been resolved:

reset: uniphier-glue: Fix possible null-ptr-deref

It will cause null-ptr-deref when resource_size(res) invoked,
if platform_get_resource() returns NULL.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3a2390c6777e3f6662980c6cfc25cafe9e4fef98
  - https://git.kernel.org/stable/c/633bad3dc81ce2aa561f704ec091e49eb647bd0b
  - https://git.kernel.org/stable/c/95de286200b2a046da01c4aeba02ae9220d68ca4

------------------------------------------------------------

CVE ID: CVE-2022-49759
Description: In the Linux kernel, the following vulnerability has been resolved:

VMCI: Use threaded irqs instead of tasklets

The vmci_dispatch_dgs() tasklet function calls vmci_read_data()
which uses wait_event() resulting in invalid sleep in an atomic
context (and therefore potentially in a deadlock).

Use threaded irqs to fix this issue and completely remove usage
of tasklets.

[   20.264639] BUG: sleeping function called from invalid context at drivers/misc/vmw_vmci/vmci_guest.c:145
[   20.264643] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 762, name: vmtoolsd
[   20.264645] preempt_count: 101, expected: 0
[   20.264646] RCU nest depth: 0, expected: 0
[   20.264647] 1 lock held by vmtoolsd/762:
[   20.264648]  #0: ffff0000874ae440 (sk_lock-AF_VSOCK){+.+.}-{0:0}, at: vsock_connect+0x60/0x330 [vsock]
[   20.264658] Preemption disabled at:
[   20.264659] [<ffff80000151d7d8>] vmci_send_datagram+0x44/0xa0 [vmw_vmci]
[   20.264665] CPU: 0 PID: 762 Comm: vmtoolsd Not tainted 5.19.0-0.rc8.20220727git39c3c396f813.60.fc37.aarch64 #1
[   20.264667] Hardware name: VMware, Inc. VBSA/VBSA, BIOS VEFI 12/31/2020
[   20.264668] Call trace:
[   20.264669]  dump_backtrace+0xc4/0x130
[   20.264672]  show_stack+0x24/0x80
[   20.264673]  dump_stack_lvl+0x88/0xb4
[   20.264676]  dump_stack+0x18/0x34
[   20.264677]  __might_resched+0x1a0/0x280
[   20.264679]  __might_sleep+0x58/0x90
[   20.264681]  vmci_read_data+0x74/0x120 [vmw_vmci]
[   20.264683]  vmci_dispatch_dgs+0x64/0x204 [vmw_vmci]
[   20.264686]  tasklet_action_common.constprop.0+0x13c/0x150
[   20.264688]  tasklet_action+0x40/0x50
[   20.264689]  __do_softirq+0x23c/0x6b4
[   20.264690]  __irq_exit_rcu+0x104/0x214
[   20.264691]  irq_exit_rcu+0x1c/0x50
[   20.264693]  el1_interrupt+0x38/0x6c
[   20.264695]  el1h_64_irq_handler+0x18/0x24
[   20.264696]  el1h_64_irq+0x68/0x6c
[   20.264697]  preempt_count_sub+0xa4/0xe0
[   20.264698]  _raw_spin_unlock_irqrestore+0x64/0xb0
[   20.264701]  vmci_send_datagram+0x7c/0xa0 [vmw_vmci]
[   20.264703]  vmci_datagram_dispatch+0x84/0x100 [vmw_vmci]
[   20.264706]  vmci_datagram_send+0x2c/0x40 [vmw_vmci]
[   20.264709]  vmci_transport_send_control_pkt+0xb8/0x120 [vmw_vsock_vmci_transport]
[   20.264711]  vmci_transport_connect+0x40/0x7c [vmw_vsock_vmci_transport]
[   20.264713]  vsock_connect+0x278/0x330 [vsock]
[   20.264715]  __sys_connect_file+0x8c/0xc0
[   20.264718]  __sys_connect+0x84/0xb4
[   20.264720]  __arm64_sys_connect+0x2c/0x3c
[   20.264721]  invoke_syscall+0x78/0x100
[   20.264723]  el0_svc_common.constprop.0+0x68/0x124
[   20.264724]  do_el0_svc+0x38/0x4c
[   20.264725]  el0_svc+0x60/0x180
[   20.264726]  el0t_64_sync_handler+0x11c/0x150
[   20.264728]  el0t_64_sync+0x190/0x194
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.1.8
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3daed6345d5880464f46adab871d208e1baa2f3a
  - https://git.kernel.org/stable/c/548ea9dd5e01b0ecf53d2563004c80abd636743d

------------------------------------------------------------

CVE ID: CVE-2022-49760
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/hugetlb: fix PTE marker handling in hugetlb_change_protection()

Patch series "mm/hugetlb: uffd-wp fixes for hugetlb_change_protection()".

Playing with virtio-mem and background snapshots (using uffd-wp) on
hugetlb in QEMU, I managed to trigger a VM_BUG_ON().  Looking into the
details, hugetlb_change_protection() seems to not handle uffd-wp correctly
in all cases.

Patch #1 fixes my test case.  I don't have reproducers for patch #2, as it
requires running into migration entries.

I did not yet check in detail yet if !hugetlb code requires similar care.


This patch (of 2):

There are two problematic cases when stumbling over a PTE marker in
hugetlb_change_protection():

(1) We protect an uffd-wp PTE marker a second time using uffd-wp: we will
    end up in the "!huge_pte_none(pte)" case and mess up the PTE marker.

(2) We unprotect a uffd-wp PTE marker: we will similarly end up in the
    "!huge_pte_none(pte)" case even though we cleared the PTE, because
    the "pte" variable is stale. We'll mess up the PTE marker.

For example, if we later stumble over such a "wrongly modified" PTE marker,
we'll treat it like a present PTE that maps some garbage page.

This can, for example, be triggered by mapping a memfd backed by huge
pages, registering uffd-wp, uffd-wp'ing an unmapped page and (a)
uffd-wp'ing it a second time; or (b) uffd-unprotecting it; or (c)
unregistering uffd-wp. Then, ff we trigger fallocate(FALLOC_FL_PUNCH_HOLE)
on that file range, we will run into a VM_BUG_ON:

[  195.039560] page:00000000ba1f2987 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x0
[  195.039565] flags: 0x7ffffc0001000(reserved|node=0|zone=0|lastcpupid=0x1fffff)
[  195.039568] raw: 0007ffffc0001000 ffffe742c0000008 ffffe742c0000008 0000000000000000
[  195.039569] raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000
[  195.039569] page dumped because: VM_BUG_ON_PAGE(compound && !PageHead(page))
[  195.039573] ------------[ cut here ]------------
[  195.039574] kernel BUG at mm/rmap.c:1346!
[  195.039579] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
[  195.039581] CPU: 7 PID: 4777 Comm: qemu-system-x86 Not tainted 6.0.12-200.fc36.x86_64 #1
[  195.039583] Hardware name: LENOVO 20WNS1F81N/20WNS1F81N, BIOS N35ET50W (1.50 ) 09/15/2022
[  195.039584] RIP: 0010:page_remove_rmap+0x45b/0x550
[  195.039588] Code: [...]
[  195.039589] RSP: 0018:ffffbc03c3633ba8 EFLAGS: 00010292
[  195.039591] RAX: 0000000000000040 RBX: ffffe742c0000000 RCX: 0000000000000000
[  195.039592] RDX: 0000000000000002 RSI: ffffffff8e7aac1a RDI: 00000000ffffffff
[  195.039592] RBP: 0000000000000001 R08: 0000000000000000 R09: ffffbc03c3633a08
[  195.039593] R10: 0000000000000003 R11: ffffffff8f146328 R12: ffff9b04c42754b0
[  195.039594] R13: ffffffff8fcc6328 R14: ffffbc03c3633c80 R15: ffff9b0484ab9100
[  195.039595] FS:  00007fc7aaf68640(0000) GS:ffff9b0bbf7c0000(0000) knlGS:0000000000000000
[  195.039596] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  195.039597] CR2: 000055d402c49110 CR3: 0000000159392003 CR4: 0000000000772ee0
[  195.039598] PKRU: 55555554
[  195.039599] Call Trace:
[  195.039600]  <TASK>
[  195.039602]  __unmap_hugepage_range+0x33b/0x7d0
[  195.039605]  unmap_hugepage_range+0x55/0x70
[  195.039608]  hugetlb_vmdelete_list+0x77/0xa0
[  195.039611]  hugetlbfs_fallocate+0x410/0x550
[  195.039612]  ? _raw_spin_unlock_irqrestore+0x23/0x40
[  195.039616]  vfs_fallocate+0x12e/0x360
[  195.039618]  __x64_sys_fallocate+0x40/0x70
[  195.039620]  do_syscall_64+0x58/0x80
[  195.039623]  ? syscall_exit_to_user_mode+0x17/0x40
[  195.039624]  ? do_syscall_64+0x67/0x80
[  195.039626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  195.039628] RIP: 0033:0x7fc7b590651f
[  195.039653] Code: [...]
[  195.039654] RSP: 002b:00007fc7aaf66e70 EFLAGS: 00000293 ORIG_RAX: 000000000000011d
[  195.039655] RAX: ffffffffffffffda RBX: 0000558ef4b7f370 RCX: 00007fc7b590651f
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e678153f5be7e6c8d28835f5a678618da4b7a9c
  - https://git.kernel.org/stable/c/6062c992e912df1eedad52cf64efb3d48e8d35c5

------------------------------------------------------------

CVE ID: CVE-2022-49761
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: always report error in run_one_delayed_ref()

Currently we have a btrfs_debug() for run_one_delayed_ref() failure, but
if end users hit such problem, there will be no chance that
btrfs_debug() is enabled.  This can lead to very little useful info for
debugging.

This patch will:

- Add extra info for error reporting
  Including:
  * logical bytenr
  * num_bytes
  * type
  * action
  * ref_mod

- Replace the btrfs_debug() with btrfs_err()

- Move the error reporting into run_one_delayed_ref()
  This is to avoid use-after-free, the @node can be freed in the caller.

This error should only be triggered at most once.

As if run_one_delayed_ref() failed, we trigger the error message, then
causing the call chain to error out:

btrfs_run_delayed_refs()
`- btrfs_run_delayed_refs()
   `- btrfs_run_delayed_refs_for_head()
      `- run_one_delayed_ref()

And we will abort the current transaction in btrfs_run_delayed_refs().
If we have to run delayed refs for the abort transaction,
run_one_delayed_ref() will just cleanup the refs and do nothing, thus no
new error messages would be output.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.165
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.90
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.8
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/18bd1c9c02e64a3567f90c83c2c8b855531c8098
  - https://git.kernel.org/stable/c/39f501d68ec1ed5cd5c66ac6ec2a7131c517bb92
  - https://git.kernel.org/stable/c/853ffa1511b058c79a4c9bb1407b3b20ce311792
  - https://git.kernel.org/stable/c/fdb4a70bb768d2a87890409597529ad81cb3de8a

------------------------------------------------------------

CVE ID: CVE-2023-52928
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Skip invalid kfunc call in backtrack_insn

The verifier skips invalid kfunc call in check_kfunc_call(), which
would be captured in fixup_kfunc_call() if such insn is not eliminated
by dead code elimination. However, this can lead to the following
warning in backtrack_insn(), also see [1]:

  ------------[ cut here ]------------
  verifier backtracking bug
  WARNING: CPU: 6 PID: 8646 at kernel/bpf/verifier.c:2756 backtrack_insn
  kernel/bpf/verifier.c:2756
	__mark_chain_precision kernel/bpf/verifier.c:3065
	mark_chain_precision kernel/bpf/verifier.c:3165
	adjust_reg_min_max_vals kernel/bpf/verifier.c:10715
	check_alu_op kernel/bpf/verifier.c:10928
	do_check kernel/bpf/verifier.c:13821 [inline]
	do_check_common kernel/bpf/verifier.c:16289
  [...]

So make backtracking conservative with this by returning ENOTSUPP.

  [1] https://lore.kernel.org/bpf/CACkBjsaXNceR8ZjkLG=dT3P=4A8SBsg0Z5h5PWLryF5=ghKq=g@mail.gmail.com/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6e2fac197de2c4c041bdd8982cffb104689113f1
  - https://git.kernel.org/stable/c/74eec8266f37aff609db6a2f2b093e56a11c28c4
  - https://git.kernel.org/stable/c/d3178e8a434b58678d99257c0387810a24042fb6

------------------------------------------------------------

CVE ID: CVE-2023-52929
Description: In the Linux kernel, the following vulnerability has been resolved:

nvmem: core: fix cleanup after dev_set_name()

If dev_set_name() fails, we leak nvmem->wp_gpio as the cleanup does not
put this. While a minimal fix for this would be to add the gpiod_put()
call, we can do better if we split device_register(), and use the
tested nvmem_release() cleanup code by initialising the device early,
and putting the device.

This results in a slightly larger fix, but results in clear code.

Note: this patch depends on "nvmem: core: initialise nvmem->id early"
and "nvmem: core: remove nvmem_config wp_gpio".

[Srini: Fixed subject line and error code handing with wp_gpio while applying.]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/23676ecd2eb377f7c24a6ff578b0f4c7135658b6
  - https://git.kernel.org/stable/c/39708bc8da7858de0bed9b3a88b3beb1d1e0b443
  - https://git.kernel.org/stable/c/560181d3ace61825f4ca9dd3481d6c0ee6709fa8
  - https://git.kernel.org/stable/c/8f9c4b2a3b132bf6698e477aba6ee194b40c75f4

------------------------------------------------------------

CVE ID: CVE-2023-52930
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915: Fix potential bit_17 double-free

A userspace with multiple threads racing I915_GEM_SET_TILING to set the
tiling to I915_TILING_NONE could trigger a double free of the bit_17
bitmask.  (Or conversely leak memory on the transition to tiled.)  Move
allocation/free'ing of the bitmask within the section protected by the
obj lock.

[tursulin: Correct fixes tag and added cc stable.]
(cherry picked from commit 10e0cbaaf1104f449d695c80bcacf930dcd3c42e)
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0769f997a7b6d5cb8336db0b4ec3d2d311b8097c
  - https://git.kernel.org/stable/c/7057a8f126f14f14b040faecfa220fd27c6c2f85
  - https://git.kernel.org/stable/c/b591abac78e25269b12e3d7170c99463f8c5cb02
  - https://git.kernel.org/stable/c/e3ebc3e23bd9028a8a9a26cbc5985f99be445f65

------------------------------------------------------------

CVE ID: CVE-2023-52931
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915: Avoid potential vm use-after-free

Adding the vm to the vm_xa table makes it visible to userspace, which
could try to race with us to close the vm.  So we need to take our extra
reference before putting it in the table.

(cherry picked from commit 99343c46d4e2b34c285d3d5f68ff04274c2f9fb4)
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/41d419382ec7e257e54b7b6ff0d3623aafb1316d
  - https://git.kernel.org/stable/c/764accc2c1b8fd1507be2e7f436c94cdce887a00

------------------------------------------------------------

CVE ID: CVE-2023-52932
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/swapfile: add cond_resched() in get_swap_pages()

The softlockup still occurs in get_swap_pages() under memory pressure.  64
CPU cores, 64GB memory, and 28 zram devices, the disksize of each zram
device is 50MB with same priority as si.  Use the stress-ng tool to
increase memory pressure, causing the system to oom frequently.

The plist_for_each_entry_safe() loops in get_swap_pages() could reach tens
of thousands of times to find available space (extreme case:
cond_resched() is not called in scan_swap_map_slots()).  Let's add
cond_resched() into get_swap_pages() when failed to find available space
to avoid softlockup.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.306
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/29f0349c5c76b627fe06b87d4b13fa03a6ce8e64
  - https://git.kernel.org/stable/c/30187be29052bba9203b0ae2bdd815e0bc2faaab
  - https://git.kernel.org/stable/c/387217b97e99699c34e6d95ce2b91b327fcd853e
  - https://git.kernel.org/stable/c/49178d4d61e78aed8c837dfeea8a450700f196e2
  - https://git.kernel.org/stable/c/5dbe1ebd56470d03b78fc31491a9e4d433106ef2
  - https://git.kernel.org/stable/c/7717fc1a12f88701573f9ed897cc4f6699c661e3
  - https://git.kernel.org/stable/c/d49c85a1913385eed46dd16a25ad0928253767f0

------------------------------------------------------------

CVE ID: CVE-2023-52933
Description: In the Linux kernel, the following vulnerability has been resolved:

Squashfs: fix handling and sanity checking of xattr_ids count

A Sysbot [1] corrupted filesystem exposes two flaws in the handling and
sanity checking of the xattr_ids count in the filesystem.  Both of these
flaws cause computation overflow due to incorrect typing.

In the corrupted filesystem the xattr_ids value is 4294967071, which
stored in a signed variable becomes the negative number -225.

Flaw 1 (64-bit systems only):

The signed integer xattr_ids variable causes sign extension.

This causes variable overflow in the SQUASHFS_XATTR_*(A) macros.  The
variable is first multiplied by sizeof(struct squashfs_xattr_id) where the
type of the sizeof operator is "unsigned long".

On a 64-bit system this is 64-bits in size, and causes the negative number
to be sign extended and widened to 64-bits and then become unsigned.  This
produces the very large number 18446744073709548016 or 2^64 - 3600.  This
number when rounded up by SQUASHFS_METADATA_SIZE - 1 (8191 bytes) and
divided by SQUASHFS_METADATA_SIZE overflows and produces a length of 0
(stored in len).

Flaw 2 (32-bit systems only):

On a 32-bit system the integer variable is not widened by the unsigned
long type of the sizeof operator (32-bits), and the signedness of the
variable has no effect due it always being treated as unsigned.

The above corrupted xattr_ids value of 4294967071, when multiplied
overflows and produces the number 4294963696 or 2^32 - 3400.  This number
when rounded up by SQUASHFS_METADATA_SIZE - 1 (8191 bytes) and divided by
SQUASHFS_METADATA_SIZE overflows again and produces a length of 0.

The effect of the 0 length computation:

In conjunction with the corrupted xattr_ids field, the filesystem also has
a corrupted xattr_table_start value, where it matches the end of
filesystem value of 850.

This causes the following sanity check code to fail because the
incorrectly computed len of 0 matches the incorrect size of the table
reported by the superblock (0 bytes).

    len = SQUASHFS_XATTR_BLOCK_BYTES(*xattr_ids);
    indexes = SQUASHFS_XATTR_BLOCKS(*xattr_ids);

    /*
     * The computed size of the index table (len bytes) should exactly
     * match the table start and end points
    */
    start = table_start + sizeof(*id_table);
    end = msblk->bytes_used;

    if (len != (end - start))
            return ERR_PTR(-EINVAL);

Changing the xattr_ids variable to be "usigned int" fixes the flaw on a
64-bit system.  This relies on the fact the computation is widened by the
unsigned long type of the sizeof operator.

Casting the variable to u64 in the above macro fixes this flaw on a 32-bit
system.

It also means 64-bit systems do not implicitly rely on the type of the
sizeof operator to widen the computation.

[1] https://lore.kernel.org/lkml/000000000000cd44f005f1a0f17f@google.com/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1369322c1de52c7b9b988b95c9903110a4566778
  - https://git.kernel.org/stable/c/5c4d4a83bf1a862d80c1efff1c6e3ce33b501e2e
  - https://git.kernel.org/stable/c/7fe583c9bec10cd4b76231c51b37f3e4ca646e01
  - https://git.kernel.org/stable/c/997bed0f3cde78a3e639d624985bf4a95cf767e6
  - https://git.kernel.org/stable/c/a7da7d01ac5ce9b369a1ac70e1197999cc6c9686
  - https://git.kernel.org/stable/c/b38c3e9e0adc01956cc3e5a52e4d3f92f79d88e2
  - https://git.kernel.org/stable/c/f65c4bbbd682b0877b669828b4e033b8d5d0a2dc

------------------------------------------------------------

CVE ID: CVE-2023-52934
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/MADV_COLLAPSE: catch !none !huge !bad pmd lookups

In commit 34488399fa08 ("mm/madvise: add file and shmem support to
MADV_COLLAPSE") we make the following change to find_pmd_or_thp_or_none():

	-       if (!pmd_present(pmde))
	-               return SCAN_PMD_NULL;
	+       if (pmd_none(pmde))
	+               return SCAN_PMD_NONE;

This was for-use by MADV_COLLAPSE file/shmem codepaths, where
MADV_COLLAPSE might identify a pte-mapped hugepage, only to have
khugepaged race-in, free the pte table, and clear the pmd.  Such codepaths
include:

A) If we find a suitably-aligned compound page of order HPAGE_PMD_ORDER
   already in the pagecache.
B) In retract_page_tables(), if we fail to grab mmap_lock for the target
   mm/address.

In these cases, collapse_pte_mapped_thp() really does expect a none (not
just !present) pmd, and we want to suitably identify that case separate
from the case where no pmd is found, or it's a bad-pmd (of course, many
things could happen once we drop mmap_lock, and the pmd could plausibly
undergo multiple transitions due to intervening fault, split, etc). 
Regardless, the code is prepared install a huge-pmd only when the existing
pmd entry is either a genuine pte-table-mapping-pmd, or the none-pmd.

However, the commit introduces a logical hole; namely, that we've allowed
!none- && !huge- && !bad-pmds to be classified as genuine
pte-table-mapping-pmds.  One such example that could leak through are swap
entries.  The pmd values aren't checked again before use in
pte_offset_map_lock(), which is expecting nothing less than a genuine
pte-table-mapping-pmd.

We want to put back the !pmd_present() check (below the pmd_none() check),
but need to be careful to deal with subtleties in pmd transitions and
treatments by various arch.

The issue is that __split_huge_pmd_locked() temporarily clears the present
bit (or otherwise marks the entry as invalid), but pmd_present() and
pmd_trans_huge() still need to return true while the pmd is in this
transitory state.  For example, x86's pmd_present() also checks the
_PAGE_PSE , riscv's version also checks the _PAGE_LEAF bit, and arm64 also
checks a PMD_PRESENT_INVALID bit.

Covering all 4 cases for x86 (all checks done on the same pmd value):

1) pmd_present() && pmd_trans_huge()
   All we actually know here is that the PSE bit is set. Either:
   a) We aren't racing with __split_huge_page(), and PRESENT or PROTNONE
      is set.
      => huge-pmd
   b) We are currently racing with __split_huge_page().  The danger here
      is that we proceed as-if we have a huge-pmd, but really we are
      looking at a pte-mapping-pmd.  So, what is the risk of this
      danger?

      The only relevant path is:

	madvise_collapse() -> collapse_pte_mapped_thp()

      Where we might just incorrectly report back "success", when really
      the memory isn't pmd-backed.  This is fine, since split could
      happen immediately after (actually) successful madvise_collapse().
      So, it should be safe to just assume huge-pmd here.

2) pmd_present() && !pmd_trans_huge()
   Either:
   a) PSE not set and either PRESENT or PROTNONE is.
      => pte-table-mapping pmd (or PROT_NONE)
   b) devmap.  This routine can be called immediately after
      unlocking/locking mmap_lock -- or called with no locks held (see
      khugepaged_scan_mm_slot()), so previous VMA checks have since been
      invalidated.

3) !pmd_present() && pmd_trans_huge()
  Not possible.

4) !pmd_present() && !pmd_trans_huge()
  Neither PRESENT nor PROTNONE set
  => not present

I've checked all archs that implement pmd_trans_huge() (arm64, riscv,
powerpc, longarch, x86, mips, s390) and this logic roughly translates
(though devmap treatment is unique to x86 and powerpc, and (3) doesn't
necessarily hold in general -- but that doesn't matter since
!pmd_present() always takes failure path).

Also, add a comment above find_pmd_or_thp_or_none()
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/96aaaf8666010a39430cecf8a65c7ce2908a030f
  - https://git.kernel.org/stable/c/edb5d0cf5525357652aff6eacd9850b8ced07143

------------------------------------------------------------

CVE ID: CVE-2023-52935
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/khugepaged: fix ->anon_vma race

If an ->anon_vma is attached to the VMA, collapse_and_free_pmd() requires
it to be locked.

Page table traversal is allowed under any one of the mmap lock, the
anon_vma lock (if the VMA is associated with an anon_vma), and the
mapping lock (if the VMA is associated with a mapping); and so to be
able to remove page tables, we must hold all three of them. 
retract_page_tables() bails out if an ->anon_vma is attached, but does
this check before holding the mmap lock (as the comment above the check
explains).

If we racily merged an existing ->anon_vma (shared with a child
process) from a neighboring VMA, subsequent rmap traversals on pages
belonging to the child will be able to see the page tables that we are
concurrently removing while assuming that nothing else can access them.

Repeat the ->anon_vma check once we hold the mmap lock to ensure that
there really is no concurrent page table access.

Hitting this bug causes a lockdep warning in collapse_and_free_pmd(),
in the line "lockdep_assert_held_write(&vma->anon_vma->root->rwsem)". 
It can also lead to use-after-free access.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.8, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/023f47a8250c6bdb4aebe744db4bf7f73414028b
  - https://git.kernel.org/stable/c/acb08187b5a83cdb9ac4112fae9e18cf983b0128

------------------------------------------------------------

CVE ID: CVE-2023-52936
Description: In the Linux kernel, the following vulnerability has been resolved:

kernel/irq/irqdomain.c: fix memory leak with using debugfs_lookup()

When calling debugfs_lookup() the result must have dput() called on it,
otherwise the memory will leak over time.  To make things simpler, just
call debugfs_lookup_and_remove() instead which handles all of the logic
at once.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/066ecbf1a53eb0b92b10c8df7808666be6ea5681
  - https://git.kernel.org/stable/c/cf1c917bf1c761a557b26410024e90057646c049
  - https://git.kernel.org/stable/c/d83d7ed260283560700d4034a80baad46620481b

------------------------------------------------------------

CVE ID: CVE-2023-52937
Description: In the Linux kernel, the following vulnerability has been resolved:

HV: hv_balloon: fix memory leak with using debugfs_lookup()

When calling debugfs_lookup() the result must have dput() called on it,
otherwise the memory will leak over time.  To make things simpler, just
call debugfs_lookup_and_remove() instead which handles all of the logic
at once.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0b570a059cf42ad6e2eb632f47c23813d58d8303
  - https://git.kernel.org/stable/c/6dfb0771429a63db8561d44147f2bb76f93e1c86

------------------------------------------------------------

CVE ID: CVE-2023-52938
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: typec: ucsi: Don't attempt to resume the ports before they exist

This will fix null pointer dereference that was caused by
the driver attempting to resume ports that were not yet
registered.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0.15, Last Version (Excluding): 6.1
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.1, Last Version (Excluding): 6.1.11
References:
  - https://git.kernel.org/stable/c/f82060da749c611ed427523b6d1605d87338aac1
  - https://git.kernel.org/stable/c/fdd11d7136fd070b3a74d6d8799d9eac28a57fc5

------------------------------------------------------------

CVE ID: CVE-2023-52939
Description: In the Linux kernel, the following vulnerability has been resolved:

mm: memcg: fix NULL pointer in mem_cgroup_track_foreign_dirty_slowpath()

As commit 18365225f044 ("hwpoison, memcg: forcibly uncharge LRU pages"),
hwpoison will forcibly uncharg a LRU hwpoisoned page, the folio_memcg
could be NULl, then, mem_cgroup_track_foreign_dirty_slowpath() could
occurs a NULL pointer dereference, let's do not record the foreign
writebacks for folio memcg is null in mem_cgroup_track_foreign_dirty() to
fix it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/ac86f547ca1002aec2ef66b9e64d03f45bbbfbb9
  - https://git.kernel.org/stable/c/b79ba5953f6fdc5559389ad415620bffc24f024b

------------------------------------------------------------

CVE ID: CVE-2023-52940
Description: In the Linux kernel, the following vulnerability has been resolved:

mm: multi-gen LRU: fix crash during cgroup migration

lru_gen_migrate_mm() assumes lru_gen_add_mm() runs prior to itself.  This
isn't true for the following scenario:

    CPU 1                         CPU 2

  clone()
    cgroup_can_fork()
                                cgroup_procs_write()
    cgroup_post_fork()
                                  task_lock()
                                  lru_gen_migrate_mm()
                                  task_unlock()
    task_lock()
    lru_gen_add_mm()
    task_unlock()

And when the above happens, kernel crashes because of linked list
corruption (mm_struct->lru_gen.list).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/04448022311cebd30969d3aebdde765f1258b360
  - https://git.kernel.org/stable/c/de08eaa6156405f2e9369f06ba5afae0e4ab3b62

------------------------------------------------------------

CVE ID: CVE-2023-52941
Description: In the Linux kernel, the following vulnerability has been resolved:

can: isotp: split tx timer into transmission and timeout

The timer for the transmission of isotp PDUs formerly had two functions:
1. send two consecutive frames with a given time gap
2. monitor the timeouts for flow control frames and the echo frames

This led to larger txstate checks and potentially to a problem discovered
by syzbot which enabled the panic_on_warn feature while testing.

The former 'txtimer' function is split into 'txfrtimer' and 'txtimer'
to handle the two above functionalities with separate timer callbacks.

The two simplified timers now run in one-shot mode and make the state
transitions (especially with isotp_rcv_echo) better understandable.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4f027cba8216f42a18b544842efab134f8b1f9f4
  - https://git.kernel.org/stable/c/cae4c9bc35f72af5d4a079bb9d9fd62c4088a411

------------------------------------------------------------

CVE ID: CVE-2023-52942
Description: In the Linux kernel, the following vulnerability has been resolved:

cgroup/cpuset: Fix wrong check in update_parent_subparts_cpumask()

It was found that the check to see if a partition could use up all
the cpus from the parent cpuset in update_parent_subparts_cpumask()
was incorrect. As a result, it is possible to leave parent with no
effective cpu left even if there are tasks in the parent cpuset. This
can lead to system panic as reported in [1].

Fix this probem by updating the check to fail the enabling the partition
if parent's effective_cpus is a subset of the child's cpus_allowed.

Also record the error code when an error happens in update_prstate()
and add a test case where parent partition and child have the same cpu
list and parent has task. Enabling partition in the child will fail in
this case.

[1] https://www.spinics.net/lists/cgroups/msg36254.html
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a2ab7f2cf5ef8f0c6212a246e681d1fe358cec1f
  - https://git.kernel.org/stable/c/e5ae8803847b80fe9d744a3174abe2b7bfed222a

------------------------------------------------------------

CVE ID: CVE-2023-52973
Description: In the Linux kernel, the following vulnerability has been resolved:

vc_screen: move load of struct vc_data pointer in vcs_read() to avoid UAF

After a call to console_unlock() in vcs_read() the vc_data struct can be
freed by vc_deallocate(). Because of that, the struct vc_data pointer
load must be done at the top of while loop in vcs_read() to avoid a UAF
when vcs_size() is called.

Syzkaller reported a UAF in vcs_size().

BUG: KASAN: use-after-free in vcs_size (drivers/tty/vt/vc_screen.c:215)
Read of size 4 at addr ffff8881137479a8 by task 4a005ed81e27e65/1537

CPU: 0 PID: 1537 Comm: 4a005ed81e27e65 Not tainted 6.2.0-rc5 #1
Hardware name: Red Hat KVM, BIOS 1.15.0-2.module
Call Trace:
  <TASK>
__asan_report_load4_noabort (mm/kasan/report_generic.c:350)
vcs_size (drivers/tty/vt/vc_screen.c:215)
vcs_read (drivers/tty/vt/vc_screen.c:415)
vfs_read (fs/read_write.c:468 fs/read_write.c:450)
...
  </TASK>

Allocated by task 1191:
...
kmalloc_trace (mm/slab_common.c:1069)
vc_allocate (./include/linux/slab.h:580 ./include/linux/slab.h:720
     drivers/tty/vt/vt.c:1128 drivers/tty/vt/vt.c:1108)
con_install (drivers/tty/vt/vt.c:3383)
tty_init_dev (drivers/tty/tty_io.c:1301 drivers/tty/tty_io.c:1413
     drivers/tty/tty_io.c:1390)
tty_open (drivers/tty/tty_io.c:2080 drivers/tty/tty_io.c:2126)
chrdev_open (fs/char_dev.c:415)
do_dentry_open (fs/open.c:883)
vfs_open (fs/open.c:1014)
...

Freed by task 1548:
...
kfree (mm/slab_common.c:1021)
vc_port_destruct (drivers/tty/vt/vt.c:1094)
tty_port_destructor (drivers/tty/tty_port.c:296)
tty_port_put (drivers/tty/tty_port.c:312)
vt_disallocate_all (drivers/tty/vt/vt_ioctl.c:662 (discriminator 2))
vt_ioctl (drivers/tty/vt/vt_ioctl.c:903)
tty_ioctl (drivers/tty/tty_io.c:2776)
...

The buggy address belongs to the object at ffff888113747800
  which belongs to the cache kmalloc-1k of size 1024
The buggy address is located 424 bytes inside of
  1024-byte region [ffff888113747800, ffff888113747c00)

The buggy address belongs to the physical page:
page:00000000b3fe6c7c refcount:1 mapcount:0 mapping:0000000000000000
     index:0x0 pfn:0x113740
head:00000000b3fe6c7c order:3 compound_mapcount:0 subpages_mapcount:0
     compound_pincount:0
anon flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff)
raw: 0017ffffc0010200 ffff888100042dc0 0000000000000000 dead000000000001
raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
  ffff888113747880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  ffff888113747900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
> ffff888113747980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                   ^
  ffff888113747a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  ffff888113747a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================
Disabling lock debugging due to kernel taint
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.38, Last Version (Excluding): 4.14.329
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/226fae124b2dac217ea5436060d623ff3385bc34
  - https://git.kernel.org/stable/c/55515d7d8743b71b80bfe68e89eb9d92630626ab
  - https://git.kernel.org/stable/c/6332f52f44b9776568bf3c0b714ddfb0bb175e78
  - https://git.kernel.org/stable/c/8506f16aae9daf354e3732bcfd447e2a97f023df
  - https://git.kernel.org/stable/c/af79ea9a2443016f64d8fd8d72020cc874f0e066
  - https://git.kernel.org/stable/c/d0332cbf53dad06a22189cc341391237f4ea6d9f
  - https://git.kernel.org/stable/c/fc9e27f3ba083534b8bbf72ab0f5c810ffdc7d18

------------------------------------------------------------

CVE ID: CVE-2023-52974
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: iscsi_tcp: Fix UAF during login when accessing the shost ipaddress

If during iscsi_sw_tcp_session_create() iscsi_tcp_r2tpool_alloc() fails,
userspace could be accessing the host's ipaddress attr. If we then free the
session via iscsi_session_teardown() while userspace is still accessing the
session we will hit a use after free bug.

Set the tcp_sw_host->session after we have completed session creation and
can no longer fail.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.14.306
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0aaabdb900c7415caa2006ef580322f7eac5f6b6
  - https://git.kernel.org/stable/c/496af9d3682ed4c28fb734342a09e6cc0c056ea4
  - https://git.kernel.org/stable/c/61e43ebfd243bcbad11be26bd921723027b77441
  - https://git.kernel.org/stable/c/6abd4698f4c8a78e7bbfc421205c060c199554a0
  - https://git.kernel.org/stable/c/9758ffe1c07b86aefd7ca8e40d9a461293427ca0
  - https://git.kernel.org/stable/c/d4d765f4761f9e3a2d62992f825aeee593bcb6b9
  - https://git.kernel.org/stable/c/f484a794e4ee2a9ce61f52a78e810ac45f3fe3b3

------------------------------------------------------------

CVE ID: CVE-2023-52975
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: iscsi_tcp: Fix UAF during logout when accessing the shost ipaddress

Bug report and analysis from Ding Hui.

During iSCSI session logout, if another task accesses the shost ipaddress
attr, we can get a KASAN UAF report like this:

[  276.942144] BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x78/0xe0
[  276.942535] Write of size 4 at addr ffff8881053b45b8 by task cat/4088
[  276.943511] CPU: 2 PID: 4088 Comm: cat Tainted: G            E      6.1.0-rc8+ #3
[  276.943997] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
[  276.944470] Call Trace:
[  276.944943]  <TASK>
[  276.945397]  dump_stack_lvl+0x34/0x48
[  276.945887]  print_address_description.constprop.0+0x86/0x1e7
[  276.946421]  print_report+0x36/0x4f
[  276.947358]  kasan_report+0xad/0x130
[  276.948234]  kasan_check_range+0x35/0x1c0
[  276.948674]  _raw_spin_lock_bh+0x78/0xe0
[  276.949989]  iscsi_sw_tcp_host_get_param+0xad/0x2e0 [iscsi_tcp]
[  276.951765]  show_host_param_ISCSI_HOST_PARAM_IPADDRESS+0xe9/0x130 [scsi_transport_iscsi]
[  276.952185]  dev_attr_show+0x3f/0x80
[  276.953005]  sysfs_kf_seq_show+0x1fb/0x3e0
[  276.953401]  seq_read_iter+0x402/0x1020
[  276.954260]  vfs_read+0x532/0x7b0
[  276.955113]  ksys_read+0xed/0x1c0
[  276.955952]  do_syscall_64+0x38/0x90
[  276.956347]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  276.956769] RIP: 0033:0x7f5d3a679222
[  276.957161] Code: c0 e9 b2 fe ff ff 50 48 8d 3d 32 c0 0b 00 e8 a5 fe 01 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24
[  276.958009] RSP: 002b:00007ffc864d16a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
[  276.958431] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5d3a679222
[  276.958857] RDX: 0000000000020000 RSI: 00007f5d3a4fe000 RDI: 0000000000000003
[  276.959281] RBP: 00007f5d3a4fe000 R08: 00000000ffffffff R09: 0000000000000000
[  276.959682] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000020000
[  276.960126] R13: 0000000000000003 R14: 0000000000000000 R15: 0000557a26dada58
[  276.960536]  </TASK>
[  276.961357] Allocated by task 2209:
[  276.961756]  kasan_save_stack+0x1e/0x40
[  276.962170]  kasan_set_track+0x21/0x30
[  276.962557]  __kasan_kmalloc+0x7e/0x90
[  276.962923]  __kmalloc+0x5b/0x140
[  276.963308]  iscsi_alloc_session+0x28/0x840 [scsi_transport_iscsi]
[  276.963712]  iscsi_session_setup+0xda/0xba0 [libiscsi]
[  276.964078]  iscsi_sw_tcp_session_create+0x1fd/0x330 [iscsi_tcp]
[  276.964431]  iscsi_if_create_session.isra.0+0x50/0x260 [scsi_transport_iscsi]
[  276.964793]  iscsi_if_recv_msg+0xc5a/0x2660 [scsi_transport_iscsi]
[  276.965153]  iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi]
[  276.965546]  netlink_unicast+0x4d5/0x7b0
[  276.965905]  netlink_sendmsg+0x78d/0xc30
[  276.966236]  sock_sendmsg+0xe5/0x120
[  276.966576]  ____sys_sendmsg+0x5fe/0x860
[  276.966923]  ___sys_sendmsg+0xe0/0x170
[  276.967300]  __sys_sendmsg+0xc8/0x170
[  276.967666]  do_syscall_64+0x38/0x90
[  276.968028]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  276.968773] Freed by task 2209:
[  276.969111]  kasan_save_stack+0x1e/0x40
[  276.969449]  kasan_set_track+0x21/0x30
[  276.969789]  kasan_save_free_info+0x2a/0x50
[  276.970146]  __kasan_slab_free+0x106/0x190
[  276.970470]  __kmem_cache_free+0x133/0x270
[  276.970816]  device_release+0x98/0x210
[  276.971145]  kobject_cleanup+0x101/0x360
[  276.971462]  iscsi_session_teardown+0x3fb/0x530 [libiscsi]
[  276.971775]  iscsi_sw_tcp_session_destroy+0xd8/0x130 [iscsi_tcp]
[  276.972143]  iscsi_if_recv_msg+0x1bf1/0x2660 [scsi_transport_iscsi]
[  276.972485]  iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi]
[  276.972808]  netlink_unicast+0x4d5/0x7b0
[  276.973201]  netlink_sendmsg+0x78d/0xc30
[  276.973544]  sock_sendmsg+0xe5/0x120
[  276.973864]  ____sys_sendmsg+0x5fe/0x860
[  276.974248]  ___sys_
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/17b738590b97fb3fc287289971d1519ff9b875a1
  - https://git.kernel.org/stable/c/6f1d64b13097e85abda0f91b5638000afc5f9a06
  - https://git.kernel.org/stable/c/8859687f5b242c0b057461df0a9ff51d5500783b

------------------------------------------------------------

CVE ID: CVE-2023-52976
Description: In the Linux kernel, the following vulnerability has been resolved:

efi: fix potential NULL deref in efi_mem_reserve_persistent

When iterating on a linked list, a result of memremap is dereferenced
without checking it for NULL.

This patch adds a check that falls back on allocating a new page in
case memremap doesn't succeed.

Found by Linux Verification Center (linuxtesting.org) with SVACE.

[ardb: return -ENOMEM instead of breaking out of the loop]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.1.16, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/87d4ff18738fd71e7e3c10827c80257da6283697
  - https://git.kernel.org/stable/c/966d47e1f27c45507c5df82b2a2157e5a4fd3909
  - https://git.kernel.org/stable/c/a2e6a9ff89f13666a1c3ff7195612ab949ea9afc
  - https://git.kernel.org/stable/c/d8fc0b5fb3e816a4a8684bcd3ed02cbef0fce23c
  - https://git.kernel.org/stable/c/d92a25627bcdf264183670da73c9a60c0bac327e

------------------------------------------------------------

CVE ID: CVE-2023-52977
Description: In the Linux kernel, the following vulnerability has been resolved:

net: openvswitch: fix flow memory leak in ovs_flow_cmd_new

Syzkaller reports a memory leak of new_flow in ovs_flow_cmd_new() as it is
not freed when an allocation of a key fails.

BUG: memory leak
unreferenced object 0xffff888116668000 (size 632):
  comm "syz-executor231", pid 1090, jiffies 4294844701 (age 18.871s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<00000000defa3494>] kmem_cache_zalloc include/linux/slab.h:654 [inline]
    [<00000000defa3494>] ovs_flow_alloc+0x19/0x180 net/openvswitch/flow_table.c:77
    [<00000000c67d8873>] ovs_flow_cmd_new+0x1de/0xd40 net/openvswitch/datapath.c:957
    [<0000000010a539a8>] genl_family_rcv_msg_doit+0x22d/0x330 net/netlink/genetlink.c:739
    [<00000000dff3302d>] genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]
    [<00000000dff3302d>] genl_rcv_msg+0x328/0x590 net/netlink/genetlink.c:800
    [<000000000286dd87>] netlink_rcv_skb+0x153/0x430 net/netlink/af_netlink.c:2515
    [<0000000061fed410>] genl_rcv+0x24/0x40 net/netlink/genetlink.c:811
    [<000000009dc0f111>] netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]
    [<000000009dc0f111>] netlink_unicast+0x545/0x7f0 net/netlink/af_netlink.c:1339
    [<000000004a5ee816>] netlink_sendmsg+0x8e7/0xde0 net/netlink/af_netlink.c:1934
    [<00000000482b476f>] sock_sendmsg_nosec net/socket.c:651 [inline]
    [<00000000482b476f>] sock_sendmsg+0x152/0x190 net/socket.c:671
    [<00000000698574ba>] ____sys_sendmsg+0x70a/0x870 net/socket.c:2356
    [<00000000d28d9e11>] ___sys_sendmsg+0xf3/0x170 net/socket.c:2410
    [<0000000083ba9120>] __sys_sendmsg+0xe5/0x1b0 net/socket.c:2439
    [<00000000c00628f8>] do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46
    [<000000004abfdcf4>] entry_SYSCALL_64_after_hwframe+0x61/0xc6

To fix this the patch rearranges the goto labels to reflect the order of
object allocations and adds appropriate goto statements on the error
paths.

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.337, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.303, Last Version (Excluding): 4.14.306
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.270, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.229, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.163, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.86, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0.16, Last Version (Excluding): 6.1
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.2, Last Version (Excluding): 6.1.11
References:
  - https://git.kernel.org/stable/c/0c598aed445eb45b0ee7ba405f7ece99ee349c30
  - https://git.kernel.org/stable/c/1ac653cf886cdfc082708c82dc6ac6115cebd2ee
  - https://git.kernel.org/stable/c/70154489f531587996f3e9d7cceeee65cff0001d
  - https://git.kernel.org/stable/c/70d40674a549d498bd63d5432acf46205da1534b
  - https://git.kernel.org/stable/c/af4e720bc00a2653f7b9df21755b9978b3d7f386
  - https://git.kernel.org/stable/c/ed6c5e8caf55778500202775167e8ccdb1a030cb
  - https://git.kernel.org/stable/c/f423c2efd51d7eb1d143c2be7eea233241d9bbbf

------------------------------------------------------------

CVE ID: CVE-2023-52978
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv: kprobe: Fixup kernel panic when probing an illegal position

The kernel would panic when probed for an illegal position. eg:

(CONFIG_RISCV_ISA_C=n)

echo 'p:hello kernel_clone+0x16 a0=%a0' >> kprobe_events
echo 1 > events/kprobes/hello/enable
cat trace

Kernel panic - not syncing: stack-protector: Kernel stack
is corrupted in: __do_sys_newfstatat+0xb8/0xb8
CPU: 0 PID: 111 Comm: sh Not tainted
6.2.0-rc1-00027-g2d398fe49a4d #490
Hardware name: riscv-virtio,qemu (DT)
Call Trace:
[<ffffffff80007268>] dump_backtrace+0x38/0x48
[<ffffffff80c5e83c>] show_stack+0x50/0x68
[<ffffffff80c6da28>] dump_stack_lvl+0x60/0x84
[<ffffffff80c6da6c>] dump_stack+0x20/0x30
[<ffffffff80c5ecf4>] panic+0x160/0x374
[<ffffffff80c6db94>] generic_handle_arch_irq+0x0/0xa8
[<ffffffff802deeb0>] sys_newstat+0x0/0x30
[<ffffffff800158c0>] sys_clone+0x20/0x30
[<ffffffff800039e8>] ret_from_syscall+0x0/0x4
---[ end Kernel panic - not syncing: stack-protector:
Kernel stack is corrupted in: __do_sys_newfstatat+0xb8/0xb8 ]---

That is because the kprobe's ebreak instruction broke the kernel's
original code. The user should guarantee the correction of the probe
position, but it couldn't make the kernel panic.

This patch adds arch_check_kprobe in arch_prepare_kprobe to prevent an
illegal position (Such as the middle of an instruction).
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/04a73558209554da17f46490ec4faaaf1b2bab68
  - https://git.kernel.org/stable/c/12316538b1d193064109ce1a28fc9bacd43950de
  - https://git.kernel.org/stable/c/87f48c7ccc73afc78630530d9af51f458f58cab8

------------------------------------------------------------

CVE ID: CVE-2023-52979
Description: In the Linux kernel, the following vulnerability has been resolved:

squashfs: harden sanity check in squashfs_read_xattr_id_table

While mounting a corrupted filesystem, a signed integer '*xattr_ids' can
become less than zero.  This leads to the incorrect computation of 'len'
and 'indexes' values which can cause null-ptr-deref in copy_bio_to_actor()
or out-of-bounds accesses in the next sanity checks inside
squashfs_read_xattr_id_table().

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.258, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.258, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.222, Last Version (Excluding): 4.14.306
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.176, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.98, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.16, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/29e774dcb27116c06b9c57b1f1f14a1623738989
  - https://git.kernel.org/stable/c/72e544b1b28325fe78a4687b980871a7e4101f76
  - https://git.kernel.org/stable/c/b30a74f83265c24d1d0842c6c3928cd2e775a3fb
  - https://git.kernel.org/stable/c/b7398efe24a965cf3937b716c0b1011c201c5d6e
  - https://git.kernel.org/stable/c/cf5d6612092408157db6bb500c70bf6d67c40fbc
  - https://git.kernel.org/stable/c/db76fc535fbdfbf29fd0b93e49627537ad794c8c
  - https://git.kernel.org/stable/c/de2785aa3448d1ee7be3ab47fd4a873025f1b3d7

------------------------------------------------------------

CVE ID: CVE-2023-52980
Description: In the Linux kernel, the following vulnerability has been resolved:

block: ublk: extending queue_size to fix overflow

When validating drafted SPDK ublk target, in a case that
assigning large queue depth to multiqueue ublk device,
ublk target would run into a weird incorrect state. During
rounds of review and debug, An overflow bug was found
in ublk driver.

In ublk_cmd.h, UBLK_MAX_QUEUE_DEPTH is 4096 which means
each ublk queue depth can be set as large as 4096. But
when setting qd for a ublk device,
sizeof(struct ublk_queue) + depth * sizeof(struct ublk_io)
will be larger than 65535 if qd is larger than 2728.
Then queue_size is overflowed, and ublk_get_queue()
references a wrong pointer position. The wrong content of
ublk_queue elements will lead to out-of-bounds memory
access.

Extend queue_size in ublk_device as "unsigned int".
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/29baef789c838bd5c02f50c88adbbc6b955aaf61
  - https://git.kernel.org/stable/c/ee1e3fe4b4579f856997190a00ea4db0307b4332

------------------------------------------------------------

CVE ID: CVE-2023-52981
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915: Fix request ref counting during error capture & debugfs dump

When GuC support was added to error capture, the reference counting
around the request object was broken. Fix it up.

The context based search manages the spinlocking around the search
internally. So it needs to grab the reference count internally as
well. The execlist only request based search relies on external
locking, so it needs an external reference count but within the
spinlock not outside it.

The only other caller of the context based search is the code for
dumping engine state to debugfs. That code wasn't previously getting
an explicit reference at all as it does everything while holding the
execlist specific spinlock. So, that needs updaing as well as that
spinlock doesn't help when using GuC submission. Rather than trying to
conditionally get/put depending on submission model, just change it to
always do the get/put.

v2: Explicitly document adding an extra blank line in some dense code
(Andy Shevchenko). Fix multiple potential null pointer derefs in case
of no request found (some spotted by Tvrtko, but there was more!).
Also fix a leaked request in case of !started and another in
__guc_reset_context now that intel_context_find_active_request is
actually reference counting the returned request.
v3: Add a _get suffix to intel_context_find_active_request now that it
grabs a reference (Daniele).
v4: Split the intel_guc_find_hung_context change to a separate patch
and rename intel_context_find_active_request_get to
intel_context_get_active_request (Tvrtko).
v5: s/locking/reference counting/ in commit message (Tvrtko)

(cherry picked from commit 3700e353781e27f1bc7222f51f2cc36cbeb9b4ec)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/86d8ddc74124c3fdfc139f246ba6da15e45e86e3
  - https://git.kernel.org/stable/c/9467397f417dd7b5d0db91452f0474e79716a527

------------------------------------------------------------

CVE ID: CVE-2023-52982
Description: In the Linux kernel, the following vulnerability has been resolved:

fscache: Use wait_on_bit() to wait for the freeing of relinquished volume

The freeing of relinquished volume will wake up the pending volume
acquisition by using wake_up_bit(), however it is mismatched with
wait_var_event() used in fscache_wait_on_volume_collision() and it will
never wake up the waiter in the wait-queue because these two functions
operate on different wait-queues.

According to the implementation in fscache_wait_on_volume_collision(),
if the wake-up of pending acquisition is delayed longer than 20 seconds
(e.g., due to the delay of on-demand fd closing), the first
wait_var_event_timeout() will timeout and the following wait_var_event()
will hang forever as shown below:

 FS-Cache: Potential volume collision new=00000024 old=00000022
 ......
 INFO: task mount:1148 blocked for more than 122 seconds.
       Not tainted 6.1.0-rc6+ #1
 task:mount           state:D stack:0     pid:1148  ppid:1
 Call Trace:
  <TASK>
  __schedule+0x2f6/0xb80
  schedule+0x67/0xe0
  fscache_wait_on_volume_collision.cold+0x80/0x82
  __fscache_acquire_volume+0x40d/0x4e0
  erofs_fscache_register_volume+0x51/0xe0 [erofs]
  erofs_fscache_register_fs+0x19c/0x240 [erofs]
  erofs_fc_fill_super+0x746/0xaf0 [erofs]
  vfs_get_super+0x7d/0x100
  get_tree_nodev+0x16/0x20
  erofs_fc_get_tree+0x20/0x30 [erofs]
  vfs_get_tree+0x24/0xb0
  path_mount+0x2fa/0xa90
  do_mount+0x7c/0xa0
  __x64_sys_mount+0x8b/0xe0
  do_syscall_64+0x30/0x60
  entry_SYSCALL_64_after_hwframe+0x46/0xb0

Considering that wake_up_bit() is more selective, so fix it by using
wait_on_bit() instead of wait_var_event() to wait for the freeing of
relinquished volume. In addition because waitqueue_active() is used in
wake_up_bit() and clear_bit() doesn't imply any memory barrier, use
clear_and_wake_up_bit() to add the missing memory barrier between
cursor->flags and waitqueue_active().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3be069f42a7b79d3149194f21cdf24bf23864cac
  - https://git.kernel.org/stable/c/8226e37d82f43657da34dd770e2b38f20242ada7

------------------------------------------------------------

CVE ID: CVE-2023-52983
Description: In the Linux kernel, the following vulnerability has been resolved:

block, bfq: fix uaf for bfqq in bic_set_bfqq()

After commit 64dc8c732f5c ("block, bfq: fix possible uaf for 'bfqq->bic'"),
bic->bfqq will be accessed in bic_set_bfqq(), however, in some context
bic->bfqq will be freed, and bic_set_bfqq() is called with the freed
bic->bfqq.

Fix the problem by always freeing bfqq after bic_set_bfqq().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.86, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.2, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.0.16, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/511c922c5bf6c8a166bea826e702336bc2424140
  - https://git.kernel.org/stable/c/7f77f3dab5066a7c9da73d72d1eee895ff84a8d5
  - https://git.kernel.org/stable/c/b600de2d7d3a16f9007fad1bdae82a3951a26af2
  - https://git.kernel.org/stable/c/cb1876fc33af26d00efdd473311f1b664c77c44e

------------------------------------------------------------

CVE ID: CVE-2023-52984
Description: In the Linux kernel, the following vulnerability has been resolved:

net: phy: dp83822: Fix null pointer access on DP83825/DP83826 devices

The probe() function is only used for the DP83822 PHY, leaving the
private data pointer uninitialized for the smaller DP83825/26 models.
While all uses of the private data structure are hidden in 82822 specific
callbacks, configuring the interrupt is shared across all models.
This causes a NULL pointer dereference on the smaller PHYs as it accesses
the private data unchecked. Verifying the pointer avoids that.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2cd1e9c013ec56421c58921b1ddf1d2d53bd47fa
  - https://git.kernel.org/stable/c/362a2f5531dc0e5b0b5b3e3a541000dbffa75461
  - https://git.kernel.org/stable/c/422ae7d9c7221e8d4c8526d0f54106307d69d2dc
  - https://git.kernel.org/stable/c/78901b10522cdf6badf24acf65a892637596bccc

------------------------------------------------------------

CVE ID: CVE-2023-52985
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: dts: imx8mm-verdin: Do not power down eth-phy

Currently if suspending using either freeze or memory state, the fec
driver tries to power down the phy which leads to crash of the kernel
and non-responsible kernel with the following call trace:

[   24.839889 ] Call trace:
[   24.839892 ]  phy_error+0x18/0x60
[   24.839898 ]  kszphy_handle_interrupt+0x6c/0x80
[   24.839903 ]  phy_interrupt+0x20/0x2c
[   24.839909 ]  irq_thread_fn+0x30/0xa0
[   24.839919 ]  irq_thread+0x178/0x2c0
[   24.839925 ]  kthread+0x154/0x160
[   24.839932 ]  ret_from_fork+0x10/0x20

Since there is currently no functionality in the phy subsystem to power
down phys let's just disable the feature of powering-down the ethernet
phy.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0bdd5a7b517f16fdffc444be6516c45788548d08
  - https://git.kernel.org/stable/c/39c95d0c357d7ef76aea958c1bece6b24f9b2e7e

------------------------------------------------------------

CVE ID: CVE-2023-52986
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, sockmap: Check for any of tcp_bpf_prots when cloning a listener

A listening socket linked to a sockmap has its sk_prot overridden. It
points to one of the struct proto variants in tcp_bpf_prots. The variant
depends on the socket's family and which sockmap programs are attached.

A child socket cloned from a TCP listener initially inherits their sk_prot.
But before cloning is finished, we restore the child's proto to the
listener's original non-tcp_bpf_prots one. This happens in
tcp_create_openreq_child -> tcp_bpf_clone.

Today, in tcp_bpf_clone we detect if the child's proto should be restored
by checking only for the TCP_BPF_BASE proto variant. This is not
correct. The sk_prot of listening socket linked to a sockmap can point to
to any variant in tcp_bpf_prots.

If the listeners sk_prot happens to be not the TCP_BPF_BASE variant, then
the child socket unintentionally is left if the inherited sk_prot by
tcp_bpf_clone.

This leads to issues like infinite recursion on close [1], because the
child state is otherwise not set up for use with tcp_bpf_prot operations.

Adjust the check in tcp_bpf_clone to detect all of tcp_bpf_prots variants.

Note that it wouldn't be sufficient to check the socket state when
overriding the sk_prot in tcp_bpf_update_proto in order to always use the
TCP_BPF_BASE variant for listening sockets. Since commit
b8b8315e39ff ("bpf, sockmap: Remove unhash handler for BPF sockmap usage")
it is possible for a socket to transition to TCP_LISTEN state while already
linked to a sockmap, e.g. connect() -> insert into map ->
connect(AF_UNSPEC) -> listen().

[1]: https://lore.kernel.org/all/00000000000073b14905ef2e7401@google.com/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/12b0ec7c6953e1602957926439e5297095d7d065
  - https://git.kernel.org/stable/c/9bd6074e1872d22190a8da30e796cbf937d334f0
  - https://git.kernel.org/stable/c/c681d7a4ed3d360de0574f4d6b7305a8de8dc54f
  - https://git.kernel.org/stable/c/ddce1e091757d0259107c6c0c7262df201de2b66

------------------------------------------------------------

CVE ID: CVE-2023-52987
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: ipc4-mtrace: prevent underflow in sof_ipc4_priority_mask_dfs_write()

The "id" comes from the user.  Change the type to unsigned to prevent
an array underflow.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/d52f34784e4e2f6e77671a9f104d8a69a3b5d24c
  - https://git.kernel.org/stable/c/ea57680af47587397f5005d7758022441ed66d54

------------------------------------------------------------

CVE ID: CVE-2023-52988
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: hda/via: Avoid potential array out-of-bound in add_secret_dac_path()

snd_hda_get_connections() can return a negative error code.
It may lead to accessing 'conn' array at a negative index.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.1, Last Version (Excluding): 4.14.306
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1b9256c96220bcdba287eeeb90e7c910c77f8c46
  - https://git.kernel.org/stable/c/2b557fa635e7487f638c0f030c305870839eeda2
  - https://git.kernel.org/stable/c/437e50ef6290ac835d526d0e45f466a0aa69ba1b
  - https://git.kernel.org/stable/c/6e1f586ddec48d71016b81acf68ba9f49ca54db8
  - https://git.kernel.org/stable/c/b9cee506da2b7920b5ea02ccd8e78a907d0ee7aa
  - https://git.kernel.org/stable/c/d6870f3800dbb212ae8433183ee82f566d067c6c
  - https://git.kernel.org/stable/c/f011360ad234a07cb6fbcc720fff646a93a9f0d6

------------------------------------------------------------

CVE ID: CVE-2023-52989
Description: In the Linux kernel, the following vulnerability has been resolved:

firewire: fix memory leak for payload of request subaction to IEC 61883-1 FCP region

This patch is fix for Linux kernel v2.6.33 or later.

For request subaction to IEC 61883-1 FCP region, Linux FireWire subsystem
have had an issue of use-after-free. The subsystem allows multiple
user space listeners to the region, while data of the payload was likely
released before the listeners execute read(2) to access to it for copying
to user space.

The issue was fixed by a commit 281e20323ab7 ("firewire: core: fix
use-after-free regression in FCP handler"). The object of payload is
duplicated in kernel space for each listener. When the listener executes
ioctl(2) with FW_CDEV_IOC_SEND_RESPONSE request, the object is going to
be released.

However, it causes memory leak since the commit relies on call of
release_request() in drivers/firewire/core-cdev.c. Against the
expectation, the function is never called due to the design of
release_client_resource(). The function delegates release task
to caller when called with non-NULL fourth argument. The implementation
of ioctl_send_response() is the case. It should release the object
explicitly.

This commit fixes the bug.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.33, Last Version (Excluding): 4.14.306
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.273
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.232
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.168
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.11
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/356ff89acdbe6a66019154bc7eb2d300f5b15103
  - https://git.kernel.org/stable/c/531390a243ef47448f8bad01c186c2787666bf4d
  - https://git.kernel.org/stable/c/53785fd9b315583cf029e39f72b73d23704a2253
  - https://git.kernel.org/stable/c/5f4543c9382ae2d5062f6aa4fecae0c9258d0b0e
  - https://git.kernel.org/stable/c/b2cd3947d116bb9ba7ff097b5fc747a8956764db
  - https://git.kernel.org/stable/c/c8bdc88216f09cb7387fedbdf613524367328616
  - https://git.kernel.org/stable/c/d5a2dcee53fa6e6e2822f93cb3f1b0cd23163bee

------------------------------------------------------------

CVE ID: CVE-2023-52991
Description: In the Linux kernel, the following vulnerability has been resolved:

net: fix NULL pointer in skb_segment_list

Commit 3a1296a38d0c ("net: Support GRO/GSO fraglist chaining.")
introduced UDP listifyed GRO. The segmentation relies on frag_list being
untouched when passing through the network stack. This assumption can be
broken sometimes, where frag_list itself gets pulled into linear area,
leaving frag_list being NULL. When this happens it can trigger
following NULL pointer dereference, and panic the kernel. Reverse the
test condition should fix it.

[19185.577801][    C1] BUG: kernel NULL pointer dereference, address:
...
[19185.663775][    C1] RIP: 0010:skb_segment_list+0x1cc/0x390
...
[19185.834644][    C1] Call Trace:
[19185.841730][    C1]  <TASK>
[19185.848563][    C1]  __udp_gso_segment+0x33e/0x510
[19185.857370][    C1]  inet_gso_segment+0x15b/0x3e0
[19185.866059][    C1]  skb_mac_gso_segment+0x97/0x110
[19185.874939][    C1]  __skb_gso_segment+0xb2/0x160
[19185.883646][    C1]  udp_queue_rcv_skb+0xc3/0x1d0
[19185.892319][    C1]  udp_unicast_rcv_skb+0x75/0x90
[19185.900979][    C1]  ip_protocol_deliver_rcu+0xd2/0x200
[19185.910003][    C1]  ip_local_deliver_finish+0x44/0x60
[19185.918757][    C1]  __netif_receive_skb_one_core+0x8b/0xa0
[19185.927834][    C1]  process_backlog+0x88/0x130
[19185.935840][    C1]  __napi_poll+0x27/0x150
[19185.943447][    C1]  net_rx_action+0x27e/0x5f0
[19185.951331][    C1]  ? mlx5_cq_tasklet_cb+0x70/0x160 [mlx5_core]
[19185.960848][    C1]  __do_softirq+0xbc/0x25d
[19185.968607][    C1]  irq_exit_rcu+0x83/0xb0
[19185.976247][    C1]  common_interrupt+0x43/0xa0
[19185.984235][    C1]  asm_common_interrupt+0x22/0x40
...
[19186.094106][    C1]  </TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.6, Last Version (Excluding): 5.10.167
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.92
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.10
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/046de74f9af92ae9ffce75fa22a1795223f4fb54
  - https://git.kernel.org/stable/c/6446369fb9f083ce032448c5047da08e298b22e6
  - https://git.kernel.org/stable/c/876e8ca8366735a604bac86ff7e2732fc9d85d2d
  - https://git.kernel.org/stable/c/888dad6f3e85e3b2f8389bd6478f181efc72534d

------------------------------------------------------------

CVE ID: CVE-2023-52992
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Skip task with pid=1 in send_signal_common()

The following kernel panic can be triggered when a task with pid=1 attaches
a prog that attempts to send killing signal to itself, also see [1] for more
details:

  Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
  CPU: 3 PID: 1 Comm: systemd Not tainted 6.1.0-09652-g59fe41b5255f #148
  Call Trace:
  <TASK>
  __dump_stack lib/dump_stack.c:88 [inline]
  dump_stack_lvl+0x100/0x178 lib/dump_stack.c:106
  panic+0x2c4/0x60f kernel/panic.c:275
  do_exit.cold+0x63/0xe4 kernel/exit.c:789
  do_group_exit+0xd4/0x2a0 kernel/exit.c:950
  get_signal+0x2460/0x2600 kernel/signal.c:2858
  arch_do_signal_or_restart+0x78/0x5d0 arch/x86/kernel/signal.c:306
  exit_to_user_mode_loop kernel/entry/common.c:168 [inline]
  exit_to_user_mode_prepare+0x15f/0x250 kernel/entry/common.c:203
  __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]
  syscall_exit_to_user_mode+0x1d/0x50 kernel/entry/common.c:296
  do_syscall_64+0x44/0xb0 arch/x86/entry/common.c:86
  entry_SYSCALL_64_after_hwframe+0x63/0xcd

So skip task with pid=1 in bpf_send_signal_common() to avoid the panic.

  [1] https://lore.kernel.org/bpf/20221222043507.33037-1-sunhao.th@gmail.com
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0dfef503133565fa0bcf3268d8eeb5b181191a65
  - https://git.kernel.org/stable/c/1283a01b6e19d05f7ed49584ea653947245cd41e
  - https://git.kernel.org/stable/c/4923160393b06a34759a11b17930d71e06f396f2
  - https://git.kernel.org/stable/c/a1c0263f1eb4deee132e11e52ee6982435460d81
  - https://git.kernel.org/stable/c/a3d81bc1eaef48e34dd0b9b48eefed9e02a06451

------------------------------------------------------------

CVE ID: CVE-2023-52993
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/i8259: Mark legacy PIC interrupts with IRQ_LEVEL

Baoquan reported that after triggering a crash the subsequent crash-kernel
fails to boot about half of the time. It triggers a NULL pointer
dereference in the periodic tick code.

This happens because the legacy timer interrupt (IRQ0) is resent in
software which happens in soft interrupt (tasklet) context. In this context
get_irq_regs() returns NULL which leads to the NULL pointer dereference.

The reason for the resend is a spurious APIC interrupt on the IRQ0 vector
which is captured and leads to a resend when the legacy timer interrupt is
enabled. This is wrong because the legacy PIC interrupts are level
triggered and therefore should never be resent in software, but nothing
ever sets the IRQ_LEVEL flag on those interrupts, so the core code does not
know about their trigger type.

Ensure that IRQ_LEVEL is set when the legacy PCI interrupts are set up.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.18, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0b08201158f177aab469e356b4d6af24fdd118df
  - https://git.kernel.org/stable/c/137f1b47da5f58805da42c1b7811e28c1e353f39
  - https://git.kernel.org/stable/c/496975d1a2937f4baadf3d985991b13fc4fc4f27
  - https://git.kernel.org/stable/c/5fa55950729d0762a787451dc52862c3f850f859
  - https://git.kernel.org/stable/c/744fe9be9665227335539b7a77ece8d9ff62b6c0
  - https://git.kernel.org/stable/c/8770cd9d7c14aa99c255a0d08186f0be953e1638
  - https://git.kernel.org/stable/c/e284c273dbb4c1ed68d4204bff94d0b10e4a90f5

------------------------------------------------------------

CVE ID: CVE-2023-52994
Description: In the Linux kernel, the following vulnerability has been resolved:

acpi: Fix suspend with Xen PV

Commit f1e525009493 ("x86/boot: Skip realmode init code when running as
Xen PV guest") missed one code path accessing real_mode_header, leading
to dereferencing NULL when suspending the system under Xen:

    [  348.284004] PM: suspend entry (deep)
    [  348.289532] Filesystems sync: 0.005 seconds
    [  348.291545] Freezing user space processes ... (elapsed 0.000 seconds) done.
    [  348.292457] OOM killer disabled.
    [  348.292462] Freezing remaining freezable tasks ... (elapsed 0.104 seconds) done.
    [  348.396612] printk: Suspending console(s) (use no_console_suspend to debug)
    [  348.749228] PM: suspend devices took 0.352 seconds
    [  348.769713] ACPI: EC: interrupt blocked
    [  348.816077] BUG: kernel NULL pointer dereference, address: 000000000000001c
    [  348.816080] #PF: supervisor read access in kernel mode
    [  348.816081] #PF: error_code(0x0000) - not-present page
    [  348.816083] PGD 0 P4D 0
    [  348.816086] Oops: 0000 [#1] PREEMPT SMP NOPTI
    [  348.816089] CPU: 0 PID: 6764 Comm: systemd-sleep Not tainted 6.1.3-1.fc32.qubes.x86_64 #1
    [  348.816092] Hardware name: Star Labs StarBook/StarBook, BIOS 8.01 07/03/2022
    [  348.816093] RIP: e030:acpi_get_wakeup_address+0xc/0x20

Fix that by adding an optional acpi callback allowing to skip setting
the wakeup address, as in the Xen PV case this will be handled by the
hypervisor anyway.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0.16, Last Version (Excluding): 6.1
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.2, Last Version (Excluding): 6.1.9
References:
  - https://git.kernel.org/stable/c/b96903b7fc8c82ddfd92df4cdd83db3e567da0a5
  - https://git.kernel.org/stable/c/fe0ba8c23f9a35b0307eb662f16dd3a75fcdae41

------------------------------------------------------------

CVE ID: CVE-2023-52995
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv/kprobe: Fix instruction simulation of JALR

Set kprobe at 'jalr 1140(ra)' of vfs_write results in the following
crash:

[   32.092235] Unable to handle kernel access to user memory without uaccess routines at virtual address 00aaaaaad77b1170
[   32.093115] Oops [#1]
[   32.093251] Modules linked in:
[   32.093626] CPU: 0 PID: 135 Comm: ftracetest Not tainted 6.2.0-rc2-00013-gb0aa5e5df0cb-dirty #16
[   32.093985] Hardware name: riscv-virtio,qemu (DT)
[   32.094280] epc : ksys_read+0x88/0xd6
[   32.094855]  ra : ksys_read+0xc0/0xd6
[   32.095016] epc : ffffffff801cda80 ra : ffffffff801cdab8 sp : ff20000000d7bdc0
[   32.095227]  gp : ffffffff80f14000 tp : ff60000080f9cb40 t0 : ffffffff80f13e80
[   32.095500]  t1 : ffffffff8000c29c t2 : ffffffff800dbc54 s0 : ff20000000d7be60
[   32.095716]  s1 : 0000000000000000 a0 : ffffffff805a64ae a1 : ffffffff80a83708
[   32.095921]  a2 : ffffffff80f160a0 a3 : 0000000000000000 a4 : f229b0afdb165300
[   32.096171]  a5 : f229b0afdb165300 a6 : ffffffff80eeebd0 a7 : 00000000000003ff
[   32.096411]  s2 : ff6000007ff76800 s3 : fffffffffffffff7 s4 : 00aaaaaad77b1170
[   32.096638]  s5 : ffffffff80f160a0 s6 : ff6000007ff76800 s7 : 0000000000000030
[   32.096865]  s8 : 00ffffffc3d97be0 s9 : 0000000000000007 s10: 00aaaaaad77c9410
[   32.097092]  s11: 0000000000000000 t3 : ffffffff80f13e48 t4 : ffffffff8000c29c
[   32.097317]  t5 : ffffffff8000c29c t6 : ffffffff800dbc54
[   32.097505] status: 0000000200000120 badaddr: 00aaaaaad77b1170 cause: 000000000000000d
[   32.098011] [<ffffffff801cdb72>] ksys_write+0x6c/0xd6
[   32.098222] [<ffffffff801cdc06>] sys_write+0x2a/0x38
[   32.098405] [<ffffffff80003c76>] ret_from_syscall+0x0/0x2

Since the rs1 and rd might be the same one, such as 'jalr 1140(ra)',
hence it requires obtaining the target address from rs1 followed by
updating rd.

[Palmer: Pick Guo's cleanup]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/614471b7f7cd28a2c96ab9c90b37471c82258ffb
  - https://git.kernel.org/stable/c/ca0254998be4d74cf6add70ccfab0d2dbd362a10
  - https://git.kernel.org/stable/c/f4c8fc775fcbc9e9047b22671c55ca18f9a127d4

------------------------------------------------------------

CVE ID: CVE-2023-52996
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: prevent potential spectre v1 gadget in fib_metrics_match()

if (!type)
        continue;
    if (type > RTAX_MAX)
        return false;
    ...
    fi_val = fi->fib_metrics->metrics[type - 1];

@type being used as an array index, we need to prevent
cpu speculation or risk leaking kernel memory content.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5e9398a26a92fc402d82ce1f97cc67d832527da0
  - https://git.kernel.org/stable/c/7f9828fb1f688210e681268490576f0ca65c322a
  - https://git.kernel.org/stable/c/8f0eb24f1a7a60ce635f0d757a46f1a37a4d467d
  - https://git.kernel.org/stable/c/ca3cf947760de050d558293002ad3e7f4b8745d2
  - https://git.kernel.org/stable/c/f9753ebd61be2d957b5504cbd3fd719674f05b7a

------------------------------------------------------------

CVE ID: CVE-2023-52997
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv4: prevent potential spectre v1 gadget in ip_metrics_convert()

if (!type)
		continue;
	if (type > RTAX_MAX)
		return -EINVAL;
	...
	metrics[type - 1] = val;

@type being used as an array index, we need to prevent
cpu speculation or risk leaking kernel memory content.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d1d63b612801b3f0a39b7d4467cad0abd60e5c8
  - https://git.kernel.org/stable/c/34c6142f0df9cd75cba5a7aa9df0960d2854b415
  - https://git.kernel.org/stable/c/6850fe301d015a7d2012d1de8caf43dafb7cc2f6
  - https://git.kernel.org/stable/c/746db9ec1e672eee13965625ddac0d97e16fa20c
  - https://git.kernel.org/stable/c/d50e7348b44f1e046121ff5be01b7fb6978a1149
  - https://git.kernel.org/stable/c/ef050cf5fb70d995a0d03244e25179b7c66a924a

------------------------------------------------------------

CVE ID: CVE-2023-52998
Description: In the Linux kernel, the following vulnerability has been resolved:

net: fec: Use page_pool_put_full_page when freeing rx buffers

The page_pool_release_page was used when freeing rx buffers, and this
function just unmaps the page (if mapped) and does not recycle the page.
So after hundreds of down/up the eth0, the system will out of memory.
For more details, please refer to the following reproduce steps and
bug logs. To solve this issue and refer to the doc of page pool, the
page_pool_put_full_page should be used to replace page_pool_release_page.
Because this API will try to recycle the page if the page refcnt equal to
1. After testing 20000 times, the issue can not be reproduced anymore
(about testing 391 times the issue will occur on i.MX8MN-EVK before).

Reproduce steps:
Create the test script and run the script. The script content is as
follows:
LOOPS=20000
i=1
while [ $i -le $LOOPS ]
do
    echo "TINFO:ENET $curface up and down test $i times"
    org_macaddr=$(cat /sys/class/net/eth0/address)
    ifconfig eth0 down
    ifconfig eth0  hw ether $org_macaddr up
    i=$(expr $i + 1)
done
sleep 5
if cat /sys/class/net/eth0/operstate | grep 'up';then
    echo "TEST PASS"
else
    echo "TEST FAIL"
fi

Bug detail logs:
TINFO:ENET  up and down test 391 times
[  850.471205] Qualcomm Atheros AR8031/AR8033 30be0000.ethernet-1:00: attached PHY driver (mii_bus:phy_addr=30be0000.ethernet-1:00, irq=POLL)
[  853.535318] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[  853.541694] fec 30be0000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx
[  870.590531] page_pool_release_retry() stalled pool shutdown 199 inflight 60 sec
[  931.006557] page_pool_release_retry() stalled pool shutdown 199 inflight 120 sec
TINFO:ENET  up and down test 392 times
[  991.426544] page_pool_release_retry() stalled pool shutdown 192 inflight 181 sec
[ 1051.838531] page_pool_release_retry() stalled pool shutdown 170 inflight 241 sec
[ 1093.751217] Qualcomm Atheros AR8031/AR8033 30be0000.ethernet-1:00: attached PHY driver (mii_bus:phy_addr=30be0000.ethernet-1:00, irq=POLL)
[ 1096.446520] page_pool_release_retry() stalled pool shutdown 308 inflight 60 sec
[ 1096.831245] fec 30be0000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx
[ 1096.839092] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[ 1112.254526] page_pool_release_retry() stalled pool shutdown 103 inflight 302 sec
[ 1156.862533] page_pool_release_retry() stalled pool shutdown 308 inflight 120 sec
[ 1172.674516] page_pool_release_retry() stalled pool shutdown 103 inflight 362 sec
[ 1217.278532] page_pool_release_retry() stalled pool shutdown 308 inflight 181 sec
TINFO:ENET  up and down test 393 times
[ 1233.086535] page_pool_release_retry() stalled pool shutdown 103 inflight 422 sec
[ 1277.698513] page_pool_release_retry() stalled pool shutdown 308 inflight 241 sec
[ 1293.502525] page_pool_release_retry() stalled pool shutdown 86 inflight 483 sec
[ 1338.110518] page_pool_release_retry() stalled pool shutdown 308 inflight 302 sec
[ 1353.918540] page_pool_release_retry() stalled pool shutdown 32 inflight 543 sec
[ 1361.179205] Qualcomm Atheros AR8031/AR8033 30be0000.ethernet-1:00: attached PHY driver (mii_bus:phy_addr=30be0000.ethernet-1:00, irq=POLL)
[ 1364.255298] fec 30be0000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx
[ 1364.263189] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[ 1371.998532] page_pool_release_retry() stalled pool shutdown 310 inflight 60 sec
[ 1398.530542] page_pool_release_retry() stalled pool shutdown 308 inflight 362 sec
[ 1414.334539] page_pool_release_retry() stalled pool shutdown 16 inflight 604 sec
[ 1432.414520] page_pool_release_retry() stalled pool shutdown 310 inflight 120 sec
[ 1458.942523] page_pool_release_retry() stalled pool shutdown 308 inflight 422 sec
[ 1474.750521] page_pool_release_retry() stalled pool shutdown 16 inflight 664 sec
TINFO:ENET  up and down test 394 times
[ 1492.8305
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/554484a34e985a307756ee4794e60be31e3db2e5
  - https://git.kernel.org/stable/c/e38553bdc377e3e7a6caa9dd9770d8b644d8dac3

------------------------------------------------------------

CVE ID: CVE-2023-52999
Description: In the Linux kernel, the following vulnerability has been resolved:

net: fix UaF in netns ops registration error path

If net_assign_generic() fails, the current error path in ops_init() tries
to clear the gen pointer slot. Anyway, in such error path, the gen pointer
itself has not been modified yet, and the existing and accessed one is
smaller than the accessed index, causing an out-of-bounds error:

 BUG: KASAN: slab-out-of-bounds in ops_init+0x2de/0x320
 Write of size 8 at addr ffff888109124978 by task modprobe/1018

 CPU: 2 PID: 1018 Comm: modprobe Not tainted 6.2.0-rc2.mptcp_ae5ac65fbed5+ #1641
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014
 Call Trace:
  <TASK>
  dump_stack_lvl+0x6a/0x9f
  print_address_description.constprop.0+0x86/0x2b5
  print_report+0x11b/0x1fb
  kasan_report+0x87/0xc0
  ops_init+0x2de/0x320
  register_pernet_operations+0x2e4/0x750
  register_pernet_subsys+0x24/0x40
  tcf_register_action+0x9f/0x560
  do_one_initcall+0xf9/0x570
  do_init_module+0x190/0x650
  load_module+0x1fa5/0x23c0
  __do_sys_finit_module+0x10d/0x1b0
  do_syscall_64+0x58/0x80
  entry_SYSCALL_64_after_hwframe+0x72/0xdc
 RIP: 0033:0x7f42518f778d
 Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48
       89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff
       ff 73 01 c3 48 8b 0d cb 56 2c 00 f7 d8 64 89 01 48
 RSP: 002b:00007fff96869688 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
 RAX: ffffffffffffffda RBX: 00005568ef7f7c90 RCX: 00007f42518f778d
 RDX: 0000000000000000 RSI: 00005568ef41d796 RDI: 0000000000000003
 RBP: 00005568ef41d796 R08: 0000000000000000 R09: 0000000000000000
 R10: 0000000000000003 R11: 0000000000000246 R12: 0000000000000000
 R13: 00005568ef7f7d30 R14: 0000000000040000 R15: 0000000000000000
  </TASK>

This change addresses the issue by skipping the gen pointer
de-reference in the mentioned error-path.

Found by code inspection and verified with explicit error injection
on a kasan-enabled kernel.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.264, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.223, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.153, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.77, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.2
  - Vendor: linux, Product: linux_kernel, Version: 6.0.7, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/12075708f2e77ee6a9f8bb2cf512c38be3099794
  - https://git.kernel.org/stable/c/66689a72ba73575e76d4f6a8748d3fa2690ec1c4
  - https://git.kernel.org/stable/c/71ab9c3e2253619136c31c89dbb2c69305cc89b1
  - https://git.kernel.org/stable/c/ad0dfe9bcf0d78e699c7efb64c90ed062dc48bea
  - https://git.kernel.org/stable/c/d4c008f3b7f7d4ffd311eb2dae5e75b3cbddacd0
  - https://git.kernel.org/stable/c/ddd49cbbd4c1ceb38032018b589b44208e54f55e

------------------------------------------------------------

CVE ID: CVE-2023-53000
Description: In the Linux kernel, the following vulnerability has been resolved:

netlink: prevent potential spectre v1 gadgets

Most netlink attributes are parsed and validated from
__nla_validate_parse() or validate_nla()

    u16 type = nla_type(nla);

    if (type == 0 || type > maxtype) {
        /* error or continue */
    }

@type is then used as an array index and can be used
as a Spectre v1 gadget.

array_index_nospec() can be used to prevent leaking
content of kernel memory to malicious users.

This should take care of vast majority of netlink uses,
but an audit is needed to take care of others where
validation is not yet centralized in core netlink functions.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3e5082b1c66c7783fbcd79b5b178573230e528ff
  - https://git.kernel.org/stable/c/41b74e95f297ac360ca7ed6bf200100717cb6c45
  - https://git.kernel.org/stable/c/539ca5dcbc91134bbe2c45677811c31d8b030d2d
  - https://git.kernel.org/stable/c/992e4ff7116a77968039277b5d6aaa535c2f2184
  - https://git.kernel.org/stable/c/f0950402e8c76e7dcb08563f1b4e8000fbc62455

------------------------------------------------------------

CVE ID: CVE-2023-53001
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/drm_vma_manager: Add drm_vma_node_allow_once()

Currently there is no easy way for a drm driver to safely check and allow
drm_vma_offset_node for a drm file just once. Allow drm drivers to call
non-refcounted version of drm_vma_node_allow() so that a driver doesn't
need to keep track of each drm_vma_node_allow() to call subsequent
drm_vma_node_revoke() to prevent memory leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/67444f8ca31cdaf45e0b761241ad49b1ae04bcf9
  - https://git.kernel.org/stable/c/899d3a3c19ac0e5da013ce34833dccb97d19b5e4

------------------------------------------------------------

CVE ID: CVE-2023-53002
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915: Fix a memory leak with reused mmap_offset

drm_vma_node_allow() and drm_vma_node_revoke() should be called in
balanced pairs. We call drm_vma_node_allow() once per-file everytime a
user calls mmap_offset, but only call drm_vma_node_revoke once per-file
on each mmap_offset. As the mmap_offset is reused by the client, the
per-file vm_count may remain non-zero and the rbtree leaked.

Call drm_vma_node_allow_once() instead to prevent that memory leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0220e4fe178c3390eb0291cdb34912d66972db8a
  - https://git.kernel.org/stable/c/0bdc4b4ba7206c452ee81c82fa66e39d0e1780fb

------------------------------------------------------------

CVE ID: CVE-2023-53003
Description: In the Linux kernel, the following vulnerability has been resolved:

EDAC/qcom: Do not pass llcc_driv_data as edac_device_ctl_info's pvt_info

The memory for llcc_driv_data is allocated by the LLCC driver. But when
it is passed as the private driver info to the EDAC core, it will get freed
during the qcom_edac driver release. So when the qcom_edac driver gets probed
again, it will try to use the freed data leading to the use-after-free bug.

Hence, do not pass llcc_driv_data as pvt_info but rather reference it
using the platform_data pointer in the qcom_edac driver.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/66e10d5f399629ef7877304d9ba2b35d0474e7eb
  - https://git.kernel.org/stable/c/6f0351d0c311951b8b3064db91e61841e85b2b96
  - https://git.kernel.org/stable/c/76d9ebb7f0bc10fbc78b6d576751552edf743968
  - https://git.kernel.org/stable/c/977c6ba624f24ae20cf0faee871257a39348d4a9
  - https://git.kernel.org/stable/c/bff5243bd32661cf9ce66f6d9210fc8f89bda145

------------------------------------------------------------

CVE ID: CVE-2023-53004
Description: In the Linux kernel, the following vulnerability has been resolved:

ovl: fix tmpfile leak

Missed an error cleanup.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/baabaa505563362b71f2637aedd7b807d270656c
  - https://git.kernel.org/stable/c/caa0ea92503f8afa1941f6ac899e5c4e3f6ec8bb

------------------------------------------------------------

CVE ID: CVE-2023-53005
Description: In the Linux kernel, the following vulnerability has been resolved:

trace_events_hist: add check for return value of 'create_hist_field'

Function 'create_hist_field' is called recursively at
trace_events_hist.c:1954 and can return NULL-value that's why we have
to check it to avoid null pointer dereference.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.17, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/31b2414abeaa6de0490e85164badc6dcb1bb8ec9
  - https://git.kernel.org/stable/c/592ba7116fa620425725ff0972691f352ba3caf6
  - https://git.kernel.org/stable/c/886aa449235f478e262bbd5dcdee6ed6bc202949
  - https://git.kernel.org/stable/c/8b152e9150d07a885f95e1fd401fc81af202d9a4
  - https://git.kernel.org/stable/c/b4e7e81b4fdfcf457daee6b7a61769f62198d840
  - https://git.kernel.org/stable/c/d2d1ada58e7cc100b8d7d6b082d19321ba4a700a

------------------------------------------------------------

CVE ID: CVE-2023-53006
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: Fix oops due to uncleared server->smbd_conn in reconnect

In smbd_destroy(), clear the server->smbd_conn pointer after freeing the
smbd_connection struct that it points to so that reconnection doesn't get
confused.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4b83bc6f87eedab4599b0123e572a422689444be
  - https://git.kernel.org/stable/c/5109607a4ece7cd8536172bf7549eb4dce1f3576
  - https://git.kernel.org/stable/c/91be54849d5392050f5b847b42bd5e6221551ac8
  - https://git.kernel.org/stable/c/a9640c0b268405f2540e8203a545e930ea88bb7d
  - https://git.kernel.org/stable/c/b7ab9161cf5ddc42a288edf9d1a61f3bdffe17c7
  - https://git.kernel.org/stable/c/e037baee16e0b9ace7e730888fcae9cec11daff2

------------------------------------------------------------

CVE ID: CVE-2023-53007
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Make sure trace_printk() can output as soon as it can be used

Currently trace_printk() can be used as soon as early_trace_init() is
called from start_kernel(). But if a crash happens, and
"ftrace_dump_on_oops" is set on the kernel command line, all you get will
be:

  [    0.456075]   <idle>-0         0dN.2. 347519us : Unknown type 6
  [    0.456075]   <idle>-0         0dN.2. 353141us : Unknown type 6
  [    0.456075]   <idle>-0         0dN.2. 358684us : Unknown type 6

This is because the trace_printk() event (type 6) hasn't been registered
yet. That gets done via an early_initcall(), which may be early, but not
early enough.

Instead of registering the trace_printk() event (and other ftrace events,
which are not trace events) via an early_initcall(), have them registered at
the same time that trace_printk() can be used. This way, if there is a
crash before early_initcall(), then the trace_printk()s will actually be
useful.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/198c83963f6335ca6d690cff067679560f2a3a22
  - https://git.kernel.org/stable/c/3bb06eb6e9acf7c4a3e1b5bc87aed398ff8e2253
  - https://git.kernel.org/stable/c/76b2390fdc80c0a8300e5da5b6b62d201b6fe9ce
  - https://git.kernel.org/stable/c/b0af180514edea6c83dc9a299d9f383009c99f25
  - https://git.kernel.org/stable/c/b94d7c7654356860dd7719120c7d15ba38b6162a
  - https://git.kernel.org/stable/c/de3930a4883ddad2244efd6d349013294c62c75c
  - https://git.kernel.org/stable/c/f97eb0ab066133483a65c93eb894748de2f6b598

------------------------------------------------------------

CVE ID: CVE-2023-53008
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: fix potential memory leaks in session setup

Make sure to free cifs_ses::auth_key.response before allocating it as
we might end up leaking memory in reconnect or mounting.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2fe58d977ee05da5bb89ef5dc4f5bf2dc15db46f
  - https://git.kernel.org/stable/c/893d45394dbe4b5cbf3723c19e2ccc8b93a6ac9b

------------------------------------------------------------

CVE ID: CVE-2023-53009
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Add sync after creating vram bo

There will be data corruption on vram allocated by svm
if the initialization is not complete and application is
writting on the memory. Adding sync to wait for the
initialization completion is to resolve this issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/92af2d3b57a1afdfdcafb1c6a07ffd89cf3e98fb
  - https://git.kernel.org/stable/c/ba029e9991d9be90a28b6a0ceb25e9a6fb348829

------------------------------------------------------------

CVE ID: CVE-2023-53010
Description: In the Linux kernel, the following vulnerability has been resolved:

bnxt: Do not read past the end of test names

Test names were being concatenated based on a offset beyond the end of
the first name, which tripped the buffer overflow detection logic:

 detected buffer overflow in strnlen
 [...]
 Call Trace:
 bnxt_ethtool_init.cold+0x18/0x18

Refactor struct hwrm_selftest_qlist_output to use an actual array,
and adjust the concatenation to use snprintf() rather than a series of
strncat() calls.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/cefa85480ac99c0bef5a09daadb48d65fc28e279
  - https://git.kernel.org/stable/c/d3e599c090fc6977331150c5f0a69ab8ce87da21

------------------------------------------------------------

CVE ID: CVE-2023-53011
Description: In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: enable all safety features by default

In the original implementation of dwmac5
commit 8bf993a5877e ("net: stmmac: Add support for DWMAC5 and implement Safety Features")
all safety features were enabled by default.

Later it seems some implementations didn't have support for all the
features, so in
commit 5ac712dcdfef ("net: stmmac: enable platform specific safety features")
the safety_feat_cfg structure was added to the callback and defined for
some platforms to selectively enable these safety features.

The problem is that only certain platforms were given that software
support. If the automotive safety package bit is set in the hardware
features register the safety feature callback is called for the platform,
and for platforms that didn't get a safety_feat_cfg defined this results
in the following NULL pointer dereference:

[    7.933303] Call trace:
[    7.935812]  dwmac5_safety_feat_config+0x20/0x170 [stmmac]
[    7.941455]  __stmmac_open+0x16c/0x474 [stmmac]
[    7.946117]  stmmac_open+0x38/0x70 [stmmac]
[    7.950414]  __dev_open+0x100/0x1dc
[    7.954006]  __dev_change_flags+0x18c/0x204
[    7.958297]  dev_change_flags+0x24/0x6c
[    7.962237]  do_setlink+0x2b8/0xfa4
[    7.965827]  __rtnl_newlink+0x4ec/0x840
[    7.969766]  rtnl_newlink+0x50/0x80
[    7.973353]  rtnetlink_rcv_msg+0x12c/0x374
[    7.977557]  netlink_rcv_skb+0x5c/0x130
[    7.981500]  rtnetlink_rcv+0x18/0x2c
[    7.985172]  netlink_unicast+0x2e8/0x340
[    7.989197]  netlink_sendmsg+0x1a8/0x420
[    7.993222]  ____sys_sendmsg+0x218/0x280
[    7.997249]  ___sys_sendmsg+0xac/0x100
[    8.001103]  __sys_sendmsg+0x84/0xe0
[    8.004776]  __arm64_sys_sendmsg+0x24/0x30
[    8.008983]  invoke_syscall+0x48/0x114
[    8.012840]  el0_svc_common.constprop.0+0xcc/0xec
[    8.017665]  do_el0_svc+0x38/0xb0
[    8.021071]  el0_svc+0x2c/0x84
[    8.024212]  el0t_64_sync_handler+0xf4/0x120
[    8.028598]  el0t_64_sync+0x190/0x194

Go back to the original behavior, if the automotive safety package
is found to be supported in hardware enable all the features unless
safety_feat_cfg is passed in saying this particular platform only
supports a subset of the features.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/120b8e527e07c65de7f2b9018dcd9d17e66f2427
  - https://git.kernel.org/stable/c/aebf7e62708ba706ee7bf484c9023b15c214e92a
  - https://git.kernel.org/stable/c/fdfc76a116b5e9d3e98e6c96fe83b42d011d21d4

------------------------------------------------------------

CVE ID: CVE-2023-53012
Description: In the Linux kernel, the following vulnerability has been resolved:

thermal: core: call put_device() only after device_register() fails

put_device() shouldn't be called before a prior call to
device_register(). __thermal_cooling_device_register() doesn't follow
that properly and needs fixing. Also
thermal_cooling_device_destroy_sysfs() is getting called unnecessarily
on few error paths.

Fix all this by placing the calls at the right place.

Based on initial work done by Caleb Connolly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2846a7412f6246fd5171f51011bf76dfebcec0ee
  - https://git.kernel.org/stable/c/6c54b7bc8a31ce0f7cc7f8deef05067df414f1d8
  - https://git.kernel.org/stable/c/a7d736cc3c6cb0d7498bbfb56515d414e35e9510

------------------------------------------------------------

CVE ID: CVE-2023-53013
Description: In the Linux kernel, the following vulnerability has been resolved:

ptdma: pt_core_execute_cmd() should use spinlock

The interrupt handler (pt_core_irq_handler()) of the ptdma
driver can be called from interrupt context. The code flow
in this function can lead down to pt_core_execute_cmd() which
will attempt to grab a mutex, which is not appropriate in
interrupt context and ultimately leads to a kernel panic.
The fix here changes this mutex to a spinlock, which has
been verified to resolve the issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/13ba563c2c8055ba8a637c9f70bb833b43cb4207
  - https://git.kernel.org/stable/c/95e5fda3b5f9ed8239b145da3fa01e641cf5d53c
  - https://git.kernel.org/stable/c/ed0d8f731e0bf1bb12a7a37698ac613db20e2794

------------------------------------------------------------

CVE ID: CVE-2023-53014
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: tegra: Fix memory leak in terminate_all()

Terminate vdesc when terminating an ongoing transfer.
This will ensure that the vdesc is present in the desc_terminated list
The descriptor will be freed later in desc_free_list().

This fixes the memory leaks which can happen when terminating an
ongoing transfer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/567128076d554e41609c61b7d447089094ff72c5
  - https://git.kernel.org/stable/c/a7a7ee6f5a019ad72852c001abbce50d35e992f2

------------------------------------------------------------

CVE ID: CVE-2023-53015
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: betop: check shape of output reports

betopff_init() only checks the total sum of the report counts for each
report field to be at least 4, but hid_betopff_play() expects 4 report
fields.
A device advertising an output report with one field and 4 report counts
would pass the check but crash the kernel with a NULL pointer dereference
in hid_betopff_play().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07bc32e53c7bd5c91472cc485231ef6274db9b76
  - https://git.kernel.org/stable/c/1a2a47b85cab50a3c146731bfeaf2d860f5344ee
  - https://git.kernel.org/stable/c/28fc6095da22dc88433d79578ae1c495ebe8ca43
  - https://git.kernel.org/stable/c/3782c0d6edf658b71354a64d60aa7a296188fc90
  - https://git.kernel.org/stable/c/7317326f685824c7c29bd80841fd18041af6bb73
  - https://git.kernel.org/stable/c/d3065cc56221d1a5eda237e94eaf2a627b88ab79
  - https://git.kernel.org/stable/c/dbab4dba400d6ea9a9697fbbd287adbf7db1dac4

------------------------------------------------------------

CVE ID: CVE-2023-53016
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: Fix possible deadlock in rfcomm_sk_state_change

syzbot reports a possible deadlock in rfcomm_sk_state_change [1].
While rfcomm_sock_connect acquires the sk lock and waits for
the rfcomm lock, rfcomm_sock_release could have the rfcomm
lock and hit a deadlock for acquiring the sk lock.
Here's a simplified flow:

rfcomm_sock_connect:
  lock_sock(sk)
  rfcomm_dlc_open:
    rfcomm_lock()

rfcomm_sock_release:
  rfcomm_sock_shutdown:
    rfcomm_lock()
    __rfcomm_dlc_close:
        rfcomm_k_state_change:
	  lock_sock(sk)

This patch drops the sk lock before calling rfcomm_dlc_open to
avoid the possible deadlock and holds sk's reference count to
prevent use-after-free after rfcomm_dlc_open completes.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/17511bd84871f4a6106cb335616e086880313f3f
  - https://git.kernel.org/stable/c/1d80d57ffcb55488f0ec0b77928d4f82d16b6a90
  - https://git.kernel.org/stable/c/98aec50ff7f60cc6f2d6a4396b475c547e58b04d

------------------------------------------------------------

CVE ID: CVE-2023-53017
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: hci_sync: fix memory leak in hci_update_adv_data()

When hci_cmd_sync_queue() failed in hci_update_adv_data(), inst_ptr is
not freed, which will cause memory leak, convert to use ERR_PTR/PTR_ERR
to pass the instance to callback so no memory needs to be allocated.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1ed8b37cbaf14574c779064ef1372af62e8ba6aa
  - https://git.kernel.org/stable/c/8ac6043bd3e5b58d30f50737aedc2e58e8087ad5

------------------------------------------------------------

CVE ID: CVE-2023-53018
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: hci_conn: Fix memory leaks

When hci_cmd_sync_queue() failed in hci_le_terminate_big() or
hci_le_big_terminate(), the memory pointed by variable d is not freed,
which will cause memory leak. Add release process to error path.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3aa21311f36d8a2730c7ccef37235e951f23927b
  - https://git.kernel.org/stable/c/f51a825b9f730a782aa768454906b4468e67b667

------------------------------------------------------------

CVE ID: CVE-2023-53019
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mdio: validate parameter addr in mdiobus_get_phy()

The caller may pass any value as addr, what may result in an out-of-bounds
access to array mdio_map. One existing case is stmmac_init_phy() that
may pass -1 as addr. Therefore validate addr before using it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d80c259dfbadefa61b7ea334dfce5cb57f8c72f
  - https://git.kernel.org/stable/c/4bc5f1f6bc94e695dfd912122af96e7115a0ddb8
  - https://git.kernel.org/stable/c/7879626296e6ffd838ae0f2af1ab49ee46354973
  - https://git.kernel.org/stable/c/867dbe784c5010a466f00a7d1467c1c5ea569c75
  - https://git.kernel.org/stable/c/8a7b9560a3a8eb8724888c426e05926752f73aa0
  - https://git.kernel.org/stable/c/ad67de330d83e8078372b52af18ffe8d39e26c85
  - https://git.kernel.org/stable/c/c431a3d642593bbdb99e8a9e3eed608b730db6f8

------------------------------------------------------------

CVE ID: CVE-2023-53020
Description: In the Linux kernel, the following vulnerability has been resolved:

l2tp: close all race conditions in l2tp_tunnel_register()

The code in l2tp_tunnel_register() is racy in several ways:

1. It modifies the tunnel socket _after_ publishing it.

2. It calls setup_udp_tunnel_sock() on an existing socket without
   locking.

3. It changes sock lock class on fly, which triggers many syzbot
   reports.

This patch amends all of them by moving socket initialization code
before publishing and under sock lock. As suggested by Jakub, the
l2tp lockdep class is not necessary as we can just switch to
bh_lock_sock_nested().
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.6, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0b2c59720e65885a394a017d0cf9cab118914682
  - https://git.kernel.org/stable/c/2d77e5c0ad79004b5ef901895437e9cce6dfcc7e
  - https://git.kernel.org/stable/c/77e8ed776cdb1a24b2aab8fe7c6f1f154235e1ce
  - https://git.kernel.org/stable/c/cef0845b6dcfa2f6c2c832e7f9622551456c741d

------------------------------------------------------------

CVE ID: CVE-2023-53021
Description: In the Linux kernel, the following vulnerability has been resolved:

net/sched: sch_taprio: fix possible use-after-free

syzbot reported a nasty crash [1] in net_tx_action() which
made little sense until we got a repro.

This repro installs a taprio qdisc, but providing an
invalid TCA_RATE attribute.

qdisc_create() has to destroy the just initialized
taprio qdisc, and taprio_destroy() is called.

However, the hrtimer used by taprio had already fired,
therefore advance_sched() called __netif_schedule().

Then net_tx_action was trying to use a destroyed qdisc.

We can not undo the __netif_schedule(), so we must wait
until one cpu serviced the qdisc before we can proceed.

Many thanks to Alexander Potapenko for his help.

[1]
BUG: KMSAN: uninit-value in queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline]
BUG: KMSAN: uninit-value in do_raw_spin_trylock include/linux/spinlock.h:191 [inline]
BUG: KMSAN: uninit-value in __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline]
BUG: KMSAN: uninit-value in _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138
 queued_spin_trylock include/asm-generic/qspinlock.h:94 [inline]
 do_raw_spin_trylock include/linux/spinlock.h:191 [inline]
 __raw_spin_trylock include/linux/spinlock_api_smp.h:89 [inline]
 _raw_spin_trylock+0x92/0xa0 kernel/locking/spinlock.c:138
 spin_trylock include/linux/spinlock.h:359 [inline]
 qdisc_run_begin include/net/sch_generic.h:187 [inline]
 qdisc_run+0xee/0x540 include/net/pkt_sched.h:125
 net_tx_action+0x77c/0x9a0 net/core/dev.c:5086
 __do_softirq+0x1cc/0x7fb kernel/softirq.c:571
 run_ksoftirqd+0x2c/0x50 kernel/softirq.c:934
 smpboot_thread_fn+0x554/0x9f0 kernel/smpboot.c:164
 kthread+0x31b/0x430 kernel/kthread.c:376
 ret_from_fork+0x1f/0x30

Uninit was created at:
 slab_post_alloc_hook mm/slab.h:732 [inline]
 slab_alloc_node mm/slub.c:3258 [inline]
 __kmalloc_node_track_caller+0x814/0x1250 mm/slub.c:4970
 kmalloc_reserve net/core/skbuff.c:358 [inline]
 __alloc_skb+0x346/0xcf0 net/core/skbuff.c:430
 alloc_skb include/linux/skbuff.h:1257 [inline]
 nlmsg_new include/net/netlink.h:953 [inline]
 netlink_ack+0x5f3/0x12b0 net/netlink/af_netlink.c:2436
 netlink_rcv_skb+0x55d/0x6c0 net/netlink/af_netlink.c:2507
 rtnetlink_rcv+0x30/0x40 net/core/rtnetlink.c:6108
 netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
 netlink_unicast+0xf3b/0x1270 net/netlink/af_netlink.c:1345
 netlink_sendmsg+0x1288/0x1440 net/netlink/af_netlink.c:1921
 sock_sendmsg_nosec net/socket.c:714 [inline]
 sock_sendmsg net/socket.c:734 [inline]
 ____sys_sendmsg+0xabc/0xe90 net/socket.c:2482
 ___sys_sendmsg+0x2a1/0x3f0 net/socket.c:2536
 __sys_sendmsg net/socket.c:2565 [inline]
 __do_sys_sendmsg net/socket.c:2574 [inline]
 __se_sys_sendmsg net/socket.c:2572 [inline]
 __x64_sys_sendmsg+0x367/0x540 net/socket.c:2572
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd

CPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 6.0.0-rc2-syzkaller-47461-gac3859c02d7f #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/22/2022
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1200388a0b1c3c6fda48d4d2143db8f7e4ef5348
  - https://git.kernel.org/stable/c/3a415d59c1dbec9d772dbfab2d2520d98360caae
  - https://git.kernel.org/stable/c/c53acbf2facfdfabdc6e6984a1a38f5d38b606a1
  - https://git.kernel.org/stable/c/c60fe70078d6e515f424cb868d07e00411b27fbc
  - https://git.kernel.org/stable/c/d3b2d2820a005e43855fa71b80c4a4b194201c60

------------------------------------------------------------

CVE ID: CVE-2023-53022
Description: In the Linux kernel, the following vulnerability has been resolved:

net: enetc: avoid deadlock in enetc_tx_onestep_tstamp()

This lockdep splat says it better than I could:

================================
WARNING: inconsistent lock state
6.2.0-rc2-07010-ga9b9500ffaac-dirty #967 Not tainted
--------------------------------
inconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-W} usage.
kworker/1:3/179 [HC0[0]:SC0[0]:HE1:SE1] takes:
ffff3ec4036ce098 (_xmit_ETHER#2){+.?.}-{3:3}, at: netif_freeze_queues+0x5c/0xc0
{IN-SOFTIRQ-W} state was registered at:
  _raw_spin_lock+0x5c/0xc0
  sch_direct_xmit+0x148/0x37c
  __dev_queue_xmit+0x528/0x111c
  ip6_finish_output2+0x5ec/0xb7c
  ip6_finish_output+0x240/0x3f0
  ip6_output+0x78/0x360
  ndisc_send_skb+0x33c/0x85c
  ndisc_send_rs+0x54/0x12c
  addrconf_rs_timer+0x154/0x260
  call_timer_fn+0xb8/0x3a0
  __run_timers.part.0+0x214/0x26c
  run_timer_softirq+0x3c/0x74
  __do_softirq+0x14c/0x5d8
  ____do_softirq+0x10/0x20
  call_on_irq_stack+0x2c/0x5c
  do_softirq_own_stack+0x1c/0x30
  __irq_exit_rcu+0x168/0x1a0
  irq_exit_rcu+0x10/0x40
  el1_interrupt+0x38/0x64
irq event stamp: 7825
hardirqs last  enabled at (7825): [<ffffdf1f7200cae4>] exit_to_kernel_mode+0x34/0x130
hardirqs last disabled at (7823): [<ffffdf1f708105f0>] __do_softirq+0x550/0x5d8
softirqs last  enabled at (7824): [<ffffdf1f7081050c>] __do_softirq+0x46c/0x5d8
softirqs last disabled at (7811): [<ffffdf1f708166e0>] ____do_softirq+0x10/0x20

other info that might help us debug this:
 Possible unsafe locking scenario:

       CPU0
       ----
  lock(_xmit_ETHER#2);
  <Interrupt>
    lock(_xmit_ETHER#2);

 *** DEADLOCK ***

3 locks held by kworker/1:3/179:
 #0: ffff3ec400004748 ((wq_completion)events){+.+.}-{0:0}, at: process_one_work+0x1f4/0x6c0
 #1: ffff80000a0bbdc8 ((work_completion)(&priv->tx_onestep_tstamp)){+.+.}-{0:0}, at: process_one_work+0x1f4/0x6c0
 #2: ffff3ec4036cd438 (&dev->tx_global_lock){+.+.}-{3:3}, at: netif_tx_lock+0x1c/0x34

Workqueue: events enetc_tx_onestep_tstamp
Call trace:
 print_usage_bug.part.0+0x208/0x22c
 mark_lock+0x7f0/0x8b0
 __lock_acquire+0x7c4/0x1ce0
 lock_acquire.part.0+0xe0/0x220
 lock_acquire+0x68/0x84
 _raw_spin_lock+0x5c/0xc0
 netif_freeze_queues+0x5c/0xc0
 netif_tx_lock+0x24/0x34
 enetc_tx_onestep_tstamp+0x20/0x100
 process_one_work+0x28c/0x6c0
 worker_thread+0x74/0x450
 kthread+0x118/0x11c

but I'll say it anyway: the enetc_tx_onestep_tstamp() work item runs in
process context, therefore with softirqs enabled (i.o.w., it can be
interrupted by a softirq). If we hold the netif_tx_lock() when there is
an interrupt, and the NET_TX softirq then gets scheduled, this will take
the netif_tx_lock() a second time and deadlock the kernel.

To solve this, use netif_tx_lock_bh(), which blocks softirqs from
running.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3c463721a73bdb57a913e0d3124677a3758886fc
  - https://git.kernel.org/stable/c/8232e5a84d25a84a5cbda0f241a00793fb6eb608
  - https://git.kernel.org/stable/c/e893dced1a18e77b1262f5c10169413f0ece0da7

------------------------------------------------------------

CVE ID: CVE-2023-53023
Description: In the Linux kernel, the following vulnerability has been resolved:

net: nfc: Fix use-after-free in local_cleanup()

Fix a use-after-free that occurs in kfree_skb() called from
local_cleanup(). This could happen when killing nfc daemon (e.g. neard)
after detaching an nfc device.
When detaching an nfc device, local_cleanup() called from
nfc_llcp_unregister_device() frees local->rx_pending and decreases
local->ref by kref_put() in nfc_llcp_local_put().
In the terminating process, nfc daemon releases all sockets and it leads
to decreasing local->ref. After the last release of local->ref,
local_cleanup() called from local_release() frees local->rx_pending
again, which leads to the bug.

Setting local->rx_pending to NULL in local_cleanup() could prevent
use-after-free when local_cleanup() is called twice.

Found by a modified version of syzkaller.

BUG: KASAN: use-after-free in kfree_skb()

Call Trace:
dump_stack_lvl (lib/dump_stack.c:106)
print_address_description.constprop.0.cold (mm/kasan/report.c:306)
kasan_check_range (mm/kasan/generic.c:189)
kfree_skb (net/core/skbuff.c:955)
local_cleanup (net/nfc/llcp_core.c:159)
nfc_llcp_local_put.part.0 (net/nfc/llcp_core.c:172)
nfc_llcp_local_put (net/nfc/llcp_core.c:181)
llcp_sock_destruct (net/nfc/llcp_sock.c:959)
__sk_destruct (net/core/sock.c:2133)
sk_destruct (net/core/sock.c:2181)
__sk_free (net/core/sock.c:2192)
sk_free (net/core/sock.c:2203)
llcp_sock_release (net/nfc/llcp_sock.c:646)
__sock_release (net/socket.c:650)
sock_close (net/socket.c:1365)
__fput (fs/file_table.c:306)
task_work_run (kernel/task_work.c:179)
ptrace_notify (kernel/signal.c:2354)
syscall_exit_to_user_mode_prepare (kernel/entry/common.c:278)
syscall_exit_to_user_mode (kernel/entry/common.c:296)
do_syscall_64 (arch/x86/entry/common.c:86)
entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:106)

Allocated by task 4719:
kasan_save_stack (mm/kasan/common.c:45)
__kasan_slab_alloc (mm/kasan/common.c:325)
slab_post_alloc_hook (mm/slab.h:766)
kmem_cache_alloc_node (mm/slub.c:3497)
__alloc_skb (net/core/skbuff.c:552)
pn533_recv_response (drivers/nfc/pn533/usb.c:65)
__usb_hcd_giveback_urb (drivers/usb/core/hcd.c:1671)
usb_giveback_urb_bh (drivers/usb/core/hcd.c:1704)
tasklet_action_common.isra.0 (kernel/softirq.c:797)
__do_softirq (kernel/softirq.c:571)

Freed by task 1901:
kasan_save_stack (mm/kasan/common.c:45)
kasan_set_track (mm/kasan/common.c:52)
kasan_save_free_info (mm/kasan/genericdd.c:518)
__kasan_slab_free (mm/kasan/common.c:236)
kmem_cache_free (mm/slub.c:3809)
kfree_skbmem (net/core/skbuff.c:874)
kfree_skb (net/core/skbuff.c:931)
local_cleanup (net/nfc/llcp_core.c:159)
nfc_llcp_unregister_device (net/nfc/llcp_core.c:1617)
nfc_unregister_device (net/nfc/core.c:1179)
pn53x_unregister_nfc (drivers/nfc/pn533/pn533.c:2846)
pn533_usb_disconnect (drivers/nfc/pn533/usb.c:579)
usb_unbind_interface (drivers/usb/core/driver.c:458)
device_release_driver_internal (drivers/base/dd.c:1279)
bus_remove_device (drivers/base/bus.c:529)
device_del (drivers/base/core.c:3665)
usb_disable_device (drivers/usb/core/message.c:1420)
usb_disconnect (drivers/usb/core.c:2261)
hub_event (drivers/usb/core/hub.c:5833)
process_one_work (arch/x86/include/asm/jump_label.h:27 include/linux/jump_label.h:212 include/trace/events/workqueue.h:108 kernel/workqueue.c:2281)
worker_thread (include/linux/list.h:282 kernel/workqueue.c:2423)
kthread (kernel/kthread.c:319)
ret_from_fork (arch/x86/entry/entry_64.S:301)
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.9, Last Version (Excluding): 4.14.305
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.272
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4bb4db7f3187c6e3de6b229ffc87cdb30a2d22b6
  - https://git.kernel.org/stable/c/54f7be61584b8ec4c6df405f479495b9397bae4a
  - https://git.kernel.org/stable/c/7f129927feaf7c10b1c38bbce630172e9a08c834
  - https://git.kernel.org/stable/c/a59cdbda3714e11aa3ab579132864c4c8c6d54f9
  - https://git.kernel.org/stable/c/ad1baab3a5c03692d22ce446f38596a126377f6a
  - https://git.kernel.org/stable/c/b09ae26f08aaf2d85f96ea7f90ddd3387f62216f
  - https://git.kernel.org/stable/c/d3605282ec3502ec8847915eb2cf1f340493ff79

------------------------------------------------------------

CVE ID: CVE-2023-53024
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix pointer-leak due to insufficient speculative store bypass mitigation

To mitigate Spectre v4, 2039f26f3aca ("bpf: Fix leakage due to
insufficient speculative store bypass mitigation") inserts lfence
instructions after 1) initializing a stack slot and 2) spilling a
pointer to the stack.

However, this does not cover cases where a stack slot is first
initialized with a pointer (subject to sanitization) but then
overwritten with a scalar (not subject to sanitization because
the slot was already initialized). In this case, the second write
may be subject to speculative store bypass (SSB) creating a
speculative pointer-as-scalar type confusion. This allows the
program to subsequently leak the numerical pointer value using,
for example, a branch-based cache side channel.

To fix this, also sanitize scalars if they write a stack slot
that previously contained a pointer. Assuming that pointer-spills
are only generated by LLVM on register-pressure, the performance
impact on most real-world BPF programs should be small.

The following unprivileged BPF bytecode drafts a minimal exploit
and the mitigation:

  [...]
  // r6 = 0 or 1 (skalar, unknown user input)
  // r7 = accessible ptr for side channel
  // r10 = frame pointer (fp), to be leaked
  //
  r9 = r10 # fp alias to encourage ssb
  *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked
  // lfence added here because of pointer spill to stack.
  //
  // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor
  // for no r9-r10 dependency.
  //
  *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr
  // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID,
  // store may be subject to SSB
  //
  // fix: also add an lfence when the slot contained a ptr
  //
  r8 = *(u64 *)(r9 - 8)
  // r8 = architecturally a scalar, speculatively a ptr
  //
  // leak ptr using branch-based cache side channel:
  r8 &= 1 // choose bit to leak
  if r8 == 0 goto SLOW // no mispredict
  // architecturally dead code if input r6 is 0,
  // only executes speculatively iff ptr bit is 1
  r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast)
SLOW:
  [...]

After running this, the program can time the access to *(r7 + 0) to
determine whether the chosen pointer bit was 0 or 1. Repeat this 64
times to recover the whole address on amd64.

In summary, sanitization can only be skipped if one scalar is
overwritten with another scalar. Scalar-confusion due to speculative
store bypass can not lead to invalid accesses because the pointer
bounds deducted during verification are enforced using branchless
logic. See 979d63d50c0c ("bpf: prevent out of bounds speculation on
pointer arithmetic") for details.

Do not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks}
because speculative leaks are likely unexpected if these were enabled.
For example, leaking the address to a protected log file may be acceptable
while disabling the mitigation might unintentionally leak the address
into the cached-state of a map that is accessible to unprivileged
processes.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01bdcc73dbe7be3ad4d4ee9a59b71e42f461a528
  - https://git.kernel.org/stable/c/81b3374944d201872cfcf82730a7860f8e7c31dd
  - https://git.kernel.org/stable/c/aae109414a57ab4164218f36e2e4a17f027fcaaa
  - https://git.kernel.org/stable/c/b0c89ef025562161242a7c19b213bd6b272e93df
  - https://git.kernel.org/stable/c/da75dec7c6617bddad418159ffebcb133f008262
  - https://git.kernel.org/stable/c/e4f4db47794c9f474b184ee1418f42e6a07412b6

------------------------------------------------------------

CVE ID: CVE-2023-53025
Description: In the Linux kernel, the following vulnerability has been resolved:

NFSD: fix use-after-free in nfsd4_ssc_setup_dul()

If signal_pending() returns true, schedule_timeout() will not be executed,
causing the waiting task to remain in the wait queue.
Fixed by adding a call to finish_wait(), which ensures that the waiting
task will always be removed from the wait queue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0a27dcd5343026ac0cb168ee63304255372b7a36
  - https://git.kernel.org/stable/c/32d5eb95f8f0e362e37c393310b13b9e95404560
  - https://git.kernel.org/stable/c/6ac4c383c39f8f2f955f868d1ad9365c2363e80b
  - https://git.kernel.org/stable/c/e6cf91b7b47ff82b624bdfe2fdcde32bb52e71dd

------------------------------------------------------------

CVE ID: CVE-2023-53026
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/core: Fix ib block iterator counter overflow

When registering a new DMA MR after selecting the best aligned page size
for it, we iterate over the given sglist to split each entry to smaller,
aligned to the selected page size, DMA blocks.

In given circumstances where the sg entry and page size fit certain
sizes and the sg entry is not aligned to the selected page size, the
total size of the aligned pages we need to cover the sg entry is >= 4GB.
Under this circumstances, while iterating page aligned blocks, the
counter responsible for counting how much we advanced from the start of
the sg entry is overflowed because its type is u32 and we pass 4GB in
size. This can lead to an infinite loop inside the iterator function
because the overflow prevents the counter to be larger
than the size of the sg entry.

Fix the presented problem by changing the advancement condition to
eliminate overflow.

Backtrace:
[  192.374329] efa_reg_user_mr_dmabuf
[  192.376783] efa_register_mr
[  192.382579] pgsz_bitmap 0xfffff000 rounddown 0x80000000
[  192.386423] pg_sz [0x80000000] umem_length[0xc0000000]
[  192.392657] start 0x0 length 0xc0000000 params.page_shift 31 params.page_num 3
[  192.399559] hp_cnt[3], pages_in_hp[524288]
[  192.403690] umem->sgt_append.sgt.nents[1]
[  192.407905] number entries: [1], pg_bit: [31]
[  192.411397] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8]
[  192.415601] biter->__sg_advance [665837568] sg_dma_len[3221225472]
[  192.419823] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8]
[  192.423976] biter->__sg_advance [2813321216] sg_dma_len[3221225472]
[  192.428243] biter->__sg_nents [1] biter->__sg [0000000008b0c5d8]
[  192.432397] biter->__sg_advance [665837568] sg_dma_len[3221225472]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 5.4.231
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.166
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.91
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.9
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.2, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0afec5e9cea732cb47014655685a2a47fb180c31
  - https://git.kernel.org/stable/c/362c9489720b31b6aa7491423ba65a4e98aa9838
  - https://git.kernel.org/stable/c/43811d07ea64366af8ec9e168c558ec51440c39e
  - https://git.kernel.org/stable/c/902063a9fea5f8252df392ade746bc9cfd07a5ae
  - https://git.kernel.org/stable/c/d66c1d4178c219b6e7d7a6f714e3e3656faccc36

------------------------------------------------------------

CVE ID: CVE-2023-53028
Description: In the Linux kernel, the following vulnerability has been resolved:

Revert "wifi: mac80211: fix memory leak in ieee80211_if_add()"

This reverts commit 13e5afd3d773c6fc6ca2b89027befaaaa1ea7293.

ieee80211_if_free() is already called from free_netdev(ndev)
because ndev->priv_destructor == ieee80211_if_free

syzbot reported:

general protection fault, probably for non-canonical address 0xdffffc0000000004: 0000 [#1] PREEMPT SMP KASAN
KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027]
CPU: 0 PID: 10041 Comm: syz-executor.0 Not tainted 6.2.0-rc2-syzkaller-00388-g55b98837e37d #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
RIP: 0010:pcpu_get_page_chunk mm/percpu.c:262 [inline]
RIP: 0010:pcpu_chunk_addr_search mm/percpu.c:1619 [inline]
RIP: 0010:free_percpu mm/percpu.c:2271 [inline]
RIP: 0010:free_percpu+0x186/0x10f0 mm/percpu.c:2254
Code: 80 3c 02 00 0f 85 f5 0e 00 00 48 8b 3b 48 01 ef e8 cf b3 0b 00 48 ba 00 00 00 00 00 fc ff df 48 8d 78 20 48 89 f9 48 c1 e9 03 <80> 3c 11 00 0f 85 3b 0e 00 00 48 8b 58 20 48 b8 00 00 00 00 00 fc
RSP: 0018:ffffc90004ba7068 EFLAGS: 00010002
RAX: 0000000000000000 RBX: ffff88823ffe2b80 RCX: 0000000000000004
RDX: dffffc0000000000 RSI: ffffffff81c1f4e7 RDI: 0000000000000020
RBP: ffffe8fffe8fc220 R08: 0000000000000005 R09: 0000000000000000
R10: 0000000000000000 R11: 1ffffffff2179ab2 R12: ffff8880b983d000
R13: 0000000000000003 R14: 0000607f450fc220 R15: ffff88823ffe2988
FS: 00007fcb349de700(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000001b32220000 CR3: 000000004914f000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
netdev_run_todo+0x6bf/0x1100 net/core/dev.c:10352
ieee80211_register_hw+0x2663/0x4040 net/mac80211/main.c:1411
mac80211_hwsim_new_radio+0x2537/0x4d80 drivers/net/wireless/mac80211_hwsim.c:4583
hwsim_new_radio_nl+0xa09/0x10f0 drivers/net/wireless/mac80211_hwsim.c:5176
genl_family_rcv_msg_doit.isra.0+0x1e6/0x2d0 net/netlink/genetlink.c:968
genl_family_rcv_msg net/netlink/genetlink.c:1048 [inline]
genl_rcv_msg+0x4ff/0x7e0 net/netlink/genetlink.c:1065
netlink_rcv_skb+0x165/0x440 net/netlink/af_netlink.c:2564
genl_rcv+0x28/0x40 net/netlink/genetlink.c:1076
netlink_unicast_kernel net/netlink/af_netlink.c:1330 [inline]
netlink_unicast+0x547/0x7f0 net/netlink/af_netlink.c:1356
netlink_sendmsg+0x91b/0xe10 net/netlink/af_netlink.c:1932
sock_sendmsg_nosec net/socket.c:714 [inline]
sock_sendmsg+0xd3/0x120 net/socket.c:734
____sys_sendmsg+0x712/0x8c0 net/socket.c:2476
___sys_sendmsg+0x110/0x1b0 net/socket.c:2530
__sys_sendmsg+0xf7/0x1c0 net/socket.c:2559
do_syscall_x64 arch/x86/entry/common.c:50 [inline]
do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.163, Last Version (Excluding): 5.10.165
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.86, Last Version (Excluding): 5.15.90
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0.16, Last Version (Excluding): 6.1
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.2, Last Version (Excluding): 6.1.8
References:
  - https://git.kernel.org/stable/c/71e5cd1018d345e649e63f74a56c1897f99db7e9
  - https://git.kernel.org/stable/c/80f8a66dede0a4b4e9e846765a97809c6fe49ce5
  - https://git.kernel.org/stable/c/982c8b1e95c088f5d8f65967ec25be66e961401c
  - https://git.kernel.org/stable/c/effecd8d116d3d3a28b4f628e61bba8d318fdfcf

------------------------------------------------------------

CVE ID: CVE-2023-53029
Description: In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: Fix the use of GFP_KERNEL in atomic context on rt

The commit 4af1b64f80fb ("octeontx2-pf: Fix lmtst ID used in aura
free") uses the get/put_cpu() to protect the usage of percpu pointer
in ->aura_freeptr() callback, but it also unnecessarily disable the
preemption for the blockable memory allocation. The commit 87b93b678e95
("octeontx2-pf: Avoid use of GFP_KERNEL in atomic context") tried to
fix these sleep inside atomic warnings. But it only fix the one for
the non-rt kernel. For the rt kernel, we still get the similar warnings
like below.
  BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46
  in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0
  preempt_count: 1, expected: 0
  RCU nest depth: 0, expected: 0
  3 locks held by swapper/0/1:
   #0: ffff800009fc5fe8 (rtnl_mutex){+.+.}-{3:3}, at: rtnl_lock+0x24/0x30
   #1: ffff000100c276c0 (&mbox->lock){+.+.}-{3:3}, at: otx2_init_hw_resources+0x8c/0x3a4
   #2: ffffffbfef6537e0 (&cpu_rcache->lock){+.+.}-{2:2}, at: alloc_iova_fast+0x1ac/0x2ac
  Preemption disabled at:
  [<ffff800008b1908c>] otx2_rq_aura_pool_init+0x14c/0x284
  CPU: 20 PID: 1 Comm: swapper/0 Tainted: G        W          6.2.0-rc3-rt1-yocto-preempt-rt #1
  Hardware name: Marvell OcteonTX CN96XX board (DT)
  Call trace:
   dump_backtrace.part.0+0xe8/0xf4
   show_stack+0x20/0x30
   dump_stack_lvl+0x9c/0xd8
   dump_stack+0x18/0x34
   __might_resched+0x188/0x224
   rt_spin_lock+0x64/0x110
   alloc_iova_fast+0x1ac/0x2ac
   iommu_dma_alloc_iova+0xd4/0x110
   __iommu_dma_map+0x80/0x144
   iommu_dma_map_page+0xe8/0x260
   dma_map_page_attrs+0xb4/0xc0
   __otx2_alloc_rbuf+0x90/0x150
   otx2_rq_aura_pool_init+0x1c8/0x284
   otx2_init_hw_resources+0xe4/0x3a4
   otx2_open+0xf0/0x610
   __dev_open+0x104/0x224
   __dev_change_flags+0x1e4/0x274
   dev_change_flags+0x2c/0x7c
   ic_open_devs+0x124/0x2f8
   ip_auto_config+0x180/0x42c
   do_one_initcall+0x90/0x4dc
   do_basic_setup+0x10c/0x14c
   kernel_init_freeable+0x10c/0x13c
   kernel_init+0x2c/0x140
   ret_from_fork+0x10/0x20

Of course, we can shuffle the get/put_cpu() to only wrap the invocation
of ->aura_freeptr() as what commit 87b93b678e95 does. But there are only
two ->aura_freeptr() callbacks, otx2_aura_freeptr() and
cn10k_aura_freeptr(). There is no usage of perpcu variable in the
otx2_aura_freeptr() at all, so the get/put_cpu() seems redundant to it.
We can move the get/put_cpu() into the corresponding callback which
really has the percpu variable usage and avoid the sprinkling of
get/put_cpu() in several places.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/29e9c67bf3271067735c188e95cf3631ecd64d58
  - https://git.kernel.org/stable/c/55ba18dc62deff5910c0fa64486dea1ff20832ff
  - https://git.kernel.org/stable/c/659518e013d6bd562bb0f1d2d9f99d0ac54720e2

------------------------------------------------------------

CVE ID: CVE-2023-53030
Description: In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: Avoid use of GFP_KERNEL in atomic context

Using GFP_KERNEL in preemption disable context, causing below warning
when CONFIG_DEBUG_ATOMIC_SLEEP is enabled.

[   32.542271] BUG: sleeping function called from invalid context at include/linux/sched/mm.h:274
[   32.550883] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: swapper/0
[   32.558707] preempt_count: 1, expected: 0
[   32.562710] RCU nest depth: 0, expected: 0
[   32.566800] CPU: 3 PID: 1 Comm: swapper/0 Tainted: G        W          6.2.0-rc2-00269-gae9dcb91c606 #7
[   32.576188] Hardware name: Marvell CN106XX board (DT)
[   32.581232] Call trace:
[   32.583670]  dump_backtrace.part.0+0xe0/0xf0
[   32.587937]  show_stack+0x18/0x30
[   32.591245]  dump_stack_lvl+0x68/0x84
[   32.594900]  dump_stack+0x18/0x34
[   32.598206]  __might_resched+0x12c/0x160
[   32.602122]  __might_sleep+0x48/0xa0
[   32.605689]  __kmem_cache_alloc_node+0x2b8/0x2e0
[   32.610301]  __kmalloc+0x58/0x190
[   32.613610]  otx2_sq_aura_pool_init+0x1a8/0x314
[   32.618134]  otx2_open+0x1d4/0x9d0

To avoid use of GFP_ATOMIC for memory allocation, disable preemption
after all memory allocation is done.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1eb57b87f106c90cee6b2a56a10f2e29c7a25f3e
  - https://git.kernel.org/stable/c/2827c4eb429db64befdca11362e2b1c5f524f6ba
  - https://git.kernel.org/stable/c/87b93b678e95c7d93fe6a55b0e0fbda26d8c7760

------------------------------------------------------------

CVE ID: CVE-2023-53031
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/imc-pmu: Fix use of mutex in IRQs disabled section

Current imc-pmu code triggers a WARNING with CONFIG_DEBUG_ATOMIC_SLEEP
and CONFIG_PROVE_LOCKING enabled, while running a thread_imc event.

Command to trigger the warning:
  # perf stat -e thread_imc/CPM_CS_FROM_L4_MEM_X_DPTEG/ sleep 5

   Performance counter stats for 'sleep 5':

                   0      thread_imc/CPM_CS_FROM_L4_MEM_X_DPTEG/

         5.002117947 seconds time elapsed

         0.000131000 seconds user
         0.001063000 seconds sys

Below is snippet of the warning in dmesg:

  BUG: sleeping function called from invalid context at kernel/locking/mutex.c:580
  in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 2869, name: perf-exec
  preempt_count: 2, expected: 0
  4 locks held by perf-exec/2869:
   #0: c00000004325c540 (&sig->cred_guard_mutex){+.+.}-{3:3}, at: bprm_execve+0x64/0xa90
   #1: c00000004325c5d8 (&sig->exec_update_lock){++++}-{3:3}, at: begin_new_exec+0x460/0xef0
   #2: c0000003fa99d4e0 (&cpuctx_lock){-...}-{2:2}, at: perf_event_exec+0x290/0x510
   #3: c000000017ab8418 (&ctx->lock){....}-{2:2}, at: perf_event_exec+0x29c/0x510
  irq event stamp: 4806
  hardirqs last  enabled at (4805): [<c000000000f65b94>] _raw_spin_unlock_irqrestore+0x94/0xd0
  hardirqs last disabled at (4806): [<c0000000003fae44>] perf_event_exec+0x394/0x510
  softirqs last  enabled at (0): [<c00000000013c404>] copy_process+0xc34/0x1ff0
  softirqs last disabled at (0): [<0000000000000000>] 0x0
  CPU: 36 PID: 2869 Comm: perf-exec Not tainted 6.2.0-rc2-00011-g1247637727f2 #61
  Hardware name: 8375-42A POWER9 0x4e1202 opal:v7.0-16-g9b85f7d961 PowerNV
  Call Trace:
    dump_stack_lvl+0x98/0xe0 (unreliable)
    __might_resched+0x2f8/0x310
    __mutex_lock+0x6c/0x13f0
    thread_imc_event_add+0xf4/0x1b0
    event_sched_in+0xe0/0x210
    merge_sched_in+0x1f0/0x600
    visit_groups_merge.isra.92.constprop.166+0x2bc/0x6c0
    ctx_flexible_sched_in+0xcc/0x140
    ctx_sched_in+0x20c/0x2a0
    ctx_resched+0x104/0x1c0
    perf_event_exec+0x340/0x510
    begin_new_exec+0x730/0xef0
    load_elf_binary+0x3f8/0x1e10
  ...
  do not call blocking ops when !TASK_RUNNING; state=2001 set at [<00000000fd63e7cf>] do_nanosleep+0x60/0x1a0
  WARNING: CPU: 36 PID: 2869 at kernel/sched/core.c:9912 __might_sleep+0x9c/0xb0
  CPU: 36 PID: 2869 Comm: sleep Tainted: G        W          6.2.0-rc2-00011-g1247637727f2 #61
  Hardware name: 8375-42A POWER9 0x4e1202 opal:v7.0-16-g9b85f7d961 PowerNV
  NIP:  c000000000194a1c LR: c000000000194a18 CTR: c000000000a78670
  REGS: c00000004d2134e0 TRAP: 0700   Tainted: G        W           (6.2.0-rc2-00011-g1247637727f2)
  MSR:  9000000000021033 <SF,HV,ME,IR,DR,RI,LE>  CR: 48002824  XER: 00000000
  CFAR: c00000000013fb64 IRQMASK: 1

The above warning triggered because the current imc-pmu code uses mutex
lock in interrupt disabled sections. The function mutex_lock()
internally calls __might_resched(), which will check if IRQs are
disabled and in case IRQs are disabled, it will trigger the warning.

Fix the issue by changing the mutex lock to spinlock.

[mpe: Fix comments, trim oops in change log, add reported-by tags]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/424bcb570cb320d1d15238cd4c933522b90f78fa
  - https://git.kernel.org/stable/c/76d588dddc459fefa1da96e0a081a397c5c8e216
  - https://git.kernel.org/stable/c/8cbeb60320ac45a8240b561c8ef466b86c34dedc
  - https://git.kernel.org/stable/c/a90d339f1f66be4a946769b565668e2bd0686dfa
  - https://git.kernel.org/stable/c/d0c6d2a31026102d4738b47a610bed4401b9834f

------------------------------------------------------------

CVE ID: CVE-2023-53032
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: ipset: Fix overflow before widen in the bitmap_ip_create() function.

When first_ip is 0, last_ip is 0xFFFFFFFF, and netmask is 31, the value of
an arithmetic expression 2 << (netmask - mask_bits - 1) is subject
to overflow due to a failure casting operands to a larger data type
before performing the arithmetic.

Note that it's harmless since the value will be checked at the next step.

Found by InfoTeCS on behalf of Linux Verification Center
(linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4e6a70fd840400e3a2e784a6673968a3eb2431c0
  - https://git.kernel.org/stable/c/511cf17b2447fc41cfef8d71936e1fa53e395c1e
  - https://git.kernel.org/stable/c/9ea4b476cea1b7d461d16dda25ca3c7e616e2d15
  - https://git.kernel.org/stable/c/dfd834ccc1b88bbbab81b9046a3a539dd0c2d14f
  - https://git.kernel.org/stable/c/e137d9bb26bd85ce07323a38e38ceb0b160db841
  - https://git.kernel.org/stable/c/e88865876d47c790be0d5e23973499d75d034364
  - https://git.kernel.org/stable/c/feefb33eefa166fc3e0fd17547b0bc0cb3baced9

------------------------------------------------------------

CVE ID: CVE-2023-53033
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nft_payload: incorrect arithmetics when fetching VLAN header bits

If the offset + length goes over the ethernet + vlan header, then the
length is adjusted to copy the bytes that are within the boundaries of
the vlan_ethhdr scratchpad area. The remaining bytes beyond ethernet +
vlan header are copied directly from the skbuff data area.

Fix incorrect arithmetic operator: subtract, not add, the size of the
vlan header in case of double-tagged packets to adjust the length
accordingly to address CVE-2023-0179.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/550efeff989b041f3746118c0ddd863c39ddc1aa
  - https://git.kernel.org/stable/c/696e1a48b1a1b01edad542a1ef293665864a4dd0
  - https://git.kernel.org/stable/c/76ef74d4a379faa451003621a84e3498044e7aa3
  - https://git.kernel.org/stable/c/a8acfe2c6fb99f9375a9325807a179cd8c32e6e3

------------------------------------------------------------

CVE ID: CVE-2025-0986
Description: IBM PowerVM Hypervisor FW1050.00 through FW1050.30 and FW1060.00 through FW1060.20 could allow a local user, under certain Linux processor combability mode configurations, to cause undetected data loss or errors when performing gzip compression using HW acceleration.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:N/I:L/A:L
CPEs:
  - No CPE data available.
References:
  - https://www.ibm.com/support/pages/node/7229349

------------------------------------------------------------

CVE ID: CVE-2023-0881
Description: Running DDoS on tcp port 22 will trigger a kernel crash. This issue is introduced by the backport of a commit regarding nft_lookup without the subsequent fixes that were introduced after this commit. The resolution of this CVE introduces those commits to the linux-bluefield package.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.5
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://bugs.launchpad.net/ubuntu/+source/linux-bluefield/+bug/2006397

------------------------------------------------------------

CVE ID: CVE-2025-30095
Description: VyOS 1.3 through 1.5 (fixed in 1.4.2) or any Debian-based system using dropbear in combination with live-build has the same Dropbear private host keys across different installations. Thus, an attacker can conduct active man-in-the-middle attacks against SSH connections if Dropbear is enabled as the SSH daemon. I n VyOS, this is not the default configuration for the system SSH daemon, but is for the console service. To mitigate this, one can run "rm -f /etc/dropbear/*key*" and/or "rm -f /etc/dropbear-initramfs/*key*" and then dropbearkey -t rsa -s 4096 -f /etc/dropbear_rsa_host_key and reload the service or reboot the system before using Dropbear as the SSH daemon (this clears out all keys mistakenly built into the release image) or update to the latest version of VyOS 1.4 or 1.5. Note that this vulnerability is not unique to VyOS and may appear in any Debian-based Linux distribution that uses Dropbear in combination with live-build, which has a safeguard against this behavior in OpenSSH but no equivalent one for Dropbear.
Severity:
  - CVSS Version: 3.1
  - Base Score: 9.0
  - Base Severity: CRITICAL
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://blog.vyos.io/vyos-project-march-2025-update
  - https://blog.vyos.io/vyos-stream-1.5-2025-q1
  - https://github.com/vyos/
  - https://vyos.dev/T7217
  - https://vyos.net/get/stream/#1.5-2025-Q1

------------------------------------------------------------

CVE ID: CVE-2025-21893
Description: In the Linux kernel, the following vulnerability has been resolved:

keys: Fix UAF in key_put()

Once a key's reference count has been reduced to 0, the garbage collector
thread may destroy it at any time and so key_put() is not allowed to touch
the key after that point.  The most key_put() is normally allowed to do is
to touch key_gc_work as that's a static global variable.

However, in an effort to speed up the reclamation of quota, this is now
done in key_put() once the key's usage is reduced to 0 - but now the code
is looking at the key after the deadline, which is forbidden.

Fix this by using a flag to indicate that a key can be gc'd now rather than
looking at the key's refcount in the garbage collector.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6afe2ea2daec156bd94ad2c5a6f4f4c48240dcd3
  - https://git.kernel.org/stable/c/75845c6c1a64483e9985302793dbf0dfa5f71e32
  - https://git.kernel.org/stable/c/f6a3cf833188e897c97028cd7b926e3f2cb1a8c0

------------------------------------------------------------

CVE ID: CVE-2025-3051
Description: Linux::Statm::Tiny for Perl before 0.0701 allows untrusted code from the current working directory ('.') to be loaded similar to CVE-2016-1238.

If an attacker can place a malicious file in current working directory, it may be loaded instead of the intended file, potentially leading to arbitrary code execution.

Linux::Statm::Tiny uses Mite to produce the affected code section due to CVE-2025-30672
Severity:
  - CVSS Version: 3.1
  - Base Score: 6.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N
CPEs:
  - No CPE data available.
References:
  - https://blogs.perl.org/users/todd_rinaldo/2016/11/what-happened-to-dot-in-inc.html
  - https://metacpan.org/release/RRWO/Linux-Statm-Tiny-0.0700/source/lib/Linux/Statm/Tiny/Mite.pm#L82
  - https://metacpan.org/release/RRWO/Linux-Statm-Tiny-0.0701/changes

------------------------------------------------------------

CVE ID: CVE-2025-3085
Description: A MongoDB server under specific conditions running on Linux with TLS and CRL revocation status checking enabled, fails to check the revocation status of the intermediate certificates in the peer's certificate chain. In cases of MONGODB-X509, which is not enabled by default, this may lead to improper authentication. This issue may also affect intra-cluster authentication. This issue affects MongoDB Server v5.0 versions prior to 5.0.31, MongoDB Server v6.0 versions prior to 6.0.20, MongoDB Server v7.0 versions prior to 7.0.16 and MongoDB Server v8.0 versions prior to 8.0.4.
Required Configuration : MongoDB Server must be running on Linux Operating Systems and CRL revocation status checking must be enabled
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://jira.mongodb.org/browse/SERVER-95445

------------------------------------------------------------

CVE ID: CVE-2025-21894
Description: In the Linux kernel, the following vulnerability has been resolved:

net: enetc: VFs do not support HWTSTAMP_TX_ONESTEP_SYNC

Actually ENETC VFs do not support HWTSTAMP_TX_ONESTEP_SYNC because only
ENETC PF can access PMa_SINGLE_STEP registers. And there will be a crash
if VFs are used to test one-step timestamp, the crash log as follows.

[  129.110909] Unable to handle kernel paging request at virtual address 00000000000080c0
[  129.287769] Call trace:
[  129.290219]  enetc_port_mac_wr+0x30/0xec (P)
[  129.294504]  enetc_start_xmit+0xda4/0xe74
[  129.298525]  enetc_xmit+0x70/0xec
[  129.301848]  dev_hard_start_xmit+0x98/0x118
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1748531839298ab7be682155f6cd98ae04773e6a
  - https://git.kernel.org/stable/c/3d9634211121700568d0e3635ebdd5df06d20440
  - https://git.kernel.org/stable/c/8c393efd7420cc994864d059fcc6219bfd7cb840
  - https://git.kernel.org/stable/c/a562d0c4a893eae3ea51d512c4d90ab858a6b7ec

------------------------------------------------------------

CVE ID: CVE-2025-21895
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/core: Order the PMU list to fix warning about unordered pmu_ctx_list

Syskaller triggers a warning due to prev_epc->pmu != next_epc->pmu in
perf_event_swap_task_ctx_data(). vmcore shows that two lists have the same
perf_event_pmu_context, but not in the same order.

The problem is that the order of pmu_ctx_list for the parent is impacted by
the time when an event/PMU is added. While the order for a child is
impacted by the event order in the pinned_groups and flexible_groups. So
the order of pmu_ctx_list in the parent and child may be different.

To fix this problem, insert the perf_event_pmu_context to its proper place
after iteration of the pmu_ctx_list.

The follow testcase can trigger above warning:

 # perf record -e cycles --call-graph lbr -- taskset -c 3 ./a.out &
 # perf stat -e cpu-clock,cs -p xxx // xxx is the pid of a.out

 test.c

 void main() {
        int count = 0;
        pid_t pid;

        printf("%d running\n", getpid());
        sleep(30);
        printf("running\n");

        pid = fork();
        if (pid == -1) {
                printf("fork error\n");
                return;
        }
        if (pid == 0) {
                while (1) {
                        count++;
                }
        } else {
                while (1) {
                        count++;
                }
        }
 }

The testcase first opens an LBR event, so it will allocate task_ctx_data,
and then open tracepoint and software events, so the parent context will
have 3 different perf_event_pmu_contexts. On inheritance, child ctx will
insert the perf_event_pmu_context in another order and the warning will
trigger.

[ mingo: Tidied up the changelog. ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2016066c66192a99d9e0ebf433789c490a6785a2
  - https://git.kernel.org/stable/c/3e812a70732d84b7873cea61a7f6349b9a9dcbf5
  - https://git.kernel.org/stable/c/7d582eb6e4e100959ba07083d7563453c8c2a343
  - https://git.kernel.org/stable/c/f0c3971405cef6892844016aa710121a02da3a23

------------------------------------------------------------

CVE ID: CVE-2025-21896
Description: In the Linux kernel, the following vulnerability has been resolved:

fuse: revert back to __readahead_folio() for readahead

In commit 3eab9d7bc2f4 ("fuse: convert readahead to use folios"), the
logic was converted to using the new folio readahead code, which drops
the reference on the folio once it is locked, using an inferred
reference on the folio. Previously we held a reference on the folio for
the entire duration of the readpages call.

This is fine, however for the case for splice pipe responses where we
will remove the old folio and splice in the new folio (see
fuse_try_move_page()), we assume that there is a reference held on the
folio for ap->folios, which is no longer the case.

To fix this, revert back to __readahead_folio() which allows us to hold
the reference on the folio for the duration of readpages until either we
drop the reference ourselves in fuse_readpages_end() or the reference is
dropped after it's replaced in the page cache in the splice case.
This will fix the UAF bug that was reported.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c67c37e1710b2a8f61c8a02db95a51fe577e2c1
  - https://git.kernel.org/stable/c/60db11f1b7fba4a66b117ea998d965818784a98d

------------------------------------------------------------

CVE ID: CVE-2025-21897
Description: In the Linux kernel, the following vulnerability has been resolved:

sched_ext: Fix pick_task_scx() picking non-queued tasks when it's called without balance()

a6250aa251ea ("sched_ext: Handle cases where pick_task_scx() is called
without preceding balance_scx()") added a workaround to handle the cases
where pick_task_scx() is called without prececing balance_scx() which is due
to a fair class bug where pick_taks_fair() may return NULL after a true
return from balance_fair().

The workaround detects when pick_task_scx() is called without preceding
balance_scx() and emulates SCX_RQ_BAL_KEEP and triggers kicking to avoid
stalling. Unfortunately, the workaround code was testing whether @prev was
on SCX to decide whether to keep the task running. This is incorrect as the
task may be on SCX but no longer runnable.

This could lead to a non-runnable task to be returned from pick_task_scx()
which cause interesting confusions and failures. e.g. A common failure mode
is the task ending up with (!on_rq && on_cpu) state which can cause
potential wakers to busy loop, which can easily lead to deadlocks.

Fix it by testing whether @prev has SCX_TASK_QUEUED set. This makes
@prev_on_scx only used in one place. Open code the usage and improve the
comment while at it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5324c459f90d16b0c43a78b494c598915d782b7a
  - https://git.kernel.org/stable/c/8fef0a3b17bb258130a4fcbcb5addf94b25e9ec5
  - https://git.kernel.org/stable/c/de60a31cb0bcacfaf9487546eac5e70e0a9c66d7

------------------------------------------------------------

CVE ID: CVE-2025-21898
Description: In the Linux kernel, the following vulnerability has been resolved:

ftrace: Avoid potential division by zero in function_stat_show()

Check whether denominator expression x * (x - 1) * 1000 mod {2^32, 2^64}
produce zero and skip stddev computation in that case.

For now don't care about rec->counter * rec->counter overflow because
rec->time * rec->time overflow will likely happen earlier.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.16.83, Last Version (Excluding): 3.17
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.206, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.209, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.163, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.94, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.9, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.130
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.81
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.18
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.6
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3d738b53ed6cddb68e68c9874520a4bf846163b5
  - https://git.kernel.org/stable/c/5b3d32f607f0478b414b16516cf27f9170cf66c8
  - https://git.kernel.org/stable/c/746cc474a95473591853927b3a9792a2d671155b
  - https://git.kernel.org/stable/c/992775227843c9376773784b8b362add44592ad7
  - https://git.kernel.org/stable/c/9cdac46fa7e854e587eb5f393fe491b6d7a9bdf6
  - https://git.kernel.org/stable/c/a1a7eb89ca0b89dc1c326eeee2596f263291aca3
  - https://git.kernel.org/stable/c/ca381f60a3bb7cfaa618d73ca411610bd7fc3149
  - https://git.kernel.org/stable/c/f58a3f8e284d0bdf94164a8e61cd4e70d337a1a3

------------------------------------------------------------

CVE ID: CVE-2025-21899
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix bad hist from corrupting named_triggers list

The following commands causes a crash:

 ~# cd /sys/kernel/tracing/events/rcu/rcu_callback
 ~# echo 'hist:name=bad:keys=common_pid:onmax(bogus).save(common_pid)' > trigger
 bash: echo: write error: Invalid argument
 ~# echo 'hist:name=bad:keys=common_pid' > trigger

Because the following occurs:

event_trigger_write() {
  trigger_process_regex() {
    event_hist_trigger_parse() {

      data = event_trigger_alloc(..);

      event_trigger_register(.., data) {
        cmd_ops->reg(.., data, ..) [hist_register_trigger()] {
          data->ops->init() [event_hist_trigger_init()] {
            save_named_trigger(name, data) {
              list_add(&data->named_list, &named_triggers);
            }
          }
        }
      }

      ret = create_actions(); (return -EINVAL)
      if (ret)
        goto out_unreg;
[..]
      ret = hist_trigger_enable(data, ...) {
        list_add_tail_rcu(&data->list, &file->triggers); <<<---- SKIPPED!!! (this is important!)
[..]
 out_unreg:
      event_hist_unregister(.., data) {
        cmd_ops->unreg(.., data, ..) [hist_unregister_trigger()] {
          list_for_each_entry(iter, &file->triggers, list) {
            if (!hist_trigger_match(data, iter, named_data, false))   <- never matches
                continue;
            [..]
            test = iter;
          }
          if (test && test->ops->free) <<<-- test is NULL

            test->ops->free(test) [event_hist_trigger_free()] {
              [..]
              if (data->name)
                del_named_trigger(data) {
                  list_del(&data->named_list);  <<<<-- NEVER gets removed!
                }
              }
           }
         }

         [..]
         kfree(data); <<<-- frees item but it is still on list

The next time a hist with name is registered, it causes an u-a-f bug and
the kernel can crash.

Move the code around such that if event_trigger_register() succeeds, the
next thing called is hist_trigger_enable() which adds it to the list.

A bunch of actions is called if get_named_trigger_data() returns false.
But that doesn't need to be called after event_trigger_register(), so it
can be moved up, allowing event_trigger_register() to be called just
before hist_trigger_enable() keeping them together and allowing the
file->triggers to be properly populated.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/435d2964af815aae456db554c62963b4515f19d0
  - https://git.kernel.org/stable/c/43b254d46c740bf9dbe65709afa021dd726dfa99
  - https://git.kernel.org/stable/c/5ae1b18f05ee2b849dc03b6c15d7da0c1c6efa77
  - https://git.kernel.org/stable/c/6f86bdeab633a56d5c6dccf1a2c5989b6a5e323e
  - https://git.kernel.org/stable/c/f1ae50cfb818ce1ac7a674406dfadb7653e2552d

------------------------------------------------------------

CVE ID: CVE-2025-21900
Description: In the Linux kernel, the following vulnerability has been resolved:

NFSv4: Fix a deadlock when recovering state on a sillyrenamed file

If the file is sillyrenamed, and slated for delete on close, it is
possible for a server reboot to triggeer an open reclaim, with can again
race with the application call to close(). When that happens, the call
to put_nfs_open_context() can trigger a synchronous delegreturn call
which deadlocks because it is not marked as privileged.

Instead, ensure that the call to nfs4_inode_return_delegation_on_close()
catches the delegreturn, and schedules it asynchronously.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.18
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.6
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4fe4ae6c2e01d028856b73b6328b12b8945df871
  - https://git.kernel.org/stable/c/8f8df955f078e1a023ee55161935000a67651f38
  - https://git.kernel.org/stable/c/f41a60bc43e7abbc636fee78bed0d74c31e738b0

------------------------------------------------------------

CVE ID: CVE-2025-21901
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/bnxt_re: Add sanity checks on rdev validity

There is a possibility that ulp_irq_stop and ulp_irq_start
callbacks will be called when the device is in detached state.
This can cause a crash due to NULL pointer dereference as
the rdev is already freed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.18
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.6
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/8cb0eef46d70a99c88c26a1addb7fd955242e0e6
  - https://git.kernel.org/stable/c/aed1bc673907e3df372b317c10ff2f3582f8bf1a
  - https://git.kernel.org/stable/c/f0df225d12fcb049429fb5bf5122afe143c2dd15

------------------------------------------------------------

CVE ID: CVE-2025-21902
Description: In the Linux kernel, the following vulnerability has been resolved:

acpi: typec: ucsi: Introduce a ->poll_cci method

For the ACPI backend of UCSI the UCSI "registers" are just a memory copy
of the register values in an opregion. The ACPI implementation in the
BIOS ensures that the opregion contents are synced to the embedded
controller and it ensures that the registers (in particular CCI) are
synced back to the opregion on notifications. While there is an ACPI call
that syncs the actual registers to the opregion there is rarely a need to
do this and on some ACPI implementations it actually breaks in various
interesting ways.

The only reason to force a sync from the embedded controller is to poll
CCI while notifications are disabled. Only the ucsi core knows if this
is the case and guessing based on the current command is suboptimal, i.e.
leading to the following spurious assertion splat:

WARNING: CPU: 3 PID: 76 at drivers/usb/typec/ucsi/ucsi.c:1388 ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi]
CPU: 3 UID: 0 PID: 76 Comm: kworker/3:0 Not tainted 6.12.11-200.fc41.x86_64 #1
Hardware name: LENOVO 21D0/LNVNB161216, BIOS J6CN45WW 03/17/2023
Workqueue: events_long ucsi_init_work [typec_ucsi]
RIP: 0010:ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi]
Call Trace:
 <TASK>
 ucsi_init_work+0x3c/0xac0 [typec_ucsi]
 process_one_work+0x179/0x330
 worker_thread+0x252/0x390
 kthread+0xd2/0x100
 ret_from_fork+0x34/0x50
 ret_from_fork_asm+0x1a/0x30
 </TASK>

Thus introduce a ->poll_cci() method that works like ->read_cci() with an
additional forced sync and document that this should be used when polling
with notifications disabled. For all other backends that presumably don't
have this issue use the same implementation for both methods.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/012b98cdb54c7d47743ee7fc402fa23f2d90529a
  - https://git.kernel.org/stable/c/1aec5c9066965ac0984e385bbc31455ae31cbffc
  - https://git.kernel.org/stable/c/976e7e9bdc7719a023a4ecccd2e3daec9ab20a40

------------------------------------------------------------

CVE ID: CVE-2025-21903
Description: In the Linux kernel, the following vulnerability has been resolved:

mctp i3c: handle NULL header address

daddr can be NULL if there is no neighbour table entry present,
in that case the tx packet should be dropped.

saddr will usually be set by MCTP core, but check for NULL in case a
packet is transmitted by a different protocol.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/740bf9c9b715cc327d34b1e2d4ee79fcd4c47a56
  - https://git.kernel.org/stable/c/cf7ee25e70c6edfac4553d6b671e8b19db1d9573
  - https://git.kernel.org/stable/c/d8be54c35aee29d96d1350b1b6f153be4da37c07

------------------------------------------------------------

CVE ID: CVE-2025-21904
Description: In the Linux kernel, the following vulnerability has been resolved:

caif_virtio: fix wrong pointer check in cfv_probe()

del_vqs() frees virtqueues, therefore cfv->vq_tx pointer should be checked
for NULL before calling it, not cfv->vdev. Also the current implementation
is redundant because the pointer cfv->vdev is dereferenced before it is
checked for NULL.

Fix this by checking cfv->vq_tx for NULL instead of cfv->vdev before
calling del_vqs().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.10, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/29e0cd296c87240278e2f7ea4cf3f496b60c03af
  - https://git.kernel.org/stable/c/56cddf71cce3b15b078e937fadab29962b6f6643
  - https://git.kernel.org/stable/c/597c27e5f04cb50e56cc9aeda75d3e42b6b89c3e
  - https://git.kernel.org/stable/c/7b5fe58959822e6cfa884327cabba6be3b01883d
  - https://git.kernel.org/stable/c/8e4e08ca4cc634b337bb74bc9a70758fdeda0bcb
  - https://git.kernel.org/stable/c/90d302619ee7ce5ed0c69c29c290bdccfde66418
  - https://git.kernel.org/stable/c/990fff6980d0c1693d60a812f58dbf93eab0473f
  - https://git.kernel.org/stable/c/a466fd7e9fafd975949e5945e2f70c33a94b1a70

------------------------------------------------------------

CVE ID: CVE-2025-21905
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: limit printed string from FW file

There's no guarantee here that the file is always with a
NUL-termination, so reading the string may read beyond the
end of the TLV. If that's the last TLV in the file, it can
perhaps even read beyond the end of the file buffer.

Fix that by limiting the print format to the size of the
buffer we have.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/38f0d398b6d7640d223db69df022c4a232f24774
  - https://git.kernel.org/stable/c/47616b82f2d42ea2060334746fed9a2988d845c9
  - https://git.kernel.org/stable/c/59cdda202829d1d6a095d233386870a59aff986f
  - https://git.kernel.org/stable/c/88ed69f924638c7503644e1f8eed1e976f3ffa7a
  - https://git.kernel.org/stable/c/b02f8d5a71c8571ccf77f285737c566db73ef5e5
  - https://git.kernel.org/stable/c/c0e626f2b2390472afac52dfe72b29daf9ed8e1d
  - https://git.kernel.org/stable/c/e0dc2c1bef722cbf16ae557690861e5f91208129
  - https://git.kernel.org/stable/c/f265e6031d0bc4fc40c4619cb42466722b46eaa9

------------------------------------------------------------

CVE ID: CVE-2025-21906
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: clean up ROC on failure

If the firmware fails to start the session protection, then we
do call iwl_mvm_roc_finished() here, but that won't do anything
at all because IWL_MVM_STATUS_ROC_P2P_RUNNING was never set.
Set IWL_MVM_STATUS_ROC_P2P_RUNNING in the failure/stop path.
If it started successfully before, it's already set, so that
doesn't matter, and if it didn't start it needs to be set to
clean up.

Not doing so will lead to a WARN_ON() later on a fresh remain-
on-channel, since the link is already active when activated as
it was never deactivated.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a88c18409b5d69f426d5acc583c053eac71756a3
  - https://git.kernel.org/stable/c/d1a12fcb9051bbf38b2e5af310ffb102a0fab6f9
  - https://git.kernel.org/stable/c/f9751163bffd3fe60794929829f810968c6de73d

------------------------------------------------------------

CVE ID: CVE-2025-21907
Description: In the Linux kernel, the following vulnerability has been resolved:

mm: memory-failure: update ttu flag inside unmap_poisoned_folio

Patch series "mm: memory_failure: unmap poisoned folio during migrate
properly", v3.

Fix two bugs during folio migration if the folio is poisoned.


This patch (of 3):

Commit 6da6b1d4a7df ("mm/hwpoison: convert TTU_IGNORE_HWPOISON to
TTU_HWPOISON") introduce TTU_HWPOISON to replace TTU_IGNORE_HWPOISON in
order to stop send SIGBUS signal when accessing an error page after a
memory error on a clean folio.  However during page migration, anon folio
must be set with TTU_HWPOISON during unmap_*().  For pagecache we need
some policy just like the one in hwpoison_user_mappings to set this flag. 
So move this policy from hwpoison_user_mappings to unmap_poisoned_folio to
handle this warning properly.

Warning will be produced during unamp poison folio with the following log:

  ------------[ cut here ]------------
  WARNING: CPU: 1 PID: 365 at mm/rmap.c:1847 try_to_unmap_one+0x8fc/0xd3c
  Modules linked in:
  CPU: 1 UID: 0 PID: 365 Comm: bash Tainted: G        W          6.13.0-rc1-00018-gacdb4bbda7ab #42
  Tainted: [W]=WARN
  Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015
  pstate: 20400005 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : try_to_unmap_one+0x8fc/0xd3c
  lr : try_to_unmap_one+0x3dc/0xd3c
  Call trace:
   try_to_unmap_one+0x8fc/0xd3c (P)
   try_to_unmap_one+0x3dc/0xd3c (L)
   rmap_walk_anon+0xdc/0x1f8
   rmap_walk+0x3c/0x58
   try_to_unmap+0x88/0x90
   unmap_poisoned_folio+0x30/0xa8
   do_migrate_range+0x4a0/0x568
   offline_pages+0x5a4/0x670
   memory_block_action+0x17c/0x374
   memory_subsys_offline+0x3c/0x78
   device_offline+0xa4/0xd0
   state_store+0x8c/0xf0
   dev_attr_store+0x18/0x2c
   sysfs_kf_write+0x44/0x54
   kernfs_fop_write_iter+0x118/0x1a8
   vfs_write+0x3a8/0x4bc
   ksys_write+0x6c/0xf8
   __arm64_sys_write+0x1c/0x28
   invoke_syscall+0x44/0x100
   el0_svc_common.constprop.0+0x40/0xe0
   do_el0_svc+0x1c/0x28
   el0_svc+0x30/0xd0
   el0t_64_sync_handler+0xc8/0xcc
   el0t_64_sync+0x198/0x19c
  ---[ end trace 0000000000000000 ]---

[mawupeng1@huawei.com: unmap_poisoned_folio(): remove shadowed local `mapping', per Miaohe]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/425c12c076e6fc6b2cb04b9f960319d31dcabc76
  - https://git.kernel.org/stable/c/608cc7deb428f1122ed426060233622ebf667b6e
  - https://git.kernel.org/stable/c/b81679b1633aa43c0d973adfa816d78c1ed0d032

------------------------------------------------------------

CVE ID: CVE-2025-21908
Description: In the Linux kernel, the following vulnerability has been resolved:

NFS: fix nfs_release_folio() to not deadlock via kcompactd writeback

Add PF_KCOMPACTD flag and current_is_kcompactd() helper to check for it so
nfs_release_folio() can skip calling nfs_wb_folio() from kcompactd.

Otherwise NFS can deadlock waiting for kcompactd enduced writeback which
recurses back to NFS (which triggers writeback to NFSD via NFS loopback
mount on the same host, NFSD blocks waiting for XFS's call to
__filemap_get_folio):

6070.550357] INFO: task kcompactd0:58 blocked for more than 4435 seconds.

{---
[58] "kcompactd0"
[<0>] folio_wait_bit+0xe8/0x200
[<0>] folio_wait_writeback+0x2b/0x80
[<0>] nfs_wb_folio+0x80/0x1b0 [nfs]
[<0>] nfs_release_folio+0x68/0x130 [nfs]
[<0>] split_huge_page_to_list_to_order+0x362/0x840
[<0>] migrate_pages_batch+0x43d/0xb90
[<0>] migrate_pages_sync+0x9a/0x240
[<0>] migrate_pages+0x93c/0x9f0
[<0>] compact_zone+0x8e2/0x1030
[<0>] compact_node+0xdb/0x120
[<0>] kcompactd+0x121/0x2e0
[<0>] kthread+0xcf/0x100
[<0>] ret_from_fork+0x31/0x40
[<0>] ret_from_fork_asm+0x1a/0x30
---}

[akpm@linux-foundation.org: fix build]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.3, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5ae31c54cff745832b9bd5b32e71f3d1b607cd1e
  - https://git.kernel.org/stable/c/8253ff29edcb429a9a6c75710941c6a16a9a34b1
  - https://git.kernel.org/stable/c/ab0727d6e2196682351c25c1dd112136f6991f11
  - https://git.kernel.org/stable/c/ce6d9c1c2b5cc785016faa11b48b6cd317eb367e

------------------------------------------------------------

CVE ID: CVE-2025-21909
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: nl80211: reject cooked mode if it is set along with other flags

It is possible to set both MONITOR_FLAG_COOK_FRAMES and MONITOR_FLAG_ACTIVE
flags simultaneously on the same monitor interface from the userspace. This
causes a sub-interface to be created with no IEEE80211_SDATA_IN_DRIVER bit
set because the monitor interface is in the cooked state and it takes
precedence over all other states. When the interface is then being deleted
the kernel calls WARN_ONCE() from check_sdata_in_driver() because of missing
that bit.

Fix this by rejecting MONITOR_FLAG_COOK_FRAMES if it is set along with
other flags.

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/236f41ca728f23210b31ed2d1d8a6df575a4b2d6
  - https://git.kernel.org/stable/c/351eb7ac53ff1cd94d893c0c4534ced2f36ae7d7
  - https://git.kernel.org/stable/c/49f27f29446a5bfe633dd2cc0cfebd48a1a5e77f
  - https://git.kernel.org/stable/c/521e55c2b0d6028861ac0a2d06aa57bb0e3ac486
  - https://git.kernel.org/stable/c/5ea856d93794c4afa5542defd8c61f2708dc245a
  - https://git.kernel.org/stable/c/ac4860141300581d3e2f6c6dafa37220f7ea9f65
  - https://git.kernel.org/stable/c/cd1bdcb77fdc03c253137e55bae10551b3481461
  - https://git.kernel.org/stable/c/ebebbb0eded2ed9a1abfa31962f6fb699e6abce7

------------------------------------------------------------

CVE ID: CVE-2025-21910
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: regulatory: improve invalid hints checking

Syzbot keeps reporting an issue [1] that occurs when erroneous symbols
sent from userspace get through into user_alpha2[] via
regulatory_hint_user() call. Such invalid regulatory hints should be
rejected.

While a sanity check from commit 47caf685a685 ("cfg80211: regulatory:
reject invalid hints") looks to be enough to deter these very cases,
there is a way to get around it due to 2 reasons.

1) The way isalpha() works, symbols other than latin lower and
upper letters may be used to determine a country/domain.
For instance, greek letters will also be considered upper/lower
letters and for such characters isalpha() will return true as well.
However, ISO-3166-1 alpha2 codes should only hold latin
characters.

2) While processing a user regulatory request, between
reg_process_hint_user() and regulatory_hint_user() there happens to
be a call to queue_regulatory_request() which modifies letters in
request->alpha2[] with toupper(). This works fine for latin symbols,
less so for weird letter characters from the second part of _ctype[].

Syzbot triggers a warning in is_user_regdom_saved() by first sending
over an unexpected non-latin letter that gets malformed by toupper()
into a character that ends up failing isalpha() check.

Prevent this by enhancing is_an_alpha2() to ensure that incoming
symbols are latin letters and nothing else.

[1] Syzbot report:
------------[ cut here ]------------
Unexpected user alpha2: A�
WARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 is_user_regdom_saved net/wireless/reg.c:440 [inline]
WARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 restore_alpha2 net/wireless/reg.c:3424 [inline]
WARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 restore_regulatory_settings+0x3c0/0x1e50 net/wireless/reg.c:3516
Modules linked in:
CPU: 1 UID: 0 PID: 964 Comm: kworker/1:2 Not tainted 6.12.0-rc5-syzkaller-00044-gc1e939a21eb1 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Workqueue: events_power_efficient crda_timeout_work
RIP: 0010:is_user_regdom_saved net/wireless/reg.c:440 [inline]
RIP: 0010:restore_alpha2 net/wireless/reg.c:3424 [inline]
RIP: 0010:restore_regulatory_settings+0x3c0/0x1e50 net/wireless/reg.c:3516
...
Call Trace:
 <TASK>
 crda_timeout_work+0x27/0x50 net/wireless/reg.c:542
 process_one_work kernel/workqueue.c:3229 [inline]
 process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310
 worker_thread+0x870/0xd30 kernel/workqueue.c:3391
 kthread+0x2f2/0x390 kernel/kthread.c:389
 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/17aa34c84867f6cd181a5743e1c647e7766962a6
  - https://git.kernel.org/stable/c/35ef07112b61b06eb30683a6563c9f6378c02476
  - https://git.kernel.org/stable/c/59b348be7597c4a9903cb003c69e37df20c04a30
  - https://git.kernel.org/stable/c/62b1a9bbfebba4b4c2bb6c1ede9ef7ecee7a9ff6
  - https://git.kernel.org/stable/c/6a5e3b23054cee3b92683d1467e3fa83921f5622
  - https://git.kernel.org/stable/c/be7c5f00aa7f1344293e4d48d0e12be83a2f223d
  - https://git.kernel.org/stable/c/da3f599517ef2ea851208df3229d07728d238dc5
  - https://git.kernel.org/stable/c/f4112cb477c727a65787a4065a75ca593bb5b2f4

------------------------------------------------------------

CVE ID: CVE-2025-21911
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/imagination: avoid deadlock on fence release

Do scheduler queue fence release processing on a workqueue, rather
than in the release function itself.

Fixes deadlock issues such as the following:

[  607.400437] ============================================
[  607.405755] WARNING: possible recursive locking detected
[  607.415500] --------------------------------------------
[  607.420817] weston:zfq0/24149 is trying to acquire lock:
[  607.426131] ffff000017d041a0 (reservation_ww_class_mutex){+.+.}-{3:3}, at: pvr_gem_object_vunmap+0x40/0xc0 [powervr]
[  607.436728]
               but task is already holding lock:
[  607.442554] ffff000017d105a0 (reservation_ww_class_mutex){+.+.}-{3:3}, at: dma_buf_ioctl+0x250/0x554
[  607.451727]
               other info that might help us debug this:
[  607.458245]  Possible unsafe locking scenario:

[  607.464155]        CPU0
[  607.466601]        ----
[  607.469044]   lock(reservation_ww_class_mutex);
[  607.473584]   lock(reservation_ww_class_mutex);
[  607.478114]
                *** DEADLOCK ***
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/9bd8b8d34cf4efba18766d64f817c819ed1bbde7
  - https://git.kernel.org/stable/c/d993ae7360923efd6ade43a32043459a121c28c1
  - https://git.kernel.org/stable/c/df1a1ed5e1bdd9cc13148e0e5549f5ebcf76cf13

------------------------------------------------------------

CVE ID: CVE-2025-21912
Description: In the Linux kernel, the following vulnerability has been resolved:

gpio: rcar: Use raw_spinlock to protect register access

Use raw_spinlock in order to fix spurious messages about invalid context
when spinlock debugging is enabled. The lock is only used to serialize
register access.

    [    4.239592] =============================
    [    4.239595] [ BUG: Invalid wait context ]
    [    4.239599] 6.13.0-rc7-arm64-renesas-05496-gd088502a519f #35 Not tainted
    [    4.239603] -----------------------------
    [    4.239606] kworker/u8:5/76 is trying to lock:
    [    4.239609] ffff0000091898a0 (&p->lock){....}-{3:3}, at: gpio_rcar_config_interrupt_input_mode+0x34/0x164
    [    4.239641] other info that might help us debug this:
    [    4.239643] context-{5:5}
    [    4.239646] 5 locks held by kworker/u8:5/76:
    [    4.239651]  #0: ffff0000080fb148 ((wq_completion)async){+.+.}-{0:0}, at: process_one_work+0x190/0x62c
    [    4.250180] OF: /soc/sound@ec500000/ports/port@0/endpoint: Read of boolean property 'frame-master' with a value.
    [    4.254094]  #1: ffff80008299bd80 ((work_completion)(&entry->work)){+.+.}-{0:0}, at: process_one_work+0x1b8/0x62c
    [    4.254109]  #2: ffff00000920c8f8
    [    4.258345] OF: /soc/sound@ec500000/ports/port@1/endpoint: Read of boolean property 'bitclock-master' with a value.
    [    4.264803]  (&dev->mutex){....}-{4:4}, at: __device_attach_async_helper+0x3c/0xdc
    [    4.264820]  #3: ffff00000a50ca40 (request_class#2){+.+.}-{4:4}, at: __setup_irq+0xa0/0x690
    [    4.264840]  #4:
    [    4.268872] OF: /soc/sound@ec500000/ports/port@1/endpoint: Read of boolean property 'frame-master' with a value.
    [    4.273275] ffff00000a50c8c8 (lock_class){....}-{2:2}, at: __setup_irq+0xc4/0x690
    [    4.296130] renesas_sdhi_internal_dmac ee100000.mmc: mmc1 base at 0x00000000ee100000, max clock rate 200 MHz
    [    4.304082] stack backtrace:
    [    4.304086] CPU: 1 UID: 0 PID: 76 Comm: kworker/u8:5 Not tainted 6.13.0-rc7-arm64-renesas-05496-gd088502a519f #35
    [    4.304092] Hardware name: Renesas Salvator-X 2nd version board based on r8a77965 (DT)
    [    4.304097] Workqueue: async async_run_entry_fn
    [    4.304106] Call trace:
    [    4.304110]  show_stack+0x14/0x20 (C)
    [    4.304122]  dump_stack_lvl+0x6c/0x90
    [    4.304131]  dump_stack+0x14/0x1c
    [    4.304138]  __lock_acquire+0xdfc/0x1584
    [    4.426274]  lock_acquire+0x1c4/0x33c
    [    4.429942]  _raw_spin_lock_irqsave+0x5c/0x80
    [    4.434307]  gpio_rcar_config_interrupt_input_mode+0x34/0x164
    [    4.440061]  gpio_rcar_irq_set_type+0xd4/0xd8
    [    4.444422]  __irq_set_trigger+0x5c/0x178
    [    4.448435]  __setup_irq+0x2e4/0x690
    [    4.452012]  request_threaded_irq+0xc4/0x190
    [    4.456285]  devm_request_threaded_irq+0x7c/0xf4
    [    4.459398] ata1: link resume succeeded after 1 retries
    [    4.460902]  mmc_gpiod_request_cd_irq+0x68/0xe0
    [    4.470660]  mmc_start_host+0x50/0xac
    [    4.474327]  mmc_add_host+0x80/0xe4
    [    4.477817]  tmio_mmc_host_probe+0x2b0/0x440
    [    4.482094]  renesas_sdhi_probe+0x488/0x6f4
    [    4.486281]  renesas_sdhi_internal_dmac_probe+0x60/0x78
    [    4.491509]  platform_probe+0x64/0xd8
    [    4.495178]  really_probe+0xb8/0x2a8
    [    4.498756]  __driver_probe_device+0x74/0x118
    [    4.503116]  driver_probe_device+0x3c/0x154
    [    4.507303]  __device_attach_driver+0xd4/0x160
    [    4.511750]  bus_for_each_drv+0x84/0xe0
    [    4.515588]  __device_attach_async_helper+0xb0/0xdc
    [    4.520470]  async_run_entry_fn+0x30/0xd8
    [    4.524481]  process_one_work+0x210/0x62c
    [    4.528494]  worker_thread+0x1ac/0x340
    [    4.532245]  kthread+0x10c/0x110
    [    4.535476]  ret_from_fork+0x10/0x20
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3e300913c42041e81c5b17a970c4e078086ff2d1
  - https://git.kernel.org/stable/c/51ef3073493e2a25dced05fdd59dfb059e7e284d
  - https://git.kernel.org/stable/c/7c1f36f9c9aca507d317479a3d3388150ae40a87
  - https://git.kernel.org/stable/c/b42c84f9e4ec5bc2885e7fd80c79ec0352f5d2af
  - https://git.kernel.org/stable/c/c10365031f16514a29c812cd909085a6e4ea4b61
  - https://git.kernel.org/stable/c/f02c41f87cfe61440c18bf77d1ef0a884b9ee2b5

------------------------------------------------------------

CVE ID: CVE-2025-21913
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/amd_nb: Use rdmsr_safe() in amd_get_mmconfig_range()

Xen doesn't offer MSR_FAM10H_MMIO_CONF_BASE to all guests.  This results
in the following warning:

  unchecked MSR access error: RDMSR from 0xc0010058 at rIP: 0xffffffff8101d19f (xen_do_read_msr+0x7f/0xa0)
  Call Trace:
   xen_read_msr+0x1e/0x30
   amd_get_mmconfig_range+0x2b/0x80
   quirk_amd_mmconfig_area+0x28/0x100
   pnp_fixup_device+0x39/0x50
   __pnp_add_device+0xf/0x150
   pnp_add_device+0x3d/0x100
   pnpacpi_add_device_handler+0x1f9/0x280
   acpi_ns_get_device_callback+0x104/0x1c0
   acpi_ns_walk_namespace+0x1d0/0x260
   acpi_get_devices+0x8a/0xb0
   pnpacpi_init+0x50/0x80
   do_one_initcall+0x46/0x2e0
   kernel_init_freeable+0x1da/0x2f0
   kernel_init+0x16/0x1b0
   ret_from_fork+0x30/0x50
   ret_from_fork_asm+0x1b/0x30

based on quirks for a "PNP0c01" device.  Treating MMCFG as disabled is the
right course of action, so no change is needed there.

This was most likely exposed by fixing the Xen MSR accessors to not be
silently-safe.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c65d13bdcc54e5b924ebe790f85a7f01bfe1cb1
  - https://git.kernel.org/stable/c/14cb5d83068ecf15d2da6f7d0e9ea9edbcbc0457
  - https://git.kernel.org/stable/c/8f43ba5ee498fe037d1570f6868d9aeaf49dda80
  - https://git.kernel.org/stable/c/923fede9eae9865af305bcdf8f111e4b62ae4bda
  - https://git.kernel.org/stable/c/ebf6a763904e42dabeb2e270ceb0bbe0f825d7ae

------------------------------------------------------------

CVE ID: CVE-2025-21914
Description: In the Linux kernel, the following vulnerability has been resolved:

slimbus: messaging: Free transaction ID in delayed interrupt scenario

In case of interrupt delay for any reason, slim_do_transfer()
returns timeout error but the transaction ID (TID) is not freed.
This results into invalid memory access inside
qcom_slim_ngd_rx_msgq_cb() due to invalid TID.

Fix the issue by freeing the TID in slim_do_transfer() before
returning timeout error to avoid invalid memory access.

Call trace:
__memcpy_fromio+0x20/0x190
qcom_slim_ngd_rx_msgq_cb+0x130/0x290 [slim_qcom_ngd_ctrl]
vchan_complete+0x2a0/0x4a0
tasklet_action_common+0x274/0x700
tasklet_action+0x28/0x3c
_stext+0x188/0x620
run_ksoftirqd+0x34/0x74
smpboot_thread_fn+0x1d8/0x464
kthread+0x178/0x238
ret_from_fork+0x10/0x20
Code: aa0003e8 91000429 f100044a 3940002b (3800150b)
---[ end trace 0fe00bec2b975c99 ]---
Kernel panic - not syncing: Oops: Fatal exception in interrupt.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09d34c4cbc38485c7514069f25348e439555b282
  - https://git.kernel.org/stable/c/0c541c8f6da23e0b92f0a6216d899659a7572074
  - https://git.kernel.org/stable/c/18ae4cee05c310c299ba75d7477dcf34be67aa16
  - https://git.kernel.org/stable/c/6abf3d8bb51cbaf886c3f08109a0462890b10db6
  - https://git.kernel.org/stable/c/a32e5198a9134772eb03f7b72a7849094c55bda9
  - https://git.kernel.org/stable/c/cec8c0ac173fe5321f03fdb1a09a9cb69bc9a9fe
  - https://git.kernel.org/stable/c/dcb0d43ba8eb9517e70b1a0e4b0ae0ab657a0e5a
  - https://git.kernel.org/stable/c/faac8e894014e8167471a8e4a5eb35a8fefbb82a

------------------------------------------------------------

CVE ID: CVE-2025-21915
Description: In the Linux kernel, the following vulnerability has been resolved:

cdx: Fix possible UAF error in driver_override_show()

Fixed a possible UAF problem in driver_override_show() in drivers/cdx/cdx.c

This function driver_override_show() is part of DEVICE_ATTR_RW, which
includes both driver_override_show() and driver_override_store().
These functions can be executed concurrently in sysfs.

The driver_override_store() function uses driver_set_override() to
update the driver_override value, and driver_set_override() internally
locks the device (device_lock(dev)). If driver_override_show() reads
cdx_dev->driver_override without locking, it could potentially access
a freed pointer if driver_override_store() frees the string
concurrently. This could lead to printing a kernel address, which is a
security risk since DEVICE_ATTR can be read by all users.

Additionally, a similar pattern is used in drivers/amba/bus.c, as well
as many other bus drivers, where device_lock() is taken in the show
function, and it has been working without issues.

This potential bug was detected by our experimental static analysis
tool, which analyzes locking APIs and paired functions to identify
data races and atomicity violations.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0439d541aa8d3444ad41c39e39eb71acb57acde3
  - https://git.kernel.org/stable/c/8473135f89c0949436a22adb05b8cece2fb3da91
  - https://git.kernel.org/stable/c/91d44c1afc61a2fec37a9c7a3485368309391e0b
  - https://git.kernel.org/stable/c/d7b339bbc887bcfc1a5b620bfc70c6fbb8f733bf

------------------------------------------------------------

CVE ID: CVE-2025-21916
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: atm: cxacru: fix a flaw in existing endpoint checks

Syzbot once again identified a flaw in usb endpoint checking, see [1].
This time the issue stems from a commit authored by me (2eabb655a968
("usb: atm: cxacru: fix endpoint checking in cxacru_bind()")).

While using usb_find_common_endpoints() may usually be enough to
discard devices with wrong endpoints, in this case one needs more
than just finding and identifying the sufficient number of endpoints
of correct types - one needs to check the endpoint's address as well.

Since cxacru_bind() fills URBs with CXACRU_EP_CMD address in mind,
switch the endpoint verification approach to usb_check_XXX_endpoints()
instead to fix incomplete ep testing.

[1] Syzbot report:
usb 5-1: BOGUS urb xfer, pipe 3 != type 1
WARNING: CPU: 0 PID: 1378 at drivers/usb/core/urb.c:504 usb_submit_urb+0xc4e/0x18c0 drivers/usb/core/urb.c:503
...
RIP: 0010:usb_submit_urb+0xc4e/0x18c0 drivers/usb/core/urb.c:503
...
Call Trace:
 <TASK>
 cxacru_cm+0x3c8/0xe50 drivers/usb/atm/cxacru.c:649
 cxacru_card_status drivers/usb/atm/cxacru.c:760 [inline]
 cxacru_bind+0xcf9/0x1150 drivers/usb/atm/cxacru.c:1223
 usbatm_usb_probe+0x314/0x1d30 drivers/usb/atm/usbatm.c:1058
 cxacru_usb_probe+0x184/0x220 drivers/usb/atm/cxacru.c:1377
 usb_probe_interface+0x641/0xbb0 drivers/usb/core/driver.c:396
 really_probe+0x2b9/0xad0 drivers/base/dd.c:658
 __driver_probe_device+0x1a2/0x390 drivers/base/dd.c:800
 driver_probe_device+0x50/0x430 drivers/base/dd.c:830
...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/197e78076c5ecd895f109158c4ea2954b9919af6
  - https://git.kernel.org/stable/c/319529e0356bd904528c64647725a2272d297c83
  - https://git.kernel.org/stable/c/903b80c21458bb1e34c3a78c5fdc553821e357f8
  - https://git.kernel.org/stable/c/a0475a885d69849b1ade38add6d64338dfa83a8f
  - https://git.kernel.org/stable/c/bf4409f84023b52b5e9b36c0a071a121eee42138
  - https://git.kernel.org/stable/c/c90aad369899a607cfbc002bebeafd51e31900cd
  - https://git.kernel.org/stable/c/cfc295f7cccf66cbd5123416bcf1bee2e1bd37de
  - https://git.kernel.org/stable/c/dcd592ab9dd8a2bfc36e75583b9006db2a77ec24

------------------------------------------------------------

CVE ID: CVE-2025-21917
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: renesas_usbhs: Flush the notify_hotplug_work

When performing continuous unbind/bind operations on the USB drivers
available on the Renesas RZ/G2L SoC, a kernel crash with the message
"Unable to handle kernel NULL pointer dereference at virtual address"
may occur. This issue points to the usbhsc_notify_hotplug() function.

Flush the delayed work to avoid its execution when driver resources are
unavailable.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.0, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3248c1f833f924246cb98ce7da4569133c1b2292
  - https://git.kernel.org/stable/c/394965f90454d6f00fe11879142b720c6c1a872e
  - https://git.kernel.org/stable/c/4ca078084cdd5f32d533311d6a0b63a60dcadd41
  - https://git.kernel.org/stable/c/4cd847a7b630a85493d0294ad9542c21aafaa246
  - https://git.kernel.org/stable/c/552ca6b87e3778f3dd5b87842f95138162e16c82
  - https://git.kernel.org/stable/c/830818c8e70c0364e377f0c243b28061ef7967eb
  - https://git.kernel.org/stable/c/d50f5c0cd949593eb9a3d822b34d7b50046a06b7
  - https://git.kernel.org/stable/c/e5aac1c9b2974636db7ce796ffa6de88fa08335e

------------------------------------------------------------

CVE ID: CVE-2025-21918
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: typec: ucsi: Fix NULL pointer access

Resources should be released only after all threads that utilize them
have been destroyed.
This commit ensures that resources are not released prematurely by waiting
for the associated workqueue to complete before deallocating them.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.133
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/079a3e52f3e751bb8f5937195bdf25c5d14fdff0
  - https://git.kernel.org/stable/c/46fba7be161bb89068958138ea64ec33c0b446d4
  - https://git.kernel.org/stable/c/592a0327d026a122e97e8e8bb7c60cbbe7697344
  - https://git.kernel.org/stable/c/7a735a8a46f6ebf898bbefd96659ca5da798bce0
  - https://git.kernel.org/stable/c/b13abcb7ddd8d38de769486db5bd917537b32ab1

------------------------------------------------------------

CVE ID: CVE-2025-21919
Description: In the Linux kernel, the following vulnerability has been resolved:

sched/fair: Fix potential memory corruption in child_cfs_rq_on_list

child_cfs_rq_on_list attempts to convert a 'prev' pointer to a cfs_rq.
This 'prev' pointer can originate from struct rq's leaf_cfs_rq_list,
making the conversion invalid and potentially leading to memory
corruption. Depending on the relative positions of leaf_cfs_rq_list and
the task group (tg) pointer within the struct, this can cause a memory
fault or access garbage data.

The issue arises in list_add_leaf_cfs_rq, where both
cfs_rq->leaf_cfs_rq_list and rq->leaf_cfs_rq_list are added to the same
leaf list. Also, rq->tmp_alone_branch can be set to rq->leaf_cfs_rq_list.

This adds a check `if (prev == &rq->leaf_cfs_rq_list)` after the main
conditional in child_cfs_rq_on_list. This ensures that the container_of
operation will convert a correct cfs_rq struct.

This check is sufficient because only cfs_rqs on the same CPU are added
to the list, so verifying the 'prev' pointer against the current rq's list
head is enough.

Fixes a potential memory corruption issue that due to current struct
layout might not be manifesting as a crash but could lead to unpredictable
behavior when the layout changes.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/000c9ee43928f2ce68a156dd40bab7616256f4dd
  - https://git.kernel.org/stable/c/3b4035ddbfc8e4521f85569998a7569668cccf51
  - https://git.kernel.org/stable/c/5cb300dcdd27e6a351ac02541e0231261c775852
  - https://git.kernel.org/stable/c/9cc7f0018609f75a349e42e3aebc3b0e905ba775
  - https://git.kernel.org/stable/c/b5741e4b9ef3567613b2351384f91d3f16e59986
  - https://git.kernel.org/stable/c/e1dd09df30ba86716cb2ffab97dc35195c01eb8f

------------------------------------------------------------

CVE ID: CVE-2025-21920
Description: In the Linux kernel, the following vulnerability has been resolved:

vlan: enforce underlying device type

Currently, VLAN devices can be created on top of non-ethernet devices.

Besides the fact that it doesn't make much sense, this also causes a
bug which leaks the address of a kernel function to usermode.

When creating a VLAN device, we initialize GARP (garp_init_applicant)
and MRP (mrp_init_applicant) for the underlying device.

As part of the initialization process, we add the multicast address of
each applicant to the underlying device, by calling dev_mc_add.

__dev_mc_add uses dev->addr_len to determine the length of the new
multicast address.

This causes an out-of-bounds read if dev->addr_len is greater than 6,
since the multicast addresses provided by GARP and MRP are only 6
bytes long.

This behaviour can be reproduced using the following commands:

ip tunnel add gretest mode ip6gre local ::1 remote ::2 dev lo
ip l set up dev gretest
ip link add link gretest name vlantest type vlan id 100

Then, the following command will display the address of garp_pdu_rcv:

ip maddr show | grep 01:80:c2:00:00:21

Fix the bug by enforcing the type of the underlying device during VLAN
device initialization.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.35, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0fb7aa04c19eac4417f360a9f7611a60637bdacc
  - https://git.kernel.org/stable/c/30e8aee77899173a82ae5ed89f536c096f20aaeb
  - https://git.kernel.org/stable/c/3561442599804905c3defca241787cd4546e99a7
  - https://git.kernel.org/stable/c/5a515d13e15536e82c5c7c83eb6cf5bc4827fee5
  - https://git.kernel.org/stable/c/7f1564b2b2072b7aa1ac75350e9560a07c7a44fd
  - https://git.kernel.org/stable/c/b33a534610067ade2bdaf2052900aaad99701353
  - https://git.kernel.org/stable/c/b6c72479748b7ea09f53ed64b223cee6463dc278
  - https://git.kernel.org/stable/c/fa40ebef69234e39ec2d26930d045f2fb9a8cb2b

------------------------------------------------------------

CVE ID: CVE-2025-21921
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethtool: netlink: Allow NULL nlattrs when getting a phy_device

ethnl_req_get_phydev() is used to lookup a phy_device, in the case an
ethtool netlink command targets a specific phydev within a netdev's
topology.

It takes as a parameter a const struct nlattr *header that's used for
error handling :

       if (!phydev) {
               NL_SET_ERR_MSG_ATTR(extack, header,
                                   "no phy matching phyindex");
               return ERR_PTR(-ENODEV);
       }

In the notify path after a ->set operation however, there's no request
attributes available.

The typical callsite for the above function looks like:

	phydev = ethnl_req_get_phydev(req_base, tb[ETHTOOL_A_XXX_HEADER],
				      info->extack);

So, when tb is NULL (such as in the ethnl notify path), we have a nice
crash.

It turns out that there's only the PLCA command that is in that case, as
the other phydev-specific commands don't have a notification.

This commit fixes the crash by passing the cmd index and the nlattr
array separately, allowing NULL-checking it directly inside the helper.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1f458fa42c29144cef280e05bc49fc21b873d897
  - https://git.kernel.org/stable/c/637399bf7e77797811adf340090b561a8f9d1213
  - https://git.kernel.org/stable/c/639c70352958735addbba5ae7dd65985da96e061

------------------------------------------------------------

CVE ID: CVE-2025-21922
Description: In the Linux kernel, the following vulnerability has been resolved:

ppp: Fix KMSAN uninit-value warning with bpf

Syzbot caught an "KMSAN: uninit-value" warning [1], which is caused by the
ppp driver not initializing a 2-byte header when using socket filter.

The following code can generate a PPP filter BPF program:
'''
struct bpf_program fp;
pcap_t *handle;
handle = pcap_open_dead(DLT_PPP_PPPD, 65535);
pcap_compile(handle, &fp, "ip and outbound", 0, 0);
bpf_dump(&fp, 1);
'''
Its output is:
'''
(000) ldh [2]
(001) jeq #0x21 jt 2 jf 5
(002) ldb [0]
(003) jeq #0x1 jt 4 jf 5
(004) ret #65535
(005) ret #0
'''
Wen can find similar code at the following link:
https://github.com/ppp-project/ppp/blob/master/pppd/options.c#L1680
The maintainer of this code repository is also the original maintainer
of the ppp driver.

As you can see the BPF program skips 2 bytes of data and then reads the
'Protocol' field to determine if it's an IP packet. Then it read the first
byte of the first 2 bytes to determine the direction.

The issue is that only the first byte indicating direction is initialized
in current ppp driver code while the second byte is not initialized.

For normal BPF programs generated by libpcap, uninitialized data won't be
used, so it's not a problem. However, for carefully crafted BPF programs,
such as those generated by syzkaller [2], which start reading from offset
0, the uninitialized data will be used and caught by KMSAN.

[1] https://syzkaller.appspot.com/bug?extid=853242d9c9917165d791
[2] https://syzkaller.appspot.com/text?tag=ReproC&x=11994913980000
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1eacd47636a9de5bee25d9d5962dc538a82d9f0b
  - https://git.kernel.org/stable/c/2f591cb158807bdcf424f66f1fbfa6e4e50f3757
  - https://git.kernel.org/stable/c/3de809a768464528762757e433cd50de35bcb3c1
  - https://git.kernel.org/stable/c/4c2d14c40a68678d885eab4008a0129646805bae
  - https://git.kernel.org/stable/c/4e2191b0fd0c064d37b0db67396216f2d4787e0f
  - https://git.kernel.org/stable/c/8aa8a40c766b3945b40565a70349d5581458ff63
  - https://git.kernel.org/stable/c/c036f5f2680cbdabdbbace86baee3c83721634d6
  - https://git.kernel.org/stable/c/d685096c8129c9a92689975193e268945fd21dbf

------------------------------------------------------------

CVE ID: CVE-2025-21923
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: hid-steam: Fix use-after-free when detaching device

When a hid-steam device is removed it must clean up the client_hdev used for
intercepting hidraw access. This can lead to scheduling deferred work to
reattach the input device. Though the cleanup cancels the deferred work, this
was done before the client_hdev itself is cleaned up, so it gets rescheduled.
This patch fixes the ordering to make sure the deferred work is properly
canceled.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.79, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.16, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13.4, Last Version (Excluding): 6.13.7
References:
  - https://git.kernel.org/stable/c/026714ec7546de741826324a6a1914c91024d06c
  - https://git.kernel.org/stable/c/a899adf7063c6745aaff1ec869f3c7f6329ed0a1
  - https://git.kernel.org/stable/c/e53fc232a65f7488ab75d03a5b95f06aaada7262
  - https://git.kernel.org/stable/c/ea3f18d2f02629653b7bfe42607737ccd1343e54

------------------------------------------------------------

CVE ID: CVE-2025-21924
Description: In the Linux kernel, the following vulnerability has been resolved:

net: hns3: make sure ptp clock is unregister and freed if hclge_ptp_get_cycle returns an error

During the initialization of ptp, hclge_ptp_get_cycle might return an error
and returned directly without unregister clock and free it. To avoid that,
call hclge_ptp_destroy_clock to unregist and free clock if
hclge_ptp_get_cycle failed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/21dba813d9821687a7f9aff576798ba21a859a32
  - https://git.kernel.org/stable/c/2c04e507f3a5c5dc6e2b9ab37d8cdedee1ef1a37
  - https://git.kernel.org/stable/c/33244e98aa9503585e585335fe2ceb4492630949
  - https://git.kernel.org/stable/c/9cfc43c0e6e6a31122b4008d763a2960c206aa2d
  - https://git.kernel.org/stable/c/b7365eab39831487a84e63a9638209b68dc54008
  - https://git.kernel.org/stable/c/b7d8d4529984e2d4a72a6d552fb886233e8e83cb

------------------------------------------------------------

CVE ID: CVE-2025-21925
Description: In the Linux kernel, the following vulnerability has been resolved:

llc: do not use skb_get() before dev_queue_xmit()

syzbot is able to crash hosts [1], using llc and devices
not supporting IFF_TX_SKB_SHARING.

In this case, e1000 driver calls eth_skb_pad(), while
the skb is shared.

Simply replace skb_get() by skb_clone() in net/llc/llc_s_ac.c

Note that e1000 driver might have an issue with pktgen,
because it does not clear IFF_TX_SKB_SHARING, this is an
orthogonal change.

We need to audit other skb_get() uses in net/llc.

[1]

kernel BUG at net/core/skbuff.c:2178 !
Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI
CPU: 0 UID: 0 PID: 16371 Comm: syz.2.2764 Not tainted 6.14.0-rc4-syzkaller-00052-gac9c34d1e45a #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
 RIP: 0010:pskb_expand_head+0x6ce/0x1240 net/core/skbuff.c:2178
Call Trace:
 <TASK>
  __skb_pad+0x18a/0x610 net/core/skbuff.c:2466
  __skb_put_padto include/linux/skbuff.h:3843 [inline]
  skb_put_padto include/linux/skbuff.h:3862 [inline]
  eth_skb_pad include/linux/etherdevice.h:656 [inline]
  e1000_xmit_frame+0x2d99/0x5800 drivers/net/ethernet/intel/e1000/e1000_main.c:3128
  __netdev_start_xmit include/linux/netdevice.h:5151 [inline]
  netdev_start_xmit include/linux/netdevice.h:5160 [inline]
  xmit_one net/core/dev.c:3806 [inline]
  dev_hard_start_xmit+0x9a/0x7b0 net/core/dev.c:3822
  sch_direct_xmit+0x1ae/0xc30 net/sched/sch_generic.c:343
  __dev_xmit_skb net/core/dev.c:4045 [inline]
  __dev_queue_xmit+0x13d4/0x43e0 net/core/dev.c:4621
  dev_queue_xmit include/linux/netdevice.h:3313 [inline]
  llc_sap_action_send_test_c+0x268/0x320 net/llc/llc_s_ac.c:144
  llc_exec_sap_trans_actions net/llc/llc_sap.c:153 [inline]
  llc_sap_next_state net/llc/llc_sap.c:182 [inline]
  llc_sap_state_process+0x239/0x510 net/llc/llc_sap.c:209
  llc_ui_sendmsg+0xd0d/0x14e0 net/llc/af_llc.c:993
  sock_sendmsg_nosec net/socket.c:718 [inline]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/056e8a46d79e22983bae4267e0d9c52927076f46
  - https://git.kernel.org/stable/c/0f764208dc24ea043c3e20194d32aebf94f8459c
  - https://git.kernel.org/stable/c/13f3f872627f0f27c31245524fc11367756240ad
  - https://git.kernel.org/stable/c/17f86e25431ebc15aa9245ff156414fdad47822d
  - https://git.kernel.org/stable/c/416e8b4c20c6398044e93008deefd563289f477d
  - https://git.kernel.org/stable/c/64e6a754d33d31aa844b3ee66fb93ac84ca1565e
  - https://git.kernel.org/stable/c/9b6f083db141ece0024be01526aa05aa978811cb
  - https://git.kernel.org/stable/c/cd1c44327bbbd50fc24f2b38892f5f328b784d0f

------------------------------------------------------------

CVE ID: CVE-2025-21926
Description: In the Linux kernel, the following vulnerability has been resolved:

net: gso: fix ownership in __udp_gso_segment

In __udp_gso_segment the skb destructor is removed before segmenting the
skb but the socket reference is kept as-is. This is an issue if the
original skb is later orphaned as we can hit the following bug:

  kernel BUG at ./include/linux/skbuff.h:3312!  (skb_orphan)
  RIP: 0010:ip_rcv_core+0x8b2/0xca0
  Call Trace:
   ip_rcv+0xab/0x6e0
   __netif_receive_skb_one_core+0x168/0x1b0
   process_backlog+0x384/0x1100
   __napi_poll.constprop.0+0xa1/0x370
   net_rx_action+0x925/0xe50

The above can happen following a sequence of events when using
OpenVSwitch, when an OVS_ACTION_ATTR_USERSPACE action precedes an
OVS_ACTION_ATTR_OUTPUT action:

1. OVS_ACTION_ATTR_USERSPACE is handled (in do_execute_actions): the skb
   goes through queue_gso_packets and then __udp_gso_segment, where its
   destructor is removed.
2. The segments' data are copied and sent to userspace.
3. OVS_ACTION_ATTR_OUTPUT is handled (in do_execute_actions) and the
   same original skb is sent to its path.
4. If it later hits skb_orphan, we hit the bug.

Fix this by also removing the reference to the socket in
__udp_gso_segment.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01a83237644d6822bc7df2c5564fc81b0df84358
  - https://git.kernel.org/stable/c/084819b0d8b1bd433b90142371eb9450d657f8ca
  - https://git.kernel.org/stable/c/455217ac9db0cf9349b3933664355e907bb1a569
  - https://git.kernel.org/stable/c/9f28205ddb76e86cac418332e952241d85fed0dc
  - https://git.kernel.org/stable/c/a2d1cca955ed34873e524cc2e6e885450d262f05
  - https://git.kernel.org/stable/c/c32da44cc9298eaa6109e3fc2c2b4e07cc4bf11b
  - https://git.kernel.org/stable/c/e8db70537878e1bb3fd83e5abcc6feefc0587828
  - https://git.kernel.org/stable/c/ee01b2f2d7d0010787c2343463965bbc283a497f

------------------------------------------------------------

CVE ID: CVE-2025-21927
Description: In the Linux kernel, the following vulnerability has been resolved:

nvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu()

nvme_tcp_recv_pdu() doesn't check the validity of the header length.
When header digests are enabled, a target might send a packet with an
invalid header length (e.g. 255), causing nvme_tcp_verify_hdgst()
to access memory outside the allocated area and cause memory corruptions
by overwriting it with the calculated digest.

Fix this by rejecting packets with an unexpected header length.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/22b06c89aa6b2d1ecb8aea72edfb9d53af8d5126
  - https://git.kernel.org/stable/c/9fbc953d6b38bc824392e01850f0aeee3b348722
  - https://git.kernel.org/stable/c/ad95bab0cd28ed77c2c0d0b6e76e03e031391064

------------------------------------------------------------

CVE ID: CVE-2025-21928
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: intel-ish-hid: Fix use-after-free issue in ishtp_hid_remove()

The system can experience a random crash a few minutes after the driver is
removed. This issue occurs due to improper handling of memory freeing in
the ishtp_hid_remove() function.

The function currently frees the `driver_data` directly within the loop
that destroys the HID devices, which can lead to accessing freed memory.
Specifically, `hid_destroy_device()` uses `driver_data` when it calls
`hid_ishtp_set_feature()` to power off the sensor, so freeing
`driver_data` beforehand can result in accessing invalid memory.

This patch resolves the issue by storing the `driver_data` in a temporary
variable before calling `hid_destroy_device()`, and then freeing the
`driver_data` after the device is destroyed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/01b18a330cda61cc21423a7d1af92cf31ded8f60
  - https://git.kernel.org/stable/c/07583a0010696a17fb0942e0b499a62785c5fc9f
  - https://git.kernel.org/stable/c/0c1fb475ef999d6c22fc3f963fdf20cb3ed1b03d
  - https://git.kernel.org/stable/c/560f4d1299342504a6ab8a47f575b5e6b8345ada
  - https://git.kernel.org/stable/c/cf1a6015d2f6b1f0afaa0fd6a0124ff2c7943394
  - https://git.kernel.org/stable/c/d3faae7f42181865c799d88c5054176f38ae4625
  - https://git.kernel.org/stable/c/dea6a349bcaf243fff95dfd0428a26be6a0fb44e
  - https://git.kernel.org/stable/c/eb0695d87a81e7c1f0509b7d8ee7c65fbc26aec9

------------------------------------------------------------

CVE ID: CVE-2025-21929
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: intel-ish-hid: Fix use-after-free issue in hid_ishtp_cl_remove()

During the `rmmod` operation for the `intel_ishtp_hid` driver, a
use-after-free issue can occur in the hid_ishtp_cl_remove() function.
The function hid_ishtp_cl_deinit() is called before ishtp_hid_remove(),
which can lead to accessing freed memory or resources during the
removal process.

Call Trace:
 ? ishtp_cl_send+0x168/0x220 [intel_ishtp]
 ? hid_output_report+0xe3/0x150 [hid]
 hid_ishtp_set_feature+0xb5/0x120 [intel_ishtp_hid]
 ishtp_hid_request+0x7b/0xb0 [intel_ishtp_hid]
 hid_hw_request+0x1f/0x40 [hid]
 sensor_hub_set_feature+0x11f/0x190 [hid_sensor_hub]
 _hid_sensor_power_state+0x147/0x1e0 [hid_sensor_trigger]
 hid_sensor_runtime_resume+0x22/0x30 [hid_sensor_trigger]
 sensor_hub_remove+0xa8/0xe0 [hid_sensor_hub]
 hid_device_remove+0x49/0xb0 [hid]
 hid_destroy_device+0x6f/0x90 [hid]
 ishtp_hid_remove+0x42/0x70 [intel_ishtp_hid]
 hid_ishtp_cl_remove+0x6b/0xb0 [intel_ishtp_hid]
 ishtp_cl_device_remove+0x4a/0x60 [intel_ishtp]
 ...

Additionally, ishtp_hid_remove() is a HID level power off, which should
occur before the ISHTP level disconnect.

This patch resolves the issue by reordering the calls in
hid_ishtp_cl_remove(). The function ishtp_hid_remove() is now
called before hid_ishtp_cl_deinit().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/823987841424289339fdb4ba90e6d2c3792836db
  - https://git.kernel.org/stable/c/9c677fe859a73f5dd3dd84c27f99e10d28047c73
  - https://git.kernel.org/stable/c/e040f11fbca868c6d151e9f2c5730c476abfcf17

------------------------------------------------------------

CVE ID: CVE-2025-21930
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: don't try to talk to a dead firmware

This fixes:

 bad state = 0
 WARNING: CPU: 10 PID: 702 at drivers/net/wireless/inel/iwlwifi/iwl-trans.c:178 iwl_trans_send_cmd+0xba/0xe0 [iwlwifi]
 Call Trace:
  <TASK>
  ? __warn+0xca/0x1c0
  ? iwl_trans_send_cmd+0xba/0xe0 [iwlwifi 64fa9ad799a0e0d2ba53d4af93a53ad9a531f8d4]
  iwl_fw_dbg_clear_monitor_buf+0xd7/0x110 [iwlwifi 64fa9ad799a0e0d2ba53d4af93a53ad9a531f8d4]
  _iwl_dbgfs_fw_dbg_clear_write+0xe2/0x120 [iwlmvm 0e8adb18cea92d2c341766bcc10b18699290068a]

Ask whether the firmware is alive before sending a command.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/437e93ecd40754f9e938d524daf52a10c589e2d4
  - https://git.kernel.org/stable/c/d73d2c6e3313f0ba60711ab4f4b9044eddca9ca5
  - https://git.kernel.org/stable/c/e7c31a3f4f27d61b9ccd894a7bf4690f137da0ec

------------------------------------------------------------

CVE ID: CVE-2025-21931
Description: In the Linux kernel, the following vulnerability has been resolved:

hwpoison, memory_hotplug: lock folio before unmap hwpoisoned folio

Commit b15c87263a69 ("hwpoison, memory_hotplug: allow hwpoisoned pages to
be offlined) add page poison checks in do_migrate_range in order to make
offline hwpoisoned page possible by introducing isolate_lru_page and
try_to_unmap for hwpoisoned page.  However folio lock must be held before
calling try_to_unmap.  Add it to fix this problem.

Warning will be produced if folio is not locked during unmap:

  ------------[ cut here ]------------
  kernel BUG at ./include/linux/swapops.h:400!
  Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP
  Modules linked in:
  CPU: 4 UID: 0 PID: 411 Comm: bash Tainted: G        W          6.13.0-rc1-00016-g3c434c7ee82a-dirty #41
  Tainted: [W]=WARN
  Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015
  pstate: 40400005 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : try_to_unmap_one+0xb08/0xd3c
  lr : try_to_unmap_one+0x3dc/0xd3c
  Call trace:
   try_to_unmap_one+0xb08/0xd3c (P)
   try_to_unmap_one+0x3dc/0xd3c (L)
   rmap_walk_anon+0xdc/0x1f8
   rmap_walk+0x3c/0x58
   try_to_unmap+0x88/0x90
   unmap_poisoned_folio+0x30/0xa8
   do_migrate_range+0x4a0/0x568
   offline_pages+0x5a4/0x670
   memory_block_action+0x17c/0x374
   memory_subsys_offline+0x3c/0x78
   device_offline+0xa4/0xd0
   state_store+0x8c/0xf0
   dev_attr_store+0x18/0x2c
   sysfs_kf_write+0x44/0x54
   kernfs_fop_write_iter+0x118/0x1a8
   vfs_write+0x3a8/0x4bc
   ksys_write+0x6c/0xf8
   __arm64_sys_write+0x1c/0x28
   invoke_syscall+0x44/0x100
   el0_svc_common.constprop.0+0x40/0xe0
   do_el0_svc+0x1c/0x28
   el0_svc+0x30/0xd0
   el0t_64_sync_handler+0xc8/0xcc
   el0t_64_sync+0x198/0x19c
  Code: f9407be0 b5fff320 d4210000 17ffff97 (d4210000)
  ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/576a2f4c437c19bec7d05d05b5990f178d2b0f40
  - https://git.kernel.org/stable/c/629dfc6ba5431056701d4e44830f3409b989955a
  - https://git.kernel.org/stable/c/af288a426c3e3552b62595c6138ec6371a17dbba

------------------------------------------------------------

CVE ID: CVE-2025-21932
Description: In the Linux kernel, the following vulnerability has been resolved:

mm: abort vma_modify() on merge out of memory failure

The remainder of vma_modify() relies upon the vmg state remaining pristine
after a merge attempt.

Usually this is the case, however in the one edge case scenario of a merge
attempt failing not due to the specified range being unmergeable, but
rather due to an out of memory error arising when attempting to commit the
merge, this assumption becomes untrue.

This results in vmg->start, end being modified, and thus the proceeding
attempts to split the VMA will be done with invalid start/end values.

Thankfully, it is likely practically impossible for us to hit this in
reality, as it would require a maple tree node pre-allocation failure that
would likely never happen due to it being 'too small to fail', i.e.  the
kernel would simply keep retrying reclaim until it succeeded.

However, this scenario remains theoretically possible, and what we are
doing here is wrong so we must correct it.

The safest option is, when this scenario occurs, to simply give up the
operation.  If we cannot allocate memory to merge, then we cannot allocate
memory to split either (perhaps moreso!).

Any scenario where this would be happening would be under very extreme
(likely fatal) memory pressure, so it's best we give up early.

So there is no doubt it is appropriate to simply bail out in this
scenario.

However, in general we must if at all possible never assume VMG state is
stable after a merge attempt, since merge operations update VMG fields. 
As a result, additionally also make this clear by storing start, end in
local variables.

The issue was reported originally by syzkaller, and by Brad Spengler (via
an off-list discussion), and in both instances it manifested as a
triggering of the assert:

	VM_WARN_ON_VMG(start >= end, vmg);

In vma_merge_existing_range().

It seems at least one scenario in which this is occurring is one in which
the merge being attempted is due to an madvise() across multiple VMAs
which looks like this:

        start     end
          |<------>|
     |----------|------|
     |   vma    | next |
     |----------|------|

When madvise_walk_vmas() is invoked, we first find vma in the above
(determining prev to be equal to vma as we are offset into vma), and then
enter the loop.

We determine the end of vma that forms part of the range we are
madvise()'ing by setting 'tmp' to this value:

		/* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;

We then invoke the madvise() operation via visit(), letting prev get
updated to point to vma as part of the operation:

		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = visit(vma, &prev, start, tmp, arg);

Where the visit() function pointer in this instance is
madvise_vma_behavior().

As observed in syzkaller reports, it is ultimately madvise_update_vma()
that is invoked, calling vma_modify_flags_name() and vma_modify() in turn.

Then, in vma_modify(), we attempt the merge:

	merged = vma_merge_existing_range(vmg);
	if (merged)
		return merged;

We invoke this with vmg->start, end set to start, tmp as such:

        start  tmp
          |<--->|
     |----------|------|
     |   vma    | next |
     |----------|------|

We find ourselves in the merge right scenario, but the one in which we
cannot remove the middle (we are offset into vma).

Here we have a special case where vmg->start, end get set to perhaps
unintuitive values - we intended to shrink the middle VMA and expand the
next.

This means vmg->start, end are set to...  vma->vm_start, start.

Now the commit_merge() fails, and vmg->start, end are left like this. 
This means we return to the rest of vma_modify() with vmg->start, end
(here denoted as start', end') set as:

  start' end'
     |<-->|
     |----------|------|
     |   vma    | next |
     |----------|------|

So we now erroneously try to split accordingly.  This is where the
unfortunate
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/47b16d0462a460000b8f05dfb1292377ac48f3ca
  - https://git.kernel.org/stable/c/53fd215f7886a1e8dea5a9ca1391dbb697fff601
  - https://git.kernel.org/stable/c/79636d2981b066acd945117387a9533f56411f6f

------------------------------------------------------------

CVE ID: CVE-2025-21933
Description: In the Linux kernel, the following vulnerability has been resolved:

arm: pgtable: fix NULL pointer dereference issue

When update_mmu_cache_range() is called by update_mmu_cache(), the vmf
parameter is NULL, which will cause a NULL pointer dereference issue in
adjust_pte():

Unable to handle kernel NULL pointer dereference at virtual address 00000030 when read
Hardware name: Atmel AT91SAM9
PC is at update_mmu_cache_range+0x1e0/0x278
LR is at pte_offset_map_rw_nolock+0x18/0x2c
Call trace:
 update_mmu_cache_range from remove_migration_pte+0x29c/0x2ec
 remove_migration_pte from rmap_walk_file+0xcc/0x130
 rmap_walk_file from remove_migration_ptes+0x90/0xa4
 remove_migration_ptes from migrate_pages_batch+0x6d4/0x858
 migrate_pages_batch from migrate_pages+0x188/0x488
 migrate_pages from compact_zone+0x56c/0x954
 compact_zone from compact_node+0x90/0xf0
 compact_node from kcompactd+0x1d4/0x204
 kcompactd from kthread+0x120/0x12c
 kthread from ret_from_fork+0x14/0x38
Exception stack(0xc0d8bfb0 to 0xc0d8bff8)

To fix it, do not rely on whether 'ptl' is equal to decide whether to hold
the pte lock, but decide it by whether CONFIG_SPLIT_PTE_PTLOCKS is
enabled.  In addition, if two vmas map to the same PTE page, there is no
need to hold the pte lock again, otherwise a deadlock will occur.  Just
add the need_lock parameter to let adjust_pte() know this information.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/91d011efe30aedde067ce6d218d521cf99b162e5
  - https://git.kernel.org/stable/c/a564ccfe300fa6a065beda06ab7f3c140d6b4d63

------------------------------------------------------------

CVE ID: CVE-2025-21934
Description: In the Linux kernel, the following vulnerability has been resolved:

rapidio: fix an API misues when rio_add_net() fails

rio_add_net() calls device_register() and fails when device_register()
fails.  Thus, put_device() should be used rather than kfree().  Add
"mport->net = NULL;" to avoid a use after free issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.6, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/22e4977141dfc6d109bf29b495bf2187b4250990
  - https://git.kernel.org/stable/c/2537f01d57f08c527e40bbb5862aa6ff43344898
  - https://git.kernel.org/stable/c/88ddad53e4cfb6de861c6d4fb7b25427f46baed5
  - https://git.kernel.org/stable/c/a5f5e520e8fbc6294020ff8afa36f684d92c6e6a
  - https://git.kernel.org/stable/c/b2ef51c74b0171fde7eb69b6152d3d2f743ef269
  - https://git.kernel.org/stable/c/cdd9f58f7fe41a55fae4305ea51fc234769fd466
  - https://git.kernel.org/stable/c/d4ec862ce80f64db923a1d942b5d11cf6fc87d36
  - https://git.kernel.org/stable/c/f0aa4ee1cbbf7789907e5a3f6810de01c146c211

------------------------------------------------------------

CVE ID: CVE-2025-21935
Description: In the Linux kernel, the following vulnerability has been resolved:

rapidio: add check for rio_add_net() in rio_scan_alloc_net()

The return value of rio_add_net() should be checked.  If it fails,
put_device() should be called to free the memory and give up the reference
initialized in rio_add_net().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/181d4daaefb3bceeb2f2635ba9f3781eeda9e550
  - https://git.kernel.org/stable/c/4f3509cfcc02e9d757f2714bb7dbbeec35de6fa7
  - https://git.kernel.org/stable/c/6d22953c4a183d0b7fdf34d68c5debd16da6edc5
  - https://git.kernel.org/stable/c/a0d069ccc475abaaa79c6368ee27fc0b5912bea8
  - https://git.kernel.org/stable/c/ad82be4298a89a9ae46f07128bdf3d8614bce745
  - https://git.kernel.org/stable/c/c332f3e2df0fcae5a45fd55cc18902fb1e4825ca
  - https://git.kernel.org/stable/c/e6411c3b9512dba09af7d014d474516828c89706
  - https://git.kernel.org/stable/c/e842f9a1edf306bf36fe2a4d847a0b0d458770de

------------------------------------------------------------

CVE ID: CVE-2025-21936
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: Add check for mgmt_alloc_skb() in mgmt_device_connected()

Add check for the return value of mgmt_alloc_skb() in
mgmt_device_connected() to prevent null pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/7841180342c9a0fd97d54f3e62c7369309b5cd84
  - https://git.kernel.org/stable/c/7d39387886ffe220323cbed5c155233c3276926b
  - https://git.kernel.org/stable/c/bdb1805c248e9694dbb3ffa8867cef2e52cf7261
  - https://git.kernel.org/stable/c/d8df010f72b8a32aaea393e36121738bb53ed905
  - https://git.kernel.org/stable/c/dc516e66fb28c61b248b393e2ddd63bd7f104969

------------------------------------------------------------

CVE ID: CVE-2025-21937
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: Add check for mgmt_alloc_skb() in mgmt_remote_name()

Add check for the return value of mgmt_alloc_skb() in
mgmt_remote_name() to prevent null pointer dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17.2, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/37785a01040cb5d11ed0ddbcbf78491fcd073161
  - https://git.kernel.org/stable/c/69fb168b88e4d62cb31cdd725b67ccc5216cfcaf
  - https://git.kernel.org/stable/c/88310caff68ae69d0574859f7926a59c1da2d60b
  - https://git.kernel.org/stable/c/c5845c73cbacf5704169283ef29ca02031a36564
  - https://git.kernel.org/stable/c/f2176a07e7b19f73e05c805cf3d130a2999154cb

------------------------------------------------------------

CVE ID: CVE-2025-21938
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: fix 'scheduling while atomic' in mptcp_pm_nl_append_new_local_addr

If multiple connection requests attempt to create an implicit mptcp
endpoint in parallel, more than one caller may end up in
mptcp_pm_nl_append_new_local_addr because none found the address in
local_addr_list during their call to mptcp_pm_nl_get_local_id.  In this
case, the concurrent new_local_addr calls may delete the address entry
created by the previous caller.  These deletes use synchronize_rcu, but
this is not permitted in some of the contexts where this function may be
called.  During packet recv, the caller may be in a rcu read critical
section and have preemption disabled.

An example stack:

   BUG: scheduling while atomic: swapper/2/0/0x00000302

   Call Trace:
   <IRQ>
   dump_stack_lvl (lib/dump_stack.c:117 (discriminator 1))
   dump_stack (lib/dump_stack.c:124)
   __schedule_bug (kernel/sched/core.c:5943)
   schedule_debug.constprop.0 (arch/x86/include/asm/preempt.h:33 kernel/sched/core.c:5970)
   __schedule (arch/x86/include/asm/jump_label.h:27 include/linux/jump_label.h:207 kernel/sched/features.h:29 kernel/sched/core.c:6621)
   schedule (arch/x86/include/asm/preempt.h:84 kernel/sched/core.c:6804 kernel/sched/core.c:6818)
   schedule_timeout (kernel/time/timer.c:2160)
   wait_for_completion (kernel/sched/completion.c:96 kernel/sched/completion.c:116 kernel/sched/completion.c:127 kernel/sched/completion.c:148)
   __wait_rcu_gp (include/linux/rcupdate.h:311 kernel/rcu/update.c:444)
   synchronize_rcu (kernel/rcu/tree.c:3609)
   mptcp_pm_nl_append_new_local_addr (net/mptcp/pm_netlink.c:966 net/mptcp/pm_netlink.c:1061)
   mptcp_pm_nl_get_local_id (net/mptcp/pm_netlink.c:1164)
   mptcp_pm_get_local_id (net/mptcp/pm.c:420)
   subflow_check_req (net/mptcp/subflow.c:98 net/mptcp/subflow.c:213)
   subflow_v4_route_req (net/mptcp/subflow.c:305)
   tcp_conn_request (net/ipv4/tcp_input.c:7216)
   subflow_v4_conn_request (net/mptcp/subflow.c:651)
   tcp_rcv_state_process (net/ipv4/tcp_input.c:6709)
   tcp_v4_do_rcv (net/ipv4/tcp_ipv4.c:1934)
   tcp_v4_rcv (net/ipv4/tcp_ipv4.c:2334)
   ip_protocol_deliver_rcu (net/ipv4/ip_input.c:205 (discriminator 1))
   ip_local_deliver_finish (include/linux/rcupdate.h:813 net/ipv4/ip_input.c:234)
   ip_local_deliver (include/linux/netfilter.h:314 include/linux/netfilter.h:308 net/ipv4/ip_input.c:254)
   ip_sublist_rcv_finish (include/net/dst.h:461 net/ipv4/ip_input.c:580)
   ip_sublist_rcv (net/ipv4/ip_input.c:640)
   ip_list_rcv (net/ipv4/ip_input.c:675)
   __netif_receive_skb_list_core (net/core/dev.c:5583 net/core/dev.c:5631)
   netif_receive_skb_list_internal (net/core/dev.c:5685 net/core/dev.c:5774)
   napi_complete_done (include/linux/list.h:37 include/net/gro.h:449 include/net/gro.h:444 net/core/dev.c:6114)
   igb_poll (drivers/net/ethernet/intel/igb/igb_main.c:8244) igb
   __napi_poll (net/core/dev.c:6582)
   net_rx_action (net/core/dev.c:6653 net/core/dev.c:6787)
   handle_softirqs (kernel/softirq.c:553)
   __irq_exit_rcu (kernel/softirq.c:588 kernel/softirq.c:427 kernel/softirq.c:636)
   irq_exit_rcu (kernel/softirq.c:651)
   common_interrupt (arch/x86/kernel/irq.c:247 (discriminator 14))
   </IRQ>

This problem seems particularly prevalent if the user advertises an
endpoint that has a different external vs internal address.  In the case
where the external address is advertised and multiple connections
already exist, multiple subflow SYNs arrive in parallel which tends to
trigger the race during creation of the first local_addr_list entries
which have the internal address instead.

Fix by skipping the replacement of an existing implicit local address if
called via mptcp_pm_nl_get_local_id.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/022bfe24aad8937705704ff2e414b100cf0f2e1a
  - https://git.kernel.org/stable/c/125ccafe6dd062901b5a0c31ee9038740fc8859e
  - https://git.kernel.org/stable/c/4b228dae3d2cc6d9dce167449cd8fa9f028e9376
  - https://git.kernel.org/stable/c/f1404f368c40fc6a068dad72e4ee0824ee6a78ee
  - https://git.kernel.org/stable/c/f3fcdb2de9fdbed9d8c6a8eb2c5fbd7d6f54a4d8

------------------------------------------------------------

CVE ID: CVE-2025-21939
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe/hmm: Don't dereference struct page pointers without notifier lock

The pnfs that we obtain from hmm_range_fault() point to pages that
we don't have a reference on, and the guarantee that they are still
in the cpu page-tables is that the notifier lock must be held and the
notifier seqno is still valid.

So while building the sg table and marking the pages accesses / dirty
we need to hold this lock with a validated seqno.

However, the lock is reclaim tainted which makes
sg_alloc_table_from_pages_segment() unusable, since it internally
allocates memory.

Instead build the sg-table manually. For the non-iommu case
this might lead to fewer coalesces, but if that's a problem it can
be fixed up later in the resource cursor code. For the iommu case,
the whole sg-table may still be coalesced to a single contigous
device va region.

This avoids marking pages that we don't own dirty and accessed, and
it also avoid dereferencing struct pages that we don't own.

v2:
- Use assert to check whether hmm pfns are valid (Matthew Auld)
- Take into account that large pages may cross range boundaries
  (Matthew Auld)

v3:
- Don't unnecessarily check for a non-freed sg-table. (Matthew Auld)
- Add a missing up_read() in an error path. (Matthew Auld)

(cherry picked from commit ea3e66d280ce2576664a862693d1da8fd324c317)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a98219bcc961edd3388960576e4353e123b4a51
  - https://git.kernel.org/stable/c/2a24c98f0e4cc994334598d4f3a851972064809d
  - https://git.kernel.org/stable/c/f9326f529da7298a95643c3267f1c0fdb0db55eb

------------------------------------------------------------

CVE ID: CVE-2025-21940
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Fix NULL Pointer Dereference in KFD queue

Through KFD IOCTL Fuzzing we encountered a NULL pointer derefrence
when calling kfd_queue_acquire_buffers.

(cherry picked from commit 049e5bf3c8406f87c3d8e1958e0a16804fa1d530)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/33eb8041c5d6c19d46e7bfd23a031844336afd80
  - https://git.kernel.org/stable/c/c3cbeafb4e0001d9146df50b470885e02664f3c7
  - https://git.kernel.org/stable/c/fd617ea3b79d2116d53f76cdb5a3601c0ba6e42f

------------------------------------------------------------

CVE ID: CVE-2025-21941
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix null check for pipe_ctx->plane_state in resource_build_scaling_params

Null pointer dereference issue could occur when pipe_ctx->plane_state
is null. The fix adds a check to ensure 'pipe_ctx->plane_state' is not
null before accessing. This prevents a null pointer dereference.

Found by code review.

(cherry picked from commit 63e6a77ccf239337baa9b1e7787cde9fa0462092)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/265422915416468ba91bffa56addbff45e18342a
  - https://git.kernel.org/stable/c/3748fad09d89e9a5290e1738fd6872a79f794743
  - https://git.kernel.org/stable/c/374c9faac5a763a05bc3f68ad9f73dab3c6aec90
  - https://git.kernel.org/stable/c/3b3c2be58d5275aa59d8b4810a59f173f2f5bac1
  - https://git.kernel.org/stable/c/c1e54752dc12e90305eb0475ca908f42f5b369ca
  - https://git.kernel.org/stable/c/e0345c3478f185ca840daac7f08a1fcd4ebec3e9
  - https://git.kernel.org/stable/c/f435192e00bc4d5d4134356b93212670ec47fa8d

------------------------------------------------------------

CVE ID: CVE-2025-21942
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: zoned: fix extent range end unlock in cow_file_range()

Running generic/751 on the for-next branch often results in a hang like
below. They are both stack by locking an extent. This suggests someone
forget to unlock an extent.

  INFO: task kworker/u128:1:12 blocked for more than 323 seconds.
        Not tainted 6.13.0-BTRFS-ZNS+ #503
  "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
  task:kworker/u128:1  state:D stack:0     pid:12    tgid:12    ppid:2      flags:0x00004000
  Workqueue: btrfs-fixup btrfs_work_helper [btrfs]
  Call Trace:
   <TASK>
   __schedule+0x534/0xdd0
   schedule+0x39/0x140
   __lock_extent+0x31b/0x380 [btrfs]
   ? __pfx_autoremove_wake_function+0x10/0x10
   btrfs_writepage_fixup_worker+0xf1/0x3a0 [btrfs]
   btrfs_work_helper+0xff/0x480 [btrfs]
   ? lock_release+0x178/0x2c0
   process_one_work+0x1ee/0x570
   ? srso_return_thunk+0x5/0x5f
   worker_thread+0x1d1/0x3b0
   ? __pfx_worker_thread+0x10/0x10
   kthread+0x10b/0x230
   ? __pfx_kthread+0x10/0x10
   ret_from_fork+0x30/0x50
   ? __pfx_kthread+0x10/0x10
   ret_from_fork_asm+0x1a/0x30
   </TASK>
  INFO: task kworker/u134:0:184 blocked for more than 323 seconds.
        Not tainted 6.13.0-BTRFS-ZNS+ #503
  "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
  task:kworker/u134:0  state:D stack:0     pid:184   tgid:184   ppid:2      flags:0x00004000
  Workqueue: writeback wb_workfn (flush-btrfs-4)
  Call Trace:
   <TASK>
   __schedule+0x534/0xdd0
   schedule+0x39/0x140
   __lock_extent+0x31b/0x380 [btrfs]
   ? __pfx_autoremove_wake_function+0x10/0x10
   find_lock_delalloc_range+0xdb/0x260 [btrfs]
   writepage_delalloc+0x12f/0x500 [btrfs]
   ? srso_return_thunk+0x5/0x5f
   extent_write_cache_pages+0x232/0x840 [btrfs]
   btrfs_writepages+0x72/0x130 [btrfs]
   do_writepages+0xe7/0x260
   ? srso_return_thunk+0x5/0x5f
   ? lock_acquire+0xd2/0x300
   ? srso_return_thunk+0x5/0x5f
   ? find_held_lock+0x2b/0x80
   ? wbc_attach_and_unlock_inode.part.0+0x102/0x250
   ? wbc_attach_and_unlock_inode.part.0+0x102/0x250
   __writeback_single_inode+0x5c/0x4b0
   writeback_sb_inodes+0x22d/0x550
   __writeback_inodes_wb+0x4c/0xe0
   wb_writeback+0x2f6/0x3f0
   wb_workfn+0x32a/0x510
   process_one_work+0x1ee/0x570
   ? srso_return_thunk+0x5/0x5f
   worker_thread+0x1d1/0x3b0
   ? __pfx_worker_thread+0x10/0x10
   kthread+0x10b/0x230
   ? __pfx_kthread+0x10/0x10
   ret_from_fork+0x30/0x50
   ? __pfx_kthread+0x10/0x10
   ret_from_fork_asm+0x1a/0x30
   </TASK>

This happens because we have another success path for the zoned mode. When
there is no active zone available, btrfs_reserve_extent() returns
-EAGAIN. In this case, we have two reactions.

(1) If the given range is never allocated, we can only wait for someone
    to finish a zone, so wait on BTRFS_FS_NEED_ZONE_FINISH bit and retry
    afterward.

(2) Or, if some allocations are already done, we must bail out and let
    the caller to send IOs for the allocation. This is because these IOs
    may be necessary to finish a zone.

The commit 06f364284794 ("btrfs: do proper folio cleanup when
cow_file_range() failed") moved the unlock code from the inside of the
loop to the outside. So, previously, the allocated extents are unlocked
just after the allocation and so before returning from the function.
However, they are no longer unlocked on the case (2) above. That caused
the hang issue.

Fix the issue by modifying the 'end' to the end of the allocated
range. Then, we can exit the loop and the same unlock code can properly
handle the case.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3fcff2f55389306482ab049b4321bda49495e546
  - https://git.kernel.org/stable/c/5a4041f2c47247575a6c2e53ce14f7b0ac946c33

------------------------------------------------------------

CVE ID: CVE-2025-21943
Description: In the Linux kernel, the following vulnerability has been resolved:

gpio: aggregator: protect driver attr handlers against module unload

Both new_device_store and delete_device_store touch module global
resources (e.g. gpio_aggregator_lock). To prevent race conditions with
module unload, a reference needs to be held.

Add try_module_get() in these handlers.

For new_device_store, this eliminates what appears to be the most dangerous
scenario: if an id is allocated from gpio_aggregator_idr but
platform_device_register has not yet been called or completed, a concurrent
module unload could fail to unregister/delete the device, leaving behind a
dangling platform device/GPIO forwarder. This can result in various issues.
The following simple reproducer demonstrates these problems:

  #!/bin/bash
  while :; do
    # note: whether 'gpiochip0 0' exists or not does not matter.
    echo 'gpiochip0 0' > /sys/bus/platform/drivers/gpio-aggregator/new_device
  done &
  while :; do
    modprobe gpio-aggregator
    modprobe -r gpio-aggregator
  done &
  wait

  Starting with the following warning, several kinds of warnings will appear
  and the system may become unstable:

  ------------[ cut here ]------------
  list_del corruption, ffff888103e2e980->next is LIST_POISON1 (dead000000000100)
  WARNING: CPU: 1 PID: 1327 at lib/list_debug.c:56 __list_del_entry_valid_or_report+0xa3/0x120
  [...]
  RIP: 0010:__list_del_entry_valid_or_report+0xa3/0x120
  [...]
  Call Trace:
   <TASK>
   ? __list_del_entry_valid_or_report+0xa3/0x120
   ? __warn.cold+0x93/0xf2
   ? __list_del_entry_valid_or_report+0xa3/0x120
   ? report_bug+0xe6/0x170
   ? __irq_work_queue_local+0x39/0xe0
   ? handle_bug+0x58/0x90
   ? exc_invalid_op+0x13/0x60
   ? asm_exc_invalid_op+0x16/0x20
   ? __list_del_entry_valid_or_report+0xa3/0x120
   gpiod_remove_lookup_table+0x22/0x60
   new_device_store+0x315/0x350 [gpio_aggregator]
   kernfs_fop_write_iter+0x137/0x1f0
   vfs_write+0x262/0x430
   ksys_write+0x60/0xd0
   do_syscall_64+0x6c/0x180
   entry_SYSCALL_64_after_hwframe+0x76/0x7e
   [...]
   </TASK>
  ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/12f65d1203507f7db3ba59930fe29a3b8eee9945
  - https://git.kernel.org/stable/c/56281a76b805b5ac61feb5d580139695a22f87f0
  - https://git.kernel.org/stable/c/807789018186cf508ceb3a1f8f02935cd195717b
  - https://git.kernel.org/stable/c/8fb07fb1bba91d45846ed8605c3097fe67a7d54c
  - https://git.kernel.org/stable/c/9334c88fc2fbc6836b307d269fcc1744c69701c0
  - https://git.kernel.org/stable/c/d99dc8f7ea01ee1b21306e0eda8eb18a4af80db6
  - https://git.kernel.org/stable/c/fd6aa1f8cbe0979eb66ac32ebc231bf0b10a2117

------------------------------------------------------------

CVE ID: CVE-2025-21944
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix bug on trap in smb2_lock

If lock count is greater than 1, flags could be old value.
It should be checked with flags of smb_lock, not flags.
It will cause bug-on trap from locks_free_lock in error handling
routine.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11e0e74e14f1832a95092f2c98ed3b99f57797ee
  - https://git.kernel.org/stable/c/2b70e3ac79eacbdf32571f7af48dd81cdd957ca8
  - https://git.kernel.org/stable/c/8994f0ce8259f812b4f4a681d8298c6ff682efaa
  - https://git.kernel.org/stable/c/dbcd7fdd86f77529210fe8978154a81cd479844c
  - https://git.kernel.org/stable/c/e26e2d2e15daf1ab33e0135caf2304a0cfa2744b

------------------------------------------------------------

CVE ID: CVE-2025-21945
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix use-after-free in smb2_lock

If smb_lock->zero_len has value, ->llist of smb_lock is not delete and
flock is old one. It will cause use-after-free on error handling
routine.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/410ce35a2ed6d0e114132bba29af49b69880c8c7
  - https://git.kernel.org/stable/c/636e021646cf9b52ddfea7c809b018e91f2188cb
  - https://git.kernel.org/stable/c/84d2d1641b71dec326e8736a749b7ee76a9599fc
  - https://git.kernel.org/stable/c/8573571060ca466cbef2c6f03306b2cc7b883506
  - https://git.kernel.org/stable/c/a0609097fd10d618aed4864038393dd75131289e

------------------------------------------------------------

CVE ID: CVE-2025-21946
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix out-of-bounds in parse_sec_desc()

If osidoffset, gsidoffset and dacloffset could be greater than smb_ntsd
struct size. If it is smaller, It could cause slab-out-of-bounds.
And when validating sid, It need to check it included subauth array size.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/159d059cbcb0e6d0e7a7b34af3862ba09a6b22d1
  - https://git.kernel.org/stable/c/6a9831180d0b23b5c97e2bd841aefc8f82900172
  - https://git.kernel.org/stable/c/c1569dbbe2d43041be9f3fef7ca08bec3b66ad1b
  - https://git.kernel.org/stable/c/d6e13e19063db24f94b690159d0633aaf72a0f03

------------------------------------------------------------

CVE ID: CVE-2025-21947
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix type confusion via race condition when using ipc_msg_send_request

req->handle is allocated using ksmbd_acquire_id(&ipc_ida), based on
ida_alloc. req->handle from ksmbd_ipc_login_request and
FSCTL_PIPE_TRANSCEIVE ioctl can be same and it could lead to type confusion
between messages, resulting in access to unexpected parts of memory after
an incorrect delivery. ksmbd check type of ipc response but missing add
continue to check next ipc reponse.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1e8833c03a38e1d5d5df6484e3f670a2fd38fb76
  - https://git.kernel.org/stable/c/3cb2b2e41541fe6f9cc55ca22d4c0bd260498aea
  - https://git.kernel.org/stable/c/6321bbda4244b93802d61cfe0887883aae322f4b
  - https://git.kernel.org/stable/c/76861630b29e51373e73e7b00ad0d467b6941162
  - https://git.kernel.org/stable/c/e2ff19f0b7a30e03516e6eb73b948e27a55bc9d2

------------------------------------------------------------

CVE ID: CVE-2025-21948
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: appleir: Fix potential NULL dereference at raw event handle

Syzkaller reports a NULL pointer dereference issue in input_event().

BUG: KASAN: null-ptr-deref in instrument_atomic_read include/linux/instrumented.h:68 [inline]
BUG: KASAN: null-ptr-deref in _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]
BUG: KASAN: null-ptr-deref in is_event_supported drivers/input/input.c:67 [inline]
BUG: KASAN: null-ptr-deref in input_event+0x42/0xa0 drivers/input/input.c:395
Read of size 8 at addr 0000000000000028 by task syz-executor199/2949

CPU: 0 UID: 0 PID: 2949 Comm: syz-executor199 Not tainted 6.13.0-rc4-syzkaller-00076-gf097a36ef88d #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Call Trace:
 <IRQ>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120
 kasan_report+0xd9/0x110 mm/kasan/report.c:602
 check_region_inline mm/kasan/generic.c:183 [inline]
 kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189
 instrument_atomic_read include/linux/instrumented.h:68 [inline]
 _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]
 is_event_supported drivers/input/input.c:67 [inline]
 input_event+0x42/0xa0 drivers/input/input.c:395
 input_report_key include/linux/input.h:439 [inline]
 key_down drivers/hid/hid-appleir.c:159 [inline]
 appleir_raw_event+0x3e5/0x5e0 drivers/hid/hid-appleir.c:232
 __hid_input_report.constprop.0+0x312/0x440 drivers/hid/hid-core.c:2111
 hid_ctrl+0x49f/0x550 drivers/hid/usbhid/hid-core.c:484
 __usb_hcd_giveback_urb+0x389/0x6e0 drivers/usb/core/hcd.c:1650
 usb_hcd_giveback_urb+0x396/0x450 drivers/usb/core/hcd.c:1734
 dummy_timer+0x17f7/0x3960 drivers/usb/gadget/udc/dummy_hcd.c:1993
 __run_hrtimer kernel/time/hrtimer.c:1739 [inline]
 __hrtimer_run_queues+0x20a/0xae0 kernel/time/hrtimer.c:1803
 hrtimer_run_softirq+0x17d/0x350 kernel/time/hrtimer.c:1820
 handle_softirqs+0x206/0x8d0 kernel/softirq.c:561
 __do_softirq kernel/softirq.c:595 [inline]
 invoke_softirq kernel/softirq.c:435 [inline]
 __irq_exit_rcu+0xfa/0x160 kernel/softirq.c:662
 irq_exit_rcu+0x9/0x30 kernel/softirq.c:678
 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]
 sysvec_apic_timer_interrupt+0x90/0xb0 arch/x86/kernel/apic/apic.c:1049
 </IRQ>
 <TASK>
 asm_sysvec_apic_timer_interrupt+0x1a/0x20 arch/x86/include/asm/idtentry.h:702
 __mod_timer+0x8f6/0xdc0 kernel/time/timer.c:1185
 add_timer+0x62/0x90 kernel/time/timer.c:1295
 schedule_timeout+0x11f/0x280 kernel/time/sleep_timeout.c:98
 usbhid_wait_io+0x1c7/0x380 drivers/hid/usbhid/hid-core.c:645
 usbhid_init_reports+0x19f/0x390 drivers/hid/usbhid/hid-core.c:784
 hiddev_ioctl+0x1133/0x15b0 drivers/hid/usbhid/hiddev.c:794
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:906 [inline]
 __se_sys_ioctl fs/ioctl.c:892 [inline]
 __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
 </TASK>

This happens due to the malformed report items sent by the emulated device
which results in a report, that has no fields, being added to the report list.
Due to this appleir_input_configured() is never called, hidinput_connect()
fails which results in the HID_CLAIMED_INPUT flag is not being set. However,
it  does not make appleir_probe() fail and lets the event callback to be
called without the associated input device.

Thus, add a check for the HID_CLAIMED_INPUT flag and leave the event hook
early if the driver didn't claim any input_dev for some reason. Moreover,
some other hid drivers accessing input_dev in their event callbacks do have
similar checks, too.

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.10, Last Version (Excluding): 5.4.291
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.235
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0df1ac8ee417ad76760ff076faa4518a4d861894
  - https://git.kernel.org/stable/c/2ff5baa9b5275e3acafdf7f2089f74cccb2f38d1
  - https://git.kernel.org/stable/c/68cdf6710f228dfd74f66ec61fbe636da2646a73
  - https://git.kernel.org/stable/c/6db423b00940b05df2a1265d3c7eabafe9f1734c
  - https://git.kernel.org/stable/c/8d39eb8c5e14f2f0f441eed832ef8a7b654e6fee
  - https://git.kernel.org/stable/c/b1d95d733cd6e74f595653daddcfc357bea461e8
  - https://git.kernel.org/stable/c/d335fce8b88b2353f4bb20c631698e20384e3610
  - https://git.kernel.org/stable/c/fc69e2c3219d433caabba4b5d6371ba726a4b37f

------------------------------------------------------------

CVE ID: CVE-2025-21949
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Set hugetlb mmap base address aligned with pmd size

With ltp test case "testcases/bin/hugefork02", there is a dmesg error
report message such as:

 kernel BUG at mm/hugetlb.c:5550!
 Oops - BUG[#1]:
 CPU: 0 UID: 0 PID: 1517 Comm: hugefork02 Not tainted 6.14.0-rc2+ #241
 Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022
 pc 90000000004eaf1c ra 9000000000485538 tp 900000010edbc000 sp 900000010edbf940
 a0 900000010edbfb00 a1 9000000108d20280 a2 00007fffe9474000 a3 00007ffff3474000
 a4 0000000000000000 a5 0000000000000003 a6 00000000003cadd3 a7 0000000000000000
 t0 0000000001ffffff t1 0000000001474000 t2 900000010ecd7900 t3 00007fffe9474000
 t4 00007fffe9474000 t5 0000000000000040 t6 900000010edbfb00 t7 0000000000000001
 t8 0000000000000005 u0 90000000004849d0 s9 900000010edbfa00 s0 9000000108d20280
 s1 00007fffe9474000 s2 0000000002000000 s3 9000000108d20280 s4 9000000002b38b10
 s5 900000010edbfb00 s6 00007ffff3474000 s7 0000000000000406 s8 900000010edbfa08
    ra: 9000000000485538 unmap_vmas+0x130/0x218
   ERA: 90000000004eaf1c __unmap_hugepage_range+0x6f4/0x7d0
  PRMD: 00000004 (PPLV0 +PIE -PWE)
  EUEN: 00000007 (+FPE +SXE +ASXE -BTE)
  ECFG: 00071c1d (LIE=0,2-4,10-12 VS=7)
 ESTAT: 000c0000 [BRK] (IS= ECode=12 EsubCode=0)
 PRID: 0014c010 (Loongson-64bit, Loongson-3A5000)
 Process hugefork02 (pid: 1517, threadinfo=00000000a670eaf4, task=000000007a95fc64)
 Call Trace:
 [<90000000004eaf1c>] __unmap_hugepage_range+0x6f4/0x7d0
 [<9000000000485534>] unmap_vmas+0x12c/0x218
 [<9000000000494068>] exit_mmap+0xe0/0x308
 [<900000000025fdc4>] mmput+0x74/0x180
 [<900000000026a284>] do_exit+0x294/0x898
 [<900000000026aa30>] do_group_exit+0x30/0x98
 [<900000000027bed4>] get_signal+0x83c/0x868
 [<90000000002457b4>] arch_do_signal_or_restart+0x54/0xfa0
 [<90000000015795e8>] irqentry_exit_to_user_mode+0xb8/0x138
 [<90000000002572d0>] tlb_do_page_fault_1+0x114/0x1b4

The problem is that base address allocated from hugetlbfs is not aligned
with pmd size. Here add a checking for hugetlbfs and align base address
with pmd size. After this patch the test case "testcases/bin/hugefork02"
passes to run.

This is similar to the commit 7f24cbc9c4d42db8a3c8484d1 ("mm/mmap: teach
generic_get_unmapped_area{_topdown} to handle hugetlb mappings").
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/242b34f48a377afe4b285b472bd0f17744fca8e8
  - https://git.kernel.org/stable/c/3109d5ff484b7bc7b955f166974c6776d91f247b

------------------------------------------------------------

CVE ID: CVE-2025-21950
Description: In the Linux kernel, the following vulnerability has been resolved:

drivers: virt: acrn: hsm: Use kzalloc to avoid info leak in pmcmd_ioctl

In the "pmcmd_ioctl" function, three memory objects allocated by
kmalloc are initialized by "hcall_get_cpu_state", which are then
copied to user space. The initializer is indeed implemented in
"acrn_hypercall2" (arch/x86/include/asm/acrn.h). There is a risk of
information leakage due to uninitialized bytes.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b8f7a2caa7f9cdfd135e3f78eb9d7e36fb95083
  - https://git.kernel.org/stable/c/4e15cf870d2c748e45d45ffc4d5b1dc1b7d50120
  - https://git.kernel.org/stable/c/524f29d78c9bdeb49f31f5b0376a07d2fc5cf563
  - https://git.kernel.org/stable/c/819cec1dc47cdeac8f5dd6ba81c1dbee2a68c3bb
  - https://git.kernel.org/stable/c/a4c21b878f0e237f45209a324c903ea7fb05247d
  - https://git.kernel.org/stable/c/d7e5031fe3f161c8eb5e84db1540bc4373ed861b

------------------------------------------------------------

CVE ID: CVE-2025-21951
Description: In the Linux kernel, the following vulnerability has been resolved:

bus: mhi: host: pci_generic: Use pci_try_reset_function() to avoid deadlock

There are multiple places from where the recovery work gets scheduled
asynchronously. Also, there are multiple places where the caller waits
synchronously for the recovery to be completed. One such place is during
the PM shutdown() callback.

If the device is not alive during recovery_work, it will try to reset the
device using pci_reset_function(). This function internally will take the
device_lock() first before resetting the device. By this time, if the lock
has already been acquired, then recovery_work will get stalled while
waiting for the lock. And if the lock was already acquired by the caller
which waits for the recovery_work to be completed, it will lead to
deadlock.

This is what happened on the X1E80100 CRD device when the device died
before shutdown() callback. Driver core calls the driver's shutdown()
callback while holding the device_lock() leading to deadlock.

And this deadlock scenario can occur on other paths as well, like during
the PM suspend() callback, where the driver core would hold the
device_lock() before calling driver's suspend() callback. And if the
recovery_work was already started, it could lead to deadlock. This is also
observed on the X1E80100 CRD.

So to fix both issues, use pci_try_reset_function() in recovery_work. This
function first checks for the availability of the device_lock() before
trying to reset the device. If the lock is available, it will acquire it
and reset the device. Otherwise, it will return -EAGAIN. If that happens,
recovery_work will fail with the error message "Recovery failed" as not
much could be done.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.179
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.131
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.83
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.7
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1f9eb7078bc6b5fb5cbfbcb37c4bc01685332b95
  - https://git.kernel.org/stable/c/62505657475c245c9cd46e42ac01026d1e61f027
  - https://git.kernel.org/stable/c/7746f3bb8917fccb4571a576f3837d80fc513054
  - https://git.kernel.org/stable/c/7a5ffadd54fe2662f5c99cdccf30144d060376f7
  - https://git.kernel.org/stable/c/985d3cf56d8745ca637deee273929e01df449f85
  - https://git.kernel.org/stable/c/a321d163de3d8aa38a6449ab2becf4b1581aed96

------------------------------------------------------------

CVE ID: CVE-2025-21952
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: corsair-void: Update power supply values with a unified work handler

corsair_void_process_receiver can be called from an interrupt context,
locking battery_mutex in it was causing a kernel panic.
Fix it by moving the critical section into its own work, sharing this
work with battery_add_work and battery_remove_work to remove the need
for any locking
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c28e4d1e10d2aae608094620bb386e6fd73d55e
  - https://git.kernel.org/stable/c/de19c9dfb68f7c5791accc89047f92e952f57996

------------------------------------------------------------

CVE ID: CVE-2025-21953
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mana: cleanup mana struct after debugfs_remove()

When on a MANA VM hibernation is triggered, as part of hibernate_snapshot(),
mana_gd_suspend() and mana_gd_resume() are called. If during this
mana_gd_resume(), a failure occurs with HWC creation, mana_port_debugfs
pointer does not get reinitialized and ends up pointing to older,
cleaned-up dentry.
Further in the hibernation path, as part of power_down(), mana_gd_shutdown()
is triggered. This call, unaware of the failures in resume, tries to cleanup
the already cleaned up  mana_port_debugfs value and hits the following bug:

[  191.359296] mana 7870:00:00.0: Shutdown was called
[  191.359918] BUG: kernel NULL pointer dereference, address: 0000000000000098
[  191.360584] #PF: supervisor write access in kernel mode
[  191.361125] #PF: error_code(0x0002) - not-present page
[  191.361727] PGD 1080ea067 P4D 0
[  191.362172] Oops: Oops: 0002 [#1] SMP NOPTI
[  191.362606] CPU: 11 UID: 0 PID: 1674 Comm: bash Not tainted 6.14.0-rc5+ #2
[  191.363292] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 11/21/2024
[  191.364124] RIP: 0010:down_write+0x19/0x50
[  191.364537] Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 55 48 89 e5 53 48 89 fb e8 de cd ff ff 31 c0 ba 01 00 00 00 <f0> 48 0f b1 13 75 16 65 48 8b 05 88 24 4c 6a 48 89 43 08 48 8b 5d
[  191.365867] RSP: 0000:ff45fbe0c1c037b8 EFLAGS: 00010246
[  191.366350] RAX: 0000000000000000 RBX: 0000000000000098 RCX: ffffff8100000000
[  191.366951] RDX: 0000000000000001 RSI: 0000000000000064 RDI: 0000000000000098
[  191.367600] RBP: ff45fbe0c1c037c0 R08: 0000000000000000 R09: 0000000000000001
[  191.368225] R10: ff45fbe0d2b01000 R11: 0000000000000008 R12: 0000000000000000
[  191.368874] R13: 000000000000000b R14: ff43dc27509d67c0 R15: 0000000000000020
[  191.369549] FS:  00007dbc5001e740(0000) GS:ff43dc663f380000(0000) knlGS:0000000000000000
[  191.370213] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  191.370830] CR2: 0000000000000098 CR3: 0000000168e8e002 CR4: 0000000000b73ef0
[  191.371557] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  191.372192] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400
[  191.372906] Call Trace:
[  191.373262]  <TASK>
[  191.373621]  ? show_regs+0x64/0x70
[  191.374040]  ? __die+0x24/0x70
[  191.374468]  ? page_fault_oops+0x290/0x5b0
[  191.374875]  ? do_user_addr_fault+0x448/0x800
[  191.375357]  ? exc_page_fault+0x7a/0x160
[  191.375971]  ? asm_exc_page_fault+0x27/0x30
[  191.376416]  ? down_write+0x19/0x50
[  191.376832]  ? down_write+0x12/0x50
[  191.377232]  simple_recursive_removal+0x4a/0x2a0
[  191.377679]  ? __pfx_remove_one+0x10/0x10
[  191.378088]  debugfs_remove+0x44/0x70
[  191.378530]  mana_detach+0x17c/0x4f0
[  191.378950]  ? __flush_work+0x1e2/0x3b0
[  191.379362]  ? __cond_resched+0x1a/0x50
[  191.379787]  mana_remove+0xf2/0x1a0
[  191.380193]  mana_gd_shutdown+0x3b/0x70
[  191.380642]  pci_device_shutdown+0x3a/0x80
[  191.381063]  device_shutdown+0x13e/0x230
[  191.381480]  kernel_power_off+0x35/0x80
[  191.381890]  hibernate+0x3c6/0x470
[  191.382312]  state_store+0xcb/0xd0
[  191.382734]  kobj_attr_store+0x12/0x30
[  191.383211]  sysfs_kf_write+0x3e/0x50
[  191.383640]  kernfs_fop_write_iter+0x140/0x1d0
[  191.384106]  vfs_write+0x271/0x440
[  191.384521]  ksys_write+0x72/0xf0
[  191.384924]  __x64_sys_write+0x19/0x20
[  191.385313]  x64_sys_call+0x2b0/0x20b0
[  191.385736]  do_syscall_64+0x79/0x150
[  191.386146]  ? __mod_memcg_lruvec_state+0xe7/0x240
[  191.386676]  ? __lruvec_stat_mod_folio+0x79/0xb0
[  191.387124]  ? __pfx_lru_add+0x10/0x10
[  191.387515]  ? queued_spin_unlock+0x9/0x10
[  191.387937]  ? do_anonymous_page+0x33c/0xa00
[  191.388374]  ? __handle_mm_fault+0xcf3/0x1210
[  191.388805]  ? __count_memcg_events+0xbe/0x180
[  191.389235]  ? handle_mm_fault+0xae/0x300
[  19
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3e64bb2ae7d9f2b3a8259d4d6b86ed1984d5460a
  - https://git.kernel.org/stable/c/a1466112fb6e819261272ad75e7db750a43b78bf

------------------------------------------------------------

CVE ID: CVE-2025-21954
Description: In the Linux kernel, the following vulnerability has been resolved:

netmem: prevent TX of unreadable skbs

Currently on stable trees we have support for netmem/devmem RX but not
TX. It is not safe to forward/redirect an RX unreadable netmem packet
into the device's TX path, as the device may call dma-mapping APIs on
dma addrs that should not be passed to it.

Fix this by preventing the xmit of unreadable skbs.

Tested by configuring tc redirect:

sudo tc qdisc add dev eth1 ingress
sudo tc filter add dev eth1 ingress protocol ip prio 1 flower ip_proto \
	tcp src_ip 192.168.1.12 action mirred egress redirect dev eth1

Before, I see unreadable skbs in the driver's TX path passed to dma
mapping APIs.

After, I don't see unreadable skbs in the driver's TX path passed to dma
mapping APIs.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c17c8ced25c5fbe424c7ad7ea11d33014a986b1
  - https://git.kernel.org/stable/c/454825019d2f0c59e5174ece9e713f45ad80beff
  - https://git.kernel.org/stable/c/f3600c867c99a2cc8038680ecf211089c50e7971

------------------------------------------------------------

CVE ID: CVE-2025-21955
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: prevent connection release during oplock break notification

ksmbd_work could be freed when after connection release.
Increment r_count of ksmbd_conn to indicate that requests
are not finished yet and to not release the connection.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09aeab68033161cb54f194da93e51a11aee6144b
  - https://git.kernel.org/stable/c/3aa660c059240e0c795217182cf7df32909dd917
  - https://git.kernel.org/stable/c/a4261bbc33fbf99b99c80aa3a2c5097611802980
  - https://git.kernel.org/stable/c/f17d1c63a76b0fe8e9c78023a86507a3a6d62cfa

------------------------------------------------------------

CVE ID: CVE-2025-21956
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Assign normalized_pix_clk when color depth = 14

[WHY & HOW]
A warning message "WARNING: CPU: 4 PID: 459 at ... /dc_resource.c:3397
calculate_phy_pix_clks+0xef/0x100 [amdgpu]" occurs because the
display_color_depth == COLOR_DEPTH_141414 is not handled. This is
observed in Radeon RX 6600 XT.

It is fixed by assigning pix_clk * (14 * 3) / 24 - same as the rests.

Also fixes the indentation in get_norm_pix_clk.

(cherry picked from commit 274a87eb389f58eddcbc5659ab0b180b37e92775)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0174a2e5770efee9dbd4b58963ed4d939298ff5e
  - https://git.kernel.org/stable/c/04f90b505ad3a6eed474bbaa03167095fef5203a
  - https://git.kernel.org/stable/c/0c0016712e5dc23ce4a7e673cbebc24a535d8c8a
  - https://git.kernel.org/stable/c/27df30106690969f7d63604f0d49ed8e9bffa2cb
  - https://git.kernel.org/stable/c/79e31396fdd7037c503e6add15af7cb00633ea92
  - https://git.kernel.org/stable/c/a8f77e1658d78e4a8bb227a83bcee67de97f7634
  - https://git.kernel.org/stable/c/cca3ab74f90176099b6392e8e894b52b27b3d080
  - https://git.kernel.org/stable/c/dc831b38680c47d07e425871a9852109183895cf

------------------------------------------------------------

CVE ID: CVE-2025-21957
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: qla1280: Fix kernel oops when debug level > 2

A null dereference or oops exception will eventually occur when qla1280.c
driver is compiled with DEBUG_QLA1280 enabled and ql_debug_level > 2.  I
think its clear from the code that the intention here is sg_dma_len(s) not
length of sg_next(s) when printing the debug info.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/11a8dac1177a596648a020a7f3708257a2f95fee
  - https://git.kernel.org/stable/c/24602e2664c515a4f2950d7b52c3d5997463418c
  - https://git.kernel.org/stable/c/5233e3235dec3065ccc632729675575dbe3c6b8a
  - https://git.kernel.org/stable/c/7ac2473e727d67a38266b2b7e55c752402ab588c
  - https://git.kernel.org/stable/c/af71ba921d08c241a817010f96458dc5e5e26762
  - https://git.kernel.org/stable/c/afa27b7c17a48e01546ccaad0ab017ad0496a522
  - https://git.kernel.org/stable/c/c737e2a5fb7f90b96a96121da1b50a9c74ae9b8c
  - https://git.kernel.org/stable/c/ea371d1cdefb0951c7127a33bcd7eb931cf44571

------------------------------------------------------------

CVE ID: CVE-2025-21958
Description: In the Linux kernel, the following vulnerability has been resolved:

Revert "openvswitch: switch to per-action label counting in conntrack"

Currently, ovs_ct_set_labels() is only called for confirmed conntrack
entries (ct) within ovs_ct_commit(). However, if the conntrack entry
does not have the labels_ext extension, attempting to allocate it in
ovs_ct_get_conn_labels() for a confirmed entry triggers a warning in
nf_ct_ext_add():

  WARN_ON(nf_ct_is_confirmed(ct));

This happens when the conntrack entry is created externally before OVS
increments net->ct.labels_used. The issue has become more likely since
commit fcb1aa5163b1 ("openvswitch: switch to per-action label counting
in conntrack"), which changed to use per-action label counting and
increment net->ct.labels_used when a flow with ct action is added.

Since there’s no straightforward way to fully resolve this issue at the
moment, this reverts the commit to avoid breaking existing use cases.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1063ae07383c0ddc5bcce170260c143825846b03
  - https://git.kernel.org/stable/c/9e79fdabd52cfce1a021640a81256878a2c516a2
  - https://git.kernel.org/stable/c/d91bfc64a4886102746e74d2c6f3a61e9a77fd7d

------------------------------------------------------------

CVE ID: CVE-2025-21959
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_conncount: Fully initialize struct nf_conncount_tuple in insert_tree()

Since commit b36e4523d4d5 ("netfilter: nf_conncount: fix garbage
collection confirm race"), `cpu` and `jiffies32` were introduced to
the struct nf_conncount_tuple.

The commit made nf_conncount_add() initialize `conn->cpu` and
`conn->jiffies32` when allocating the struct.
In contrast, count_tree() was not changed to initialize them.

By commit 34848d5c896e ("netfilter: nf_conncount: Split insert and
traversal"), count_tree() was split and the relevant allocation
code now resides in insert_tree().
Initialize `conn->cpu` and `conn->jiffies32` in insert_tree().

BUG: KMSAN: uninit-value in find_or_evict net/netfilter/nf_conncount.c:117 [inline]
BUG: KMSAN: uninit-value in __nf_conncount_add+0xd9c/0x2850 net/netfilter/nf_conncount.c:143
 find_or_evict net/netfilter/nf_conncount.c:117 [inline]
 __nf_conncount_add+0xd9c/0x2850 net/netfilter/nf_conncount.c:143
 count_tree net/netfilter/nf_conncount.c:438 [inline]
 nf_conncount_count+0x82f/0x1e80 net/netfilter/nf_conncount.c:521
 connlimit_mt+0x7f6/0xbd0 net/netfilter/xt_connlimit.c:72
 __nft_match_eval net/netfilter/nft_compat.c:403 [inline]
 nft_match_eval+0x1a5/0x300 net/netfilter/nft_compat.c:433
 expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]
 nft_do_chain+0x426/0x2290 net/netfilter/nf_tables_core.c:288
 nft_do_chain_ipv4+0x1a5/0x230 net/netfilter/nft_chain_filter.c:23
 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]
 nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626
 nf_hook_slow_list+0x24d/0x860 net/netfilter/core.c:663
 NF_HOOK_LIST include/linux/netfilter.h:350 [inline]
 ip_sublist_rcv+0x17b7/0x17f0 net/ipv4/ip_input.c:633
 ip_list_rcv+0x9ef/0xa40 net/ipv4/ip_input.c:669
 __netif_receive_skb_list_ptype net/core/dev.c:5936 [inline]
 __netif_receive_skb_list_core+0x15c5/0x1670 net/core/dev.c:5983
 __netif_receive_skb_list net/core/dev.c:6035 [inline]
 netif_receive_skb_list_internal+0x1085/0x1700 net/core/dev.c:6126
 netif_receive_skb_list+0x5a/0x460 net/core/dev.c:6178
 xdp_recv_frames net/bpf/test_run.c:280 [inline]
 xdp_test_run_batch net/bpf/test_run.c:361 [inline]
 bpf_test_run_xdp_live+0x2e86/0x3480 net/bpf/test_run.c:390
 bpf_prog_test_run_xdp+0xf1d/0x1ae0 net/bpf/test_run.c:1316
 bpf_prog_test_run+0x5e5/0xa30 kernel/bpf/syscall.c:4407
 __sys_bpf+0x6aa/0xd90 kernel/bpf/syscall.c:5813
 __do_sys_bpf kernel/bpf/syscall.c:5902 [inline]
 __se_sys_bpf kernel/bpf/syscall.c:5900 [inline]
 __ia32_sys_bpf+0xa0/0xe0 kernel/bpf/syscall.c:5900
 ia32_sys_call+0x394d/0x4180 arch/x86/include/generated/asm/syscalls_32.h:358
 do_syscall_32_irqs_on arch/x86/entry/common.c:165 [inline]
 __do_fast_syscall_32+0xb0/0x110 arch/x86/entry/common.c:387
 do_fast_syscall_32+0x38/0x80 arch/x86/entry/common.c:412
 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:450
 entry_SYSENTER_compat_after_hwframe+0x84/0x8e

Uninit was created at:
 slab_post_alloc_hook mm/slub.c:4121 [inline]
 slab_alloc_node mm/slub.c:4164 [inline]
 kmem_cache_alloc_noprof+0x915/0xe10 mm/slub.c:4171
 insert_tree net/netfilter/nf_conncount.c:372 [inline]
 count_tree net/netfilter/nf_conncount.c:450 [inline]
 nf_conncount_count+0x1415/0x1e80 net/netfilter/nf_conncount.c:521
 connlimit_mt+0x7f6/0xbd0 net/netfilter/xt_connlimit.c:72
 __nft_match_eval net/netfilter/nft_compat.c:403 [inline]
 nft_match_eval+0x1a5/0x300 net/netfilter/nft_compat.c:433
 expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]
 nft_do_chain+0x426/0x2290 net/netfilter/nf_tables_core.c:288
 nft_do_chain_ipv4+0x1a5/0x230 net/netfilter/nft_chain_filter.c:23
 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]
 nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626
 nf_hook_slow_list+0x24d/0x860 net/netfilter/core.c:663
 NF_HOOK_LIST include/linux/netfilter.h:350 [inline]
 ip_sublist_rcv+0x17b7/0x17f0 net/ipv4/ip_input.c:633
 ip_list_rcv+0x9ef/0xa40 net/ip
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.92, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.18, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2a154ce766b995494e88d8d117fa82cc6b73dd87
  - https://git.kernel.org/stable/c/2db5baaf047a7c8d6ed5e2cc657b7854e155b7fc
  - https://git.kernel.org/stable/c/a62a25c6ad58fae997f48a0749afeda1c252ae51
  - https://git.kernel.org/stable/c/d653bfeb07ebb3499c403404c21ac58a16531607
  - https://git.kernel.org/stable/c/db1e0c0856821c59a32ea3af79476bf20a6beeb2
  - https://git.kernel.org/stable/c/e8544a5a97bee3674e7cd6bf0f3a4af517fa9146
  - https://git.kernel.org/stable/c/f522229c5563b59b4240261e406779bba6754159
  - https://git.kernel.org/stable/c/fda50302a13701d47fbe01e1739c7a51114144fb

------------------------------------------------------------

CVE ID: CVE-2025-21960
Description: In the Linux kernel, the following vulnerability has been resolved:

eth: bnxt: do not update checksum in bnxt_xdp_build_skb()

The bnxt_rx_pkt() updates ip_summed value at the end if checksum offload
is enabled.
When the XDP-MB program is attached and it returns XDP_PASS, the
bnxt_xdp_build_skb() is called to update skb_shared_info.
The main purpose of bnxt_xdp_build_skb() is to update skb_shared_info,
but it updates ip_summed value too if checksum offload is enabled.
This is actually duplicate work.

When the bnxt_rx_pkt() updates ip_summed value, it checks if ip_summed
is CHECKSUM_NONE or not.
It means that ip_summed should be CHECKSUM_NONE at this moment.
But ip_summed may already be updated to CHECKSUM_UNNECESSARY in the
XDP-MB-PASS path.
So the by skb_checksum_none_assert() WARNS about it.

This is duplicate work and updating ip_summed in the
bnxt_xdp_build_skb() is not needed.

Splat looks like:
WARNING: CPU: 3 PID: 5782 at ./include/linux/skbuff.h:5155 bnxt_rx_pkt+0x479b/0x7610 [bnxt_en]
Modules linked in: bnxt_re bnxt_en rdma_ucm rdma_cm iw_cm ib_cm ib_uverbs veth xt_nat xt_tcpudp xt_conntrack nft_chain_nat xt_MASQUERADE nf_]
CPU: 3 UID: 0 PID: 5782 Comm: socat Tainted: G        W          6.14.0-rc4+ #27
Tainted: [W]=WARN
Hardware name: ASUS System Product Name/PRIME Z690-P D4, BIOS 0603 11/01/2021
RIP: 0010:bnxt_rx_pkt+0x479b/0x7610 [bnxt_en]
Code: 54 24 0c 4c 89 f1 4c 89 ff c1 ea 1f ff d3 0f 1f 00 49 89 c6 48 85 c0 0f 84 4c e5 ff ff 48 89 c7 e8 ca 3d a0 c8 e9 8f f4 ff ff <0f> 0b f
RSP: 0018:ffff88881ba09928 EFLAGS: 00010202
RAX: 0000000000000000 RBX: 00000000c7590303 RCX: 0000000000000000
RDX: 1ffff1104e7d1610 RSI: 0000000000000001 RDI: ffff8881c91300b8
RBP: ffff88881ba09b28 R08: ffff888273e8b0d0 R09: ffff888273e8b070
R10: ffff888273e8b010 R11: ffff888278b0f000 R12: ffff888273e8b080
R13: ffff8881c9130e00 R14: ffff8881505d3800 R15: ffff888273e8b000
FS:  00007f5a2e7be080(0000) GS:ffff88881ba00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fff2e708ff8 CR3: 000000013e3b0000 CR4: 00000000007506f0
PKRU: 55555554
Call Trace:
 <IRQ>
 ? __warn+0xcd/0x2f0
 ? bnxt_rx_pkt+0x479b/0x7610
 ? report_bug+0x326/0x3c0
 ? handle_bug+0x53/0xa0
 ? exc_invalid_op+0x14/0x50
 ? asm_exc_invalid_op+0x16/0x20
 ? bnxt_rx_pkt+0x479b/0x7610
 ? bnxt_rx_pkt+0x3e41/0x7610
 ? __pfx_bnxt_rx_pkt+0x10/0x10
 ? napi_complete_done+0x2cf/0x7d0
 __bnxt_poll_work+0x4e8/0x1220
 ? __pfx___bnxt_poll_work+0x10/0x10
 ? __pfx_mark_lock.part.0+0x10/0x10
 bnxt_poll_p5+0x36a/0xfa0
 ? __pfx_bnxt_poll_p5+0x10/0x10
 __napi_poll.constprop.0+0xa0/0x440
 net_rx_action+0x899/0xd00
...

Following ping.py patch adds xdp-mb-pass case. so ping.py is going
to be able to reproduce this issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/44578bc6460b8fca530fc7bd5897c115d9bd27e2
  - https://git.kernel.org/stable/c/5b57ed14a1b85e7ab0074d9668a0baa6c94826c7
  - https://git.kernel.org/stable/c/c03e7d05aa0e2f7e9a9ce5ad8a12471a53f941dc
  - https://git.kernel.org/stable/c/e8e3e03d69f2420eaa578199a65d281c58867105
  - https://git.kernel.org/stable/c/ee086c8e775f9690282e3d26471dbcfd5dad5a6a

------------------------------------------------------------

CVE ID: CVE-2025-21961
Description: In the Linux kernel, the following vulnerability has been resolved:

eth: bnxt: fix truesize for mb-xdp-pass case

When mb-xdp is set and return is XDP_PASS, packet is converted from
xdp_buff to sk_buff with xdp_update_skb_shared_info() in
bnxt_xdp_build_skb().
bnxt_xdp_build_skb() passes incorrect truesize argument to
xdp_update_skb_shared_info().
The truesize is calculated as BNXT_RX_PAGE_SIZE * sinfo->nr_frags but
the skb_shared_info was wiped by napi_build_skb() before.
So it stores sinfo->nr_frags before bnxt_xdp_build_skb() and use it
instead of getting skb_shared_info from xdp_get_shared_info_from_buff().

Splat looks like:
 ------------[ cut here ]------------
 WARNING: CPU: 2 PID: 0 at net/core/skbuff.c:6072 skb_try_coalesce+0x504/0x590
 Modules linked in: xt_nat xt_tcpudp veth af_packet xt_conntrack nft_chain_nat xt_MASQUERADE nf_conntrack_netlink xfrm_user xt_addrtype nft_coms
 CPU: 2 UID: 0 PID: 0 Comm: swapper/2 Not tainted 6.14.0-rc2+ #3
 RIP: 0010:skb_try_coalesce+0x504/0x590
 Code: 4b fd ff ff 49 8b 34 24 40 80 e6 40 0f 84 3d fd ff ff 49 8b 74 24 48 40 f6 c6 01 0f 84 2e fd ff ff 48 8d 4e ff e9 25 fd ff ff <0f> 0b e99
 RSP: 0018:ffffb62c4120caa8 EFLAGS: 00010287
 RAX: 0000000000000003 RBX: ffffb62c4120cb14 RCX: 0000000000000ec0
 RDX: 0000000000001000 RSI: ffffa06e5d7dc000 RDI: 0000000000000003
 RBP: ffffa06e5d7ddec0 R08: ffffa06e6120a800 R09: ffffa06e7a119900
 R10: 0000000000002310 R11: ffffa06e5d7dcec0 R12: ffffe4360575f740
 R13: ffffe43600000000 R14: 0000000000000002 R15: 0000000000000002
 FS:  0000000000000000(0000) GS:ffffa0755f700000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007f147b76b0f8 CR3: 00000001615d4000 CR4: 00000000007506f0
 PKRU: 55555554
 Call Trace:
  <IRQ>
  ? __warn+0x84/0x130
  ? skb_try_coalesce+0x504/0x590
  ? report_bug+0x18a/0x1a0
  ? handle_bug+0x53/0x90
  ? exc_invalid_op+0x14/0x70
  ? asm_exc_invalid_op+0x16/0x20
  ? skb_try_coalesce+0x504/0x590
  inet_frag_reasm_finish+0x11f/0x2e0
  ip_defrag+0x37a/0x900
  ip_local_deliver+0x51/0x120
  ip_sublist_rcv_finish+0x64/0x70
  ip_sublist_rcv+0x179/0x210
  ip_list_rcv+0xf9/0x130

How to reproduce:
<Node A>
ip link set $interface1 xdp obj xdp_pass.o
ip link set $interface1 mtu 9000 up
ip a a 10.0.0.1/24 dev $interface1
<Node B>
ip link set $interfac2 mtu 9000 up
ip a a 10.0.0.2/24 dev $interface2
ping 10.0.0.1 -s 65000

Following ping.py patch adds xdp-mb-pass case. so ping.py is going to be
able to reproduce this issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/19107e71be330dbccb9f8f9f4cf0a9abeadad802
  - https://git.kernel.org/stable/c/9f7b2aa5034e24d3c49db73d5f760c0435fe31c2
  - https://git.kernel.org/stable/c/b4679807c6083ade4d47f03f80da891afcb6ef62

------------------------------------------------------------

CVE ID: CVE-2025-21962
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: Fix integer overflow while processing closetimeo mount option

User-provided mount parameter closetimeo of type u32 is intended to have
an upper limit, but before it is validated, the value is converted from
seconds to jiffies which can lead to an integer overflow.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.107, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1c46673be93dd2954f44fe370fb4f2b8e6214224
  - https://git.kernel.org/stable/c/513f6cf2e906a504b7ab0b62b2eea993a6f64558
  - https://git.kernel.org/stable/c/6c13fcb7cf59ae65940da1dfea80144e42921e53
  - https://git.kernel.org/stable/c/9968fcf02cf6b0f78fbacf3f63e782162603855a
  - https://git.kernel.org/stable/c/b24edd5c191c2689c59d0509f0903f9487eb6317
  - https://git.kernel.org/stable/c/d5a30fddfe2f2e540f6c43b59cf701809995faef

------------------------------------------------------------

CVE ID: CVE-2025-21963
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: Fix integer overflow while processing acdirmax mount option

User-provided mount parameter acdirmax of type u32 is intended to have
an upper limit, but before it is validated, the value is converted from
seconds to jiffies which can lead to an integer overflow.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0c26edf477e093cefc41637f5bccc102e1a77399
  - https://git.kernel.org/stable/c/2809a79bc64964ce02e0c5f2d6bd39b9d09bdb3c
  - https://git.kernel.org/stable/c/39d086bb3558da9640ef335f97453e01d32578a1
  - https://git.kernel.org/stable/c/5b29891f91dfb8758baf1e2217bef4b16b2b165b
  - https://git.kernel.org/stable/c/6124cbf73e3dea7591857dd63b8ccece28952afd
  - https://git.kernel.org/stable/c/9e438d0410a4002d24f420f2c28897ba2dc0af64

------------------------------------------------------------

CVE ID: CVE-2025-21964
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: Fix integer overflow while processing acregmax mount option

User-provided mount parameter acregmax of type u32 is intended to have
an upper limit, but before it is validated, the value is converted from
seconds to jiffies which can lead to an integer overflow.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0252c33cc943e9e48ddfafaa6b1eb72adb68a099
  - https://git.kernel.org/stable/c/5f500874ab9b3cc8c169c2ab49f00b838520b9c5
  - https://git.kernel.org/stable/c/7489161b1852390b4413d57f2457cd40b34da6cc
  - https://git.kernel.org/stable/c/833f2903eb8b70faca7967319e580e9ce69729fc
  - https://git.kernel.org/stable/c/a13351624a6af8d91398860b8c9d4cf6c8e63de5
  - https://git.kernel.org/stable/c/dd190168e60ac15408f074a1fe0ce36aff34027b

------------------------------------------------------------

CVE ID: CVE-2025-21965
Description: In the Linux kernel, the following vulnerability has been resolved:

sched_ext: Validate prev_cpu in scx_bpf_select_cpu_dfl()

If a BPF scheduler provides an invalid CPU (outside the nr_cpu_ids
range) as prev_cpu to scx_bpf_select_cpu_dfl() it can cause a kernel
crash.

To prevent this, validate prev_cpu in scx_bpf_select_cpu_dfl() and
trigger an scx error if an invalid CPU is specified.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/515680e76c536dd4aa8e2b5d674b0d441baddf5b
  - https://git.kernel.org/stable/c/752b56bb76e2471197d25d6948d85753043b10da
  - https://git.kernel.org/stable/c/9360dfe4cbd62ff1eb8217b815964931523b75b3

------------------------------------------------------------

CVE ID: CVE-2025-21966
Description: In the Linux kernel, the following vulnerability has been resolved:

dm-flakey: Fix memory corruption in optional corrupt_bio_byte feature

Fix memory corruption due to incorrect parameter being passed to bio_init
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.5, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/57e9417f69839cb10f7ffca684c38acd28ceb57b
  - https://git.kernel.org/stable/c/5a87e46da2418c57b445371f5ca0958d5779ba5f
  - https://git.kernel.org/stable/c/818330f756f3800c37d738bd36bce60eac949938
  - https://git.kernel.org/stable/c/da070843e153471be4297a12fdaa64023276f40e

------------------------------------------------------------

CVE ID: CVE-2025-21967
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix use-after-free in ksmbd_free_work_struct

->interim_entry of ksmbd_work could be deleted after oplock is freed.
We don't need to manage it with linked list. The interim request could be
immediately sent whenever a oplock break wait is needed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/62746ae3f5414244a96293e3b017be637b641280
  - https://git.kernel.org/stable/c/bb39ed47065455604729404729d9116868638d31
  - https://git.kernel.org/stable/c/eb51f6f59d19b92f6fe84d3873f958495ab32f0a
  - https://git.kernel.org/stable/c/fb776765bfc21d5e4ed03bb3d4406c2b86ff1ac3

------------------------------------------------------------

CVE ID: CVE-2025-21968
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix slab-use-after-free on hdcp_work

[Why]
A slab-use-after-free is reported when HDCP is destroyed but the
property_validate_dwork queue is still running.

[How]
Cancel the delayed work when destroying workqueue.

(cherry picked from commit 725a04ba5a95e89c89633d4322430cfbca7ce128)
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/06acfdef370ae018dad9592369e2d2fd9a40c09e
  - https://git.kernel.org/stable/c/1397715b011bcdc6ad91b17df7acaee301e89db5
  - https://git.kernel.org/stable/c/378b361e2e30e9729f9a7676f7926868d14f4326
  - https://git.kernel.org/stable/c/4964dbc4191ab436877a5e3ecd9c67a4e50b7c36
  - https://git.kernel.org/stable/c/93d701064e56788663d7c5918fbe5e060d5df587
  - https://git.kernel.org/stable/c/bac7b8b1a3f1a86eeec85835af106cbdc2b9d9f7
  - https://git.kernel.org/stable/c/e65e7bea220c3ce8c4c793b4ba35557f4994ab2b

------------------------------------------------------------

CVE ID: CVE-2025-21969
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd

After the hci sync command releases l2cap_conn, the hci receive data work
queue references the released l2cap_conn when sending to the upper layer.
Add hci dev lock to the hci receive data work queue to synchronize the two.

[1]
BUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954
Read of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837

CPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
Workqueue: hci1 hci_rx_work
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:378 [inline]
 print_report+0x169/0x550 mm/kasan/report.c:489
 kasan_report+0x143/0x180 mm/kasan/report.c:602
 l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline]
 l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954
 l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline]
 l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline]
 l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817
 hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline]
 hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040
 process_one_work kernel/workqueue.c:3229 [inline]
 process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310
 worker_thread+0x870/0xd30 kernel/workqueue.c:3391
 kthread+0x2f0/0x390 kernel/kthread.c:389
 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
 </TASK>

Allocated by task 5837:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
 poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
 __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329
 kmalloc_noprof include/linux/slab.h:901 [inline]
 kzalloc_noprof include/linux/slab.h:1037 [inline]
 l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860
 l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239
 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]
 hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726
 hci_event_func net/bluetooth/hci_event.c:7473 [inline]
 hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525
 hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035
 process_one_work kernel/workqueue.c:3229 [inline]
 process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310
 worker_thread+0x870/0xd30 kernel/workqueue.c:3391
 kthread+0x2f0/0x390 kernel/kthread.c:389
 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

Freed by task 54:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582
 poison_slab_object mm/kasan/common.c:247 [inline]
 __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264
 kasan_slab_free include/linux/kasan.h:233 [inline]
 slab_free_hook mm/slub.c:2353 [inline]
 slab_free mm/slub.c:4613 [inline]
 kfree+0x196/0x430 mm/slub.c:4761
 l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235
 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]
 hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266
 hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603
 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332
 process_one_work kernel/workqueue.c:3229 [inline]
 process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310
 worker_thread+0x870/0xd30 kernel/workqueue.c:3391
 kthread+0x2f0/0x390 kernel/kthread.c:389
 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entr
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/7790a79c6fce8d5d552bc64f5c82819f719e4f28
  - https://git.kernel.org/stable/c/b4f82f9ed43aefa79bec2504ae8c29be0c0f5d1d
  - https://git.kernel.org/stable/c/c96cce853542b3b13da3738f35ef1be8cfcc9d1d
  - https://git.kernel.org/stable/c/f8094625a591eeb0b75b1bd9e713fac1d93f5ca9

------------------------------------------------------------

CVE ID: CVE-2025-21970
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Bridge, fix the crash caused by LAG state check

When removing LAG device from bridge, NETDEV_CHANGEUPPER event is
triggered. Driver finds the lower devices (PFs) to flush all the
offloaded entries. And mlx5_lag_is_shared_fdb is checked, it returns
false if one of PF is unloaded. In such case,
mlx5_esw_bridge_lag_rep_get() and its caller return NULL, instead of
the alive PF, and the flush is skipped.

Besides, the bridge fdb entry's lastuse is updated in mlx5 bridge
event handler. But this SWITCHDEV_FDB_ADD_TO_BRIDGE event can be
ignored in this case because the upper interface for bond is deleted,
and the entry will never be aged because lastuse is never updated.

To make things worse, as the entry is alive, mlx5 bridge workqueue
keeps sending that event, which is then handled by kernel bridge
notifier. It causes the following crash when accessing the passed bond
netdev which is already destroyed.

To fix this issue, remove such checks. LAG state is already checked in
commit 15f8f168952f ("net/mlx5: Bridge, verify LAG state when adding
bond to bridge"), driver still need to skip offload if LAG becomes
invalid state after initialization.

 Oops: stack segment: 0000 [#1] SMP
 CPU: 3 UID: 0 PID: 23695 Comm: kworker/u40:3 Tainted: G           OE      6.11.0_mlnx #1
 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
 Workqueue: mlx5_bridge_wq mlx5_esw_bridge_update_work [mlx5_core]
 RIP: 0010:br_switchdev_event+0x2c/0x110 [bridge]
 Code: 44 00 00 48 8b 02 48 f7 00 00 02 00 00 74 69 41 54 55 53 48 83 ec 08 48 8b a8 08 01 00 00 48 85 ed 74 4a 48 83 fe 02 48 89 d3 <4c> 8b 65 00 74 23 76 49 48 83 fe 05 74 7e 48 83 fe 06 75 2f 0f b7
 RSP: 0018:ffffc900092cfda0 EFLAGS: 00010297
 RAX: ffff888123bfe000 RBX: ffffc900092cfe08 RCX: 00000000ffffffff
 RDX: ffffc900092cfe08 RSI: 0000000000000001 RDI: ffffffffa0c585f0
 RBP: 6669746f6e690a30 R08: 0000000000000000 R09: ffff888123ae92c8
 R10: 0000000000000000 R11: fefefefefefefeff R12: ffff888123ae9c60
 R13: 0000000000000001 R14: ffffc900092cfe08 R15: 0000000000000000
 FS:  0000000000000000(0000) GS:ffff88852c980000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007f15914c8734 CR3: 0000000002830005 CR4: 0000000000770ef0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 PKRU: 55555554
 Call Trace:
  <TASK>
  ? __die_body+0x1a/0x60
  ? die+0x38/0x60
  ? do_trap+0x10b/0x120
  ? do_error_trap+0x64/0xa0
  ? exc_stack_segment+0x33/0x50
  ? asm_exc_stack_segment+0x22/0x30
  ? br_switchdev_event+0x2c/0x110 [bridge]
  ? sched_balance_newidle.isra.149+0x248/0x390
  notifier_call_chain+0x4b/0xa0
  atomic_notifier_call_chain+0x16/0x20
  mlx5_esw_bridge_update+0xec/0x170 [mlx5_core]
  mlx5_esw_bridge_update_work+0x19/0x40 [mlx5_core]
  process_scheduled_works+0x81/0x390
  worker_thread+0x106/0x250
  ? bh_worker+0x110/0x110
  kthread+0xb7/0xe0
  ? kthread_park+0x80/0x80
  ret_from_fork+0x2d/0x50
  ? kthread_park+0x80/0x80
  ret_from_fork_asm+0x11/0x20
  </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4b8eeed4fb105770ce6dc84a2c6ef953c7b71cbb
  - https://git.kernel.org/stable/c/5dd8bf6ab1d6db40f5d09603759fa88caec19e7f
  - https://git.kernel.org/stable/c/86ff45f5f61ae1d0d17f0f6d8797b052eacfd8f1
  - https://git.kernel.org/stable/c/bd7e3a42800743a7748c83243e4cafc1b995d4c4
  - https://git.kernel.org/stable/c/f7bf259a04271165ae667ad21cfc60c6413f25ca
  - https://git.kernel.org/stable/c/f90c4d6572488e2bad38cca00f1c59174a538a1a

------------------------------------------------------------

CVE ID: CVE-2025-21971
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: Prevent creation of classes with TC_H_ROOT

The function qdisc_tree_reduce_backlog() uses TC_H_ROOT as a termination
condition when traversing up the qdisc tree to update parent backlog
counters. However, if a class is created with classid TC_H_ROOT, the
traversal terminates prematurely at this class instead of reaching the
actual root qdisc, causing parent statistics to be incorrectly maintained.
In case of DRR, this could lead to a crash as reported by Mingi Cho.

Prevent the creation of any Qdisc class with classid TC_H_ROOT
(0xFFFFFFFF) across all qdisc types, as suggested by Jamal.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/003d92c91cdb5a64b25a9a74cb8543aac9a8bb48
  - https://git.kernel.org/stable/c/0c3057a5a04d07120b3d0ec9c79568fceb9c921e
  - https://git.kernel.org/stable/c/5c3ca9cb48b51bd72bf76b8b05e24f3cd53db5e7
  - https://git.kernel.org/stable/c/78533c4a29ac3aeddce4b481770beaaa4f3bfb67
  - https://git.kernel.org/stable/c/7a82fe67a9f4d7123d8e5ba8f0f0806c28695006
  - https://git.kernel.org/stable/c/94edfdfb9505ab608e86599d1d1e38c83816fc1c
  - https://git.kernel.org/stable/c/e05d9938b1b0ac40b6054cc5fa0ccbd9afd5ed4c
  - https://git.kernel.org/stable/c/e5ee00607bbfc97ef1526ea95b6b2458ac9e7cb7

------------------------------------------------------------

CVE ID: CVE-2025-21972
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mctp: unshare packets when reassembling

Ensure that the frag_list used for reassembly isn't shared with other
packets. This avoids incorrect reassembly when packets are cloned, and
prevents a memory leak due to circular references between fragments and
their skb_shared_info.

The upcoming MCTP-over-USB driver uses skb_clone which can trigger the
problem - other MCTP drivers don't share SKBs.

A kunit test is added to reproduce the issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5c47d5bfa7b096cf8890afac32141c578583f8e0
  - https://git.kernel.org/stable/c/f44fff3d3c6cd67b6f348b821d73c4d6888c7a6e
  - https://git.kernel.org/stable/c/f5d83cf0eeb90fade4d5c4d17d24b8bee9ceeecc

------------------------------------------------------------

CVE ID: CVE-2025-21973
Description: In the Linux kernel, the following vulnerability has been resolved:

eth: bnxt: fix kernel panic in the bnxt_get_queue_stats{rx | tx}

When qstats-get operation is executed, callbacks of netdev_stats_ops
are called. The bnxt_get_queue_stats{rx | tx} collect per-queue stats
from sw_stats in the rings.
But {rx | tx | cp}_ring are allocated when the interface is up.
So, these rings are not allocated when the interface is down.

The qstats-get is allowed even if the interface is down. However,
the bnxt_get_queue_stats{rx | tx}() accesses cp_ring and tx_ring
without null check.
So, it needs to avoid accessing rings if the interface is down.

Reproducer:
 ip link set $interface down
 ./cli.py --spec netdev.yaml --dump qstats-get
OR
 ip link set $interface down
 python ./stats.py

Splat looks like:
 BUG: kernel NULL pointer dereference, address: 0000000000000000
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 1680fa067 P4D 1680fa067 PUD 16be3b067 PMD 0
 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
 CPU: 0 UID: 0 PID: 1495 Comm: python3 Not tainted 6.14.0-rc4+ #32 5cd0f999d5a15c574ac72b3e4b907341
 Hardware name: ASUS System Product Name/PRIME Z690-P D4, BIOS 0603 11/01/2021
 RIP: 0010:bnxt_get_queue_stats_rx+0xf/0x70 [bnxt_en]
 Code: c6 87 b5 18 00 00 02 eb a2 66 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 01
 RSP: 0018:ffffabef43cdb7e0 EFLAGS: 00010282
 RAX: 0000000000000000 RBX: ffffffffc04c8710 RCX: 0000000000000000
 RDX: ffffabef43cdb858 RSI: 0000000000000000 RDI: ffff8d504e850000
 RBP: ffff8d506c9f9c00 R08: 0000000000000004 R09: ffff8d506bcd901c
 R10: 0000000000000015 R11: ffff8d506bcd9000 R12: 0000000000000000
 R13: ffffabef43cdb8c0 R14: ffff8d504e850000 R15: 0000000000000000
 FS:  00007f2c5462b080(0000) GS:ffff8d575f600000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000000000000 CR3: 0000000167fd0000 CR4: 00000000007506f0
 PKRU: 55555554
 Call Trace:
  <TASK>
  ? __die+0x20/0x70
  ? page_fault_oops+0x15a/0x460
  ? sched_balance_find_src_group+0x58d/0xd10
  ? exc_page_fault+0x6e/0x180
  ? asm_exc_page_fault+0x22/0x30
  ? bnxt_get_queue_stats_rx+0xf/0x70 [bnxt_en cdd546fd48563c280cfd30e9647efa420db07bf1]
  netdev_nl_stats_by_netdev+0x2b1/0x4e0
  ? xas_load+0x9/0xb0
  ? xas_find+0x183/0x1d0
  ? xa_find+0x8b/0xe0
  netdev_nl_qstats_get_dumpit+0xbf/0x1e0
  genl_dumpit+0x31/0x90
  netlink_dump+0x1a8/0x360
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/adb830085f0fc3a09a0fc8b64fed2e7c8d244665
  - https://git.kernel.org/stable/c/f059a0fd733078c3832fd0f3a3037aa5975d3d36
  - https://git.kernel.org/stable/c/f09af5fdfbd9b0fcee73aab1116904c53b199e97

------------------------------------------------------------

CVE ID: CVE-2025-21974
Description: In the Linux kernel, the following vulnerability has been resolved:

eth: bnxt: return fail if interface is down in bnxt_queue_mem_alloc()

The bnxt_queue_mem_alloc() is called to allocate new queue memory when
a queue is restarted.
It internally accesses rx buffer descriptor corresponding to the index.
The rx buffer descriptor is allocated and set when the interface is up
and it's freed when the interface is down.
So, if queue is restarted if interface is down, kernel panic occurs.

Splat looks like:
 BUG: unable to handle page fault for address: 000000000000b240
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 0 P4D 0
 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
 CPU: 3 UID: 0 PID: 1563 Comm: ncdevmem2 Not tainted 6.14.0-rc2+ #9 844ddba6e7c459cafd0bf4db9a3198e
 Hardware name: ASUS System Product Name/PRIME Z690-P D4, BIOS 0603 11/01/2021
 RIP: 0010:bnxt_queue_mem_alloc+0x3f/0x4e0 [bnxt_en]
 Code: 41 54 4d 89 c4 4d 69 c0 c0 05 00 00 55 48 89 f5 53 48 89 fb 4c 8d b5 40 05 00 00 48 83 ec 15
 RSP: 0018:ffff9dcc83fef9e8 EFLAGS: 00010202
 RAX: ffffffffc0457720 RBX: ffff934ed8d40000 RCX: 0000000000000000
 RDX: 000000000000001f RSI: ffff934ea508f800 RDI: ffff934ea508f808
 RBP: ffff934ea508f800 R08: 000000000000b240 R09: ffff934e84f4b000
 R10: ffff9dcc83fefa30 R11: ffff934e84f4b000 R12: 000000000000001f
 R13: ffff934ed8d40ac0 R14: ffff934ea508fd40 R15: ffff934e84f4b000
 FS:  00007fa73888c740(0000) GS:ffff93559f780000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 000000000000b240 CR3: 0000000145a2e000 CR4: 00000000007506f0
 PKRU: 55555554
 Call Trace:
  <TASK>
  ? __die+0x20/0x70
  ? page_fault_oops+0x15a/0x460
  ? exc_page_fault+0x6e/0x180
  ? asm_exc_page_fault+0x22/0x30
  ? __pfx_bnxt_queue_mem_alloc+0x10/0x10 [bnxt_en 7f85e76f4d724ba07471d7e39d9e773aea6597b7]
  ? bnxt_queue_mem_alloc+0x3f/0x4e0 [bnxt_en 7f85e76f4d724ba07471d7e39d9e773aea6597b7]
  netdev_rx_queue_restart+0xc5/0x240
  net_devmem_bind_dmabuf_to_queue+0xf8/0x200
  netdev_nl_bind_rx_doit+0x3a7/0x450
  genl_family_rcv_msg_doit+0xd9/0x130
  genl_rcv_msg+0x184/0x2b0
  ? __pfx_netdev_nl_bind_rx_doit+0x10/0x10
  ? __pfx_genl_rcv_msg+0x10/0x10
  netlink_rcv_skb+0x54/0x100
  genl_rcv+0x24/0x40
...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/14eb5f0d6554653f4b159835c2f77b2a9bd7e9be
  - https://git.kernel.org/stable/c/ca2456e073957781e1184de68551c65161b2bd30
  - https://git.kernel.org/stable/c/d3b8cd8a8a98c7c83a693bd651f1919be36a57f2

------------------------------------------------------------

CVE ID: CVE-2025-21975
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: handle errors in mlx5_chains_create_table()

In mlx5_chains_create_table(), the return value of mlx5_get_fdb_sub_ns()
and mlx5_get_flow_namespace() must be checked to prevent NULL pointer
dereferences. If either function fails, the function should log error
message with mlx5_core_warn() and return error pointer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/093b4aaec97ec048623e3fe1e516fc45a954d412
  - https://git.kernel.org/stable/c/1598307c914ba3d2642a2b03d1ff11efbdb7c6c2
  - https://git.kernel.org/stable/c/15bdd93728369b2c8942a8e5d549d4b5dc04a2d9
  - https://git.kernel.org/stable/c/1d34296409a519b4027750e3e82d9e19553a7398
  - https://git.kernel.org/stable/c/29c419c64e9b396baeda1d8713d2aa3ba7c0acf6
  - https://git.kernel.org/stable/c/637105ef0d46fe5beac15aceb431da3ec832bb00
  - https://git.kernel.org/stable/c/eab0396353be1c778eba1c0b5180176f04dd21ce

------------------------------------------------------------

CVE ID: CVE-2025-21976
Description: In the Linux kernel, the following vulnerability has been resolved:

fbdev: hyperv_fb: Allow graceful removal of framebuffer

When a Hyper-V framebuffer device is unbind, hyperv_fb driver tries to
release the framebuffer forcefully. If this framebuffer is in use it
produce the following WARN and hence this framebuffer is never released.

[   44.111220] WARNING: CPU: 35 PID: 1882 at drivers/video/fbdev/core/fb_info.c:70 framebuffer_release+0x2c/0x40
< snip >
[   44.111289] Call Trace:
[   44.111290]  <TASK>
[   44.111291]  ? show_regs+0x6c/0x80
[   44.111295]  ? __warn+0x8d/0x150
[   44.111298]  ? framebuffer_release+0x2c/0x40
[   44.111300]  ? report_bug+0x182/0x1b0
[   44.111303]  ? handle_bug+0x6e/0xb0
[   44.111306]  ? exc_invalid_op+0x18/0x80
[   44.111308]  ? asm_exc_invalid_op+0x1b/0x20
[   44.111311]  ? framebuffer_release+0x2c/0x40
[   44.111313]  ? hvfb_remove+0x86/0xa0 [hyperv_fb]
[   44.111315]  vmbus_remove+0x24/0x40 [hv_vmbus]
[   44.111323]  device_remove+0x40/0x80
[   44.111325]  device_release_driver_internal+0x20b/0x270
[   44.111327]  ? bus_find_device+0xb3/0xf0

Fix this by moving the release of framebuffer and assosiated memory
to fb_ops.fb_destroy function, so that framebuffer framework handles
it gracefully.

While we fix this, also replace manual registrations/unregistration of
framebuffer with devm_register_framebuffer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4545e2aa121aea304d33903099c03e29ed4fe50a
  - https://git.kernel.org/stable/c/a7b583dc99c6cf4a96877017be1d08247e1ef2c7
  - https://git.kernel.org/stable/c/ea2f45ab0e53b255f72c85ccd99e2b394fc5fceb

------------------------------------------------------------

CVE ID: CVE-2025-21977
Description: In the Linux kernel, the following vulnerability has been resolved:

fbdev: hyperv_fb: Fix hang in kdump kernel when on Hyper-V Gen 2 VMs

Gen 2 Hyper-V VMs boot via EFI and have a standard EFI framebuffer
device. When the kdump kernel runs in such a VM, loading the efifb
driver may hang because of accessing the framebuffer at the wrong
memory address.

The scenario occurs when the hyperv_fb driver in the original kernel
moves the framebuffer to a different MMIO address because of conflicts
with an already-running efifb or simplefb driver. The hyperv_fb driver
then informs Hyper-V of the change, which is allowed by the Hyper-V FB
VMBus device protocol. However, when the kexec command loads the kdump
kernel into crash memory via the kexec_file_load() system call, the
system call doesn't know the framebuffer has moved, and it sets up the
kdump screen_info using the original framebuffer address. The transition
to the kdump kernel does not go through the Hyper-V host, so Hyper-V
does not reset the framebuffer address like it would do on a reboot.
When efifb tries to run, it accesses a non-existent framebuffer
address, which traps to the Hyper-V host. After many such accesses,
the Hyper-V host thinks the guest is being malicious, and throttles
the guest to the point that it runs very slowly or appears to have hung.

When the kdump kernel is loaded into crash memory via the kexec_load()
system call, the problem does not occur. In this case, the kexec command
builds the screen_info table itself in user space from data returned
by the FBIOGET_FSCREENINFO ioctl against /dev/fb0, which gives it the
new framebuffer location.

This problem was originally reported in 2020 [1], resulting in commit
3cb73bc3fa2a ("hyperv_fb: Update screen_info after removing old
framebuffer"). This commit solved the problem by setting orig_video_isVGA
to 0, so the kdump kernel was unaware of the EFI framebuffer. The efifb
driver did not try to load, and no hang occurred. But in 2024, commit
c25a19afb81c ("fbdev/hyperv_fb: Do not clear global screen_info")
effectively reverted 3cb73bc3fa2a. Commit c25a19afb81c has no reference
to 3cb73bc3fa2a, so perhaps it was done without knowing the implications
that were reported with 3cb73bc3fa2a. In any case, as of commit
c25a19afb81c, the original problem came back again.

Interestingly, the hyperv_drm driver does not have this problem because
it never moves the framebuffer. The difference is that the hyperv_drm
driver removes any conflicting framebuffers *before* allocating an MMIO
address, while the hyperv_fb drivers removes conflicting framebuffers
*after* allocating an MMIO address. With the "after" ordering, hyperv_fb
may encounter a conflict and move the framebuffer to a different MMIO
address. But the conflict is essentially bogus because it is removed
a few lines of code later.

Rather than fix the problem with the approach from 2020 in commit
3cb73bc3fa2a, instead slightly reorder the steps in hyperv_fb so
conflicting framebuffers are removed before allocating an MMIO address.
Then the default framebuffer MMIO address should always be available, and
there's never any confusion about which framebuffer address the kdump
kernel should use -- it's always the original address provided by
the Hyper-V host. This approach is already used by the hyperv_drm
driver, and is consistent with the usage guidelines at the head of
the module with the function aperture_remove_conflicting_devices().

This approach also solves a related minor problem when kexec_load()
is used to load the kdump kernel. With current code, unbinding and
rebinding the hyperv_fb driver could result in the framebuffer moving
back to the default framebuffer address, because on the rebind there
are no conflicts. If such a move is done after the kdump kernel is
loaded with the new framebuffer address, at kdump time it could again
have the wrong address.

This problem and fix are described in terms of the kdump kernel, but
it can also occur
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2924802d35e00a36b1503a4e786f1926b2fdc1d0
  - https://git.kernel.org/stable/c/304386373007aaca9236a3f36afac0bbedcd2bf0
  - https://git.kernel.org/stable/c/cfffe46a994ac6d5de3b119917680ea1e9a96125

------------------------------------------------------------

CVE ID: CVE-2025-21978
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/hyperv: Fix address space leak when Hyper-V DRM device is removed

When a Hyper-V DRM device is probed, the driver allocates MMIO space for
the vram, and maps it cacheable. If the device removed, or in the error
path for device probing, the MMIO space is released but no unmap is done.
Consequently the kernel address space for the mapping is leaked.

Fix this by adding iounmap() calls in the device removal path, and in the
error path during device probing.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/158242b56bf465a73e1edeac0fe828a8acad4499
  - https://git.kernel.org/stable/c/24f1bbfb2be77dad82489c1468bbb14312aab129
  - https://git.kernel.org/stable/c/ad27b4a51495490b815580d9b935e8eee14d1a9c
  - https://git.kernel.org/stable/c/aed709355fd05ef747e1af24a1d5d78cd7feb81e
  - https://git.kernel.org/stable/c/c40cd24bfb9bfbb315c118ca14ebe6cf52e2dd1e

------------------------------------------------------------

CVE ID: CVE-2025-21979
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: cancel wiphy_work before freeing wiphy

A wiphy_work can be queued from the moment the wiphy is allocated and
initialized (i.e. wiphy_new_nm). When a wiphy_work is queued, the
rdev::wiphy_work is getting queued.

If wiphy_free is called before the rdev::wiphy_work had a chance to run,
the wiphy memory will be freed, and then when it eventally gets to run
it'll use invalid memory.

Fix this by canceling the work before freeing the wiphy.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.57, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.5, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0272d4af7f92997541d8bbf4c51918b93ded6ee2
  - https://git.kernel.org/stable/c/72d520476a2fab6f3489e8388ab524985d6c4b90
  - https://git.kernel.org/stable/c/75d262ad3c36d52852d764588fcd887f0fcd9138
  - https://git.kernel.org/stable/c/a5158d67bff06cb6fea31be39aeb319fd908ed8e
  - https://git.kernel.org/stable/c/dea22de162058216a90f2706f0d0b36f0ff309fd

------------------------------------------------------------

CVE ID: CVE-2025-21980
Description: In the Linux kernel, the following vulnerability has been resolved:

sched: address a potential NULL pointer dereference in the GRED scheduler.

If kzalloc in gred_init returns a NULL pointer, the code follows the
error handling path, invoking gred_destroy. This, in turn, calls
gred_offload, where memset could receive a NULL pointer as input,
potentially leading to a kernel crash.

When table->opt is NULL in gred_init(), gred_change_table_def()
is not called yet, so it is not necessary to call ->ndo_setup_tc()
in gred_offload().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0f0a152957d64ce45b4c27c687e7d087e8f45079
  - https://git.kernel.org/stable/c/115ef44a98220fddfab37a39a19370497cd718b9
  - https://git.kernel.org/stable/c/5f996b4f80c2cef1f9c77275055e7fcba44c9199
  - https://git.kernel.org/stable/c/68896dd50180b38ea552e49a6a00b685321e5769
  - https://git.kernel.org/stable/c/d02c9acd68950a444acda18d514e2b41f846cb7f

------------------------------------------------------------

CVE ID: CVE-2025-21981
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: fix memory leak in aRFS after reset

Fix aRFS (accelerated Receive Flow Steering) structures memory leak by
adding a checker to verify if aRFS memory is already allocated while
configuring VSI. aRFS objects are allocated in two cases:
- as part of VSI initialization (at probe), and
- as part of reset handling

However, VSI reconfiguration executed during reset involves memory
allocation one more time, without prior releasing already allocated
resources. This led to the memory leak with the following signature:

[root@os-delivery ~]# cat /sys/kernel/debug/kmemleak
unreferenced object 0xff3c1ca7252e6000 (size 8192):
  comm "kworker/0:0", pid 8, jiffies 4296833052
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace (crc 0):
    [<ffffffff991ec485>] __kmalloc_cache_noprof+0x275/0x340
    [<ffffffffc0a6e06a>] ice_init_arfs+0x3a/0xe0 [ice]
    [<ffffffffc09f1027>] ice_vsi_cfg_def+0x607/0x850 [ice]
    [<ffffffffc09f244b>] ice_vsi_setup+0x5b/0x130 [ice]
    [<ffffffffc09c2131>] ice_init+0x1c1/0x460 [ice]
    [<ffffffffc09c64af>] ice_probe+0x2af/0x520 [ice]
    [<ffffffff994fbcd3>] local_pci_probe+0x43/0xa0
    [<ffffffff98f07103>] work_for_cpu_fn+0x13/0x20
    [<ffffffff98f0b6d9>] process_one_work+0x179/0x390
    [<ffffffff98f0c1e9>] worker_thread+0x239/0x340
    [<ffffffff98f14abc>] kthread+0xcc/0x100
    [<ffffffff98e45a6d>] ret_from_fork+0x2d/0x50
    [<ffffffff98e083ba>] ret_from_fork_asm+0x1a/0x30
    ...
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.8, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/23d97f18901ef5e4e264e3b1777fe65c760186b5
  - https://git.kernel.org/stable/c/3b27e6e10a32589fcd293b8933ab6de9387a460e
  - https://git.kernel.org/stable/c/5d30d256661fc11b6e73fac6c3783a702e1006a3
  - https://git.kernel.org/stable/c/78f3d64b30210c0e521c59357431aca14024cb79
  - https://git.kernel.org/stable/c/e6902101f34f098af59b0d1d8cf90c4124c02c6a
  - https://git.kernel.org/stable/c/ef2bc94059836a115430a6ad9d2838b0b34dc8f5
  - https://git.kernel.org/stable/c/fcbacc47d16306c87ad1b820b7a575f6e9eae58b

------------------------------------------------------------

CVE ID: CVE-2025-21982
Description: In the Linux kernel, the following vulnerability has been resolved:

pinctrl: nuvoton: npcm8xx: Add NULL check in npcm8xx_gpio_fw

devm_kasprintf() calls can return null pointers on failure.
But the return values were not checked in npcm8xx_gpio_fw().
Add NULL check in npcm8xx_gpio_fw(), to handle kernel NULL
pointer dereference error.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6a08a86e5aff8e65368ccd463348fdda26100821
  - https://git.kernel.org/stable/c/a585f6ea42ec259a9a57e3e2580fa527c92187d0
  - https://git.kernel.org/stable/c/acf40ab42799e4ae1397ee6f5c5941092d66f999

------------------------------------------------------------

CVE ID: CVE-2025-21983
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/slab/kvfree_rcu: Switch to WQ_MEM_RECLAIM wq

Currently kvfree_rcu() APIs use a system workqueue which is
"system_unbound_wq" to driver RCU machinery to reclaim a memory.

Recently, it has been noted that the following kernel warning can
be observed:

<snip>
workqueue: WQ_MEM_RECLAIM nvme-wq:nvme_scan_work is flushing !WQ_MEM_RECLAIM events_unbound:kfree_rcu_work
  WARNING: CPU: 21 PID: 330 at kernel/workqueue.c:3719 check_flush_dependency+0x112/0x120
  Modules linked in: intel_uncore_frequency(E) intel_uncore_frequency_common(E) skx_edac(E) ...
  CPU: 21 UID: 0 PID: 330 Comm: kworker/u144:6 Tainted: G            E      6.13.2-0_g925d379822da #1
  Hardware name: Wiwynn Twin Lakes MP/Twin Lakes Passive MP, BIOS YMM20 02/01/2023
  Workqueue: nvme-wq nvme_scan_work
  RIP: 0010:check_flush_dependency+0x112/0x120
  Code: 05 9a 40 14 02 01 48 81 c6 c0 00 00 00 48 8b 50 18 48 81 c7 c0 00 00 00 48 89 f9 48 ...
  RSP: 0018:ffffc90000df7bd8 EFLAGS: 00010082
  RAX: 000000000000006a RBX: ffffffff81622390 RCX: 0000000000000027
  RDX: 00000000fffeffff RSI: 000000000057ffa8 RDI: ffff88907f960c88
  RBP: 0000000000000000 R08: ffffffff83068e50 R09: 000000000002fffd
  R10: 0000000000000004 R11: 0000000000000000 R12: ffff8881001a4400
  R13: 0000000000000000 R14: ffff88907f420fb8 R15: 0000000000000000
  FS:  0000000000000000(0000) GS:ffff88907f940000(0000) knlGS:0000000000000000
  CR2: 00007f60c3001000 CR3: 000000107d010005 CR4: 00000000007726f0
  PKRU: 55555554
  Call Trace:
   <TASK>
   ? __warn+0xa4/0x140
   ? check_flush_dependency+0x112/0x120
   ? report_bug+0xe1/0x140
   ? check_flush_dependency+0x112/0x120
   ? handle_bug+0x5e/0x90
   ? exc_invalid_op+0x16/0x40
   ? asm_exc_invalid_op+0x16/0x20
   ? timer_recalc_next_expiry+0x190/0x190
   ? check_flush_dependency+0x112/0x120
   ? check_flush_dependency+0x112/0x120
   __flush_work.llvm.1643880146586177030+0x174/0x2c0
   flush_rcu_work+0x28/0x30
   kvfree_rcu_barrier+0x12f/0x160
   kmem_cache_destroy+0x18/0x120
   bioset_exit+0x10c/0x150
   disk_release.llvm.6740012984264378178+0x61/0xd0
   device_release+0x4f/0x90
   kobject_put+0x95/0x180
   nvme_put_ns+0x23/0xc0
   nvme_remove_invalid_namespaces+0xb3/0xd0
   nvme_scan_work+0x342/0x490
   process_scheduled_works+0x1a2/0x370
   worker_thread+0x2ff/0x390
   ? pwq_release_workfn+0x1e0/0x1e0
   kthread+0xb1/0xe0
   ? __kthread_parkme+0x70/0x70
   ret_from_fork+0x30/0x40
   ? __kthread_parkme+0x70/0x70
   ret_from_fork_asm+0x11/0x20
   </TASK>
  ---[ end trace 0000000000000000 ]---
<snip>

To address this switch to use of independent WQ_MEM_RECLAIM
workqueue, so the rules are not violated from workqueue framework
point of view.

Apart of that, since kvfree_rcu() does reclaim memory it is worth
to go with WQ_MEM_RECLAIM type of wq because it is designed for
this purpose.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/656e35bf66a11e1adde44c4c12050086dc39f241
  - https://git.kernel.org/stable/c/a74979dce9e9c61f6d797c3761020252c4d8dc63
  - https://git.kernel.org/stable/c/dfd3df31c9db752234d7d2e09bef2aeabb643ce4

------------------------------------------------------------

CVE ID: CVE-2025-21984
Description: In the Linux kernel, the following vulnerability has been resolved:

mm: fix kernel BUG when userfaultfd_move encounters swapcache

userfaultfd_move() checks whether the PTE entry is present or a
swap entry.

- If the PTE entry is present, move_present_pte() handles folio
  migration by setting:

  src_folio->index = linear_page_index(dst_vma, dst_addr);

- If the PTE entry is a swap entry, move_swap_pte() simply copies
  the PTE to the new dst_addr.

This approach is incorrect because, even if the PTE is a swap entry,
it can still reference a folio that remains in the swap cache.

This creates a race window between steps 2 and 4.
 1. add_to_swap: The folio is added to the swapcache.
 2. try_to_unmap: PTEs are converted to swap entries.
 3. pageout: The folio is written back.
 4. Swapcache is cleared.
If userfaultfd_move() occurs in the window between steps 2 and 4,
after the swap PTE has been moved to the destination, accessing the
destination triggers do_swap_page(), which may locate the folio in
the swapcache. However, since the folio's index has not been updated
to match the destination VMA, do_swap_page() will detect a mismatch.

This can result in two critical issues depending on the system
configuration.

If KSM is disabled, both small and large folios can trigger a BUG
during the add_rmap operation due to:

 page_pgoff(folio, page) != linear_page_index(vma, address)

[   13.336953] page: refcount:6 mapcount:1 mapping:00000000f43db19c index:0xffffaf150 pfn:0x4667c
[   13.337520] head: order:2 mapcount:1 entire_mapcount:0 nr_pages_mapped:1 pincount:0
[   13.337716] memcg:ffff00000405f000
[   13.337849] anon flags: 0x3fffc0000020459(locked|uptodate|dirty|owner_priv_1|head|swapbacked|node=0|zone=0|lastcpupid=0xffff)
[   13.338630] raw: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361
[   13.338831] raw: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000
[   13.339031] head: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361
[   13.339204] head: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000
[   13.339375] head: 03fffc0000000202 fffffdffc0199f01 ffffffff00000000 0000000000000001
[   13.339546] head: 0000000000000004 0000000000000000 00000000ffffffff 0000000000000000
[   13.339736] page dumped because: VM_BUG_ON_PAGE(page_pgoff(folio, page) != linear_page_index(vma, address))
[   13.340190] ------------[ cut here ]------------
[   13.340316] kernel BUG at mm/rmap.c:1380!
[   13.340683] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP
[   13.340969] Modules linked in:
[   13.341257] CPU: 1 UID: 0 PID: 107 Comm: a.out Not tainted 6.14.0-rc3-gcf42737e247a-dirty #299
[   13.341470] Hardware name: linux,dummy-virt (DT)
[   13.341671] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   13.341815] pc : __page_check_anon_rmap+0xa0/0xb0
[   13.341920] lr : __page_check_anon_rmap+0xa0/0xb0
[   13.342018] sp : ffff80008752bb20
[   13.342093] x29: ffff80008752bb20 x28: fffffdffc0199f00 x27: 0000000000000001
[   13.342404] x26: 0000000000000000 x25: 0000000000000001 x24: 0000000000000001
[   13.342575] x23: 0000ffffaf0d0000 x22: 0000ffffaf0d0000 x21: fffffdffc0199f00
[   13.342731] x20: fffffdffc0199f00 x19: ffff000006210700 x18: 00000000ffffffff
[   13.342881] x17: 6c203d2120296567 x16: 6170202c6f696c6f x15: 662866666f67705f
[   13.343033] x14: 6567617028454741 x13: 2929737365726464 x12: ffff800083728ab0
[   13.343183] x11: ffff800082996bf8 x10: 0000000000000fd7 x9 : ffff80008011bc40
[   13.343351] x8 : 0000000000017fe8 x7 : 00000000fffff000 x6 : ffff8000829eebf8
[   13.343498] x5 : c0000000fffff000 x4 : 0000000000000000 x3 : 0000000000000000
[   13.343645] x2 : 0000000000000000 x1 : ffff0000062db980 x0 : 000000000000005f
[   13.343876] Call trace:
[   13.344045]  __page_check_anon_rmap+0xa0/0xb0 (P)
[   13.344234]  folio_add_anon_rmap_ptes+0x22c/0x320
[   13.344333]  do_swap_page+0x1060/0x1400
[   13.344417]  __handl
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4e9507246298fd6f1ca7bb42ef01a6e34fb93684
  - https://git.kernel.org/stable/c/b1e11bd86c0943bb7624efebdc384340a50ad683
  - https://git.kernel.org/stable/c/c50f8e6053b0503375c2975bf47f182445aebb4c

------------------------------------------------------------

CVE ID: CVE-2025-21985
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix out-of-bound accesses

[WHAT & HOW]
hpo_stream_to_link_encoder_mapping has size MAX_HPO_DP2_ENCODERS(=4),
but location can have size up to 6. As a result, it is necessary to
check location against MAX_HPO_DP2_ENCODERS.

Similiarly, disp_cfg_stream_location can be used as an array index which
should be 0..5, so the ASSERT's conditions should be less without equal.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/36793d90d76f667d26c6dd025571481ee0c96abc
  - https://git.kernel.org/stable/c/8adbb2a98b00926315fd513b5fe2596b5716b82d
  - https://git.kernel.org/stable/c/9aedc776b11038f04f4641241bb7e877781e4aa4

------------------------------------------------------------

CVE ID: CVE-2025-21986
Description: In the Linux kernel, the following vulnerability has been resolved:

net: switchdev: Convert blocking notification chain to a raw one

A blocking notification chain uses a read-write semaphore to protect the
integrity of the chain. The semaphore is acquired for writing when
adding / removing notifiers to / from the chain and acquired for reading
when traversing the chain and informing notifiers about an event.

In case of the blocking switchdev notification chain, recursive
notifications are possible which leads to the semaphore being acquired
twice for reading and to lockdep warnings being generated [1].

Specifically, this can happen when the bridge driver processes a
SWITCHDEV_BRPORT_UNOFFLOADED event which causes it to emit notifications
about deferred events when calling switchdev_deferred_process().

Fix this by converting the notification chain to a raw notification
chain in a similar fashion to the netdev notification chain. Protect
the chain using the RTNL mutex by acquiring it when modifying the chain.
Events are always informed under the RTNL mutex, but add an assertion in
call_switchdev_blocking_notifiers() to make sure this is not violated in
the future.

Maintain the "blocking" prefix as events are always emitted from process
context and listeners are allowed to block.

[1]:
WARNING: possible recursive locking detected
6.14.0-rc4-custom-g079270089484 #1 Not tainted
--------------------------------------------
ip/52731 is trying to acquire lock:
ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

but task is already holding lock:
ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

other info that might help us debug this:
Possible unsafe locking scenario:
CPU0
----
lock((switchdev_blocking_notif_chain).rwsem);
lock((switchdev_blocking_notif_chain).rwsem);

*** DEADLOCK ***
May be due to missing lock nesting notation
3 locks held by ip/52731:
 #0: ffffffff84f795b0 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x727/0x1dc0
 #1: ffffffff8731f628 (&net->rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x790/0x1dc0
 #2: ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0

stack backtrace:
...
? __pfx_down_read+0x10/0x10
? __pfx_mark_lock+0x10/0x10
? __pfx_switchdev_port_attr_set_deferred+0x10/0x10
blocking_notifier_call_chain+0x58/0xa0
switchdev_port_attr_notify.constprop.0+0xb3/0x1b0
? __pfx_switchdev_port_attr_notify.constprop.0+0x10/0x10
? mark_held_locks+0x94/0xe0
? switchdev_deferred_process+0x11a/0x340
switchdev_port_attr_set_deferred+0x27/0xd0
switchdev_deferred_process+0x164/0x340
br_switchdev_port_unoffload+0xc8/0x100 [bridge]
br_switchdev_blocking_event+0x29f/0x580 [bridge]
notifier_call_chain+0xa2/0x440
blocking_notifier_call_chain+0x6e/0xa0
switchdev_bridge_port_unoffload+0xde/0x1a0
...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1f7d051814e7a0cb1f0717ed5527c1059992129d
  - https://git.kernel.org/stable/c/62531a1effa87bdab12d5104015af72e60d926ff
  - https://git.kernel.org/stable/c/a597d4b75669ec82c72cbee9fe75a15d04b35b2b
  - https://git.kernel.org/stable/c/af757f5ee3f754c5dceefb05c12ff37cb46fc682
  - https://git.kernel.org/stable/c/f9ed3fb50b872bd78bcb01f25087f9e4e25085d8

------------------------------------------------------------

CVE ID: CVE-2025-25041
Description: A vulnerability in the HPE Aruba Networking Virtual Intranet Access (VIA) client could allow malicious users to overwrite arbitrary files as NT AUTHORITY\SYSTEM (root). A successful exploit could allow the creation of a Denial-of-Service (DoS) condition affecting the Microsoft Windows Operating System. This vulnerability does not affect Linux and Android based clients.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N
CPEs:
  - No CPE data available.
References:
  - https://support.hpe.com/hpesc/public/docDisplay?docId=hpesbnw04841en_us&docLocale=en_US

------------------------------------------------------------

CVE ID: CVE-2025-21987
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: init return value in amdgpu_ttm_clear_buffer

Otherwise an uninitialized value can be returned if
amdgpu_res_cleared returns true for all regions.

Possibly closes: https://gitlab.freedesktop.org/drm/amd/-/issues/3812

(cherry picked from commit 7c62aacc3b452f73a1284198c81551035fac6d71)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5bd98c2df4a0f2e2dcbdf563feb8d348406377b5
  - https://git.kernel.org/stable/c/d2c9625b0ade41f9917875d88173a0cc802b95fc
  - https://git.kernel.org/stable/c/d3c7059b6a8600fc62cd863f1ea203b8675e63e1

------------------------------------------------------------

CVE ID: CVE-2025-21988
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/netfs/read_collect: add to next->prev_donated

If multiple subrequests donate data to the same "next" request
(depending on the subrequest completion order), each of them would
overwrite the `prev_donated` field, causing data corruption and a
BUG() crash ("Can't donate prior to front").
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/e25cec3b76aba47a49138d2162fc809c6cd49c9e

------------------------------------------------------------

CVE ID: CVE-2025-21989
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix missing .is_two_pixels_per_container

Starting from 6.11, AMDGPU driver, while being loaded with amdgpu.dc=1,
due to lack of .is_two_pixels_per_container function in dce60_tg_funcs,
causes a NULL pointer dereference on PCs with old GPUs, such as R9 280X.

So this fix adds missing .is_two_pixels_per_container to dce60_tg_funcs.

(cherry picked from commit bd4b125eb949785c6f8a53b0494e32795421209d)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/36d04c9313d8d83ead92242f037099ac73e02120
  - https://git.kernel.org/stable/c/e204aab79e01bc8ff750645666993ed8b719de57
  - https://git.kernel.org/stable/c/fefa811e616b5d0b555ed65743e528a0a8a0b377

------------------------------------------------------------

CVE ID: CVE-2025-21990
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: NULL-check BO's backing store when determining GFX12 PTE flags

PRT BOs may not have any backing store, so bo->tbo.resource will be
NULL. Check for that before dereferencing.

(cherry picked from commit 3e3fcd29b505cebed659311337ea03b7698767fc)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6cc30748e17ea2a64051ceaf83a8372484e597f1
  - https://git.kernel.org/stable/c/72235808eabea93055b459a63443bd9cd6b08aa4
  - https://git.kernel.org/stable/c/af23e39b9e9280b1f6299b6f2fa090a1694240ad

------------------------------------------------------------

CVE ID: CVE-2025-21991
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/microcode/AMD: Fix out-of-bounds on systems with CPU-less NUMA nodes

Currently, load_microcode_amd() iterates over all NUMA nodes, retrieves their
CPU masks and unconditionally accesses per-CPU data for the first CPU of each
mask.

According to Documentation/admin-guide/mm/numaperf.rst:

  "Some memory may share the same node as a CPU, and others are provided as
  memory only nodes."

Therefore, some node CPU masks may be empty and wouldn't have a "first CPU".

On a machine with far memory (and therefore CPU-less NUMA nodes):
- cpumask_of_node(nid) is 0
- cpumask_first(0) is CONFIG_NR_CPUS
- cpu_data(CONFIG_NR_CPUS) accesses the cpu_info per-CPU array at an
  index that is 1 out of bounds

This does not have any security implications since flashing microcode is
a privileged operation but I believe this has reliability implications by
potentially corrupting memory while flashing a microcode update.

When booting with CONFIG_UBSAN_BOUNDS=y on an AMD machine that flashes
a microcode update. I get the following splat:

  UBSAN: array-index-out-of-bounds in arch/x86/kernel/cpu/microcode/amd.c:X:Y
  index 512 is out of range for type 'unsigned long[512]'
  [...]
  Call Trace:
   dump_stack
   __ubsan_handle_out_of_bounds
   load_microcode_amd
   request_microcode_amd
   reload_store
   kernfs_fop_write_iter
   vfs_write
   ksys_write
   do_syscall_64
   entry_SYSCALL_64_after_hwframe

Change the loop to go over only NUMA nodes which have CPUs before determining
whether the first CPU on the respective node needs microcode update.

  [ bp: Massage commit message, fix typo. ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.308, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.276, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.235, Last Version (Excluding): 5.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.173, Last Version (Excluding): 5.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.99, Last Version (Excluding): 5.16
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2.3, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/18b5d857c6496b78ead2fd10001b81ae32d30cac
  - https://git.kernel.org/stable/c/488ffc0cac38f203979f83634236ee53251ce593
  - https://git.kernel.org/stable/c/5ac295dfccb5b015493f86694fa13a0dde4d3665
  - https://git.kernel.org/stable/c/985a536e04bbfffb1770df43c6470f635a6b1073
  - https://git.kernel.org/stable/c/d509c4731090ebd9bbdb72c70a2d70003ae81f4f
  - https://git.kernel.org/stable/c/e3e89178a9f4a80092578af3ff3c8478f9187d59
  - https://git.kernel.org/stable/c/e686349cc19e800dac8971929089ba5ff59abfb0
  - https://git.kernel.org/stable/c/ec52240622c4d218d0240079b7c1d3ec2328a9f4

------------------------------------------------------------

CVE ID: CVE-2025-21992
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: ignore non-functional sensor in HP 5MP Camera

The HP 5MP Camera (USB ID 0408:5473) reports a HID sensor interface that
is not actually implemented. Attempting to access this non-functional
sensor via iio_info causes system hangs as runtime PM tries to wake up
an unresponsive sensor.

  [453] hid-sensor-hub 0003:0408:5473.0003: Report latency attributes: ffffffff:ffffffff
  [453] hid-sensor-hub 0003:0408:5473.0003: common attributes: 5:1, 2:1, 3:1 ffffffff:ffffffff

Add this device to the HID ignore list since the sensor interface is
non-functional by design and should not be exposed to userspace.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/007a849126ef7907761af6a1379400558a72e703
  - https://git.kernel.org/stable/c/363236d709e75610b628c2a4337ccbe42e454b6d
  - https://git.kernel.org/stable/c/6ca3d4d87af406a390a34ea924ab65c517e6e132
  - https://git.kernel.org/stable/c/7a7ada33879a631b05b536e66d1c5b1219d3bade
  - https://git.kernel.org/stable/c/920ea73215dbf948b661b88a79cb47b7f96adfbd
  - https://git.kernel.org/stable/c/9acdb0059fb6b82158e15adae91e629cb5974564
  - https://git.kernel.org/stable/c/9af297aea8f76a0ad21f2de5f2cd6401a748b9c3
  - https://git.kernel.org/stable/c/b6c6c2d8ab4932e5d6d439f514276cb3d257b8fe

------------------------------------------------------------

CVE ID: CVE-2025-21993
Description: In the Linux kernel, the following vulnerability has been resolved:

iscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic()

When performing an iSCSI boot using IPv6, iscsistart still reads the
/sys/firmware/ibft/ethernetX/subnet-mask entry. Since the IPv6 prefix
length is 64, this causes the shift exponent to become negative,
triggering a UBSAN warning. As the concept of a subnet mask does not
apply to IPv6, the value is set to ~0 to suppress the warning message.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.84
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.8
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07e0d99a2f701123ad3104c0f1a1e66bce74d6e5
  - https://git.kernel.org/stable/c/2d1eef248107bdf3d5a69d0fde04c30a79a7bf5d
  - https://git.kernel.org/stable/c/9bfa80c8aa4e06dff55a953c3fffbfc68a3a3b1c
  - https://git.kernel.org/stable/c/a858cd58dea06cf85b142673deea8c5d87f11e70
  - https://git.kernel.org/stable/c/b253660fac5e0e9080d2c95e3a029e1898d49afb
  - https://git.kernel.org/stable/c/b388e185bfad32bfed6a97a6817f74ca00a4318f
  - https://git.kernel.org/stable/c/c1c6e527470e5eab0b2d57bd073530fbace39eab
  - https://git.kernel.org/stable/c/f763c82db8166e28f45b7cc4a5398a7859665940

------------------------------------------------------------

CVE ID: CVE-2025-21994
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix incorrect validation for num_aces field of smb_acl

parse_dcal() validate num_aces to allocate posix_ace_state_array.

if (num_aces > ULONG_MAX / sizeof(struct smb_ace *))

It is an incorrect validation that we can create an array of size ULONG_MAX.
smb_acl has ->size field to calculate actual number of aces in request buffer
size. Use this to check invalid num_aces.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b8b67f3c5e5169535e26efedd3e422172e2db64
  - https://git.kernel.org/stable/c/9c4e202abff45f8eac17989e549fc7a75095f675
  - https://git.kernel.org/stable/c/a4cb17797a5d241f1e509cb5b46ed95a80c2f5fd
  - https://git.kernel.org/stable/c/c3a3484d9d31b27a3db0fab91fcf191132d65236
  - https://git.kernel.org/stable/c/d0f87370622a853b57e851f7d5a5452b72300f19
  - https://git.kernel.org/stable/c/f6a6721802ac2f12f4c1bbe839a4c229b61866f2

------------------------------------------------------------

CVE ID: CVE-2025-31477
Description: The Tauri shell plugin allows access to the system shell. Prior to 2.2.1, the Tauri shell plugin exposes functionality to execute code and open programs on the system. The open endpoint of this plugin is designed to allow open functionality with the system opener (e.g. xdg-open on Linux). This was meant to be restricted to a reasonable number of protocols like https or mailto by default. This default restriction was not functional due to improper validation of the allowed protocols, allowing for potentially dangerous protocols like file://, smb://, or nfs:// and others to be opened by the system registered protocol handler. By passing untrusted user input to the open endpoint these potentially dangerous protocols can be abused to gain remote code execution on the system. This either requires direct exposure of the endpoint to application users or code execution in the frontend of a Tauri application. This vulnerability is fixed in 2.2.1.
Severity:
  - CVSS Version: 4.0
  - Base Score: 9.3
  - Base Severity: CRITICAL
  - CVSS Vector: CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - Vendor: tauri, Product: plugin-shell, Version: *, First Version (Including): None, Last Version (Excluding): 2.2.1
References:
  - https://github.com/tauri-apps/plugins-workspace/commit/9cf0390a52497e273db1a1b613a0e26827aa327c
  - https://github.com/tauri-apps/plugins-workspace/security/advisories/GHSA-c9pr-q8gx-3mgp
  - https://github.com/tauri-apps/plugins-workspace/security/advisories/GHSA-c9pr-q8gx-3mgp

------------------------------------------------------------

CVE ID: CVE-2025-21995
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/sched: Fix fence reference count leak

The last_scheduled fence leaks when an entity is being killed and adding
the cleanup callback fails.

Decrement the reference count of prev when dma_fence_add_callback()
fails, ensuring proper balance.

[phasta: add git tag info for stable kernel]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1135a9431160575466ea9ac37ebd756ecbe35fff
  - https://git.kernel.org/stable/c/35399c84dcedd6d31448fb9e1336ef52673f2882
  - https://git.kernel.org/stable/c/a952f1ab696873be124e31ce5ef964d36bce817f
  - https://git.kernel.org/stable/c/c76bd3c99293834de7d1dca5de536616d5655e38

------------------------------------------------------------

CVE ID: CVE-2025-21996
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/radeon: fix uninitialized size issue in radeon_vce_cs_parse()

On the off chance that command stream passed from userspace via
ioctl() call to radeon_vce_cs_parse() is weirdly crafted and
first command to execute is to encode (case 0x03000001), the function
in question will attempt to call radeon_vce_cs_reloc() with size
argument that has not been properly initialized. Specifically, 'size'
will point to 'tmp' variable before the latter had a chance to be
assigned any value.

Play it safe and init 'tmp' with 0, thus ensuring that
radeon_vce_cs_reloc() will catch an early error in cases like these.

Found by Linux Verification Center (linuxtesting.org) with static
analysis tool SVACE.

(cherry picked from commit 2d52de55f9ee7aaee0e09ac443f77855989c6b68)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.15, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0effb378ebce52b897f85cd7f828854b8c7cb636
  - https://git.kernel.org/stable/c/3ce08215cad55c10a6eeeb33d3583b6cfffe3ab8
  - https://git.kernel.org/stable/c/5b4d9d20fd455a97920cf158dd19163b879cf65d
  - https://git.kernel.org/stable/c/78b07dada3f02f77762d0755a96d35f53b02be69
  - https://git.kernel.org/stable/c/9b2da9c673a0da1359a2151f7ce773e2f77d71a9
  - https://git.kernel.org/stable/c/dd1801aa01bba1760357f2a641346ae149686713
  - https://git.kernel.org/stable/c/dd8689b52a24807c2d5ce0a17cb26dc87f75235c
  - https://git.kernel.org/stable/c/f5e049028124f755283f2c07e7a3708361ed1dc8

------------------------------------------------------------

CVE ID: CVE-2025-21997
Description: In the Linux kernel, the following vulnerability has been resolved:

xsk: fix an integer overflow in xp_create_and_assign_umem()

Since the i and pool->chunk_size variables are of type 'u32',
their product can wrap around and then be cast to 'u64'.
This can lead to two different XDP buffers pointing to the same
memory area.

Found by InfoTeCS on behalf of Linux Verification Center
(linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/130290f44bce0eead2b827302109afc3fe189ddd
  - https://git.kernel.org/stable/c/205649d642a5b376724f04f3a5b3586815e43d3b
  - https://git.kernel.org/stable/c/559847f56769037e5b2e0474d3dbff985b98083d
  - https://git.kernel.org/stable/c/b7b4be1fa43294b50b22e812715198629806678a
  - https://git.kernel.org/stable/c/c7670c197b0f1a8726ad5c87bc2bf001a1fc1bbd

------------------------------------------------------------

CVE ID: CVE-2025-21998
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: qcom: uefisecapp: fix efivars registration race

Since the conversion to using the TZ allocator, the efivars service is
registered before the memory pool has been allocated, something which
can lead to a NULL-pointer dereference in case of a racing EFI variable
access.

Make sure that all resources have been set up before registering the
efivars.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/c4e37b381a7a243c298a4858fc0a5a74e737c79a
  - https://git.kernel.org/stable/c/da8d493a80993972c427002684d0742560f3be4a
  - https://git.kernel.org/stable/c/f15a2b96a0e41c426c63a932d0e63cde7b9784aa

------------------------------------------------------------

CVE ID: CVE-2025-21999
Description: In the Linux kernel, the following vulnerability has been resolved:

proc: fix UAF in proc_get_inode()

Fix race between rmmod and /proc/XXX's inode instantiation.

The bug is that pde->proc_ops don't belong to /proc, it belongs to a
module, therefore dereferencing it after /proc entry has been registered
is a bug unless use_pde/unuse_pde() pair has been used.

use_pde/unuse_pde can be avoided (2 atomic ops!) because pde->proc_ops
never changes so information necessary for inode instantiation can be
saved _before_ proc_register() in PDE itself and used later, avoiding
pde->proc_ops->...  dereference.

      rmmod                         lookup
sys_delete_module
                         proc_lookup_de
			   pde_get(de);
			   proc_get_inode(dir->i_sb, de);
  mod->exit()
    proc_remove
      remove_proc_subtree
       proc_entry_rundown(de);
  free_module(mod);

                               if (S_ISREG(inode->i_mode))
	                         if (de->proc_ops->proc_read_iter)
                           --> As module is already freed, will trigger UAF

BUG: unable to handle page fault for address: fffffbfff80a702b
PGD 817fc4067 P4D 817fc4067 PUD 817fc0067 PMD 102ef4067 PTE 0
Oops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI
CPU: 26 UID: 0 PID: 2667 Comm: ls Tainted: G
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
RIP: 0010:proc_get_inode+0x302/0x6e0
RSP: 0018:ffff88811c837998 EFLAGS: 00010a06
RAX: dffffc0000000000 RBX: ffffffffc0538140 RCX: 0000000000000007
RDX: 1ffffffff80a702b RSI: 0000000000000001 RDI: ffffffffc0538158
RBP: ffff8881299a6000 R08: 0000000067bbe1e5 R09: 1ffff11023906f20
R10: ffffffffb560ca07 R11: ffffffffb2b43a58 R12: ffff888105bb78f0
R13: ffff888100518048 R14: ffff8881299a6004 R15: 0000000000000001
FS:  00007f95b9686840(0000) GS:ffff8883af100000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: fffffbfff80a702b CR3: 0000000117dd2000 CR4: 00000000000006f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 proc_lookup_de+0x11f/0x2e0
 __lookup_slow+0x188/0x350
 walk_component+0x2ab/0x4f0
 path_lookupat+0x120/0x660
 filename_lookup+0x1ce/0x560
 vfs_statx+0xac/0x150
 __do_sys_newstat+0x96/0x110
 do_syscall_64+0x5f/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

[adobriyan@gmail.com: don't do 2 atomic ops on the common path]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.23, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4b0b8445b6fd41e6f62ac90547a0ea9d348de3fa
  - https://git.kernel.org/stable/c/63b53198aff2e4e6c5866a4ff73c7891f958ffa4
  - https://git.kernel.org/stable/c/64dc7c68e040251d9ec6e989acb69f8f6ae4a10b
  - https://git.kernel.org/stable/c/654b33ada4ab5e926cd9c570196fefa7bec7c1df
  - https://git.kernel.org/stable/c/966f331403dc3ed04ff64eaf3930cf1267965e53
  - https://git.kernel.org/stable/c/eda279586e571b05dff44d48e05f8977ad05855d
  - https://git.kernel.org/stable/c/ede3e8ac90ae106f0b29cd759aadebc1568f1308

------------------------------------------------------------

CVE ID: CVE-2025-22000
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/huge_memory: drop beyond-EOF folios with the right number of refs

When an after-split folio is large and needs to be dropped due to EOF,
folio_put_refs(folio, folio_nr_pages(folio)) should be used to drop all
page cache refs.  Otherwise, the folio will not be freed, causing memory
leak.

This leak would happen on a filesystem with blocksize > page_size and a
truncate is performed, where the blocksize makes folios split to >0 order
ones, causing truncated folios not being freed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/14efb4793519d73fb2902bb0ece319b886e4b4b9
  - https://git.kernel.org/stable/c/86368616a9ce51f6b41efa251b6e066893851d67
  - https://git.kernel.org/stable/c/92ad820a1f2d95d5a8d6c2bd3f391bbb068a5f9e

------------------------------------------------------------

CVE ID: CVE-2025-22001
Description: In the Linux kernel, the following vulnerability has been resolved:

accel/qaic: Fix integer overflow in qaic_validate_req()

These are u64 variables that come from the user via
qaic_attach_slice_bo_ioctl().  Use check_add_overflow() to ensure that
the math doesn't have an integer wrapping bug.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4b2a170c25862ad116bd31be6b9841646b4862e8
  - https://git.kernel.org/stable/c/57fae0c505f49bb1e3d5660cd2cc49697ed85f7c
  - https://git.kernel.org/stable/c/67d15c7aa0864dfd82325c7e7e7d8548b5224c7b
  - https://git.kernel.org/stable/c/b362fc904d264a88b4af20baae9e82491c285e9c

------------------------------------------------------------

CVE ID: CVE-2025-22002
Description: In the Linux kernel, the following vulnerability has been resolved:

netfs: Call `invalidate_cache` only if implemented

Many filesystems such as NFS and Ceph do not implement the
`invalidate_cache` method.  On those filesystems, if writing to the
cache (`NETFS_WRITE_TO_CACHE`) fails for some reason, the kernel
crashes like this:

 BUG: kernel NULL pointer dereference, address: 0000000000000000
 #PF: supervisor instruction fetch in kernel mode
 #PF: error_code(0x0010) - not-present page
 PGD 0 P4D 0
 Oops: Oops: 0010 [#1] SMP PTI
 CPU: 9 UID: 0 PID: 3380 Comm: kworker/u193:11 Not tainted 6.13.3-cm4all1-hp #437
 Hardware name: HP ProLiant DL380 Gen9/ProLiant DL380 Gen9, BIOS P89 10/17/2018
 Workqueue: events_unbound netfs_write_collection_worker
 RIP: 0010:0x0
 Code: Unable to access opcode bytes at 0xffffffffffffffd6.
 RSP: 0018:ffff9b86e2ca7dc0 EFLAGS: 00010202
 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 7fffffffffffffff
 RDX: 0000000000000001 RSI: ffff89259d576a18 RDI: ffff89259d576900
 RBP: ffff89259d5769b0 R08: ffff9b86e2ca7d28 R09: 0000000000000002
 R10: ffff89258ceaca80 R11: 0000000000000001 R12: 0000000000000020
 R13: ffff893d158b9338 R14: ffff89259d576900 R15: ffff89259d5769b0
 FS:  0000000000000000(0000) GS:ffff893c9fa40000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: ffffffffffffffd6 CR3: 000000054442e003 CR4: 00000000001706f0
 Call Trace:
  <TASK>
  ? __die+0x1f/0x60
  ? page_fault_oops+0x15c/0x460
  ? try_to_wake_up+0x2d2/0x530
  ? exc_page_fault+0x5e/0x100
  ? asm_exc_page_fault+0x22/0x30
  netfs_write_collection_worker+0xe9f/0x12b0
  ? xs_poll_check_readable+0x3f/0x80
  ? xs_stream_data_receive_workfn+0x8d/0x110
  process_one_work+0x134/0x2d0
  worker_thread+0x299/0x3a0
  ? __pfx_worker_thread+0x10/0x10
  kthread+0xba/0xe0
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x30/0x50
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1a/0x30
  </TASK>
 Modules linked in:
 CR2: 0000000000000000

This patch adds the missing `NULL` check.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0def1a40c3e76a468f8f66aa572caed44ec37277
  - https://git.kernel.org/stable/c/344b7ef248f420ed4ba3a3539cb0a0fc18df9a6c
  - https://git.kernel.org/stable/c/c2d5d14a7bcbb045d0cd0095cefe95f2a4b91159

------------------------------------------------------------

CVE ID: CVE-2025-22003
Description: In the Linux kernel, the following vulnerability has been resolved:

can: ucan: fix out of bound read in strscpy() source

Commit 7fdaf8966aae ("can: ucan: use strscpy() to instead of strncpy()")
unintentionally introduced a one byte out of bound read on strscpy()'s
source argument (which is kind of ironic knowing that strscpy() is meant
to be a more secure alternative :)).

Let's consider below buffers:

  dest[len + 1]; /* will be NUL terminated */
  src[len]; /* may not be NUL terminated */

When doing:

  strncpy(dest, src, len);
  dest[len] = '\0';

strncpy() will read up to len bytes from src.

On the other hand:

  strscpy(dest, src, len + 1);

will read up to len + 1 bytes from src, that is to say, an out of bound
read of one byte will occur on src if it is not NUL terminated. Note
that the src[len] byte is never copied, but strscpy() still needs to
read it to check whether a truncation occurred or not.

This exact pattern happened in ucan.

The root cause is that the source is not NUL terminated. Instead of
doing a copy in a local buffer, directly NUL terminate it as soon as
usb_control_msg() returns. With this, the local firmware_str[] variable
can be removed.

On top of this do a couple refactors:

  - ucan_ctl_payload->raw is only used for the firmware string, so
    rename it to ucan_ctl_payload->fw_str and change its type from u8 to
    char.

  - ucan_device_request_in() is only used to retrieve the firmware
    string, so rename it to ucan_get_fw_str() and refactor it to make it
    directly handle all the string termination logic.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1d22a122ffb116c3cf78053e812b8b21f8852ee9
  - https://git.kernel.org/stable/c/8cec9e314d3360fc1d8346297c41a6ee45cb45a9
  - https://git.kernel.org/stable/c/a4994161a61bc8fd71d105c579d847cefee99262
  - https://git.kernel.org/stable/c/cc29775a8a72d7f3b56cc026796ad99bd65804a7

------------------------------------------------------------

CVE ID: CVE-2025-22004
Description: In the Linux kernel, the following vulnerability has been resolved:

net: atm: fix use after free in lec_send()

The ->send() operation frees skb so save the length before calling
->send() to avoid a use after free.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/326223182e4703cde99fdbd36d07d0b3de9980fb
  - https://git.kernel.org/stable/c/50e288097c2c6e5f374ae079394436fc29d1e88e
  - https://git.kernel.org/stable/c/51e8be9578a2e74f9983d8fd8de8cafed191f30c
  - https://git.kernel.org/stable/c/82d9084a97892de1ee4881eb5c17911fcd9be6f6
  - https://git.kernel.org/stable/c/8cd90c7db08f32829bfa1b5b2b11fbc542afbab7
  - https://git.kernel.org/stable/c/9566f6ee13b17a15d0a47667ad1b1893c539f730
  - https://git.kernel.org/stable/c/f3009d0d6ab78053117f8857b921a8237f4d17b3
  - https://git.kernel.org/stable/c/f3271f7548385e0096739965961c7cbf7e6b4762

------------------------------------------------------------

CVE ID: CVE-2025-22005
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: Fix memleak of nhc_pcpu_rth_output in fib_check_nh_v6_gw().

fib_check_nh_v6_gw() expects that fib6_nh_init() cleans up everything
when it fails.

Commit 7dd73168e273 ("ipv6: Always allocate pcpu memory in a fib6_nh")
moved fib_nh_common_init() before alloc_percpu_gfp() within fib6_nh_init()
but forgot to add cleanup for fib6_nh->nh_common.nhc_pcpu_rth_output in
case it fails to allocate fib6_nh->rt6i_pcpu, resulting in memleak.

Let's call fib_nh_common_release() and clear nhc_pcpu_rth_output in the
error path.

Note that we can remove the fib6_nh_release() call in nh_create_ipv6()
later in net-next.git.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.3, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/119dcafe36795a15ae53351cbbd6177aaf94ffef
  - https://git.kernel.org/stable/c/16267a5036173d0173377545b4b6021b081d0933
  - https://git.kernel.org/stable/c/1bd12dfc058e1e68759d313d7727d68dbc1b8964
  - https://git.kernel.org/stable/c/29d91820184d5cbc70f3246d4911d96eaeb930d6
  - https://git.kernel.org/stable/c/596a883c4ce2d2e9c175f25b98fed3a1f33fea38
  - https://git.kernel.org/stable/c/77c41cdbe6bce476e08d3251c0d501feaf10a9f3
  - https://git.kernel.org/stable/c/9740890ee20e01f99ff1dde84c63dcf089fabb98
  - https://git.kernel.org/stable/c/d3d5b4b5ae263c3225db363ba08b937e2e2b0380

------------------------------------------------------------

CVE ID: CVE-2025-22006
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw: Fix NAPI registration sequence

Registering the interrupts for TX or RX DMA Channels prior to registering
their respective NAPI callbacks can result in a NULL pointer dereference.
This is seen in practice as a random occurrence since it depends on the
randomness associated with the generation of traffic by Linux and the
reception of traffic from the wire.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.14, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13.3, Last Version (Excluding): 6.13.9
References:
  - https://git.kernel.org/stable/c/5f079290e5913a0060e059500b7d440990ac1066
  - https://git.kernel.org/stable/c/942557abed7f38b77a47d77b92d448802eefe185
  - https://git.kernel.org/stable/c/d4bf956547c38c04fad8d72a961ac4dc00bad000

------------------------------------------------------------

CVE ID: CVE-2025-22007
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: Fix error code in chan_alloc_skb_cb()

The chan_alloc_skb_cb() function is supposed to return error pointers on
error.  Returning NULL will lead to a NULL dereference.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.17, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1bd68db7beb426ab5a45d81516ed9611284affc8
  - https://git.kernel.org/stable/c/72d061ee630d0dbb45c2920d8d19b3861c413e54
  - https://git.kernel.org/stable/c/761b7c36addd22c7e6ceb05caaadc3b062d99faa
  - https://git.kernel.org/stable/c/76304cba8cba12bb10d89d016c28403a2dd89a29
  - https://git.kernel.org/stable/c/788ae2ae4cf484e248b5bc29211c7ac6510e3e92
  - https://git.kernel.org/stable/c/a78692ec0d1e17a96b09f2349a028878f5b305e4
  - https://git.kernel.org/stable/c/b3d607e36fef4bd05fb938a8a868ff70e9fedbe2
  - https://git.kernel.org/stable/c/ecd06ad0823a90b4420c377ef8917e44e23ee841

------------------------------------------------------------

CVE ID: CVE-2025-30370
Description: jupyterlab-git is a JupyterLab extension for version control using Git. On many platforms, a third party can create a Git repository under a name that includes a shell command substitution string in the syntax $(<command>). These directory names are allowed in macOS and a majority of Linux distributions. If a user starts jupyter-lab in a parent directory of this inappropriately-named Git repository, opens it, and clicks "Git > Open Git Repository in Terminal" from the menu bar, then the injected command <command> is run in the user's shell without the user's permission. This issue is occurring because when that menu entry is clicked, jupyterlab-git opens the terminal and runs cd <git-repo-path> through the shell to set the current directory. Doing so runs any command substitution strings present in the directory name, which leads to the command injection issue described here. A previous patch provided an incomplete fix. This vulnerability is fixed in 0.51.1.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.4
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:L/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://github.com/jupyterlab/jupyterlab-git/blob/7eb3b06f0092223bd5494688ec264527bbeb2195/src/commandsAndMenu.tsx#L175-L184
  - https://github.com/jupyterlab/jupyterlab-git/commit/b46482993f76d3a546015c6a94ebed8b77fc2376
  - https://github.com/jupyterlab/jupyterlab-git/pull/1196
  - https://github.com/jupyterlab/jupyterlab-git/security/advisories/GHSA-cj5w-8mjf-r5f8
  - https://github.com/jupyterlab/jupyterlab-git/security/advisories/GHSA-cj5w-8mjf-r5f8

------------------------------------------------------------

CVE ID: CVE-2024-45556
Description: Cryptographic issue may arise because the access control configuration permits Linux to read key registers in TCSR.
Severity:
  - CVSS Version: 3.1
  - Base Score: 6.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N
CPEs:
  - No CPE data available.
References:
  - https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2025-bulletin.html

------------------------------------------------------------

CVE ID: CVE-2025-22008
Description: In the Linux kernel, the following vulnerability has been resolved:

regulator: check that dummy regulator has been probed before using it

Due to asynchronous driver probing there is a chance that the dummy
regulator hasn't already been probed when first accessing it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/21e3fdf3146f9c63888d6bfabbd553434a5fb93f
  - https://git.kernel.org/stable/c/270fe5c090f62dfce1cad0f5053e4827a6f50df4
  - https://git.kernel.org/stable/c/2c7a50bec4958f1d1c84d19cde518d0e96a676fd
  - https://git.kernel.org/stable/c/3a9c46af5654783f99015727ac65bc2a23e2735a
  - https://git.kernel.org/stable/c/8e500180904aae63afdce95cb378aeabe119ecda
  - https://git.kernel.org/stable/c/998b1aae22dca87da392ea35f089406cbef6032d
  - https://git.kernel.org/stable/c/a99f1254b11eaadd0794b74a8178bad92ab01cae

------------------------------------------------------------

CVE ID: CVE-2025-22009
Description: In the Linux kernel, the following vulnerability has been resolved:

regulator: dummy: force synchronous probing

Sometimes I get a NULL pointer dereference at boot time in kobject_get()
with the following call stack:

anatop_regulator_probe()
 devm_regulator_register()
  regulator_register()
   regulator_resolve_supply()
    kobject_get()

By placing some extra BUG_ON() statements I could verify that this is
raised because probing of the 'dummy' regulator driver is not completed
('dummy_regulator_rdev' is still NULL).

In the JTAG debugger I can see that dummy_regulator_probe() and
anatop_regulator_probe() can be run by different kernel threads
(kworker/u4:*).  I haven't further investigated whether this can be
changed or if there are other possibilities to force synchronization
between these two probe routines.  On the other hand I don't expect much
boot time penalty by probing the 'dummy' regulator synchronously.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5ade367b56c3947c990598df92395ce737bee872
  - https://git.kernel.org/stable/c/8619909b38eeebd3e60910158d7d68441fc954e9
  - https://git.kernel.org/stable/c/d3b83a1442a09b145006eb4294b1a963c5345c9c
  - https://git.kernel.org/stable/c/e26f24ca4fb940b15e092796c5993142a2558bd9

------------------------------------------------------------

CVE ID: CVE-2025-22010
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/hns: Fix soft lockup during bt pages loop

Driver runs a for-loop when allocating bt pages and mapping them with
buffer pages. When a large buffer (e.g. MR over 100GB) is being allocated,
it may require a considerable loop count. This will lead to soft lockup:

        watchdog: BUG: soft lockup - CPU#27 stuck for 22s!
        ...
        Call trace:
         hem_list_alloc_mid_bt+0x124/0x394 [hns_roce_hw_v2]
         hns_roce_hem_list_request+0xf8/0x160 [hns_roce_hw_v2]
         hns_roce_mtr_create+0x2e4/0x360 [hns_roce_hw_v2]
         alloc_mr_pbl+0xd4/0x17c [hns_roce_hw_v2]
         hns_roce_reg_user_mr+0xf8/0x190 [hns_roce_hw_v2]
         ib_uverbs_reg_mr+0x118/0x290

        watchdog: BUG: soft lockup - CPU#35 stuck for 23s!
        ...
        Call trace:
         hns_roce_hem_list_find_mtt+0x7c/0xb0 [hns_roce_hw_v2]
         mtr_map_bufs+0xc4/0x204 [hns_roce_hw_v2]
         hns_roce_mtr_create+0x31c/0x3c4 [hns_roce_hw_v2]
         alloc_mr_pbl+0xb0/0x160 [hns_roce_hw_v2]
         hns_roce_reg_user_mr+0x108/0x1c0 [hns_roce_hw_v2]
         ib_uverbs_reg_mr+0x120/0x2bc

Add a cond_resched() to fix soft lockup during these loops. In order not
to affect the allocation performance of normal-size buffer, set the loop
count of a 100GB MR as the threshold to call cond_resched().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.3, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/13a52f6c9ff99f7d88f81da535cb4e85eade662b
  - https://git.kernel.org/stable/c/25655580136de59ec89f09089dd28008ea440fc9
  - https://git.kernel.org/stable/c/4104b0023ff66b5df900d23dbf38310893deca79
  - https://git.kernel.org/stable/c/461eb4ddede266df8f181f578732bb01742c3fd6
  - https://git.kernel.org/stable/c/975355faba56c0751292ed15a90c3e2c7dc0aad6
  - https://git.kernel.org/stable/c/9ab20fec7a1ce3057ad86afd27bfd08420b7cd11
  - https://git.kernel.org/stable/c/efe544462fc0b499725364f90bd0f8bbf16f861a

------------------------------------------------------------

CVE ID: CVE-2025-22011
Description: In the Linux kernel, the following vulnerability has been resolved:

ARM: dts: bcm2711: Fix xHCI power-domain

During s2idle tests on the Raspberry CM4 the VPU firmware always crashes
on xHCI power-domain resume:

root@raspberrypi:/sys/power# echo freeze > state
[   70.724347] xhci_suspend finished
[   70.727730] xhci_plat_suspend finished
[   70.755624] bcm2835-power bcm2835-power: Power grafx off
[   70.761127]  USB: Set power to 0

[   74.653040]  USB: Failed to set power to 1 (-110)

This seems to be caused because of the mixed usage of
raspberrypi-power and bcm2835-power at the same time. So avoid
the usage of the VPU firmware power-domain driver, which
prevents the VPU crash.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/393947e06867923d4c2be380d46efd03407a8ce2
  - https://git.kernel.org/stable/c/b8a47aa0b3df701d0fc41b3caf78d00571776be0
  - https://git.kernel.org/stable/c/f44fa354a0715577ca32b085f6f60bcf32c748dd

------------------------------------------------------------

CVE ID: CVE-2025-22012
Description: In the Linux kernel, the following vulnerability has been resolved:

Revert "arm64: dts: qcom: sdm845: Affirm IDR0.CCTW on apps_smmu"

There are reports that the pagetable walker cache coherency is not a
given across the spectrum of SDM845/850 devices, leading to lock-ups
and resets. It works fine on some devices (like the Dragonboard 845c,
but not so much on the Lenovo Yoga C630).

This unfortunately looks like a fluke in firmware development, where
likely somewhere in the vast hypervisor stack, a change to accommodate
for this was only introduced after the initial software release (which
often serves as a baseline for products).

Revert the change to avoid additional guesswork around crashes.

This reverts commit 6b31a9744b8726c69bb0af290f8475a368a4b805.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/9e6e9fc90258a318d30b417bcccda908bb82ee9d
  - https://git.kernel.org/stable/c/f00db31d235946853fb430de8c6aa1295efc8353

------------------------------------------------------------

CVE ID: CVE-2025-22013
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: arm64: Unconditionally save+flush host FPSIMD/SVE/SME state

There are several problems with the way hyp code lazily saves the host's
FPSIMD/SVE state, including:

* Host SVE being discarded unexpectedly due to inconsistent
  configuration of TIF_SVE and CPACR_ELx.ZEN. This has been seen to
  result in QEMU crashes where SVE is used by memmove(), as reported by
  Eric Auger:

  https://issues.redhat.com/browse/RHEL-68997

* Host SVE state is discarded *after* modification by ptrace, which was an
  unintentional ptrace ABI change introduced with lazy discarding of SVE state.

* The host FPMR value can be discarded when running a non-protected VM,
  where FPMR support is not exposed to a VM, and that VM uses
  FPSIMD/SVE. In these cases the hyp code does not save the host's FPMR
  before unbinding the host's FPSIMD/SVE/SME state, leaving a stale
  value in memory.

Avoid these by eagerly saving and "flushing" the host's FPSIMD/SVE/SME
state when loading a vCPU such that KVM does not need to save any of the
host's FPSIMD/SVE/SME state. For clarity, fpsimd_kvm_prepare() is
removed and the necessary call to fpsimd_save_and_flush_cpu_state() is
placed in kvm_arch_vcpu_load_fp(). As 'fpsimd_state' and 'fpmr_ptr'
should not be used, they are set to NULL; all uses of these will be
removed in subsequent patches.

Historical problems go back at least as far as v5.17, e.g. erroneous
assumptions about TIF_SVE being clear in commit:

  8383741ab2e773a9 ("KVM: arm64: Get rid of host SVE tracking/saving")

... and so this eager save+flush probably needs to be backported to ALL
stable trees.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/04c50cc23a492c4d43fdaefc7c1ecc0ff6f7b82e
  - https://git.kernel.org/stable/c/5289ac43b69c61a49c75720921f2008005a31c43
  - https://git.kernel.org/stable/c/79e140bba70bcacc5fe15bf8c0b958793fd7d56f
  - https://git.kernel.org/stable/c/806d5c1e1d2e5502175a24bf70f251648d99c36a
  - https://git.kernel.org/stable/c/900b444be493b7f404898c785d6605b177a093d0
  - https://git.kernel.org/stable/c/fbc7e61195e23f744814e78524b73b59faa54ab4

------------------------------------------------------------

CVE ID: CVE-2025-22014
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: qcom: pdr: Fix the potential deadlock

When some client process A call pdr_add_lookup() to add the look up for
the service and does schedule locator work, later a process B got a new
server packet indicating locator is up and call pdr_locator_new_server()
which eventually sets pdr->locator_init_complete to true which process A
sees and takes list lock and queries domain list but it will timeout due
to deadlock as the response will queued to the same qmi->wq and it is
ordered workqueue and process B is not able to complete new server
request work due to deadlock on list lock.

Fix it by removing the unnecessary list iteration as the list iteration
is already being done inside locator work, so avoid it here and just
call schedule_work() here.

       Process A                        Process B

                                     process_scheduled_works()
pdr_add_lookup()                      qmi_data_ready_work()
 process_scheduled_works()             pdr_locator_new_server()
                                         pdr->locator_init_complete=true;
   pdr_locator_work()
    mutex_lock(&pdr->list_lock);

     pdr_locate_service()                  mutex_lock(&pdr->list_lock);

      pdr_get_domain_list()
       pr_err("PDR: %s get domain list
               txn wait failed: %d\n",
               req->service_name,
               ret);

Timeout error log due to deadlock:

"
 PDR: tms/servreg get domain list txn wait failed: -110
 PDR: service lookup for msm/adsp/sensor_pd:tms/servreg failed: -110
"

Thanks to Bjorn and Johan for letting me know that this commit also fixes
an audio regression when using the in-kernel pd-mapper as that makes it
easier to hit this race. [1]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 6.1.132
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.85
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.21
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.9
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.14, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/02612f1e4c34d94d6c8ee75bf7d254ed697e22d4
  - https://git.kernel.org/stable/c/0a566a79aca9851fae140536e0fc5b0853c90a90
  - https://git.kernel.org/stable/c/2eeb03ad9f42dfece63051be2400af487ddb96d2
  - https://git.kernel.org/stable/c/72a222b6af10c2a05a5fad0029246229ed8912c2
  - https://git.kernel.org/stable/c/daba84612236de3ab39083e62c9e326a654ebd20
  - https://git.kernel.org/stable/c/f2bbfd50e95bc117360f0f59e629aa03d821ebd6
  - https://git.kernel.org/stable/c/f4489260f5713c94e1966e5f20445bff262876f4

------------------------------------------------------------

CVE ID: CVE-2025-22015
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/migrate: fix shmem xarray update during migration

A shmem folio can be either in page cache or in swap cache, but not at the
same time.  Namely, once it is in swap cache, folio->mapping should be
NULL, and the folio is no longer in a shmem mapping.

In __folio_migrate_mapping(), to determine the number of xarray entries to
update, folio_test_swapbacked() is used, but that conflates shmem in page
cache case and shmem in swap cache case.  It leads to xarray multi-index
entry corruption, since it turns a sibling entry to a normal entry during
xas_store() (see [1] for a userspace reproduction).  Fix it by only using
folio_test_swapcache() to determine whether xarray is storing swap cache
entries or not to choose the right number of xarray entries to update.

[1] https://lore.kernel.org/linux-mm/Z8idPCkaJW1IChjT@casper.infradead.org/

Note:
In __split_huge_page(), folio_test_anon() && folio_test_swapcache() is
used to get swap_cache address space, but that ignores the shmem folio in
swap cache case.  It could lead to NULL pointer dereferencing when a
in-swap-cache shmem folio is split at __xa_store(), since
!folio_test_anon() is true and folio->mapping is NULL.  But fortunately,
its caller split_huge_page_to_list_to_order() bails out early with EBUSY
when folio->mapping is NULL.  So no need to take care of it here.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/29124ae980e2860f0eec7355949d3d3292ee81da
  - https://git.kernel.org/stable/c/49100c0b070e900f87c8fac3be9b9ef8a30fa673
  - https://git.kernel.org/stable/c/60cf233b585cdf1f3c5e52d1225606b86acd08b0
  - https://git.kernel.org/stable/c/75cfb92eb63298d717b6b0118f91ba12c4fcfeb5
  - https://git.kernel.org/stable/c/c057ee03f751d6cecf7ee64f52f6545d94082aaa

------------------------------------------------------------

CVE ID: CVE-2025-22016
Description: In the Linux kernel, the following vulnerability has been resolved:

dpll: fix xa_alloc_cyclic() error handling

In case of returning 1 from xa_alloc_cyclic() (wrapping) ERR_PTR(1) will
be returned, which will cause IS_ERR() to be false. Which can lead to
dereference not allocated pointer (pin).

Fix it by checking if err is lower than zero.

This wasn't found in real usecase, only noticed. Credit to Pierre.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3614bf90130d60f191a5fe218d04f6251c678e13
  - https://git.kernel.org/stable/c/4d350043be684762e581d9bdd32d543621d01a9c
  - https://git.kernel.org/stable/c/cb2f8a5c1fd9e7a1fefa23afe20570e16da1ada4

------------------------------------------------------------

CVE ID: CVE-2025-22017
Description: In the Linux kernel, the following vulnerability has been resolved:

devlink: fix xa_alloc_cyclic() error handling

In case of returning 1 from xa_alloc_cyclic() (wrapping) ERR_PTR(1) will
be returned, which will cause IS_ERR() to be false. Which can lead to
dereference not allocated pointer (rel).

Fix it by checking if err is lower than zero.

This wasn't found in real usecase, only noticed. Credit to Pierre.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/466132f6d28a7e47a82501fe1c46b8f90487412e
  - https://git.kernel.org/stable/c/f3b97b7d4bf316c3991e5634c9f4847c2df35478
  - https://git.kernel.org/stable/c/f8aaa38cfaf6f20afa4db36b6529032fb69165dc

------------------------------------------------------------

CVE ID: CVE-2025-26675
Description: Out-of-bounds read in Windows Subsystem for Linux allows an authorized attacker to elevate privileges locally.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-26675

------------------------------------------------------------

CVE ID: CVE-2025-31344
Description: Heap-based Buffer Overflow vulnerability in openEuler giflib on Linux. This vulnerability is associated with program files gif2rgb.C.

This issue affects giflib: through 5.2.2.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.3
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H
CPEs:
  - No CPE data available.
References:
  - https://gitee.com/src-openeuler/giflib/pulls/54
  - https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-1292
  - http://www.openwall.com/lists/oss-security/2025/04/07/3
  - http://www.openwall.com/lists/oss-security/2025/04/07/4
  - http://www.openwall.com/lists/oss-security/2025/04/07/5
  - http://www.openwall.com/lists/oss-security/2025/04/07/6
  - http://www.openwall.com/lists/oss-security/2025/04/08/1
  - http://www.openwall.com/lists/oss-security/2025/04/09/5
  - http://www.openwall.com/lists/oss-security/2025/04/09/7
  - http://www.openwall.com/lists/oss-security/2025/04/10/1

------------------------------------------------------------

CVE ID: CVE-2025-32428
Description: Jupyter Remote Desktop Proxy allows you to run a Linux Desktop on a JupyterHub. jupyter-remote-desktop-proxy was meant to rely on UNIX sockets readable only by the current user since version 3.0.0, but when used with TigerVNC, the VNC server started by jupyter-remote-desktop-proxy were still accessible via the network. This vulnerability does not affect users having TurboVNC as the vncserver executable. This issue is fixed in 3.0.1.
Severity:
  - CVSS Version: 4.0
  - Base Score: 9.0
  - Base Severity: CRITICAL
  - CVSS Vector: CVSS:4.0/AV:A/AC:L/AT:P/PR:N/UI:N/VC:H/VI:H/VA:H/SC:H/SI:H/SA:H/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - No CPE data available.
References:
  - https://github.com/jupyterhub/jupyter-remote-desktop-proxy/commit/7dd54c25a4253badd8ea68895437e5a66a59090d
  - https://github.com/jupyterhub/jupyter-remote-desktop-proxy/security/advisories/GHSA-vrq4-9hc3-cgp7

------------------------------------------------------------

CVE ID: CVE-2025-2830
Description: By crafting a malformed file name for an attachment in a multipart message, an attacker can trick Thunderbird into including a directory listing of /tmp when the message is forwarded or edited as a new message. This vulnerability could allow attackers to disclose sensitive information from the victim's system. This vulnerability is not limited to Linux; similar behavior has been observed on Windows as well. This vulnerability affects Thunderbird < 137.0.2 and Thunderbird < 128.9.2.
Severity:
  - CVSS Version: 3.1
  - Base Score: 6.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L
CPEs:
  - No CPE data available.
References:
  - https://bugzilla.mozilla.org/show_bug.cgi?id=1956379
  - https://www.mozilla.org/security/advisories/mfsa2025-26/
  - https://www.mozilla.org/security/advisories/mfsa2025-27/

------------------------------------------------------------

CVE ID: CVE-2025-22018
Description: In the Linux kernel, the following vulnerability has been resolved:

atm: Fix NULL pointer dereference

When MPOA_cache_impos_rcvd() receives the msg, it can trigger
Null Pointer Dereference Vulnerability if both entry and
holding_time are NULL. Because there is only for the situation
where entry is NULL and holding_time exists, it can be passed
when both entry and holding_time are NULL. If these are NULL,
the entry will be passd to eg_cache_put() as parameter and
it is referenced by entry->use code in it.

kasan log:

[    3.316691] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000006:I
[    3.317568] KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037]
[    3.318188] CPU: 3 UID: 0 PID: 79 Comm: ex Not tainted 6.14.0-rc2 #102
[    3.318601] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[    3.319298] RIP: 0010:eg_cache_remove_entry+0xa5/0x470
[    3.319677] Code: c1 f7 6e fd 48 c7 c7 00 7e 38 b2 e8 95 64 54 fd 48 c7 c7 40 7e 38 b2 48 89 ee e80
[    3.321220] RSP: 0018:ffff88800583f8a8 EFLAGS: 00010006
[    3.321596] RAX: 0000000000000006 RBX: ffff888005989000 RCX: ffffffffaecc2d8e
[    3.322112] RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000030
[    3.322643] RBP: 0000000000000000 R08: 0000000000000000 R09: fffffbfff6558b88
[    3.323181] R10: 0000000000000003 R11: 203a207972746e65 R12: 1ffff11000b07f15
[    3.323707] R13: dffffc0000000000 R14: ffff888005989000 R15: ffff888005989068
[    3.324185] FS:  000000001b6313c0(0000) GS:ffff88806d380000(0000) knlGS:0000000000000000
[    3.325042] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    3.325545] CR2: 00000000004b4b40 CR3: 000000000248e000 CR4: 00000000000006f0
[    3.326430] Call Trace:
[    3.326725]  <TASK>
[    3.326927]  ? die_addr+0x3c/0xa0
[    3.327330]  ? exc_general_protection+0x161/0x2a0
[    3.327662]  ? asm_exc_general_protection+0x26/0x30
[    3.328214]  ? vprintk_emit+0x15e/0x420
[    3.328543]  ? eg_cache_remove_entry+0xa5/0x470
[    3.328910]  ? eg_cache_remove_entry+0x9a/0x470
[    3.329294]  ? __pfx_eg_cache_remove_entry+0x10/0x10
[    3.329664]  ? console_unlock+0x107/0x1d0
[    3.329946]  ? __pfx_console_unlock+0x10/0x10
[    3.330283]  ? do_syscall_64+0xa6/0x1a0
[    3.330584]  ? entry_SYSCALL_64_after_hwframe+0x47/0x7f
[    3.331090]  ? __pfx_prb_read_valid+0x10/0x10
[    3.331395]  ? down_trylock+0x52/0x80
[    3.331703]  ? vprintk_emit+0x15e/0x420
[    3.331986]  ? __pfx_vprintk_emit+0x10/0x10
[    3.332279]  ? down_trylock+0x52/0x80
[    3.332527]  ? _printk+0xbf/0x100
[    3.332762]  ? __pfx__printk+0x10/0x10
[    3.333007]  ? _raw_write_lock_irq+0x81/0xe0
[    3.333284]  ? __pfx__raw_write_lock_irq+0x10/0x10
[    3.333614]  msg_from_mpoad+0x1185/0x2750
[    3.333893]  ? __build_skb_around+0x27b/0x3a0
[    3.334183]  ? __pfx_msg_from_mpoad+0x10/0x10
[    3.334501]  ? __alloc_skb+0x1c0/0x310
[    3.334809]  ? __pfx___alloc_skb+0x10/0x10
[    3.335283]  ? _raw_spin_lock+0xe0/0xe0
[    3.335632]  ? finish_wait+0x8d/0x1e0
[    3.335975]  vcc_sendmsg+0x684/0xba0
[    3.336250]  ? __pfx_vcc_sendmsg+0x10/0x10
[    3.336587]  ? __pfx_autoremove_wake_function+0x10/0x10
[    3.337056]  ? fdget+0x176/0x3e0
[    3.337348]  __sys_sendto+0x4a2/0x510
[    3.337663]  ? __pfx___sys_sendto+0x10/0x10
[    3.337969]  ? ioctl_has_perm.constprop.0.isra.0+0x284/0x400
[    3.338364]  ? sock_ioctl+0x1bb/0x5a0
[    3.338653]  ? __rseq_handle_notify_resume+0x825/0xd20
[    3.339017]  ? __pfx_sock_ioctl+0x10/0x10
[    3.339316]  ? __pfx___rseq_handle_notify_resume+0x10/0x10
[    3.339727]  ? selinux_file_ioctl+0xa4/0x260
[    3.340166]  __x64_sys_sendto+0xe0/0x1c0
[    3.340526]  ? syscall_exit_to_user_mode+0x123/0x140
[    3.340898]  do_syscall_64+0xa6/0x1a0
[    3.341170]  entry_SYSCALL_64_after_hwframe+0x77/0x7f
[    3.341533] RIP: 0033:0x44a380
[    3.341757] Code: 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 41 89 ca 64 8b 04 25 18 00 00 00 85 c00
[    
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.12, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.133
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.86
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.22
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.1
References:
  - https://git.kernel.org/stable/c/09691f367df44fe93255274d80a439f9bb3263fc
  - https://git.kernel.org/stable/c/0ef6e49881b6b50ac454cb9d6501d009fdceb6fc
  - https://git.kernel.org/stable/c/14c7aca5ba2740973de27c1bb8df77b4dcb6f775
  - https://git.kernel.org/stable/c/1505f9b720656b17865e4166ab002960162bf679
  - https://git.kernel.org/stable/c/3c23bb2c894e9ef2727682f98c341b20f78c9013
  - https://git.kernel.org/stable/c/9da6b6340dbcf0f60ae3ec6a7d6438337c32518a
  - https://git.kernel.org/stable/c/ab92f51c7f53a08f1a686bfb80690ebb3672357d
  - https://git.kernel.org/stable/c/bf2986fcf82a449441f9ee4335df19be19e83970
  - https://git.kernel.org/stable/c/d7f1e4a53a51cc6ba833afcb40439f18dab61c1f

------------------------------------------------------------

CVE ID: CVE-2024-58092
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: fix legacy client tracking initialization

Get rid of the nfsd4_legacy_tracking_ops->init() call in
check_for_legacy_methods().  That will be handled in the caller
(nfsd4_client_tracking_init()).  Otherwise, we'll wind up calling
nfsd4_legacy_tracking_ops->init() twice, and the second time we'll
trigger the BUG_ON() in nfsd4_init_recdir().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/95407304253a4bf03494d921c6913e220c26cc63
  - https://git.kernel.org/stable/c/cdd66082b227eb695cbf54b7c121ea032e869981
  - https://git.kernel.org/stable/c/de71d4e211eddb670b285a0ea477a299601ce1ca

------------------------------------------------------------

CVE ID: CVE-2025-22019
Description: In the Linux kernel, the following vulnerability has been resolved:

bcachefs: bch2_ioctl_subvolume_destroy() fixes

bch2_evict_subvolume_inodes() was getting stuck - due to incorrectly
pruning the dcache.

Also, fix missing permissions checks.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/558317a5c61045d460a37372181e7b43c0c002bb
  - https://git.kernel.org/stable/c/707549600c4a012ed71c0204a7992a679880bf33
  - https://git.kernel.org/stable/c/82383abd39abd635511b8956284a5cc8134c4dc1
  - https://git.kernel.org/stable/c/9e6e83e1e2d01b99e70cd7812d7f758a8def9fc8

------------------------------------------------------------

CVE ID: CVE-2025-22020
Description: In the Linux kernel, the following vulnerability has been resolved:

memstick: rtsx_usb_ms: Fix slab-use-after-free in rtsx_usb_ms_drv_remove

This fixes the following crash:

==================================================================
BUG: KASAN: slab-use-after-free in rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]
Read of size 8 at addr ffff888136335380 by task kworker/6:0/140241

CPU: 6 UID: 0 PID: 140241 Comm: kworker/6:0 Kdump: loaded Tainted: G            E      6.14.0-rc6+ #1
Tainted: [E]=UNSIGNED_MODULE
Hardware name: LENOVO 30FNA1V7CW/1057, BIOS S0EKT54A 07/01/2024
Workqueue: events rtsx_usb_ms_poll_card [rtsx_usb_ms]
Call Trace:
 <TASK>
 dump_stack_lvl+0x51/0x70
 print_address_description.constprop.0+0x27/0x320
 ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]
 print_report+0x3e/0x70
 kasan_report+0xab/0xe0
 ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]
 rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]
 ? __pfx_rtsx_usb_ms_poll_card+0x10/0x10 [rtsx_usb_ms]
 ? __pfx___schedule+0x10/0x10
 ? kick_pool+0x3b/0x270
 process_one_work+0x357/0x660
 worker_thread+0x390/0x4c0
 ? __pfx_worker_thread+0x10/0x10
 kthread+0x190/0x1d0
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x2d/0x50
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK>

Allocated by task 161446:
 kasan_save_stack+0x20/0x40
 kasan_save_track+0x10/0x30
 __kasan_kmalloc+0x7b/0x90
 __kmalloc_noprof+0x1a7/0x470
 memstick_alloc_host+0x1f/0xe0 [memstick]
 rtsx_usb_ms_drv_probe+0x47/0x320 [rtsx_usb_ms]
 platform_probe+0x60/0xe0
 call_driver_probe+0x35/0x120
 really_probe+0x123/0x410
 __driver_probe_device+0xc7/0x1e0
 driver_probe_device+0x49/0xf0
 __device_attach_driver+0xc6/0x160
 bus_for_each_drv+0xe4/0x160
 __device_attach+0x13a/0x2b0
 bus_probe_device+0xbd/0xd0
 device_add+0x4a5/0x760
 platform_device_add+0x189/0x370
 mfd_add_device+0x587/0x5e0
 mfd_add_devices+0xb1/0x130
 rtsx_usb_probe+0x28e/0x2e0 [rtsx_usb]
 usb_probe_interface+0x15c/0x460
 call_driver_probe+0x35/0x120
 really_probe+0x123/0x410
 __driver_probe_device+0xc7/0x1e0
 driver_probe_device+0x49/0xf0
 __device_attach_driver+0xc6/0x160
 bus_for_each_drv+0xe4/0x160
 __device_attach+0x13a/0x2b0
 rebind_marked_interfaces.isra.0+0xcc/0x110
 usb_reset_device+0x352/0x410
 usbdev_do_ioctl+0xe5c/0x1860
 usbdev_ioctl+0xa/0x20
 __x64_sys_ioctl+0xc5/0xf0
 do_syscall_64+0x59/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

Freed by task 161506:
 kasan_save_stack+0x20/0x40
 kasan_save_track+0x10/0x30
 kasan_save_free_info+0x36/0x60
 __kasan_slab_free+0x34/0x50
 kfree+0x1fd/0x3b0
 device_release+0x56/0xf0
 kobject_cleanup+0x73/0x1c0
 rtsx_usb_ms_drv_remove+0x13d/0x220 [rtsx_usb_ms]
 platform_remove+0x2f/0x50
 device_release_driver_internal+0x24b/0x2e0
 bus_remove_device+0x124/0x1d0
 device_del+0x239/0x530
 platform_device_del.part.0+0x19/0xe0
 platform_device_unregister+0x1c/0x40
 mfd_remove_devices_fn+0x167/0x170
 device_for_each_child_reverse+0xc9/0x130
 mfd_remove_devices+0x6e/0xa0
 rtsx_usb_disconnect+0x2e/0xd0 [rtsx_usb]
 usb_unbind_interface+0xf3/0x3f0
 device_release_driver_internal+0x24b/0x2e0
 proc_disconnect_claim+0x13d/0x220
 usbdev_do_ioctl+0xb5e/0x1860
 usbdev_ioctl+0xa/0x20
 __x64_sys_ioctl+0xc5/0xf0
 do_syscall_64+0x59/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

Last potentially related work creation:
 kasan_save_stack+0x20/0x40
 kasan_record_aux_stack+0x85/0x90
 insert_work+0x29/0x100
 __queue_work+0x34a/0x540
 call_timer_fn+0x2a/0x160
 expire_timers+0x5f/0x1f0
 __run_timer_base.part.0+0x1b6/0x1e0
 run_timer_softirq+0x8b/0xe0
 handle_softirqs+0xf9/0x360
 __irq_exit_rcu+0x114/0x130
 sysvec_apic_timer_interrupt+0x72/0x90
 asm_sysvec_apic_timer_interrupt+0x16/0x20

Second to last potentially related work creation:
 kasan_save_stack+0x20/0x40
 kasan_record_aux_stack+0x85/0x90
 insert_work+0x29/0x100
 __queue_work+0x34a/0x540
 call_timer_fn+0x2a/0x160
 expire_timers+0x5f/0x1f0
 __run_timer_base.part.0+0x1b6/0x1e0
 run_timer_softirq+0x8b/0xe0
 handle_softirqs+0xf9/0x
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.0, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.133
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.86
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.22
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.1
References:
  - https://git.kernel.org/stable/c/0067cb7d7e7c277e91a0887a3c24e71462379469
  - https://git.kernel.org/stable/c/31f0eaed6914333f42501fc7e0f6830879f5ef2d
  - https://git.kernel.org/stable/c/4676741a3464b300b486e70585c3c9b692be1632
  - https://git.kernel.org/stable/c/52d942a5302eefb3b7a3bfee310a5a33feeedc21
  - https://git.kernel.org/stable/c/6186fb2cd36317277a8423687982140a7f3f7841
  - https://git.kernel.org/stable/c/75123adf204f997e11bbddee48408c284f51c050
  - https://git.kernel.org/stable/c/914c5e5bfceb9878f3056eaf4d1c88f2cbe0a185
  - https://git.kernel.org/stable/c/9dfaf4d723c62bda8d9d1340e2e78acf0c190439
  - https://git.kernel.org/stable/c/b094e8e3988e02e8cef7a756c8d2cea9c12509ab

------------------------------------------------------------

CVE ID: CVE-2025-22021
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: socket: Lookup orig tuple for IPv6 SNAT

nf_sk_lookup_slow_v4 does the conntrack lookup for IPv4 packets to
restore the original 5-tuple in case of SNAT, to be able to find the
right socket (if any). Then socket_match() can correctly check whether
the socket was transparent.

However, the IPv6 counterpart (nf_sk_lookup_slow_v6) lacks this
conntrack lookup, making xt_socket fail to match on the socket when the
packet was SNATed. Add the same logic to nf_sk_lookup_slow_v6.

IPv6 SNAT is used in Kubernetes clusters for pod-to-world packets, as
pods' addresses are in the fd00::/8 ULA subnet and need to be replaced
with the node's external address. Cilium leverages Envoy to enforce L7
policies, and Envoy uses transparent sockets. Cilium inserts an iptables
prerouting rule that matches on `-m socket --transparent` and redirects
the packets to localhost, but it fails to match SNATed IPv6 packets due
to that missing conntrack lookup.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1ca2169cc19dca893c7aae6af122852097435d16
  - https://git.kernel.org/stable/c/1ec43100f7123010730b7ddfc3d5c2eac19e70e7
  - https://git.kernel.org/stable/c/221c27259324ec1404f028d4f5a0f2ae7f63ee23
  - https://git.kernel.org/stable/c/2bb139e483f8cbe488d19d8c1135ac3615e2668c
  - https://git.kernel.org/stable/c/41904cbb343d115931d6bf79aa2c815cac4ef72b
  - https://git.kernel.org/stable/c/5251041573850e5020cd447374e23010be698898
  - https://git.kernel.org/stable/c/58ab63d3ded2ca6141357a2b24eee8453d0f871d
  - https://git.kernel.org/stable/c/6488b96a79a26e19100ad872622f04e93b638d7f
  - https://git.kernel.org/stable/c/932b32ffd7604fb00b5c57e239a3cc4d901ccf6e

------------------------------------------------------------

CVE ID: CVE-2025-22022
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: xhci: Apply the link chain quirk on NEC isoc endpoints

Two clearly different specimens of NEC uPD720200 (one with start/stop
bug, one without) were seen to cause IOMMU faults after some Missed
Service Errors. Faulting address is immediately after a transfer ring
segment and patched dynamic debug messages revealed that the MSE was
received when waiting for a TD near the end of that segment:

[ 1.041954] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ffa08fe0
[ 1.042120] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09000 flags=0x0000]
[ 1.042146] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09040 flags=0x0000]

It gets even funnier if the next page is a ring segment accessible to
the HC. Below, it reports MSE in segment at ff1e8000, plows through a
zero-filled page at ff1e9000 and starts reporting events for TRBs in
page at ff1ea000 every microframe, instead of jumping to seg ff1e6000.

[ 7.041671] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0
[ 7.041999] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0
[ 7.042011] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint
[ 7.042028] xhci_hcd: All TDs skipped for slot 1 ep 2. Clear skip flag.
[ 7.042134] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint
[ 7.042138] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31
[ 7.042144] xhci_hcd: Looking for event-dma 00000000ff1ea040 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820
[ 7.042259] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint
[ 7.042262] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31
[ 7.042266] xhci_hcd: Looking for event-dma 00000000ff1ea050 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820

At some point completion events change from Isoch Buffer Overrun to
Short Packet and the HC finally finds cycle bit mismatch in ff1ec000.

[ 7.098130] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13
[ 7.098132] xhci_hcd: Looking for event-dma 00000000ff1ecc50 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820
[ 7.098254] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13
[ 7.098256] xhci_hcd: Looking for event-dma 00000000ff1ecc60 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820
[ 7.098379] xhci_hcd: Overrun event on slot 1 ep 2

It's possible that data from the isochronous device were written to
random buffers of pending TDs on other endpoints (either IN or OUT),
other devices or even other HCs in the same IOMMU domain.

Lastly, an error from a different USB device on another HC. Was it
caused by the above? I don't know, but it may have been. The disk
was working without any other issues and generated PCIe traffic to
starve the NEC of upstream BW and trigger those MSEs. The two HCs
shared one x1 slot by means of a commercial "PCIe splitter" board.

[ 7.162604] usb 10-2: reset SuperSpeed USB device number 3 using xhci_hcd
[ 7.178990] sd 9:0:0:0: [sdb] tag#0 UNKNOWN(0x2003) Result: hostbyte=0x07 driverbyte=DRIVER_OK cmd_age=0s
[ 7.179001] sd 9:0:0:0: [sdb] tag#0 CDB: opcode=0x28 28 00 04 02 ae 00 00 02 00 00
[ 7.179004] I/O error, dev sdb, sector 67284480 op 0x0:(READ) flags 0x80700 phys_seg 5 prio class 0

Fortunately, it appears that this ridiculous bug is avoided by setting
the chain bit of Link TRBs on isochronous rings. Other ancient HCs are
known which also expect the bit to be set and they ignore Link TRBs if
it's not. Reportedly, 0.95 spec guaranteed that the bit is set.

The bandwidth-starved NEC HC running a 32KB/uframe UVC endpoint reports
tens of MSEs per second and runs into the bug within seconds. Chaining
Link TRBs allows the same workload to run for many minutes, many times.

No ne
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/061a1683bae6ef56ab8fa392725ba7495515cd1d
  - https://git.kernel.org/stable/c/43a18225150ce874d23b37761c302a5dffee1595
  - https://git.kernel.org/stable/c/a4931d9fb99eb5462f3eaa231999d279c40afb21
  - https://git.kernel.org/stable/c/bb0ba4cb1065e87f9cc75db1fa454e56d0894d01

------------------------------------------------------------

CVE ID: CVE-2025-22023
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: xhci: Don't skip on Stopped - Length Invalid

Up until commit d56b0b2ab142 ("usb: xhci: ensure skipped isoc TDs are
returned when isoc ring is stopped") in v6.11, the driver didn't skip
missed isochronous TDs when handling Stoppend and Stopped - Length
Invalid events. Instead, it erroneously cleared the skip flag, which
would cause the ring to get stuck, as future events won't match the
missed TD which is never removed from the queue until it's cancelled.

This buggy logic seems to have been in place substantially unchanged
since the 3.x series over 10 years ago, which probably speaks first
and foremost about relative rarity of this case in normal usage, but
by the spec I see no reason why it shouldn't be possible.

After d56b0b2ab142, TDs are immediately skipped when handling those
Stopped events. This poses a potential problem in case of Stopped -
Length Invalid, which occurs either on completed TDs (likely already
given back) or Link and No-Op TRBs. Such event won't be recognized
as matching any TD (unless it's the rare Link TRB inside a TD) and
will result in skipping all pending TDs, giving them back possibly
before they are done, risking isoc data loss and maybe UAF by HW.

As a compromise, don't skip and don't clear the skip flag on this
kind of event. Then the next event will skip missed TDs. A downside
of not handling Stopped - Length Invalid on a Link inside a TD is
that if the TD is cancelled, its actual length will not be updated
to account for TRBs (silently) completed before the TD was stopped.

I had no luck producing this sequence of completion events so there
is no compelling demonstration of any resulting disaster. It may be
a very rare, obscure condition. The sole motivation for this patch
is that if such unlikely event does occur, I'd rather risk reporting
a cancelled partially done isoc frame as empty than gamble with UAF.

This will be fixed more properly by looking at Stopped event's TRB
pointer when making skipping decisions, but such rework is unlikely
to be backported to v6.12, which will stay around for a few years.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/49cf6f5293aeb706dd672608478336a003f37df6
  - https://git.kernel.org/stable/c/58d0a3fab5f4fdc112c16a4c6d382f62097afd1c
  - https://git.kernel.org/stable/c/6af20ac254cbd0e1178a3542767c9308e209eee5
  - https://git.kernel.org/stable/c/de9e78167f760a699806793d7c987239e4f6c8c3

------------------------------------------------------------

CVE ID: CVE-2023-53034
Description: In the Linux kernel, the following vulnerability has been resolved:

ntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_trans

There is a kernel API ntb_mw_clear_trans() would pass 0 to both addr and
size. This would make xlate_pos negative.

[   23.734156] switchtec switchtec0: MW 0: part 0 addr 0x0000000000000000 size 0x0000000000000000
[   23.734158] ================================================================================
[   23.734172] UBSAN: shift-out-of-bounds in drivers/ntb/hw/mscc/ntb_hw_switchtec.c:293:7
[   23.734418] shift exponent -1 is negative

Ensuring xlate_pos is a positive or zero before BIT.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0df2e03e4620548b41891b4e0d1bd9d2e0d8a39a
  - https://git.kernel.org/stable/c/2429bdf26a0f3950fdd996861e9c1a3873af1dbe
  - https://git.kernel.org/stable/c/36d32cfb00d42e865396424bb5d340fc0a28870d
  - https://git.kernel.org/stable/c/5b6857bb3bfb0dae17fab1e42c1e82c204a508b1
  - https://git.kernel.org/stable/c/7ed22f8d8be26225a78cf5e85b2036421a6bf2d5
  - https://git.kernel.org/stable/c/c61a3f2df162ba424be0141649a9ef5f28eaccc1
  - https://git.kernel.org/stable/c/cb153bdc1812a3375639ed6ca5f147eaefb65349
  - https://git.kernel.org/stable/c/de203da734fae00e75be50220ba5391e7beecdf9
  - https://git.kernel.org/stable/c/f56951f211f181410a383d305e8d370993e45294

------------------------------------------------------------

CVE ID: CVE-2024-58093
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI/ASPM: Fix link state exit during switch upstream function removal

Before 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to
avoid use-after-free"), we would free the ASPM link only after the last
function on the bus pertaining to the given link was removed.

That was too late. If function 0 is removed before sibling function,
link->downstream would point to free'd memory after.

After above change, we freed the ASPM parent link state upon any function
removal on the bus pertaining to a given link.

That is too early. If the link is to a PCIe switch with MFD on the upstream
port, then removing functions other than 0 first would free a link which
still remains parent_link to the remaining downstream ports.

The resulting GPFs are especially frequent during hot-unplug, because
pciehp removes devices on the link bus in reverse order.

On that switch, function 0 is the virtual P2P bridge to the internal bus.
Free exactly when function 0 is removed -- before the parent link is
obsolete, but after all subordinate links are gone.

[kwilczynski: commit log]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/cbf937dcadfd571a434f8074d057b32cd14fbea5

------------------------------------------------------------

CVE ID: CVE-2024-58094
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: add check read-only before truncation in jfs_truncate_nolock()

Added a check for "read-only" mode in the `jfs_truncate_nolock`
function to avoid errors related to writing to a read-only
filesystem.

Call stack:

block_write_begin() {
  jfs_write_failed() {
    jfs_truncate() {
      jfs_truncate_nolock() {
        txEnd() {
          ...
          log = JFS_SBI(tblk->sb)->log;
          // (log == NULL)

If the `isReadOnly(ip)` condition is triggered in
`jfs_truncate_nolock`, the function execution will stop, and no
further data modification will occur. Instead, the `xtTruncate`
function will be called with the "COMMIT_WMAP" flag, preventing
modifications in "read-only" mode.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/b5799dd77054c1ec49b0088b006c9908e256843b
  - https://git.kernel.org/stable/c/f605bc3e162f5c6faa9bd3602ce496053d06a4bb

------------------------------------------------------------

CVE ID: CVE-2024-58095
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: add check read-only before txBeginAnon() call

Added a read-only check before calling `txBeginAnon` in `extAlloc`
and `extRecord`. This prevents modification attempts on a read-only
mounted filesystem, avoiding potential errors or crashes.

Call trace:
 txBeginAnon+0xac/0x154
 extAlloc+0xe8/0xdec fs/jfs/jfs_extent.c:78
 jfs_get_block+0x340/0xb98 fs/jfs/inode.c:248
 __block_write_begin_int+0x580/0x166c fs/buffer.c:2128
 __block_write_begin fs/buffer.c:2177 [inline]
 block_write_begin+0x98/0x11c fs/buffer.c:2236
 jfs_write_begin+0x44/0x88 fs/jfs/inode.c:299
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0176e69743ecc02961f2ae1ea42439cd2bf9ed58
  - https://git.kernel.org/stable/c/15469c408af2d7a52fb186a92f2f091b0f13b1fb

------------------------------------------------------------

CVE ID: CVE-2024-58096
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath11k: add srng->lock for ath11k_hal_srng_* in monitor mode

ath11k_hal_srng_* should be used with srng->lock to protect srng data.

For ath11k_dp_rx_mon_dest_process() and ath11k_dp_full_mon_process_rx(),
they use ath11k_hal_srng_* for many times but never call srng->lock.

So when running (full) monitor mode, warning will occur:
RIP: 0010:ath11k_hal_srng_dst_peek+0x18/0x30 [ath11k]
Call Trace:
 ? ath11k_hal_srng_dst_peek+0x18/0x30 [ath11k]
 ath11k_dp_rx_process_mon_status+0xc45/0x1190 [ath11k]
 ? idr_alloc_u32+0x97/0xd0
 ath11k_dp_rx_process_mon_rings+0x32a/0x550 [ath11k]
 ath11k_dp_service_srng+0x289/0x5a0 [ath11k]
 ath11k_pcic_ext_grp_napi_poll+0x30/0xd0 [ath11k]
 __napi_poll+0x30/0x1f0
 net_rx_action+0x198/0x320
 __do_softirq+0xdd/0x319

So add srng->lock for them to avoid such warnings.

Inorder to fetch the srng->lock, should change srng's definition from
'void' to 'struct hal_srng'. And initialize them elsewhere to prevent
one line of code from being too long. This is consistent with other ring
process functions, such as ath11k_dp_process_rx().

Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30
Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/63b7af49496d0e32f7a748b6af3361ec138b1bd3
  - https://git.kernel.org/stable/c/b85758e76b6452740fc2a08ced6759af64c0d59a

------------------------------------------------------------

CVE ID: CVE-2024-58097
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath11k: fix RCU stall while reaping monitor destination ring

While processing the monitor destination ring, MSDUs are reaped from the
link descriptor based on the corresponding buf_id.

However, sometimes the driver cannot obtain a valid buffer corresponding
to the buf_id received from the hardware. This causes an infinite loop
in the destination processing, resulting in a kernel crash.

kernel log:
ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309
ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed
ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309
ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed

Fix this by skipping the problematic buf_id and reaping the next entry,
replacing the break with the next MSDU processing.

Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30
Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.6, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/16c6c35c03ea73054a1f6d3302a4ce4a331b427d
  - https://git.kernel.org/stable/c/b4991fc41745645f8050506f5a8578bd11e6b378

------------------------------------------------------------

CVE ID: CVE-2025-22024
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: fix management of listener transports

Currently, when no active threads are running, a root user using nfsdctl
command can try to remove a particular listener from the list of previously
added ones, then start the server by increasing the number of threads,
it leads to the following problem:

[  158.835354] refcount_t: addition on 0; use-after-free.
[  158.835603] WARNING: CPU: 2 PID: 9145 at lib/refcount.c:25 refcount_warn_saturate+0x160/0x1a0
[  158.836017] Modules linked in: rpcrdma rdma_cm iw_cm ib_cm ib_core nfsd auth_rpcgss nfs_acl lockd grace overlay isofs uinput snd_seq_dummy snd_hrtimer nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 rfkill ip_set nf_tables qrtr sunrpc vfat fat uvcvideo videobuf2_vmalloc videobuf2_memops uvc videobuf2_v4l2 videodev videobuf2_common snd_hda_codec_generic mc e1000e snd_hda_intel snd_intel_dspcfg snd_hda_codec snd_hda_core snd_hwdep snd_seq snd_seq_device snd_pcm snd_timer snd soundcore sg loop dm_multipath dm_mod nfnetlink vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vmw_vmci vsock xfs libcrc32c crct10dif_ce ghash_ce vmwgfx sha2_ce sha256_arm64 sr_mod sha1_ce cdrom nvme drm_client_lib drm_ttm_helper ttm nvme_core drm_kms_helper nvme_auth drm fuse
[  158.840093] CPU: 2 UID: 0 PID: 9145 Comm: nfsd Kdump: loaded Tainted: G    B   W          6.13.0-rc6+ #7
[  158.840624] Tainted: [B]=BAD_PAGE, [W]=WARN
[  158.840802] Hardware name: VMware, Inc. VMware20,1/VBSA, BIOS VMW201.00V.24006586.BA64.2406042154 06/04/2024
[  158.841220] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)
[  158.841563] pc : refcount_warn_saturate+0x160/0x1a0
[  158.841780] lr : refcount_warn_saturate+0x160/0x1a0
[  158.842000] sp : ffff800089be7d80
[  158.842147] x29: ffff800089be7d80 x28: ffff00008e68c148 x27: ffff00008e68c148
[  158.842492] x26: ffff0002e3b5c000 x25: ffff600011cd1829 x24: ffff00008653c010
[  158.842832] x23: ffff00008653c000 x22: 1fffe00011cd1829 x21: ffff00008653c028
[  158.843175] x20: 0000000000000002 x19: ffff00008653c010 x18: 0000000000000000
[  158.843505] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
[  158.843836] x14: 0000000000000000 x13: 0000000000000001 x12: ffff600050a26493
[  158.844143] x11: 1fffe00050a26492 x10: ffff600050a26492 x9 : dfff800000000000
[  158.844475] x8 : 00009fffaf5d9b6e x7 : ffff000285132493 x6 : 0000000000000001
[  158.844823] x5 : ffff000285132490 x4 : ffff600050a26493 x3 : ffff8000805e72bc
[  158.845174] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000098588000
[  158.845528] Call trace:
[  158.845658]  refcount_warn_saturate+0x160/0x1a0 (P)
[  158.845894]  svc_recv+0x58c/0x680 [sunrpc]
[  158.846183]  nfsd+0x1fc/0x348 [nfsd]
[  158.846390]  kthread+0x274/0x2f8
[  158.846546]  ret_from_fork+0x10/0x20
[  158.846714] ---[ end trace 0000000000000000 ]---

nfsd_nl_listener_set_doit() would manipulate the list of transports of
server's sv_permsocks and close the specified listener but the other
list of transports (server's sp_xprts list) would not be changed leading
to the problem above.

Instead, determined if the nfsdctl is trying to remove a listener, in
which case, delete all the existing listener transports and re-create
all-but-the-removed ones.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/052a34f093fb940a145493d1438e7abbfe507cdd
  - https://git.kernel.org/stable/c/0f42df0ab2b11ea6b2884bdaf6dbc3be6dde7e82
  - https://git.kernel.org/stable/c/a84c80515ca8a0cdf6d06f1b6ca721224b08453e
  - https://git.kernel.org/stable/c/d093c90892607be505e801469d6674459e69ab89

------------------------------------------------------------

CVE ID: CVE-2025-22025
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: put dl_stid if fail to queue dl_recall

Before calling nfsd4_run_cb to queue dl_recall to the callback_wq, we
increment the reference count of dl_stid.
We expect that after the corresponding work_struct is processed, the
reference count of dl_stid will be decremented through the callback
function nfsd4_cb_recall_release.
However, if the call to nfsd4_run_cb fails, the incremented reference
count of dl_stid will not be decremented correspondingly, leading to the
following nfs4_stid leak:
unreferenced object 0xffff88812067b578 (size 344):
  comm "nfsd", pid 2761, jiffies 4295044002 (age 5541.241s)
  hex dump (first 32 bytes):
    01 00 00 00 6b 6b 6b 6b b8 02 c0 e2 81 88 ff ff  ....kkkk........
    00 6b 6b 6b 6b 6b 6b 6b 00 00 00 00 ad 4e ad de  .kkkkkkk.....N..
  backtrace:
    kmem_cache_alloc+0x4b9/0x700
    nfsd4_process_open1+0x34/0x300
    nfsd4_open+0x2d1/0x9d0
    nfsd4_proc_compound+0x7a2/0xe30
    nfsd_dispatch+0x241/0x3e0
    svc_process_common+0x5d3/0xcc0
    svc_process+0x2a3/0x320
    nfsd+0x180/0x2e0
    kthread+0x199/0x1d0
    ret_from_fork+0x30/0x50
    ret_from_fork_asm+0x1b/0x30
unreferenced object 0xffff8881499f4d28 (size 368):
  comm "nfsd", pid 2761, jiffies 4295044005 (age 5541.239s)
  hex dump (first 32 bytes):
    01 00 00 00 00 00 00 00 30 4d 9f 49 81 88 ff ff  ........0M.I....
    30 4d 9f 49 81 88 ff ff 20 00 00 00 01 00 00 00  0M.I.... .......
  backtrace:
    kmem_cache_alloc+0x4b9/0x700
    nfs4_alloc_stid+0x29/0x210
    alloc_init_deleg+0x92/0x2e0
    nfs4_set_delegation+0x284/0xc00
    nfs4_open_delegation+0x216/0x3f0
    nfsd4_process_open2+0x2b3/0xee0
    nfsd4_open+0x770/0x9d0
    nfsd4_proc_compound+0x7a2/0xe30
    nfsd_dispatch+0x241/0x3e0
    svc_process_common+0x5d3/0xcc0
    svc_process+0x2a3/0x320
    nfsd+0x180/0x2e0
    kthread+0x199/0x1d0
    ret_from_fork+0x30/0x50
    ret_from_fork_asm+0x1b/0x30
Fix it by checking the result of nfsd4_run_cb and call nfs4_put_stid if
fail to queue dl_recall.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/133f5e2a37ce08c82d24e8fba65e0a81deae4609
  - https://git.kernel.org/stable/c/230ca758453c63bd38e4d9f4a21db698f7abada8
  - https://git.kernel.org/stable/c/63b91c8ff4589f5263873b24c052447a28e10ef7
  - https://git.kernel.org/stable/c/9a81cde8c7ce65dd90fb47ceea93a45fc1a2fbd1
  - https://git.kernel.org/stable/c/b874cdef4e67e5150e07eff0eae1cbb21fb92da1
  - https://git.kernel.org/stable/c/cad3479b63661a399c9df1d0b759e1806e2df3c8
  - https://git.kernel.org/stable/c/cdb796137c57e68ca34518d53be53b679351eb86
  - https://git.kernel.org/stable/c/d96587cc93ec369031bcd7658c6adc719873c9fd

------------------------------------------------------------

CVE ID: CVE-2025-22026
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: don't ignore the return code of svc_proc_register()

Currently, nfsd_proc_stat_init() ignores the return value of
svc_proc_register(). If the procfile creation fails, then the kernel
will WARN when it tries to remove the entry later.

Fix nfsd_proc_stat_init() to return the same type of pointer as
svc_proc_register(), and fix up nfsd_net_init() to check that and fail
the nfsd_net construction if it occurs.

svc_proc_register() can fail if the dentry can't be allocated, or if an
identical dentry already exists. The second case is pretty unlikely in
the nfsd_net construction codepath, so if this happens, return -ENOMEM.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6a59b70fe71ec66c0dd19e2c279c71846a3fb2f0
  - https://git.kernel.org/stable/c/930b64ca0c511521f0abdd1d57ce52b2a6e3476b
  - https://git.kernel.org/stable/c/9d9456185fd5f1891c74354ee297f19538141ead
  - https://git.kernel.org/stable/c/e31957a819e60cf0bc9a49408765e6095fd3d046

------------------------------------------------------------

CVE ID: CVE-2025-22027
Description: In the Linux kernel, the following vulnerability has been resolved:

media: streamzap: fix race between device disconnection and urb callback

Syzkaller has reported a general protection fault at function
ir_raw_event_store_with_filter(). This crash is caused by a NULL pointer
dereference of dev->raw pointer, even though it is checked for NULL in
the same function, which means there is a race condition. It occurs due
to the incorrect order of actions in the streamzap_disconnect() function:
rc_unregister_device() is called before usb_kill_urb(). The dev->raw
pointer is freed and set to NULL in rc_unregister_device(), and only
after that usb_kill_urb() waits for in-progress requests to finish.

If rc_unregister_device() is called while streamzap_callback() handler is
not finished, this can lead to accessing freed resources. Thus
rc_unregister_device() should be called after usb_kill_urb().

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.36, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/15483afb930fc2f883702dc96f80efbe4055235e
  - https://git.kernel.org/stable/c/30ef7cfee752ca318d5902cb67b60d9797ccd378
  - https://git.kernel.org/stable/c/4db62b60af2ccdea6ac5452fd20e29587ed85f57
  - https://git.kernel.org/stable/c/8760da4b9d44c36b93b6e4cf401ec7fe520015bd
  - https://git.kernel.org/stable/c/adf0ddb914c9e5b3e50da4c97959e82de2df75c3
  - https://git.kernel.org/stable/c/e11652a6514ec805440c1bb3739e6c6236fffcc7
  - https://git.kernel.org/stable/c/f1d518c0bad01abe83c2df880274cb6a39f4a457
  - https://git.kernel.org/stable/c/f656cfbc7a293a039d6a0c7100e1c846845148c1

------------------------------------------------------------

CVE ID: CVE-2025-22028
Description: In the Linux kernel, the following vulnerability has been resolved:

media: vimc: skip .s_stream() for stopped entities

Syzbot reported [1] a warning prompted by a check in call_s_stream()
that checks whether .s_stream() operation is warranted for unstarted
or stopped subdevs.

Add a simple fix in vimc_streamer_pipeline_terminate() ensuring that
entities skip a call to .s_stream() unless they have been previously
properly started.

[1] Syzbot report:
------------[ cut here ]------------
WARNING: CPU: 0 PID: 5933 at drivers/media/v4l2-core/v4l2-subdev.c:460 call_s_stream+0x2df/0x350 drivers/media/v4l2-core/v4l2-subdev.c:460
Modules linked in:
CPU: 0 UID: 0 PID: 5933 Comm: syz-executor330 Not tainted 6.13.0-rc2-syzkaller-00362-g2d8308bf5b67 #0
...
Call Trace:
 <TASK>
 vimc_streamer_pipeline_terminate+0x218/0x320 drivers/media/test-drivers/vimc/vimc-streamer.c:62
 vimc_streamer_pipeline_init drivers/media/test-drivers/vimc/vimc-streamer.c:101 [inline]
 vimc_streamer_s_stream+0x650/0x9a0 drivers/media/test-drivers/vimc/vimc-streamer.c:203
 vimc_capture_start_streaming+0xa1/0x130 drivers/media/test-drivers/vimc/vimc-capture.c:256
 vb2_start_streaming+0x15f/0x5a0 drivers/media/common/videobuf2/videobuf2-core.c:1789
 vb2_core_streamon+0x2a7/0x450 drivers/media/common/videobuf2/videobuf2-core.c:2348
 vb2_streamon drivers/media/common/videobuf2/videobuf2-v4l2.c:875 [inline]
 vb2_ioctl_streamon+0xf4/0x170 drivers/media/common/videobuf2/videobuf2-v4l2.c:1118
 __video_do_ioctl+0xaf0/0xf00 drivers/media/v4l2-core/v4l2-ioctl.c:3122
 video_usercopy+0x4d2/0x1620 drivers/media/v4l2-core/v4l2-ioctl.c:3463
 v4l2_ioctl+0x1ba/0x250 drivers/media/v4l2-core/v4l2-dev.c:366
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:906 [inline]
 __se_sys_ioctl fs/ioctl.c:892 [inline]
 __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7f2b85c01b19
...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/36cef585e2a31e4ddf33a004b0584a7a572246de
  - https://git.kernel.org/stable/c/6f6064dab4dcfb7e34a395040a0c9dc22cc8765d
  - https://git.kernel.org/stable/c/7a58d4c4cf8ff60ab1f93399deefaf6057da91c7
  - https://git.kernel.org/stable/c/845e9286ff99ee88cfdeb2b748f730003a512190
  - https://git.kernel.org/stable/c/a505075730d23ccc19fc4ac382a0ed73b630c057

------------------------------------------------------------

CVE ID: CVE-2025-22030
Description: In the Linux kernel, the following vulnerability has been resolved:

mm: zswap: fix crypto_free_acomp() deadlock in zswap_cpu_comp_dead()

Currently, zswap_cpu_comp_dead() calls crypto_free_acomp() while holding
the per-CPU acomp_ctx mutex.  crypto_free_acomp() then holds scomp_lock
(through crypto_exit_scomp_ops_async()).

On the other hand, crypto_alloc_acomp_node() holds the scomp_lock (through
crypto_scomp_init_tfm()), and then allocates memory.  If the allocation
results in reclaim, we may attempt to hold the per-CPU acomp_ctx mutex.

The above dependencies can cause an ABBA deadlock.  For example in the
following scenario:

(1) Task A running on CPU #1:
    crypto_alloc_acomp_node()
      Holds scomp_lock
      Enters reclaim
      Reads per_cpu_ptr(pool->acomp_ctx, 1)

(2) Task A is descheduled

(3) CPU #1 goes offline
    zswap_cpu_comp_dead(CPU #1)
      Holds per_cpu_ptr(pool->acomp_ctx, 1))
      Calls crypto_free_acomp()
      Waits for scomp_lock

(4) Task A running on CPU #2:
      Waits for per_cpu_ptr(pool->acomp_ctx, 1) // Read on CPU #1
      DEADLOCK

Since there is no requirement to call crypto_free_acomp() with the per-CPU
acomp_ctx mutex held in zswap_cpu_comp_dead(), move it after the mutex is
unlocked.  Also move the acomp_request_free() and kfree() calls for
consistency and to avoid any potential sublte locking dependencies in the
future.

With this, only setting acomp_ctx fields to NULL occurs with the mutex
held.  This is similar to how zswap_cpu_comp_prepare() only initializes
acomp_ctx fields with the mutex held, after performing all allocations
before holding the mutex.

Opportunistically, move the NULL check on acomp_ctx so that it takes place
before the mutex dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/717d9c35deff6c33235693171bacbb03e9643fa4
  - https://git.kernel.org/stable/c/747e3eec1d7d124ea90ed3d7b85369df8b4e36d2
  - https://git.kernel.org/stable/c/a8d18000e9d2d97aaf105f5f9b3b0e8a6fbf8b96
  - https://git.kernel.org/stable/c/c11bcbc0a517acf69282c8225059b2a8ac5fe628

------------------------------------------------------------

CVE ID: CVE-2025-22031
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI/bwctrl: Fix NULL pointer dereference on bus number exhaustion

When BIOS neglects to assign bus numbers to PCI bridges, the kernel
attempts to correct that during PCI device enumeration.  If it runs out
of bus numbers, no pci_bus is allocated and the "subordinate" pointer in
the bridge's pci_dev remains NULL.

The PCIe bandwidth controller erroneously does not check for a NULL
subordinate pointer and dereferences it on probe.

Bandwidth control of unusable devices below the bridge is of questionable
utility, so simply error out instead.  This mirrors what PCIe hotplug does
since commit 62e4492c3063 ("PCI: Prevent NULL dereference during pciehp
probe").

The PCI core emits a message with KERN_INFO severity if it has run out of
bus numbers.  PCIe hotplug emits an additional message with KERN_ERR
severity to inform the user that hotplug functionality is disabled at the
bridge.  A similar message for bandwidth control does not seem merited,
given that its only purpose so far is to expose an up-to-date link speed
in sysfs and throttle the link speed on certain laptops with limited
Thermal Design Power.  So error out silently.

User-visible messages:

  pci 0000:16:02.0: bridge configuration invalid ([bus 00-00]), reconfiguring
  [...]
  pci_bus 0000:45: busn_res: [bus 45-74] end is updated to 74
  pci 0000:16:02.0: devices behind bridge are unusable because [bus 45-74] cannot be assigned for them
  [...]
  pcieport 0000:16:02.0: pciehp: Hotplug bridge without secondary bus, ignoring
  [...]
  BUG: kernel NULL pointer dereference
  RIP: pcie_update_link_speed
  pcie_bwnotif_enable
  pcie_bwnotif_probe
  pcie_port_probe_service
  really_probe
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/1181924af78e5299ddec6e457789c02dd5966559
  - https://git.kernel.org/stable/c/667f053b05f00a007738cd7ed6fa1901de19dc7e
  - https://git.kernel.org/stable/c/d93d309013e89631630a12b1770d27e4be78362a

------------------------------------------------------------

CVE ID: CVE-2025-22032
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7921: fix kernel panic due to null pointer dereference

Address a kernel panic caused by a null pointer dereference in the
`mt792x_rx_get_wcid` function. The issue arises because the `deflink` structure
is not properly initialized with the `sta` context. This patch ensures that the
`deflink` structure is correctly linked to the `sta` context, preventing the
null pointer dereference.

 BUG: kernel NULL pointer dereference, address: 0000000000000400
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 0 P4D 0
 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
 CPU: 0 UID: 0 PID: 470 Comm: mt76-usb-rx phy Not tainted 6.12.13-gentoo-dist #1
 Hardware name:  /AMD HUDSON-M1, BIOS 4.6.4 11/15/2011
 RIP: 0010:mt792x_rx_get_wcid+0x48/0x140 [mt792x_lib]
 RSP: 0018:ffffa147c055fd98 EFLAGS: 00010202
 RAX: 0000000000000000 RBX: ffff8e9ecb652000 RCX: 0000000000000000
 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff8e9ecb652000
 RBP: 0000000000000685 R08: ffff8e9ec6570000 R09: 0000000000000000
 R10: ffff8e9ecd2ca000 R11: ffff8e9f22a217c0 R12: 0000000038010119
 R13: 0000000080843801 R14: ffff8e9ec6570000 R15: ffff8e9ecb652000
 FS:  0000000000000000(0000) GS:ffff8e9f22a00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000000000400 CR3: 000000000d2ea000 CR4: 00000000000006f0
 Call Trace:
  <TASK>
  ? __die_body.cold+0x19/0x27
  ? page_fault_oops+0x15a/0x2f0
  ? search_module_extables+0x19/0x60
  ? search_bpf_extables+0x5f/0x80
  ? exc_page_fault+0x7e/0x180
  ? asm_exc_page_fault+0x26/0x30
  ? mt792x_rx_get_wcid+0x48/0x140 [mt792x_lib]
  mt7921_queue_rx_skb+0x1c6/0xaa0 [mt7921_common]
  mt76u_alloc_queues+0x784/0x810 [mt76_usb]
  ? __pfx___mt76_worker_fn+0x10/0x10 [mt76]
  __mt76_worker_fn+0x4f/0x80 [mt76]
  kthread+0xd2/0x100
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x34/0x50
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1a/0x30
  </TASK>
 ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.13, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13.2, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0cfea60966e4b1239d20bebf02258295e189e82a
  - https://git.kernel.org/stable/c/5a57f8eb2a17d469d65cd1186cea26b798221d4a
  - https://git.kernel.org/stable/c/adc3fd2a2277b7cc0b61692463771bf9bd298036
  - https://git.kernel.org/stable/c/effec50381991bc067acf4b3351a57831c74d27f

------------------------------------------------------------

CVE ID: CVE-2025-22033
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: Don't call NULL in do_compat_alignment_fixup()

do_alignment_t32_to_handler() only fixes up alignment faults for
specific instructions; it returns NULL otherwise (e.g. LDREX). When
that's the case, signal to the caller that it needs to proceed with the
regular alignment fault handling (i.e. SIGBUS). Without this patch, the
kernel panics:

  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
  Mem abort info:
    ESR = 0x0000000086000006
    EC = 0x21: IABT (current EL), IL = 32 bits
    SET = 0, FnV = 0
    EA = 0, S1PTW = 0
    FSC = 0x06: level 2 translation fault
  user pgtable: 4k pages, 48-bit VAs, pgdp=00000800164aa000
  [0000000000000000] pgd=0800081fdbd22003, p4d=0800081fdbd22003, pud=08000815d51c6003, pmd=0000000000000000
  Internal error: Oops: 0000000086000006 [#1] SMP
  Modules linked in: cfg80211 rfkill xt_nat xt_tcpudp xt_conntrack nft_chain_nat xt_MASQUERADE nf_nat nf_conntrack_netlink nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xfrm_user xfrm_algo xt_addrtype nft_compat br_netfilter veth nvme_fa>
   libcrc32c crc32c_generic raid0 multipath linear dm_mod dax raid1 md_mod xhci_pci nvme xhci_hcd nvme_core t10_pi usbcore igb crc64_rocksoft crc64 crc_t10dif crct10dif_generic crct10dif_ce crct10dif_common usb_common i2c_algo_bit i2c>
  CPU: 2 PID: 3932954 Comm: WPEWebProcess Not tainted 6.1.0-31-arm64 #1  Debian 6.1.128-1
  Hardware name: GIGABYTE MP32-AR1-00/MP32-AR1-00, BIOS F18v (SCP: 1.08.20211002) 12/01/2021
  pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : 0x0
  lr : do_compat_alignment_fixup+0xd8/0x3dc
  sp : ffff80000f973dd0
  x29: ffff80000f973dd0 x28: ffff081b42526180 x27: 0000000000000000
  x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
  x23: 0000000000000004 x22: 0000000000000000 x21: 0000000000000001
  x20: 00000000e8551f00 x19: ffff80000f973eb0 x18: 0000000000000000
  x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
  x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000
  x11: 0000000000000000 x10: 0000000000000000 x9 : ffffaebc949bc488
  x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000
  x5 : 0000000000400000 x4 : 0000fffffffffffe x3 : 0000000000000000
  x2 : ffff80000f973eb0 x1 : 00000000e8551f00 x0 : 0000000000000001
  Call trace:
   0x0
   do_alignment_fault+0x40/0x50
   do_mem_abort+0x4c/0xa0
   el0_da+0x48/0xf0
   el0t_32_sync_handler+0x110/0x140
   el0t_32_sync+0x190/0x194
  Code: bad PC value
  ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/2df8ee605eb6806cd41c2095306db05206633a08
  - https://git.kernel.org/stable/c/617a4b0084a547917669fef2b54253cc9c064990
  - https://git.kernel.org/stable/c/c28f31deeacda307acfee2f18c0ad904e5123aac
  - https://git.kernel.org/stable/c/cf187601053ecaf671ae645edb898901f81d03e9
  - https://git.kernel.org/stable/c/ecf798573bbe0805803f7764e12a34b4bcc65074
  - https://git.kernel.org/stable/c/fa2a9f625f185c6acb4ee5be8d71359a567afac9

------------------------------------------------------------

CVE ID: CVE-2025-22034
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/gup: reject FOLL_SPLIT_PMD with hugetlb VMAs

Patch series "mm: fixes for device-exclusive entries (hmm)", v2.

Discussing the PageTail() call in make_device_exclusive_range() with
Willy, I recently discovered [1] that device-exclusive handling does not
properly work with THP, making the hmm-tests selftests fail if THPs are
enabled on the system.

Looking into more details, I found that hugetlb is not properly fenced,
and I realized that something that was bugging me for longer -- how
device-exclusive entries interact with mapcounts -- completely breaks
migration/swapout/split/hwpoison handling of these folios while they have
device-exclusive PTEs.

The program below can be used to allocate 1 GiB worth of pages and making
them device-exclusive on a kernel with CONFIG_TEST_HMM.

Once they are device-exclusive, these folios cannot get swapped out
(proc$pid/smaps_rollup will always indicate 1 GiB RSS no matter how much
one forces memory reclaim), and when having a memory block onlined to
ZONE_MOVABLE, trying to offline it will loop forever and complain about
failed migration of a page that should be movable.

# echo offline > /sys/devices/system/memory/memory136/state
# echo online_movable > /sys/devices/system/memory/memory136/state
# ./hmm-swap &
... wait until everything is device-exclusive
# echo offline > /sys/devices/system/memory/memory136/state
[  285.193431][T14882] page: refcount:2 mapcount:0 mapping:0000000000000000
  index:0x7f20671f7 pfn:0x442b6a
[  285.196618][T14882] memcg:ffff888179298000
[  285.198085][T14882] anon flags: 0x5fff0000002091c(referenced|uptodate|
  dirty|active|owner_2|swapbacked|node=1|zone=3|lastcpupid=0x7ff)
[  285.201734][T14882] raw: ...
[  285.204464][T14882] raw: ...
[  285.207196][T14882] page dumped because: migration failure
[  285.209072][T14882] page_owner tracks the page as allocated
[  285.210915][T14882] page last allocated via order 0, migratetype
  Movable, gfp_mask 0x140dca(GFP_HIGHUSER_MOVABLE|__GFP_COMP|__GFP_ZERO),
  id 14926, tgid 14926 (hmm-swap), ts 254506295376, free_ts 227402023774
[  285.216765][T14882]  post_alloc_hook+0x197/0x1b0
[  285.218874][T14882]  get_page_from_freelist+0x76e/0x3280
[  285.220864][T14882]  __alloc_frozen_pages_noprof+0x38e/0x2740
[  285.223302][T14882]  alloc_pages_mpol+0x1fc/0x540
[  285.225130][T14882]  folio_alloc_mpol_noprof+0x36/0x340
[  285.227222][T14882]  vma_alloc_folio_noprof+0xee/0x1a0
[  285.229074][T14882]  __handle_mm_fault+0x2b38/0x56a0
[  285.230822][T14882]  handle_mm_fault+0x368/0x9f0
...

This series fixes all issues I found so far.  There is no easy way to fix
without a bigger rework/cleanup.  I have a bunch of cleanups on top (some
previous sent, some the result of the discussion in v1) that I will send
out separately once this landed and I get to it.

I wish we could just use some special present PROT_NONE PTEs instead of
these (non-present, non-none) fake-swap entries; but that just results in
the same problem we keep having (lack of spare PTE bits), and staring at
other similar fake-swap entries, that ship has sailed.

With this series, make_device_exclusive() doesn't actually belong into
mm/rmap.c anymore, but I'll leave moving that for another day.

I only tested this series with the hmm-tests selftests due to lack of HW,
so I'd appreciate some testing, especially if the interaction between two
GPUs wanting a device-exclusive entry works as expected.

<program>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <linux/ioctl.h>

#define HMM_DMIRROR_EXCLUSIVE _IOWR('H', 0x05, struct hmm_dmirror_cmd)

struct hmm_dmirror_cmd {
	__u64 addr;
	__u64 ptr;
	__u64 npages;
	__u64 cpages;
	__u64 faults;
};

const size_t size = 1 * 1024 * 1024 * 1024ul;
const size_t chunk_size = 2 * 1024 * 1024ul;

int m
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2e877ff3492267def06dd50cb165dc9ab8838e7d
  - https://git.kernel.org/stable/c/48d28417c66cce2f3b0ba773fcb6695a56eff220
  - https://git.kernel.org/stable/c/8977752c8056a6a094a279004a49722da15bace3
  - https://git.kernel.org/stable/c/fd900832e8440046627b60697687ab5d04398008

------------------------------------------------------------

CVE ID: CVE-2025-22035
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix use-after-free in print_graph_function_flags during tracer switching

Kairui reported a UAF issue in print_graph_function_flags() during
ftrace stress testing [1]. This issue can be reproduced if puting a
'mdelay(10)' after 'mutex_unlock(&trace_types_lock)' in s_start(),
and executing the following script:

  $ echo function_graph > current_tracer
  $ cat trace > /dev/null &
  $ sleep 5  # Ensure the 'cat' reaches the 'mdelay(10)' point
  $ echo timerlat > current_tracer

The root cause lies in the two calls to print_graph_function_flags
within print_trace_line during each s_show():

  * One through 'iter->trace->print_line()';
  * Another through 'event->funcs->trace()', which is hidden in
    print_trace_fmt() before print_trace_line returns.

Tracer switching only updates the former, while the latter continues
to use the print_line function of the old tracer, which in the script
above is print_graph_function_flags.

Moreover, when switching from the 'function_graph' tracer to the
'timerlat' tracer, s_start only calls graph_trace_close of the
'function_graph' tracer to free 'iter->private', but does not set
it to NULL. This provides an opportunity for 'event->funcs->trace()'
to use an invalid 'iter->private'.

To fix this issue, set 'iter->private' to NULL immediately after
freeing it in graph_trace_close(), ensuring that an invalid pointer
is not passed to other tracers. Additionally, clean up the unnecessary
'iter->private = NULL' during each 'cat trace' when using wakeup and
irqsoff tracers.

 [1] https://lore.kernel.org/all/20231112150030.84609-1-ryncsn@gmail.com/
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.324, Last Version (Excluding): 4.15
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.293, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.255, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.193, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.129, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.50, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.4.13, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/099ef3385800828b74933a96c117574637c3fb3a
  - https://git.kernel.org/stable/c/42561fe62c3628ea3bc9623f64f047605e98857f
  - https://git.kernel.org/stable/c/70be951bc01e4a0e10d443f3510bb17426f257fb
  - https://git.kernel.org/stable/c/7f81f27b1093e4895e87b74143c59c055c3b1906
  - https://git.kernel.org/stable/c/81a85b12132c8ffe98f5ddbdc185481790aeaa1b
  - https://git.kernel.org/stable/c/a2cce54c1748216535dda02e185d07a084be837e
  - https://git.kernel.org/stable/c/c85efe6e13743cac6ba4ccf144cb91f44c86231a
  - https://git.kernel.org/stable/c/de7b309139f862a44379ecd96e93c9133c69f813
  - https://git.kernel.org/stable/c/f14752d66056d0c7bffe5092130409417d3baa70

------------------------------------------------------------

CVE ID: CVE-2025-22036
Description: In the Linux kernel, the following vulnerability has been resolved:

exfat: fix random stack corruption after get_block

When get_block is called with a buffer_head allocated on the stack, such
as do_mpage_readpage, stack corruption due to buffer_head UAF may occur in
the following race condition situation.

     <CPU 0>                      <CPU 1>
mpage_read_folio
  <<bh on stack>>
  do_mpage_readpage
    exfat_get_block
      bh_read
        __bh_read
	  get_bh(bh)
          submit_bh
          wait_on_buffer
                              ...
                              end_buffer_read_sync
                                __end_buffer_read_notouch
                                   unlock_buffer
          <<keep going>>
        ...
      ...
    ...
  ...
<<bh is not valid out of mpage_read_folio>>
   .
   .
another_function
  <<variable A on stack>>
                                   put_bh(bh)
                                     atomic_dec(bh->b_count)
  * stack corruption here *

This patch returns -EAGAIN if a folio does not have buffers when bh_read
needs to be called. By doing this, the caller can fallback to functions
like block_read_full_folio(), create a buffer_head in the folio, and then
call get_block again.

Let's do not call bh_read() with on-stack buffer_head.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.0
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/1bb7ff4204b6d4927e982cd256286c09ed4fd8ca
  - https://git.kernel.org/stable/c/49b0a6ab8e528a0c1c50e37cef9b9c7c121365f2
  - https://git.kernel.org/stable/c/f7447286363dc1e410bf30b87d75168f3519f9cc
  - https://git.kernel.org/stable/c/f807a6bf2005740fa26b4f59c4a003dc966b9afd

------------------------------------------------------------

CVE ID: CVE-2025-22037
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix null pointer dereference in alloc_preauth_hash()

The Client send malformed smb2 negotiate request. ksmbd return error
response. Subsequently, the client can send smb2 session setup even
thought conn->preauth_info is not allocated.
This patch add KSMBD_SESS_NEED_SETUP status of connection to ignore
session setup request if smb2 negotiate phase is not complete.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/8f216b33a5e1b3489c073b1ea1b3d7cb63c8dc4d
  - https://git.kernel.org/stable/c/b8eb243e670ecf30e91524dd12f7260dac07d335
  - https://git.kernel.org/stable/c/c8b5b7c5da7d0c31c9b7190b4a7bba5281fc4780
  - https://git.kernel.org/stable/c/ca8bed31edf728a662ef9d6f39f50e7a7dc2b5ad

------------------------------------------------------------

CVE ID: CVE-2025-22038
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: validate zero num_subauth before sub_auth is accessed

Access psid->sub_auth[psid->num_subauth - 1] without checking
if num_subauth is non-zero leads to an out-of-bounds read.
This patch adds a validation step to ensure num_subauth != 0
before sub_auth is accessed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0e36a3e080d6d8bd7a34e089345d043da4ac8283
  - https://git.kernel.org/stable/c/3ac65de111c686c95316ade660f8ba7aea3cd3cc
  - https://git.kernel.org/stable/c/56de7778a48560278c334077ace7b9ac4bfb2fd1
  - https://git.kernel.org/stable/c/68c6c3142bfcdb049839d40a9a59ebe8ea865002
  - https://git.kernel.org/stable/c/bf21e29d78cd2c2371023953d9c82dfef82ebb36
  - https://git.kernel.org/stable/c/c8bfe1954a0b89e7b29b3a3e7f4c5e0ebd295e20

------------------------------------------------------------

CVE ID: CVE-2025-22039
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix overflow in dacloffset bounds check

The dacloffset field was originally typed as int and used in an
unchecked addition, which could overflow and bypass the existing
bounds check in both smb_check_perm_dacl() and smb_inherit_dacl().

This could result in out-of-bounds memory access and a kernel crash
when dereferencing the DACL pointer.

This patch converts dacloffset to unsigned int and uses
check_add_overflow() to validate access to the DACL.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/443b373a4df5a2cb9f7b8c4658b2afedeb16397f
  - https://git.kernel.org/stable/c/6a9cd9ff0fa2bcc30b2bfb8bdb161eb20e44b9dc
  - https://git.kernel.org/stable/c/6b8d379048b168a0dff5ab1acb975b933f368514
  - https://git.kernel.org/stable/c/beff0bc9d69bc8e733f9bca28e2d3df5b3e10e42

------------------------------------------------------------

CVE ID: CVE-2025-22040
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix session use-after-free in multichannel connection

There is a race condition between session setup and
ksmbd_sessions_deregister. The session can be freed before the connection
is added to channel list of session.
This patch check reference count of session before freeing it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/3980770cb1470054e6400fd97668665975726737
  - https://git.kernel.org/stable/c/596407adb9af1ee75fe7c7529607783d31b66e7f
  - https://git.kernel.org/stable/c/7dfbd4c43eed91dd2548a95236908025707a8dfd
  - https://git.kernel.org/stable/c/9069939d762138e232a6f79e3e1462682ed6a17d
  - https://git.kernel.org/stable/c/94c281721d4ed2d972232414b91d98a6f5bdb16b
  - https://git.kernel.org/stable/c/fa4cdb8cbca7d6cb6aa13e4d8d83d1103f6345db

------------------------------------------------------------

CVE ID: CVE-2025-22041
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix use-after-free in ksmbd_sessions_deregister()

In multichannel mode, UAF issue can occur in session_deregister
when the second channel sets up a session through the connection of
the first channel. session that is freed through the global session
table can be accessed again through ->sessions of connection.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.13
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/15a9605f8d69dc85005b1a00c31a050b8625e1aa
  - https://git.kernel.org/stable/c/33cc29e221df7a3085ae413e8c26c4e81a151153
  - https://git.kernel.org/stable/c/8ed0e9d2f410f63525afb8351181eea36c80bcf1
  - https://git.kernel.org/stable/c/a8a8ae303a8395cbac270b5b404d85df6ec788f8
  - https://git.kernel.org/stable/c/ca042cc0e4f9e0d2c8f86dd67e4b22f30a516a9b
  - https://git.kernel.org/stable/c/f0eb3f575138b816da74697bd506682574742fcd

------------------------------------------------------------

CVE ID: CVE-2025-22042
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: add bounds check for create lease context

Add missing bounds check for create lease context.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/60b7207893a8a06c78441934931a08fdad63f18e
  - https://git.kernel.org/stable/c/629dd37acc336ad778979361c351e782053ea284
  - https://git.kernel.org/stable/c/800c482c9ef5910f05e3a713943c67cc6c1d4939
  - https://git.kernel.org/stable/c/9a1b6ea955e6c7b29939a6d98701202f9d9644ec
  - https://git.kernel.org/stable/c/a41cd52f00907a040ca22c73d4805bb79b0d0972
  - https://git.kernel.org/stable/c/bab703ed8472aa9d109c5f8c1863921533363dae

------------------------------------------------------------

CVE ID: CVE-2025-22043
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: add bounds check for durable handle context

Add missing bounds check for durable handle context.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1107b9ed92194603593c51829a3887812ae9e806
  - https://git.kernel.org/stable/c/29b946714d6aa77de54c71243bba39469ac43ef2
  - https://git.kernel.org/stable/c/542027e123fc0bfd61dd59e21ae0ee4ef2101b29
  - https://git.kernel.org/stable/c/8d4848c45943c9cf5e86142fd7347efa97f497db
  - https://git.kernel.org/stable/c/f0db3d9d416e332a0d6f045a1509539d3a4cd898

------------------------------------------------------------

CVE ID: CVE-2025-22044
Description: In the Linux kernel, the following vulnerability has been resolved:

acpi: nfit: fix narrowing conversion in acpi_nfit_ctl

Syzkaller has reported a warning in to_nfit_bus_uuid(): "only secondary
bus families can be translated". This warning is emited if the argument
is equal to NVDIMM_BUS_FAMILY_NFIT == 0. Function acpi_nfit_ctl() first
verifies that a user-provided value call_pkg->nd_family of type u64 is
not equal to 0. Then the value is converted to int, and only after that
is compared to NVDIMM_BUS_FAMILY_MAX. This can lead to passing an invalid
argument to acpi_nfit_ctl(), if call_pkg->nd_family is non-zero, while
the lower 32 bits are zero.

Furthermore, it is best to return EINVAL immediately upon seeing the
invalid user input.  The WARNING is insufficient to prevent further
undefined behavior based on other invalid user input.

All checks of the input value should be applied to the original variable
call_pkg->nd_family.

[iweiny: update commit message]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2ff0e408db36c21ed3fa5e3c1e0e687c82cf132f
  - https://git.kernel.org/stable/c/4b65cff06a004ac54f6ea8886060f0d07b1ca055
  - https://git.kernel.org/stable/c/73851cfceb00cc77d7a0851bc10f2263394c3e87
  - https://git.kernel.org/stable/c/85f11291658ab907c4294319c8102450cc75bb96
  - https://git.kernel.org/stable/c/92ba06aef65522483784dcbd6697629ddbd4c4f9
  - https://git.kernel.org/stable/c/bae5b55e0f327102e78f6a66fb127275e9bc91b6
  - https://git.kernel.org/stable/c/c90402d2a226ff7afbe1d0650bee8ecc15a91049
  - https://git.kernel.org/stable/c/e71a57c5aaa389d4c3c82f920761262efdd18d38

------------------------------------------------------------

CVE ID: CVE-2025-22045
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/mm: Fix flush_tlb_range() when used for zapping normal PMDs

On the following path, flush_tlb_range() can be used for zapping normal
PMD entries (PMD entries that point to page tables) together with the PTE
entries in the pointed-to page table:

    collapse_pte_mapped_thp
      pmdp_collapse_flush
        flush_tlb_range

The arm64 version of flush_tlb_range() has a comment describing that it can
be used for page table removal, and does not use any last-level
invalidation optimizations. Fix the X86 version by making it behave the
same way.

Currently, X86 only uses this information for the following two purposes,
which I think means the issue doesn't have much impact:

 - In native_flush_tlb_multi() for checking if lazy TLB CPUs need to be
   IPI'd to avoid issues with speculative page table walks.
 - In Hyper-V TLB paravirtualization, again for lazy TLB stuff.

The patch "x86/mm: only invalidate final translations with INVLPGB" which
is currently under review (see
<https://lore.kernel.org/all/20241230175550.4046587-13-riel@surriel.com/>)
would probably be making the impact of this a lot worse.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0708fd6bd8161871bfbadced2ca4319b84ab44fe
  - https://git.kernel.org/stable/c/0a8f806ea6b5dd64b3d1f05ff774817d5f7ddbd1
  - https://git.kernel.org/stable/c/320ac1af4c0bdb92c864dc9250d1329234820edf
  - https://git.kernel.org/stable/c/3ef938c3503563bfc2ac15083557f880d29c2e64
  - https://git.kernel.org/stable/c/556d446068f90981e5d71ca686bdaccdd545d491
  - https://git.kernel.org/stable/c/618d5612ecb7bfc1c85342daafeb2b47e29e77a3
  - https://git.kernel.org/stable/c/7085895c59e4057ffae17f58990ccb630087d0d2
  - https://git.kernel.org/stable/c/78d6f9a9eb2a5da6fcbd76d6191d24b0dcc321be
  - https://git.kernel.org/stable/c/93224deb50a8d20df3884f3672ce9f982129aa50

------------------------------------------------------------

CVE ID: CVE-2025-22046
Description: In the Linux kernel, the following vulnerability has been resolved:

uprobes/x86: Harden uretprobe syscall trampoline check

Jann reported a possible issue when trampoline_check_ip returns
address near the bottom of the address space that is allowed to
call into the syscall if uretprobes are not set up:

   https://lore.kernel.org/bpf/202502081235.5A6F352985@keescook/T/#m9d416df341b8fbc11737dacbcd29f0054413cbbf

Though the mmap minimum address restrictions will typically prevent
creating mappings there, let's make sure uretprobe syscall checks
for that.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/b0065d712049c87e1994c6eac00c6a637e39b325
  - https://git.kernel.org/stable/c/c35771342e47d58ab9433f3be1c3c30f2c5fa4f3
  - https://git.kernel.org/stable/c/d4e48b8d59fe162938a5004ace698c847e6a3207
  - https://git.kernel.org/stable/c/fa6192adc32f4fdfe5b74edd5b210e12afd6ecc0

------------------------------------------------------------

CVE ID: CVE-2025-22047
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/microcode/AMD: Fix __apply_microcode_amd()'s return value

When verify_sha256_digest() fails, __apply_microcode_amd() should propagate
the failure by returning false (and not -1 which is promoted to true).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/31ab12df723543047c3fc19cb8f8c4498ec6267f
  - https://git.kernel.org/stable/c/763f4d638f71cb45235395790a46e9f9e84227fd
  - https://git.kernel.org/stable/c/7f705a45f130a85fbf31c2abdc999c65644c8307
  - https://git.kernel.org/stable/c/ada88219d5315fc13f2910fe278c7112d8d68889
  - https://git.kernel.org/stable/c/d295c58fad1d5ab987a81f139dd21498732c4f13

------------------------------------------------------------

CVE ID: CVE-2025-22048
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: BPF: Don't override subprog's return value

The verifier test `calls: div by 0 in subprog` triggers a panic at the
ld.bu instruction. The ld.bu insn is trying to load byte from memory
address returned by the subprog. The subprog actually set the correct
address at the a5 register (dedicated register for BPF return values).
But at commit 73c359d1d356 ("LoongArch: BPF: Sign-extend return values")
we also sign extended a5 to the a0 register (return value in LoongArch).
For function call insn, we later propagate the a0 register back to a5
register. This is right for native calls but wrong for bpf2bpf calls
which expect zero-extended return value in a5 register. So only move a0
to a5 for native calls (i.e. non-BPF_PSEUDO_CALL).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/223d565d8892481684091cfbaf3466f2b0e289d3
  - https://git.kernel.org/stable/c/60f3caff1492e5b8616b9578c4bedb5c0a88ed14
  - https://git.kernel.org/stable/c/780628a780b622759d9e5adc76d15432144da1a3
  - https://git.kernel.org/stable/c/7df2696256a034405d3c5a71b3a4c54725de4404
  - https://git.kernel.org/stable/c/996e90ab446641553e8e21707b38b9709605e0e0

------------------------------------------------------------

CVE ID: CVE-2025-22049
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Increase ARCH_DMA_MINALIGN up to 16

ARCH_DMA_MINALIGN is 1 by default, but some LoongArch-specific devices
(such as APBDMA) require 16 bytes alignment. When the data buffer length
is too small, the hardware may make an error writing cacheline. Thus, it
is dangerous to allocate a small memory buffer for DMA. It's always safe
to define ARCH_DMA_MINALIGN as L1_CACHE_BYTES but unnecessary (kmalloc()
need small memory objects). Therefore, just increase it to 16.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d0def2d1658666ec1f32c9495df60e7411e3c82
  - https://git.kernel.org/stable/c/279ec25c2df49fba1cd9488f2ddd045d9cb2112e
  - https://git.kernel.org/stable/c/4103cfe9dcb88010ae4911d3ff417457d1b6a720
  - https://git.kernel.org/stable/c/8b82aea3666f8f2c78f86148d78aea99c46e0f82
  - https://git.kernel.org/stable/c/bfff341cac7c650e6ca8d10503725992f5564d0f
  - https://git.kernel.org/stable/c/f39af67f03b564b763b06e44cb960c10a382d54a

------------------------------------------------------------

CVE ID: CVE-2025-22050
Description: In the Linux kernel, the following vulnerability has been resolved:

usbnet:fix NPE during rx_complete

Missing usbnet_going_away Check in Critical Path.
The usb_submit_urb function lacks a usbnet_going_away
validation, whereas __usbnet_queue_skb includes this check.

This inconsistency creates a race condition where:
A URB request may succeed, but the corresponding SKB data
fails to be queued.

Subsequent processes:
(e.g., rx_complete → defer_bh → __skb_unlink(skb, list))
attempt to access skb->next, triggering a NULL pointer
dereference (Kernel Panic).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c30988588b28393e3e8873d5654f910e86391ba
  - https://git.kernel.org/stable/c/0f10f83acfd619e13c64d6705908dfd792f19544
  - https://git.kernel.org/stable/c/51de3600093429e3b712e5f091d767babc5dd6df
  - https://git.kernel.org/stable/c/95789c2f94fd29dce8759f9766baa333f749287c
  - https://git.kernel.org/stable/c/acacd48a37b52fc95f621765762c04152b58d642
  - https://git.kernel.org/stable/c/d689645cd1594ea1d13cb0c404f8ad1011353e0e
  - https://git.kernel.org/stable/c/fd9ee3f0d6a53844f65efde581c91bbb0ff749ac

------------------------------------------------------------

CVE ID: CVE-2025-22051
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: gpib: Fix Oops after disconnect in agilent usb

If the agilent usb dongle is disconnected subsequent calls to the
driver cause a NULL dereference Oops as the bus_interface
is set to NULL on disconnect.

This problem was introduced by setting usb_dev from the bus_interface
for dev_xxx messages.

Previously bus_interface was checked for NULL only in the functions
directly calling usb_fill_bulk_urb or usb_control_msg.

Check for valid bus_interface on all interface entry points
and return -ENODEV if it is NULL.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/50ef6e45bec79da4c5a01fad4dc23466ba255099
  - https://git.kernel.org/stable/c/8491e73a5223acb0a4b4d78c3f8b96aa9c5e774d
  - https://git.kernel.org/stable/c/e88633705078f40391a9afc6cc8ea3025e6f692b

------------------------------------------------------------

CVE ID: CVE-2025-22052
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: gpib: Fix Oops after disconnect in ni_usb

If the usb dongle is disconnected subsequent calls to the
driver cause a NULL dereference Oops as the bus_interface
is set to NULL on disconnect.

This problem was introduced by setting usb_dev from the bus_interface
for dev_xxx messages.

Previously bus_interface was checked for NULL only in the the functions
directly calling usb_fill_bulk_urb or usb_control_msg.

Check for valid bus_interface on all interface entry points
and return -ENODEV if it is NULL.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/5dc98ba6f7304c188b267ef481281849638447bf
  - https://git.kernel.org/stable/c/a239c6e91b665f1837cf57b97fe638ef1baf2e78
  - https://git.kernel.org/stable/c/b2d8d7959077c5d4b11d0dc6bd2167791fd1c72e

------------------------------------------------------------

CVE ID: CVE-2025-22053
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ibmveth: make veth_pool_store stop hanging

v2:
- Created a single error handling unlock and exit in veth_pool_store
- Greatly expanded commit message with previous explanatory-only text

Summary: Use rtnl_mutex to synchronize veth_pool_store with itself,
ibmveth_close and ibmveth_open, preventing multiple calls in a row to
napi_disable.

Background: Two (or more) threads could call veth_pool_store through
writing to /sys/devices/vio/30000002/pool*/*. You can do this easily
with a little shell script. This causes a hang.

I configured LOCKDEP, compiled ibmveth.c with DEBUG, and built a new
kernel. I ran this test again and saw:

    Setting pool0/active to 0
    Setting pool1/active to 1
    [   73.911067][ T4365] ibmveth 30000002 eth0: close starting
    Setting pool1/active to 1
    Setting pool1/active to 0
    [   73.911367][ T4366] ibmveth 30000002 eth0: close starting
    [   73.916056][ T4365] ibmveth 30000002 eth0: close complete
    [   73.916064][ T4365] ibmveth 30000002 eth0: open starting
    [  110.808564][  T712] systemd-journald[712]: Sent WATCHDOG=1 notification.
    [  230.808495][  T712] systemd-journald[712]: Sent WATCHDOG=1 notification.
    [  243.683786][  T123] INFO: task stress.sh:4365 blocked for more than 122 seconds.
    [  243.683827][  T123]       Not tainted 6.14.0-01103-g2df0c02dab82-dirty #8
    [  243.683833][  T123] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [  243.683838][  T123] task:stress.sh       state:D stack:28096 pid:4365  tgid:4365  ppid:4364   task_flags:0x400040 flags:0x00042000
    [  243.683852][  T123] Call Trace:
    [  243.683857][  T123] [c00000000c38f690] [0000000000000001] 0x1 (unreliable)
    [  243.683868][  T123] [c00000000c38f840] [c00000000001f908] __switch_to+0x318/0x4e0
    [  243.683878][  T123] [c00000000c38f8a0] [c000000001549a70] __schedule+0x500/0x12a0
    [  243.683888][  T123] [c00000000c38f9a0] [c00000000154a878] schedule+0x68/0x210
    [  243.683896][  T123] [c00000000c38f9d0] [c00000000154ac80] schedule_preempt_disabled+0x30/0x50
    [  243.683904][  T123] [c00000000c38fa00] [c00000000154dbb0] __mutex_lock+0x730/0x10f0
    [  243.683913][  T123] [c00000000c38fb10] [c000000001154d40] napi_enable+0x30/0x60
    [  243.683921][  T123] [c00000000c38fb40] [c000000000f4ae94] ibmveth_open+0x68/0x5dc
    [  243.683928][  T123] [c00000000c38fbe0] [c000000000f4aa20] veth_pool_store+0x220/0x270
    [  243.683936][  T123] [c00000000c38fc70] [c000000000826278] sysfs_kf_write+0x68/0xb0
    [  243.683944][  T123] [c00000000c38fcb0] [c0000000008240b8] kernfs_fop_write_iter+0x198/0x2d0
    [  243.683951][  T123] [c00000000c38fd00] [c00000000071b9ac] vfs_write+0x34c/0x650
    [  243.683958][  T123] [c00000000c38fdc0] [c00000000071bea8] ksys_write+0x88/0x150
    [  243.683966][  T123] [c00000000c38fe10] [c0000000000317f4] system_call_exception+0x124/0x340
    [  243.683973][  T123] [c00000000c38fe50] [c00000000000d05c] system_call_vectored_common+0x15c/0x2ec
    ...
    [  243.684087][  T123] Showing all locks held in the system:
    [  243.684095][  T123] 1 lock held by khungtaskd/123:
    [  243.684099][  T123]  #0: c00000000278e370 (rcu_read_lock){....}-{1:2}, at: debug_show_all_locks+0x50/0x248
    [  243.684114][  T123] 4 locks held by stress.sh/4365:
    [  243.684119][  T123]  #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0}, at: ksys_write+0x88/0x150
    [  243.684132][  T123]  #1: c000000041aea888 (&of->mutex#2){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x154/0x2d0
    [  243.684143][  T123]  #2: c0000000366fb9a8 (kn->active#64){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x160/0x2d0
    [  243.684155][  T123]  #3: c000000035ff4cb8 (&dev->lock){+.+.}-{3:3}, at: napi_enable+0x30/0x60
    [  243.684166][  T123] 5 locks held by stress.sh/4366:
    [  243.684170][  T123]  #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0}, at: ksys_write+0x88/0x150
    [  243.
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/053f3ff67d7feefc75797863f3d84b47ad47086f
  - https://git.kernel.org/stable/c/0a2470e3ecde64fc7e3781dc474923193621ae67
  - https://git.kernel.org/stable/c/1e458c292f4c687dcf5aad32dd4836d03cd2191f
  - https://git.kernel.org/stable/c/86cc70f5c85dc09bf7f3e1eee380eefe73c90765
  - https://git.kernel.org/stable/c/8a88bb092f4208355880b9fdcc69d491aa297595

------------------------------------------------------------

CVE ID: CVE-2025-22054
Description: In the Linux kernel, the following vulnerability has been resolved:

arcnet: Add NULL check in com20020pci_probe()

devm_kasprintf() returns NULL when memory allocation fails. Currently,
com20020pci_probe() does not check for this case, which results in a
NULL pointer dereference.

Add NULL check after devm_kasprintf() to prevent this issue and ensure
no resources are left allocated.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.302, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.264, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.204, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.143, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.68, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.7, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/661cf5d102949898c931e81fd4e1c773afcdeafa
  - https://git.kernel.org/stable/c/887226163504494ea7e58033a97c2d2ab12e05d4
  - https://git.kernel.org/stable/c/905a34dc1ad9a53a8aaaf8a759ea5dbaaa30418d
  - https://git.kernel.org/stable/c/a654f31b33515d39bb56c75fd8b26bef025ced7e
  - https://git.kernel.org/stable/c/be8a0decd0b59a52a07276f9ef3b33ef820b2179
  - https://git.kernel.org/stable/c/ebebeb58d48e25525fa654f2c53a24713fe141c3
  - https://git.kernel.org/stable/c/ececf8eff6c25acc239fa8f0fd837c76bc770547
  - https://git.kernel.org/stable/c/ef8b29398ea6061ac8257f3e45c9be45cc004ce2
  - https://git.kernel.org/stable/c/fda8c491db2a90ff3e6fbbae58e495b4ddddeca3

------------------------------------------------------------

CVE ID: CVE-2025-22055
Description: In the Linux kernel, the following vulnerability has been resolved:

net: fix geneve_opt length integer overflow

struct geneve_opt uses 5 bit length for each single option, which
means every vary size option should be smaller than 128 bytes.

However, all current related Netlink policies cannot promise this
length condition and the attacker can exploit a exact 128-byte size
option to *fake* a zero length option and confuse the parsing logic,
further achieve heap out-of-bounds read.

One example crash log is like below:

[    3.905425] ==================================================================
[    3.905925] BUG: KASAN: slab-out-of-bounds in nla_put+0xa9/0xe0
[    3.906255] Read of size 124 at addr ffff888005f291cc by task poc/177
[    3.906646]
[    3.906775] CPU: 0 PID: 177 Comm: poc-oob-read Not tainted 6.1.132 #1
[    3.907131] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
[    3.907784] Call Trace:
[    3.907925]  <TASK>
[    3.908048]  dump_stack_lvl+0x44/0x5c
[    3.908258]  print_report+0x184/0x4be
[    3.909151]  kasan_report+0xc5/0x100
[    3.909539]  kasan_check_range+0xf3/0x1a0
[    3.909794]  memcpy+0x1f/0x60
[    3.909968]  nla_put+0xa9/0xe0
[    3.910147]  tunnel_key_dump+0x945/0xba0
[    3.911536]  tcf_action_dump_1+0x1c1/0x340
[    3.912436]  tcf_action_dump+0x101/0x180
[    3.912689]  tcf_exts_dump+0x164/0x1e0
[    3.912905]  fw_dump+0x18b/0x2d0
[    3.913483]  tcf_fill_node+0x2ee/0x460
[    3.914778]  tfilter_notify+0xf4/0x180
[    3.915208]  tc_new_tfilter+0xd51/0x10d0
[    3.918615]  rtnetlink_rcv_msg+0x4a2/0x560
[    3.919118]  netlink_rcv_skb+0xcd/0x200
[    3.919787]  netlink_unicast+0x395/0x530
[    3.921032]  netlink_sendmsg+0x3d0/0x6d0
[    3.921987]  __sock_sendmsg+0x99/0xa0
[    3.922220]  __sys_sendto+0x1b7/0x240
[    3.922682]  __x64_sys_sendto+0x72/0x90
[    3.922906]  do_syscall_64+0x5e/0x90
[    3.923814]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8
[    3.924122] RIP: 0033:0x7e83eab84407
[    3.924331] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 faf
[    3.925330] RSP: 002b:00007ffff505e370 EFLAGS: 00000202 ORIG_RAX: 000000000000002c
[    3.925752] RAX: ffffffffffffffda RBX: 00007e83eaafa740 RCX: 00007e83eab84407
[    3.926173] RDX: 00000000000001a8 RSI: 00007ffff505e3c0 RDI: 0000000000000003
[    3.926587] RBP: 00007ffff505f460 R08: 00007e83eace1000 R09: 000000000000000c
[    3.926977] R10: 0000000000000000 R11: 0000000000000202 R12: 00007ffff505f3c0
[    3.927367] R13: 00007ffff505f5c8 R14: 00007e83ead1b000 R15: 00005d4fbbe6dcb8

Fix these issues by enforing correct length condition in related
policies.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/21748669c5825761cbbf47cbeeb01387ddccc8cb
  - https://git.kernel.org/stable/c/2952776c69a1a551649ed770bf22e3f691f6ec65
  - https://git.kernel.org/stable/c/4d606069bdd3c76f8ab1f06796c97ef7f4746807
  - https://git.kernel.org/stable/c/5a2976cc4d9c36ff58a0f10e35ce4283cbaa9c0e
  - https://git.kernel.org/stable/c/738ae5712215fe9181587d582b23333f02c62ca6
  - https://git.kernel.org/stable/c/a2cb85f989e2074e2f392e00188c438cab3de088
  - https://git.kernel.org/stable/c/b27055a08ad4b415dcf15b63034f9cb236f7fb40
  - https://git.kernel.org/stable/c/b4513ad0f391871d3feee8ddf535609a3aabeeac

------------------------------------------------------------

CVE ID: CVE-2025-22056
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nft_tunnel: fix geneve_opt type confusion addition

When handling multiple NFTA_TUNNEL_KEY_OPTS_GENEVE attributes, the
parsing logic should place every geneve_opt structure one by one
compactly. Hence, when deciding the next geneve_opt position, the
pointer addition should be in units of char *.

However, the current implementation erroneously does type conversion
before the addition, which will lead to heap out-of-bounds write.

[    6.989857] ==================================================================
[    6.990293] BUG: KASAN: slab-out-of-bounds in nft_tunnel_obj_init+0x977/0xa70
[    6.990725] Write of size 124 at addr ffff888005f18974 by task poc/178
[    6.991162]
[    6.991259] CPU: 0 PID: 178 Comm: poc-oob-write Not tainted 6.1.132 #1
[    6.991655] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
[    6.992281] Call Trace:
[    6.992423]  <TASK>
[    6.992586]  dump_stack_lvl+0x44/0x5c
[    6.992801]  print_report+0x184/0x4be
[    6.993790]  kasan_report+0xc5/0x100
[    6.994252]  kasan_check_range+0xf3/0x1a0
[    6.994486]  memcpy+0x38/0x60
[    6.994692]  nft_tunnel_obj_init+0x977/0xa70
[    6.995677]  nft_obj_init+0x10c/0x1b0
[    6.995891]  nf_tables_newobj+0x585/0x950
[    6.996922]  nfnetlink_rcv_batch+0xdf9/0x1020
[    6.998997]  nfnetlink_rcv+0x1df/0x220
[    6.999537]  netlink_unicast+0x395/0x530
[    7.000771]  netlink_sendmsg+0x3d0/0x6d0
[    7.001462]  __sock_sendmsg+0x99/0xa0
[    7.001707]  ____sys_sendmsg+0x409/0x450
[    7.002391]  ___sys_sendmsg+0xfd/0x170
[    7.003145]  __sys_sendmsg+0xea/0x170
[    7.004359]  do_syscall_64+0x5e/0x90
[    7.005817]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8
[    7.006127] RIP: 0033:0x7ec756d4e407
[    7.006339] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 faf
[    7.007364] RSP: 002b:00007ffed5d46760 EFLAGS: 00000202 ORIG_RAX: 000000000000002e
[    7.007827] RAX: ffffffffffffffda RBX: 00007ec756cc4740 RCX: 00007ec756d4e407
[    7.008223] RDX: 0000000000000000 RSI: 00007ffed5d467f0 RDI: 0000000000000003
[    7.008620] RBP: 00007ffed5d468a0 R08: 0000000000000000 R09: 0000000000000000
[    7.009039] R10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000000
[    7.009429] R13: 00007ffed5d478b0 R14: 00007ec756ee5000 R15: 00005cbd4e655cb8

Fix this bug with correct pointer addition and conversion in parse
and dump code.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0a93a710d6df334b828ea064c6d39fda34f901dc
  - https://git.kernel.org/stable/c/1b755d8eb1ace3870789d48fbd94f386ad6e30be
  - https://git.kernel.org/stable/c/28d88ee1e1cc8ac2d79aeb112717b97c5c833d43
  - https://git.kernel.org/stable/c/31d49eb436f2da61280508d7adf8c9b473b967aa
  - https://git.kernel.org/stable/c/446d94898c560ed2f61e26ae445858a4c4830762
  - https://git.kernel.org/stable/c/708e268acb3a446ad2a8a3d2e9bd41cc23660cd6
  - https://git.kernel.org/stable/c/a263d31c8c92e5919d41af57d9479cfb66323782
  - https://git.kernel.org/stable/c/ca2adfc03cd6273f0b589fe65afc6f75e0fe116e

------------------------------------------------------------

CVE ID: CVE-2025-22057
Description: In the Linux kernel, the following vulnerability has been resolved:

net: decrease cached dst counters in dst_release

Upstream fix ac888d58869b ("net: do not delay dst_entries_add() in
dst_release()") moved decrementing the dst count from dst_destroy to
dst_release to avoid accessing already freed data in case of netns
dismantle. However in case CONFIG_DST_CACHE is enabled and OvS+tunnels
are used, this fix is incomplete as the same issue will be seen for
cached dsts:

  Unable to handle kernel paging request at virtual address ffff5aabf6b5c000
  Call trace:
   percpu_counter_add_batch+0x3c/0x160 (P)
   dst_release+0xec/0x108
   dst_cache_destroy+0x68/0xd8
   dst_destroy+0x13c/0x168
   dst_destroy_rcu+0x1c/0xb0
   rcu_do_batch+0x18c/0x7d0
   rcu_core+0x174/0x378
   rcu_core_si+0x18/0x30

Fix this by invalidating the cache, and thus decrementing cached dst
counters, in dst_release too.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a0a3ff6593d670af2451ec363ccb7b18aec0c0a
  - https://git.kernel.org/stable/c/836415a8405c9665ae55352fc5ba865c242f5e4f
  - https://git.kernel.org/stable/c/92a5c18513117be69bc00419dd1724c1940f8fcd
  - https://git.kernel.org/stable/c/ccc331fd5bcae131d2627d5ef099d4a1f6540aea
  - https://git.kernel.org/stable/c/e833e7ad64eb2f63867f65303be49ca30ee8819e

------------------------------------------------------------

CVE ID: CVE-2025-22058
Description: In the Linux kernel, the following vulnerability has been resolved:

udp: Fix memory accounting leak.

Matt Dowling reported a weird UDP memory usage issue.

Under normal operation, the UDP memory usage reported in /proc/net/sockstat
remains close to zero.  However, it occasionally spiked to 524,288 pages
and never dropped.  Moreover, the value doubled when the application was
terminated.  Finally, it caused intermittent packet drops.

We can reproduce the issue with the script below [0]:

  1. /proc/net/sockstat reports 0 pages

    # cat /proc/net/sockstat | grep UDP:
    UDP: inuse 1 mem 0

  2. Run the script till the report reaches 524,288

    # python3 test.py & sleep 5
    # cat /proc/net/sockstat | grep UDP:
    UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> PAGE_SHIFT

  3. Kill the socket and confirm the number never drops

    # pkill python3 && sleep 5
    # cat /proc/net/sockstat | grep UDP:
    UDP: inuse 1 mem 524288

  4. (necessary since v6.0) Trigger proto_memory_pcpu_drain()

    # python3 test.py & sleep 1 && pkill python3

  5. The number doubles

    # cat /proc/net/sockstat | grep UDP:
    UDP: inuse 1 mem 1048577

The application set INT_MAX to SO_RCVBUF, which triggered an integer
overflow in udp_rmem_release().

When a socket is close()d, udp_destruct_common() purges its receive
queue and sums up skb->truesize in the queue.  This total is calculated
and stored in a local unsigned integer variable.

The total size is then passed to udp_rmem_release() to adjust memory
accounting.  However, because the function takes a signed integer
argument, the total size can wrap around, causing an overflow.

Then, the released amount is calculated as follows:

  1) Add size to sk->sk_forward_alloc.
  2) Round down sk->sk_forward_alloc to the nearest lower multiple of
      PAGE_SIZE and assign it to amount.
  3) Subtract amount from sk->sk_forward_alloc.
  4) Pass amount >> PAGE_SHIFT to __sk_mem_reduce_allocated().

When the issue occurred, the total in udp_destruct_common() was 2147484480
(INT_MAX + 833), which was cast to -2147482816 in udp_rmem_release().

At 1) sk->sk_forward_alloc is changed from 3264 to -2147479552, and
2) sets -2147479552 to amount.  3) reverts the wraparound, so we don't
see a warning in inet_sock_destruct().  However, udp_memory_allocated
ends up doubling at 4).

Since commit 3cd3399dd7a8 ("net: implement per-cpu reserves for
memory_allocated"), memory usage no longer doubles immediately after
a socket is close()d because __sk_mem_reduce_allocated() caches the
amount in udp_memory_per_cpu_fw_alloc.  However, the next time a UDP
socket receives a packet, the subtraction takes effect, causing UDP
memory usage to double.

This issue makes further memory allocation fail once the socket's
sk->sk_rmem_alloc exceeds net.ipv4.udp_rmem_min, resulting in packet
drops.

To prevent this issue, let's use unsigned int for the calculation and
call sk_forward_alloc_add() only once for the small delta.

Note that first_packet_length() also potentially has the same problem.

[0]:
from socket import *

SO_RCVBUFFORCE = 33
INT_MAX = (2 ** 31) - 1

s = socket(AF_INET, SOCK_DGRAM)
s.bind(('', 0))
s.setsockopt(SOL_SOCKET, SO_RCVBUFFORCE, INT_MAX)

c = socket(AF_INET, SOCK_DGRAM)
c.connect(s.getsockname())

data = b'a' * 100

while True:
    c.send(data)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3836029448e76c1e6f77cc5fe0adc09b018b5fa8
  - https://git.kernel.org/stable/c/9122fec396950cc866137af7154b1d0d989be52e
  - https://git.kernel.org/stable/c/a116b271bf3cb72c8155b6b7f39083c1b80dcd00
  - https://git.kernel.org/stable/c/aeef6456692c6f11ae53d278df64f1316a2a405a
  - https://git.kernel.org/stable/c/c4bac6c398118fba79e32b1cd01db22dbfe29fbf
  - https://git.kernel.org/stable/c/df207de9d9e7a4d92f8567e2c539d9c8c12fd99d

------------------------------------------------------------

CVE ID: CVE-2025-22059
Description: In the Linux kernel, the following vulnerability has been resolved:

udp: Fix multiple wraparounds of sk->sk_rmem_alloc.

__udp_enqueue_schedule_skb() has the following condition:

  if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)
          goto drop;

sk->sk_rcvbuf is initialised by net.core.rmem_default and later can
be configured by SO_RCVBUF, which is limited by net.core.rmem_max,
or SO_RCVBUFFORCE.

If we set INT_MAX to sk->sk_rcvbuf, the condition is always false
as sk->sk_rmem_alloc is also signed int.

Then, the size of the incoming skb is added to sk->sk_rmem_alloc
unconditionally.

This results in integer overflow (possibly multiple times) on
sk->sk_rmem_alloc and allows a single socket to have skb up to
net.core.udp_mem[1].

For example, if we set a large value to udp_mem[1] and INT_MAX to
sk->sk_rcvbuf and flood packets to the socket, we can see multiple
overflows:

  # cat /proc/net/sockstat | grep UDP:
  UDP: inuse 3 mem 7956736  <-- (7956736 << 12) bytes > INT_MAX * 15
                                             ^- PAGE_SHIFT
  # ss -uam
  State  Recv-Q      ...
  UNCONN -1757018048 ...    <-- flipping the sign repeatedly
         skmem:(r2537949248,rb2147483646,t0,tb212992,f1984,w0,o0,bl0,d0)

Previously, we had a boundary check for INT_MAX, which was removed by
commit 6a1f12dd85a8 ("udp: relax atomic operation on sk->sk_rmem_alloc").

A complete fix would be to revert it and cap the right operand by
INT_MAX:

  rmem = atomic_add_return(size, &sk->sk_rmem_alloc);
  if (rmem > min(size + (unsigned int)sk->sk_rcvbuf, INT_MAX))
          goto uncharge_drop;

but we do not want to add the expensive atomic_add_return() back just
for the corner case.

Casting rmem to unsigned int prevents multiple wraparounds, but we still
allow a single wraparound.

  # cat /proc/net/sockstat | grep UDP:
  UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> 12

  # ss -uam
  State  Recv-Q      ...
  UNCONN -2147482816 ...   <-- INT_MAX + 831 bytes
         skmem:(r2147484480,rb2147483646,t0,tb212992,f3264,w0,o0,bl0,d14468947)

So, let's define rmem and rcvbuf as unsigned int and check skb->truesize
only when rcvbuf is large enough to lower the overflow possibility.

Note that we still have a small chance to see overflow if multiple skbs
to the same socket are processed on different core at the same time and
each size does not exceed the limit but the total size does.

Note also that we must ignore skb->truesize for a small buffer as
explained in commit 363dc73acacb ("udp: be less conservative with
sock rmem accounting").
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.10, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/1f529988efe9870db802cb79d01d8f473099b4d7
  - https://git.kernel.org/stable/c/5a465a0da13ee9fbd7d3cd0b2893309b0fe4b7e3
  - https://git.kernel.org/stable/c/7571aadd20289e9ea10ebfed0986f39ed8b3c16b
  - https://git.kernel.org/stable/c/94d5ad7b41122be33ebc2a6830fe710cba1ecd75

------------------------------------------------------------

CVE ID: CVE-2025-22060
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mvpp2: Prevent parser TCAM memory corruption

Protect the parser TCAM/SRAM memory, and the cached (shadow) SRAM
information, from concurrent modifications.

Both the TCAM and SRAM tables are indirectly accessed by configuring
an index register that selects the row to read or write to. This means
that operations must be atomic in order to, e.g., avoid spreading
writes across multiple rows. Since the shadow SRAM array is used to
find free rows in the hardware table, it must also be protected in
order to avoid TOCTOU errors where multiple cores allocate the same
row.

This issue was detected in a situation where `mvpp2_set_rx_mode()` ran
concurrently on two CPUs. In this particular case the
MVPP2_PE_MAC_UC_PROMISCUOUS entry was corrupted, causing the
classifier unit to drop all incoming unicast - indicated by the
`rx_classifier_drops` counter.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/46c1e23e34c9d1eaadf37f88216d9d8ce0d0bcee
  - https://git.kernel.org/stable/c/5b0ae1723a7d9574ae1aee7d9cf9757a30069865
  - https://git.kernel.org/stable/c/96844075226b49af25a69a1d084b648ec2d9b08d
  - https://git.kernel.org/stable/c/b3f48a41a00d6d8d9c6fe09ae47dd21c8c1c8b03
  - https://git.kernel.org/stable/c/e3711163d14d02af9005e4cdad30899c565f13fb
  - https://git.kernel.org/stable/c/e64e9b6e86b39db3baa576fd73da73533b54cb2d
  - https://git.kernel.org/stable/c/fcbfb54a0269875cf3cd6a2bff4f85a2e0a0b552

------------------------------------------------------------

CVE ID: CVE-2025-22061
Description: In the Linux kernel, the following vulnerability has been resolved:

net: airoha: Fix qid report in airoha_tc_get_htb_get_leaf_queue()

Fix the following kernel warning deleting HTB offloaded leafs and/or root
HTB qdisc in airoha_eth driver properly reporting qid in
airoha_tc_get_htb_get_leaf_queue routine.

$tc qdisc replace dev eth1 root handle 10: htb offload
$tc class add dev eth1 arent 10: classid 10:4 htb rate 100mbit ceil 100mbit
$tc qdisc replace dev eth1 parent 10:4 handle 4: ets bands 8 \
 quanta 1514 3028 4542 6056 7570 9084 10598 12112
$tc qdisc del dev eth1 root

[   55.827864] ------------[ cut here ]------------
[   55.832493] WARNING: CPU: 3 PID: 2678 at 0xffffffc0798695a4
[   55.956510] CPU: 3 PID: 2678 Comm: tc Tainted: G           O 6.6.71 #0
[   55.963557] Hardware name: Airoha AN7581 Evaluation Board (DT)
[   55.969383] pstate: 20400005 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   55.976344] pc : 0xffffffc0798695a4
[   55.979851] lr : 0xffffffc079869a20
[   55.983358] sp : ffffffc0850536a0
[   55.986665] x29: ffffffc0850536a0 x28: 0000000000000024 x27: 0000000000000001
[   55.993800] x26: 0000000000000000 x25: ffffff8008b19000 x24: ffffff800222e800
[   56.000935] x23: 0000000000000001 x22: 0000000000000000 x21: ffffff8008b19000
[   56.008071] x20: ffffff8002225800 x19: ffffff800379d000 x18: 0000000000000000
[   56.015206] x17: ffffffbf9ea59000 x16: ffffffc080018000 x15: 0000000000000000
[   56.022342] x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000001
[   56.029478] x11: ffffffc081471008 x10: ffffffc081575a98 x9 : 0000000000000000
[   56.036614] x8 : ffffffc08167fd40 x7 : ffffffc08069e104 x6 : ffffff8007f86000
[   56.043748] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000001
[   56.050884] x2 : 0000000000000000 x1 : 0000000000000250 x0 : ffffff800222c000
[   56.058020] Call trace:
[   56.060459]  0xffffffc0798695a4
[   56.063618]  0xffffffc079869a20
[   56.066777]  __qdisc_destroy+0x40/0xa0
[   56.070528]  qdisc_put+0x54/0x6c
[   56.073748]  qdisc_graft+0x41c/0x648
[   56.077324]  tc_get_qdisc+0x168/0x2f8
[   56.080978]  rtnetlink_rcv_msg+0x230/0x330
[   56.085076]  netlink_rcv_skb+0x5c/0x128
[   56.088913]  rtnetlink_rcv+0x14/0x1c
[   56.092490]  netlink_unicast+0x1e0/0x2c8
[   56.096413]  netlink_sendmsg+0x198/0x3c8
[   56.100337]  ____sys_sendmsg+0x1c4/0x274
[   56.104261]  ___sys_sendmsg+0x7c/0xc0
[   56.107924]  __sys_sendmsg+0x44/0x98
[   56.111492]  __arm64_sys_sendmsg+0x20/0x28
[   56.115580]  invoke_syscall.constprop.0+0x58/0xfc
[   56.120285]  do_el0_svc+0x3c/0xbc
[   56.123592]  el0_svc+0x18/0x4c
[   56.126647]  el0t_64_sync_handler+0x118/0x124
[   56.131005]  el0t_64_sync+0x150/0x154
[   56.134660] ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/57b290d97c6150774bf929117ca737a26d8fc33d
  - https://git.kernel.org/stable/c/d7f76197e49e46a8c082a6fededaa8a07e69a860

------------------------------------------------------------

CVE ID: CVE-2025-22062
Description: In the Linux kernel, the following vulnerability has been resolved:

sctp: add mutual exclusion in proc_sctp_do_udp_port()

We must serialize calls to sctp_udp_sock_stop() and sctp_udp_sock_start()
or risk a crash as syzbot reported:

Oops: general protection fault, probably for non-canonical address 0xdffffc000000000d: 0000 [#1] SMP KASAN PTI
KASAN: null-ptr-deref in range [0x0000000000000068-0x000000000000006f]
CPU: 1 UID: 0 PID: 6551 Comm: syz.1.44 Not tainted 6.14.0-syzkaller-g7f2ff7b62617 #0 PREEMPT(full)
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025
 RIP: 0010:kernel_sock_shutdown+0x47/0x70 net/socket.c:3653
Call Trace:
 <TASK>
  udp_tunnel_sock_release+0x68/0x80 net/ipv4/udp_tunnel_core.c:181
  sctp_udp_sock_stop+0x71/0x160 net/sctp/protocol.c:930
  proc_sctp_do_udp_port+0x264/0x450 net/sctp/sysctl.c:553
  proc_sys_call_handler+0x3d0/0x5b0 fs/proc/proc_sysctl.c:601
  iter_file_splice_write+0x91c/0x1150 fs/splice.c:738
  do_splice_from fs/splice.c:935 [inline]
  direct_splice_actor+0x18f/0x6c0 fs/splice.c:1158
  splice_direct_to_actor+0x342/0xa30 fs/splice.c:1102
  do_splice_direct_actor fs/splice.c:1201 [inline]
  do_splice_direct+0x174/0x240 fs/splice.c:1227
  do_sendfile+0xafd/0xe50 fs/read_write.c:1368
  __do_sys_sendfile64 fs/read_write.c:1429 [inline]
  __se_sys_sendfile64 fs/read_write.c:1415 [inline]
  __x64_sys_sendfile64+0x1d8/0x220 fs/read_write.c:1415
  do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/10206302af856791fbcc27a33ed3c3eb09b2793d
  - https://git.kernel.org/stable/c/d3d7675d77622f6ca1aae14c51f80027b36283f8
  - https://git.kernel.org/stable/c/e5178bfc55b3a78000f0f8298e7ade88783ce581
  - https://git.kernel.org/stable/c/efb8cb487be8f4ba6aaef616011d702d6a083ed1

------------------------------------------------------------

CVE ID: CVE-2025-22063
Description: In the Linux kernel, the following vulnerability has been resolved:

netlabel: Fix NULL pointer exception caused by CALIPSO on IPv4 sockets

When calling netlbl_conn_setattr(), addr->sa_family is used
to determine the function behavior. If sk is an IPv4 socket,
but the connect function is called with an IPv6 address,
the function calipso_sock_setattr() is triggered.
Inside this function, the following code is executed:

sk_fullsock(__sk) ? inet_sk(__sk)->pinet6 : NULL;

Since sk is an IPv4 socket, pinet6 is NULL, leading to a
null pointer dereference.

This patch fixes the issue by checking if inet6_sk(sk)
returns a NULL pointer before accessing pinet6.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.8, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/078aabd567de3d63d37d7673f714e309d369e6e2
  - https://git.kernel.org/stable/c/172a8a996a337206970467e871dd995ac07640b1
  - https://git.kernel.org/stable/c/1927d0bcd5b81e80971bf6b8eba267508bd1c78b
  - https://git.kernel.org/stable/c/1ad9166cab6a0f5c0b10344a97bdf749ae11dcbf
  - https://git.kernel.org/stable/c/1e38f7a6cdd68377f8a4189b2fbaec14a6dd5152
  - https://git.kernel.org/stable/c/3ba9cf69de50e8abed32b448616c313baa4c5712
  - https://git.kernel.org/stable/c/797e5371cf55463b4530bab3fef5f27f7c6657a8
  - https://git.kernel.org/stable/c/9fe3839588db7519030377b7dee3f165e654f6c5
  - https://git.kernel.org/stable/c/a7e89541d05b98c79a51c0f95df020f8e82b62ed

------------------------------------------------------------

CVE ID: CVE-2025-22064
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: don't unregister hook when table is dormant

When nf_tables_updchain encounters an error, hook registration needs to
be rolled back.

This should only be done if the hook has been registered, which won't
happen when the table is flagged as dormant (inactive).

Just move the assignment into the registration block.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/03d1fb457b696c18fe15661440c4f052b2374e7e
  - https://git.kernel.org/stable/c/6134d1ea1e1408e8e7c8c26545b3b301cbdf1eda
  - https://git.kernel.org/stable/c/688c15017d5cd5aac882400782e7213d40dc3556
  - https://git.kernel.org/stable/c/ce571eba07d54e3637bf334bc48376fbfa55defe
  - https://git.kernel.org/stable/c/feb1fa2a03a27fec7001e93e4223be4120d1784b

------------------------------------------------------------

CVE ID: CVE-2025-22065
Description: In the Linux kernel, the following vulnerability has been resolved:

idpf: fix adapter NULL pointer dereference on reboot

With SRIOV enabled, idpf ends up calling into idpf_remove() twice.
First via idpf_shutdown() and then again when idpf_remove() calls into
sriov_disable(), because the VF devices use the idpf driver, hence the
same remove routine. When that happens, it is possible for the adapter
to be NULL from the first call to idpf_remove(), leading to a NULL
pointer dereference.

echo 1 > /sys/class/net/<netif>/device/sriov_numvfs
reboot

BUG: kernel NULL pointer dereference, address: 0000000000000020
...
RIP: 0010:idpf_remove+0x22/0x1f0 [idpf]
...
? idpf_remove+0x22/0x1f0 [idpf]
? idpf_remove+0x1e4/0x1f0 [idpf]
pci_device_remove+0x3f/0xb0
device_release_driver_internal+0x19f/0x200
pci_stop_bus_device+0x6d/0x90
pci_stop_and_remove_bus_device+0x12/0x20
pci_iov_remove_virtfn+0xbe/0x120
sriov_disable+0x34/0xe0
idpf_sriov_configure+0x58/0x140 [idpf]
idpf_remove+0x1b9/0x1f0 [idpf]
idpf_shutdown+0x12/0x30 [idpf]
pci_device_shutdown+0x35/0x60
device_shutdown+0x156/0x200
...

Replace the direct idpf_remove() call in idpf_shutdown() with
idpf_vc_core_deinit() and idpf_deinit_dflt_mbx(), which perform
the bulk of the cleanup, such as stopping the init task, freeing IRQs,
destroying the vports and freeing the mailbox. This avoids the calls to
sriov_disable() in addition to a small netdev cleanup, and destroying
workqueues, which don't seem to be required on shutdown.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/4c9106f4906a85f6b13542d862e423bcdc118cc3
  - https://git.kernel.org/stable/c/79618e952ef4dfa1a17ee0631d5549603fab58d8
  - https://git.kernel.org/stable/c/88a6d562e92a295648f8636acf2a6aa714241771
  - https://git.kernel.org/stable/c/9fc9b3dc0d0c189ed205acf1e5fbd73e0becc4d6

------------------------------------------------------------

CVE ID: CVE-2025-22066
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: imx-card: Add NULL check in imx_card_probe()

devm_kasprintf() returns NULL when memory allocation fails. Currently,
imx_card_probe() does not check for this case, which results in a NULL
pointer dereference.

Add NULL check after devm_kasprintf() to prevent this issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/018e6cf2503e60087747b0ebc190e18b3640766f
  - https://git.kernel.org/stable/c/38253922a89a742e7e622f626b41c64388367361
  - https://git.kernel.org/stable/c/4d8458e48ff135bddc402ad79821dc058ea163d0
  - https://git.kernel.org/stable/c/93d34608fd162f725172e780b1c60cc93a920719
  - https://git.kernel.org/stable/c/b01700e08be99e3842570142ec5973ccd7e73eaf
  - https://git.kernel.org/stable/c/dd2bbb9564d0d24a2643ad90008a79840368c4b4
  - https://git.kernel.org/stable/c/e283a5bf4337a7300ac5e6ae363cc8b242a0b4b7

------------------------------------------------------------

CVE ID: CVE-2025-22067
Description: In the Linux kernel, the following vulnerability has been resolved:

spi: cadence: Fix out-of-bounds array access in cdns_mrvl_xspi_setup_clock()

If requested_clk > 128, cdns_mrvl_xspi_setup_clock() iterates over the
entire cdns_mrvl_xspi_clk_div_list array without breaking out early,
causing 'i' to go beyond the array bounds.

Fix that by stopping the loop when it gets to the last entry, clamping
the clock to the minimum 6.25 MHz.

Fixes the following warning with an UBSAN kernel:

  vmlinux.o: warning: objtool: cdns_mrvl_xspi_setup_clock: unexpected end of section .text.cdns_mrvl_xspi_setup_clock
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/645f1813fe0dc96381c36b834131e643b798fd73
  - https://git.kernel.org/stable/c/7ba0847fa1c22e7801cebfe5f7b75aee4fae317e
  - https://git.kernel.org/stable/c/c1fb84e274cb6a2bce6ba5e65116c06e0b3ab275
  - https://git.kernel.org/stable/c/e50781bf7accc75883cb8a6a9921fb4e2fa8cca4

------------------------------------------------------------

CVE ID: CVE-2025-22068
Description: In the Linux kernel, the following vulnerability has been resolved:

ublk: make sure ubq->canceling is set when queue is frozen

Now ublk driver depends on `ubq->canceling` for deciding if the request
can be dispatched via uring_cmd & io_uring_cmd_complete_in_task().

Once ubq->canceling is set, the uring_cmd can be done via ublk_cancel_cmd()
and io_uring_cmd_done().

So set ubq->canceling when queue is frozen, this way makes sure that the
flag can be observed from ublk_queue_rq() reliably, and avoids
use-after-free on uring_cmd.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/5491400589e7572c2d2627ed6384302f7672aa1d
  - https://git.kernel.org/stable/c/7e3497d7dacb5aee69dd9be842b778083cae0e75
  - https://git.kernel.org/stable/c/8741d0737921ec1c03cf59aebf4d01400c2b461a
  - https://git.kernel.org/stable/c/9158359015f0eda00e521e35b7bc7ebce176aebf

------------------------------------------------------------

CVE ID: CVE-2025-22069
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv: fgraph: Fix stack layout to match __arch_ftrace_regs argument of ftrace_return_to_handler

Naresh Kamboju reported a "Bad frame pointer" kernel warning while
running LTP trace ftrace_stress_test.sh in riscv. We can reproduce the
same issue with the following command:

```
$ cd /sys/kernel/debug/tracing
$ echo 'f:myprobe do_nanosleep%return args1=$retval' > dynamic_events
$ echo 1 > events/fprobes/enable
$ echo 1 > tracing_on
$ sleep 1
```

And we can get the following kernel warning:

[  127.692888] ------------[ cut here ]------------
[  127.693755] Bad frame pointer: expected ff2000000065be50, received ba34c141e9594000
[  127.693755]   from func do_nanosleep return to ffffffff800ccb16
[  127.698699] WARNING: CPU: 1 PID: 129 at kernel/trace/fgraph.c:755 ftrace_return_to_handler+0x1b2/0x1be
[  127.699894] Modules linked in:
[  127.700908] CPU: 1 UID: 0 PID: 129 Comm: sleep Not tainted 6.14.0-rc3-g0ab191c74642 #32
[  127.701453] Hardware name: riscv-virtio,qemu (DT)
[  127.701859] epc : ftrace_return_to_handler+0x1b2/0x1be
[  127.702032]  ra : ftrace_return_to_handler+0x1b2/0x1be
[  127.702151] epc : ffffffff8013b5e0 ra : ffffffff8013b5e0 sp : ff2000000065bd10
[  127.702221]  gp : ffffffff819c12f8 tp : ff60000080853100 t0 : 6e00000000000000
[  127.702284]  t1 : 0000000000000020 t2 : 6e7566206d6f7266 s0 : ff2000000065bd80
[  127.702346]  s1 : ff60000081262000 a0 : 000000000000007b a1 : ffffffff81894f20
[  127.702408]  a2 : 0000000000000010 a3 : fffffffffffffffe a4 : 0000000000000000
[  127.702470]  a5 : 0000000000000000 a6 : 0000000000000008 a7 : 0000000000000038
[  127.702530]  s2 : ba34c141e9594000 s3 : 0000000000000000 s4 : ff2000000065bdd0
[  127.702591]  s5 : 00007fff8adcf400 s6 : 000055556dc1d8c0 s7 : 0000000000000068
[  127.702651]  s8 : 00007fff8adf5d10 s9 : 000000000000006d s10: 0000000000000001
[  127.702710]  s11: 00005555737377c8 t3 : ffffffff819d899e t4 : ffffffff819d899e
[  127.702769]  t5 : ffffffff819d89a0 t6 : ff2000000065bb18
[  127.702826] status: 0000000200000120 badaddr: 0000000000000000 cause: 0000000000000003
[  127.703292] [<ffffffff8013b5e0>] ftrace_return_to_handler+0x1b2/0x1be
[  127.703760] [<ffffffff80017bce>] return_to_handler+0x16/0x26
[  127.704009] [<ffffffff80017bb8>] return_to_handler+0x0/0x26
[  127.704057] [<ffffffff800d3352>] common_nsleep+0x42/0x54
[  127.704117] [<ffffffff800d44a2>] __riscv_sys_clock_nanosleep+0xba/0x10a
[  127.704176] [<ffffffff80901c56>] do_trap_ecall_u+0x188/0x218
[  127.704295] [<ffffffff8090cc3e>] handle_exception+0x14a/0x156
[  127.705436] ---[ end trace 0000000000000000 ]---

The reason is that the stack layout for constructing argument for the
ftrace_return_to_handler in the return_to_handler does not match the
__arch_ftrace_regs structure of riscv, leading to unexpected results.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/67a5ba8f742f247bc83e46dd2313c142b1383276
  - https://git.kernel.org/stable/c/78b39c587b8f6c69140177108f9c08a75b1c7c37

------------------------------------------------------------

CVE ID: CVE-2025-22070
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/9p: fix NULL pointer dereference on mkdir

When a 9p tree was mounted with option 'posixacl', parent directory had a
default ACL set for its subdirectories, e.g.:

  setfacl -m default:group:simpsons:rwx parentdir

then creating a subdirectory crashed 9p client, as v9fs_fid_add() call in
function v9fs_vfs_mkdir_dotl() sets the passed 'fid' pointer to NULL
(since dafbe689736) even though the subsequent v9fs_set_create_acl() call
expects a valid non-NULL 'fid' pointer:

  [   37.273191] BUG: kernel NULL pointer dereference, address: 0000000000000000
  ...
  [   37.322338] Call Trace:
  [   37.323043]  <TASK>
  [   37.323621] ? __die (arch/x86/kernel/dumpstack.c:421 arch/x86/kernel/dumpstack.c:434)
  [   37.324448] ? page_fault_oops (arch/x86/mm/fault.c:714)
  [   37.325532] ? search_module_extables (kernel/module/main.c:3733)
  [   37.326742] ? p9_client_walk (net/9p/client.c:1165) 9pnet
  [   37.328006] ? search_bpf_extables (kernel/bpf/core.c:804)
  [   37.329142] ? exc_page_fault (./arch/x86/include/asm/paravirt.h:686 arch/x86/mm/fault.c:1488 arch/x86/mm/fault.c:1538)
  [   37.330196] ? asm_exc_page_fault (./arch/x86/include/asm/idtentry.h:574)
  [   37.331330] ? p9_client_walk (net/9p/client.c:1165) 9pnet
  [   37.332562] ? v9fs_fid_xattr_get (fs/9p/xattr.c:30) 9p
  [   37.333824] v9fs_fid_xattr_set (fs/9p/fid.h:23 fs/9p/xattr.c:121) 9p
  [   37.335077] v9fs_set_acl (fs/9p/acl.c:276) 9p
  [   37.336112] v9fs_set_create_acl (fs/9p/acl.c:307) 9p
  [   37.337326] v9fs_vfs_mkdir_dotl (fs/9p/vfs_inode_dotl.c:411) 9p
  [   37.338590] vfs_mkdir (fs/namei.c:4313)
  [   37.339535] do_mkdirat (fs/namei.c:4336)
  [   37.340465] __x64_sys_mkdir (fs/namei.c:4354)
  [   37.341455] do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)
  [   37.342447] entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)

Fix this by simply swapping the sequence of these two calls in
v9fs_vfs_mkdir_dotl(), i.e. calling v9fs_set_create_acl() before
v9fs_fid_add().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/2139dea5c53e3bb63ac49a6901c85e525a80ee8a
  - https://git.kernel.org/stable/c/3f61ac7c65bdb26accb52f9db66313597e759821
  - https://git.kernel.org/stable/c/6517b395cb1e43fbf3962dd93e6fb4a5e5ab100e
  - https://git.kernel.org/stable/c/8522051c58d68146b93e8a5ba9987e83b3d64e7b

------------------------------------------------------------

CVE ID: CVE-2025-22071
Description: In the Linux kernel, the following vulnerability has been resolved:

spufs: fix a leak in spufs_create_context()

Leak fixes back in 2008 missed one case - if we are trying to set affinity
and spufs_mkdir() fails, we need to drop the reference to neighbor.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0f5cce3fc55b08ee4da3372baccf4bcd36a98396
  - https://git.kernel.org/stable/c/239ea3c34673b3244a499fd65771c47e5bffcbb0
  - https://git.kernel.org/stable/c/410c787d89c92df4215d7b1a338e2c1a8aba6b9b
  - https://git.kernel.org/stable/c/4a7448c83e117ed68597952ecaede1cebc4427a7
  - https://git.kernel.org/stable/c/5a90b699844a5bb96961e5892e51cc59255444a3
  - https://git.kernel.org/stable/c/829bd6139968e2e759f3928cf65ad0db1e302fe3
  - https://git.kernel.org/stable/c/a333f223e555d27609f8b45d75a08e8e1d36c432
  - https://git.kernel.org/stable/c/c4e72a0d75442237b6f3bcca10a7d81b89376d16
  - https://git.kernel.org/stable/c/d04600f43569d48262e1328eaa1592fcefa2c19c

------------------------------------------------------------

CVE ID: CVE-2025-22072
Description: In the Linux kernel, the following vulnerability has been resolved:

spufs: fix gang directory lifetimes

prior to "[POWERPC] spufs: Fix gang destroy leaks" we used to have
a problem with gang lifetimes - creation of a gang returns opened
gang directory, which normally gets removed when that gets closed,
but if somebody has created a context belonging to that gang and
kept it alive until the gang got closed, removal failed and we
ended up with a leak.

Unfortunately, it had been fixed the wrong way.  Dentry of gang
directory was no longer pinned, and rmdir on close was gone.
One problem was that failure of open kept calling simple_rmdir()
as cleanup, which meant an unbalanced dput().  Another bug was
in the success case - gang creation incremented link count on
root directory, but that was no longer undone when gang got
destroyed.

Fix consists of
	* reverting the commit in question
	* adding a counter to gang, protected by ->i_rwsem
of gang directory inode.
	* having it set to 1 at creation time, dropped
in both spufs_dir_close() and spufs_gang_close() and bumped
in spufs_create_context(), provided that it's not 0.
	* using simple_recursive_removal() to take the gang
directory out when counter reaches zero.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/029d8c711f5e5fe8cf63e8a4a1a140a06e224e45
  - https://git.kernel.org/stable/c/324f280806aab28ef757aecc18df419676c10ef8
  - https://git.kernel.org/stable/c/880e7b3da2e765c1f90c94c0539be039e96c7062
  - https://git.kernel.org/stable/c/903733782f3ae28a2f7fe4dfb47c7fe3e079a528
  - https://git.kernel.org/stable/c/c134deabf4784e155d360744d4a6a835b9de4dd4
  - https://git.kernel.org/stable/c/fc646a6c6d14b5d581f162a7e32999f789e3a3ac

------------------------------------------------------------

CVE ID: CVE-2025-22073
Description: In the Linux kernel, the following vulnerability has been resolved:

spufs: fix a leak on spufs_new_file() failure

It's called from spufs_fill_dir(), and caller of that will do
spufs_rmdir() in case of failure.  That does remove everything
we'd managed to create, but... the problem dentry is still
negative.  IOW, it needs to be explicitly dropped.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0bd56e4e72c354b65c0a7e5ac1c09eca81949d5b
  - https://git.kernel.org/stable/c/132925bd6772d7614340fb755ac5415462ac8edd
  - https://git.kernel.org/stable/c/35f789ccebd69f6f9a1e0a9b85435003b2450065
  - https://git.kernel.org/stable/c/53b189651c33b5f1fb3b755e6a37a8206978514e
  - https://git.kernel.org/stable/c/90d1b276d1b1379d20ad27d1f6349ba9f44a2e00
  - https://git.kernel.org/stable/c/96de7fbdc2dcadeebc17c3cb89e7cdab487bfce0
  - https://git.kernel.org/stable/c/b1eef06d10c1a9848e3a762919bbbe315a0a7cb4
  - https://git.kernel.org/stable/c/d1ca8698ca1332625d83ea0d753747be66f9906d
  - https://git.kernel.org/stable/c/d791985ceeb081155b4e96d314ca54c7605dcbe0

------------------------------------------------------------

CVE ID: CVE-2025-22074
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix r_count dec/increment mismatch

r_count is only increased when there is an oplock break wait,
so r_count inc/decrement are not paired. This can cause r_count
to become negative, which can lead to a problem where the ksmbd
thread does not terminate.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/20378cf48359f39dee0ef9b61470ebe77bd49c0d
  - https://git.kernel.org/stable/c/457db486203c90e10c3efc87fd45cc7000b1cd36
  - https://git.kernel.org/stable/c/4790bcb269e5d6d88200a67c54ae6d627332a3be
  - https://git.kernel.org/stable/c/c2ec33d46b4d1c8085dab5d02e00b21f4f0fb8a9
  - https://git.kernel.org/stable/c/ddb7ea36ba7129c2ed107e2186591128618864e1

------------------------------------------------------------

CVE ID: CVE-2025-22075
Description: In the Linux kernel, the following vulnerability has been resolved:

rtnetlink: Allocate vfinfo size for VF GUIDs when supported

Commit 30aad41721e0 ("net/core: Add support for getting VF GUIDs")
added support for getting VF port and node GUIDs in netlink ifinfo
messages, but their size was not taken into consideration in the
function that allocates the netlink message, causing the following
warning when a netlink message is filled with many VF port and node
GUIDs:
 # echo 64 > /sys/bus/pci/devices/0000\:08\:00.0/sriov_numvfs
 # ip link show dev ib0
 RTNETLINK answers: Message too long
 Cannot send link get request: Message too long

Kernel warning:

 ------------[ cut here ]------------
 WARNING: CPU: 2 PID: 1930 at net/core/rtnetlink.c:4151 rtnl_getlink+0x586/0x5a0
 Modules linked in: xt_conntrack xt_MASQUERADE nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter overlay mlx5_ib macsec mlx5_core tls rpcrdma rdma_ucm ib_uverbs ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm iw_cm ib_ipoib fuse ib_cm ib_core
 CPU: 2 UID: 0 PID: 1930 Comm: ip Not tainted 6.14.0-rc2+ #1
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
 RIP: 0010:rtnl_getlink+0x586/0x5a0
 Code: cb 82 e8 3d af 0a 00 4d 85 ff 0f 84 08 ff ff ff 4c 89 ff 41 be ea ff ff ff e8 66 63 5b ff 49 c7 07 80 4f cb 82 e9 36 fc ff ff <0f> 0b e9 16 fe ff ff e8 de a0 56 00 66 66 2e 0f 1f 84 00 00 00 00
 RSP: 0018:ffff888113557348 EFLAGS: 00010246
 RAX: 00000000ffffffa6 RBX: ffff88817e87aa34 RCX: dffffc0000000000
 RDX: 0000000000000003 RSI: 0000000000000000 RDI: ffff88817e87afb8
 RBP: 0000000000000009 R08: ffffffff821f44aa R09: 0000000000000000
 R10: ffff8881260f79a8 R11: ffff88817e87af00 R12: ffff88817e87aa00
 R13: ffffffff8563d300 R14: 00000000ffffffa6 R15: 00000000ffffffff
 FS:  00007f63a5dbf280(0000) GS:ffff88881ee00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007f63a5ba4493 CR3: 00000001700fe002 CR4: 0000000000772eb0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 PKRU: 55555554
 Call Trace:
  <TASK>
  ? __warn+0xa5/0x230
  ? rtnl_getlink+0x586/0x5a0
  ? report_bug+0x22d/0x240
  ? handle_bug+0x53/0xa0
  ? exc_invalid_op+0x14/0x50
  ? asm_exc_invalid_op+0x16/0x20
  ? skb_trim+0x6a/0x80
  ? rtnl_getlink+0x586/0x5a0
  ? __pfx_rtnl_getlink+0x10/0x10
  ? rtnetlink_rcv_msg+0x1e5/0x860
  ? __pfx___mutex_lock+0x10/0x10
  ? rcu_is_watching+0x34/0x60
  ? __pfx_lock_acquire+0x10/0x10
  ? stack_trace_save+0x90/0xd0
  ? filter_irq_stacks+0x1d/0x70
  ? kasan_save_stack+0x30/0x40
  ? kasan_save_stack+0x20/0x40
  ? kasan_save_track+0x10/0x30
  rtnetlink_rcv_msg+0x21c/0x860
  ? entry_SYSCALL_64_after_hwframe+0x76/0x7e
  ? __pfx_rtnetlink_rcv_msg+0x10/0x10
  ? arch_stack_walk+0x9e/0xf0
  ? rcu_is_watching+0x34/0x60
  ? lock_acquire+0xd5/0x410
  ? rcu_is_watching+0x34/0x60
  netlink_rcv_skb+0xe0/0x210
  ? __pfx_rtnetlink_rcv_msg+0x10/0x10
  ? __pfx_netlink_rcv_skb+0x10/0x10
  ? rcu_is_watching+0x34/0x60
  ? __pfx___netlink_lookup+0x10/0x10
  ? lock_release+0x62/0x200
  ? netlink_deliver_tap+0xfd/0x290
  ? rcu_is_watching+0x34/0x60
  ? lock_release+0x62/0x200
  ? netlink_deliver_tap+0x95/0x290
  netlink_unicast+0x31f/0x480
  ? __pfx_netlink_unicast+0x10/0x10
  ? rcu_is_watching+0x34/0x60
  ? lock_acquire+0xd5/0x410
  netlink_sendmsg+0x369/0x660
  ? lock_release+0x62/0x200
  ? __pfx_netlink_sendmsg+0x10/0x10
  ? import_ubuf+0xb9/0xf0
  ? __import_iovec+0x254/0x2b0
  ? lock_release+0x62/0x200
  ? __pfx_netlink_sendmsg+0x10/0x10
  ____sys_sendmsg+0x559/0x5a0
  ? __pfx_____sys_sendmsg+0x10/0x10
  ? __pfx_copy_msghdr_from_user+0x10/0x10
  ? rcu_is_watching+0x34/0x60
  ? do_read_fault+0x213/0x4a0
  ? rcu_is_watching+0x34/0x60
  ___sys_sendmsg+0xe4/0x150
  ? __pfx____sys_sendmsg+0x10/0x10
  ? do_fault+0x2cc/0x6f0
  ? handle_pte_fault+0x2e3/0x3d0
  ? __pfx_handle_pte_fault+0x10/0x10
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0f5489707cf528f9df2f39a3045c1ee713ec90e7
  - https://git.kernel.org/stable/c/15f150771e0ec97f8ab1657e7d2568e593c7fa04
  - https://git.kernel.org/stable/c/23f00807619d15063d676218f36c5dfeda1eb420
  - https://git.kernel.org/stable/c/28b21ee8e8fb326ba961a4bbce04ec04c65e705a
  - https://git.kernel.org/stable/c/365c1ae819455561d4746aafabad673e4bcb0163
  - https://git.kernel.org/stable/c/5f39454468329bb7fc7fc4895a6ba6ae3b95027e
  - https://git.kernel.org/stable/c/5fed5f6de3cf734b231a11775748a6871ee3020f
  - https://git.kernel.org/stable/c/bb7bdf636cef74cdd7a7d548bdc7457ae161f617

------------------------------------------------------------

CVE ID: CVE-2025-22076
Description: In the Linux kernel, the following vulnerability has been resolved:

exfat: fix missing shutdown check

xfstests generic/730 test failed because after deleting the device
that still had dirty data, the file could still be read without
returning an error. The reason is the missing shutdown check in
->read_iter.

I also noticed that shutdown checks were missing from ->write_iter,
->splice_read, and ->mmap. This commit adds shutdown checks to all
of them.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/47e35366bc6fa3cf189a8305bce63992495f3efa
  - https://git.kernel.org/stable/c/4a9595eb024b8319957c178be3cdeed613ac0795
  - https://git.kernel.org/stable/c/539147585ca453db6e3d7a5cf3b9c9690513762d
  - https://git.kernel.org/stable/c/e41e33eb795cb9c1ead6ac627d8710546fac6e81

------------------------------------------------------------

CVE ID: CVE-2025-22077
Description: In the Linux kernel, the following vulnerability has been resolved:

Revert "smb: client: fix TCP timers deadlock after rmmod"

This reverts commit e9f2517a3e18a54a3943c098d2226b245d488801.

Commit e9f2517a3e18 ("smb: client: fix TCP timers deadlock after
rmmod") is intended to fix a null-ptr-deref in LOCKDEP, which is
mentioned as CVE-2024-54680, but is actually did not fix anything;
The issue can be reproduced on top of it. [0]

Also, it reverted the change by commit ef7134c7fc48 ("smb: client:
Fix use-after-free of network namespace.") and introduced a real
issue by reviving the kernel TCP socket.

When a reconnect happens for a CIFS connection, the socket state
transitions to FIN_WAIT_1.  Then, inet_csk_clear_xmit_timers_sync()
in tcp_close() stops all timers for the socket.

If an incoming FIN packet is lost, the socket will stay at FIN_WAIT_1
forever, and such sockets could be leaked up to net.ipv4.tcp_max_orphans.

Usually, FIN can be retransmitted by the peer, but if the peer aborts
the connection, the issue comes into reality.

I warned about this privately by pointing out the exact report [1],
but the bogus fix was finally merged.

So, we should not stop the timers to finally kill the connection on
our side in that case, meaning we must not use a kernel socket for
TCP whose sk->sk_net_refcnt is 0.

The kernel socket does not have a reference to its netns to make it
possible to tear down netns without cleaning up every resource in it.

For example, tunnel devices use a UDP socket internally, but we can
destroy netns without removing such devices and let it complete
during exit.  Otherwise, netns would be leaked when the last application
died.

However, this is problematic for TCP sockets because TCP has timers to
close the connection gracefully even after the socket is close()d.  The
lifetime of the socket and its netns is different from the lifetime of
the underlying connection.

If the socket user does not maintain the netns lifetime, the timer could
be fired after the socket is close()d and its netns is freed up, resulting
in use-after-free.

Actually, we have seen so many similar issues and converted such sockets
to have a reference to netns.

That's why I converted the CIFS client socket to have a reference to
netns (sk->sk_net_refcnt == 1), which is somehow mentioned as out-of-scope
of CIFS and technically wrong in e9f2517a3e18, but **is in-scope and right
fix**.

Regarding the LOCKDEP issue, we can prevent the module unload by
bumping the module refcount when switching the LOCKDDEP key in
sock_lock_init_class_and_name(). [2]

For a while, let's revert the bogus fix.

Note that now we can use sk_net_refcnt_upgrade() for the socket
conversion, but I'll do so later separately to make backport easy.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4b6f6bf1bde8d6045c389fda8d21c304dfe49384
  - https://git.kernel.org/stable/c/8dbf060480236877703bff0106fc984576184d11
  - https://git.kernel.org/stable/c/95d2b9f693ff2a1180a23d7d59acc0c4e72f4c41
  - https://git.kernel.org/stable/c/f761eeefd531e6550cd3a5c047835b4892acb00d

------------------------------------------------------------

CVE ID: CVE-2025-22078
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: vchiq_arm: Fix possible NPR of keep-alive thread

In case vchiq_platform_conn_state_changed() is never called or fails before
driver removal, ka_thread won't be a valid pointer to a task_struct. So
do the necessary checks before calling kthread_stop to avoid a crash.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1817c4b85011998604e5ff9a80a6e01adb7e7e81
  - https://git.kernel.org/stable/c/3db89bc6d973e2bcaa852f6409c98c228f39a926
  - https://git.kernel.org/stable/c/a915c896f95a989a7759a73f8c064f5dc3775175
  - https://git.kernel.org/stable/c/bd38395b901327f77a82112f006240de22cf2ceb

------------------------------------------------------------

CVE ID: CVE-2025-22079
Description: In the Linux kernel, the following vulnerability has been resolved:

ocfs2: validate l_tree_depth to avoid out-of-bounds access

The l_tree_depth field is 16-bit (__le16), but the actual maximum depth is
limited to OCFS2_MAX_PATH_DEPTH.

Add a check to prevent out-of-bounds access if l_tree_depth has an invalid
value, which may occur when reading from a corrupted mounted disk [1].
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11e24802e73362aa2948ee16b8fb4e32635d5b2a
  - https://git.kernel.org/stable/c/17c99ab3db2ba74096d36c69daa6e784e98fc0b8
  - https://git.kernel.org/stable/c/3d012ba4404a0bb517658699ba85e6abda386dc3
  - https://git.kernel.org/stable/c/49d2a2ea9d30991bae82107f9523915b91637683
  - https://git.kernel.org/stable/c/538ed8b049ef801a86c543433e5061a91cc106e3
  - https://git.kernel.org/stable/c/a406aff8c05115119127c962cbbbbd202e1973ef
  - https://git.kernel.org/stable/c/b942f88fe7d2d789e51c5c30a675fa1c126f5a6d
  - https://git.kernel.org/stable/c/e95d97c9c8cd0c239b7b59c79be0f6a9dcf7905c
  - https://git.kernel.org/stable/c/ef34840bda333fe99bafbd2d73b70ceaaf9eba66

------------------------------------------------------------

CVE ID: CVE-2025-22080
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Prevent integer overflow in hdr_first_de()

The "de_off" and "used" variables come from the disk so they both need to
check.  The problem is that on 32bit systems if they're both greater than
UINT_MAX - 16 then the check does work as intended because of an integer
overflow.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/201a2bdda13b619c4927700ffe47d387a30ced50
  - https://git.kernel.org/stable/c/6bb81b94f7a9cba6bde9a905cef52a65317a8b04
  - https://git.kernel.org/stable/c/85615aa442830027923fc690390fa74d17b36ae1
  - https://git.kernel.org/stable/c/b9982065b82b4177ba3a7a72ce18c84921f7494d
  - https://git.kernel.org/stable/c/f6d44b1aa46d317e52c21fb9314cfb20dd69e7b0

------------------------------------------------------------

CVE ID: CVE-2025-22081
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Fix a couple integer overflows on 32bit systems

On 32bit systems the "off + sizeof(struct NTFS_DE)" addition can
have an integer wrapping issue.  Fix it by using size_add().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0538f52410b619737e663167b6a2b2d0bc1a589d
  - https://git.kernel.org/stable/c/0922d86a7a6032cb1694eab0b44b861bd33ba8d5
  - https://git.kernel.org/stable/c/0dfe700fbd3525f30a36ffbe390a5b9319bd009a
  - https://git.kernel.org/stable/c/1a14e9718a19d2e88de004a1360bfd7a86ed1395
  - https://git.kernel.org/stable/c/284c9549386e9883855fb82b730303bb2edea9de
  - https://git.kernel.org/stable/c/4d0f4f42922a832388a0c2fe5204c0a1037ff786
  - https://git.kernel.org/stable/c/5ad414f4df2294b28836b5b7b69787659d6aa708

------------------------------------------------------------

CVE ID: CVE-2025-22082
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: backend: make sure to NULL terminate stack buffer

Make sure to NULL terminate the buffer in
iio_backend_debugfs_write_reg() before passing it to sscanf(). It is a
stack variable so we should not assume it will 0 initialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/035b4989211dc1c8626e186d655ae8ca5141bb73
  - https://git.kernel.org/stable/c/04271a4d2740f98bbe36f82cd3d74677a839d1eb
  - https://git.kernel.org/stable/c/df3892e5e861c43d5612728ed259634675b8a71f
  - https://git.kernel.org/stable/c/fd791c81f410ab1c554686a6f486dc7a176dfe35

------------------------------------------------------------

CVE ID: CVE-2025-22083
Description: In the Linux kernel, the following vulnerability has been resolved:

vhost-scsi: Fix handling of multiple calls to vhost_scsi_set_endpoint

If vhost_scsi_set_endpoint is called multiple times without a
vhost_scsi_clear_endpoint between them, we can hit multiple bugs
found by Haoran Zhang:

1. Use-after-free when no tpgs are found:

This fixes a use after free that occurs when vhost_scsi_set_endpoint is
called more than once and calls after the first call do not find any
tpgs to add to the vs_tpg. When vhost_scsi_set_endpoint first finds
tpgs to add to the vs_tpg array match=true, so we will do:

vhost_vq_set_backend(vq, vs_tpg);
...

kfree(vs->vs_tpg);
vs->vs_tpg = vs_tpg;

If vhost_scsi_set_endpoint is called again and no tpgs are found
match=false so we skip the vhost_vq_set_backend call leaving the
pointer to the vs_tpg we then free via:

kfree(vs->vs_tpg);
vs->vs_tpg = vs_tpg;

If a scsi request is then sent we do:

vhost_scsi_handle_vq -> vhost_scsi_get_req -> vhost_vq_get_backend

which sees the vs_tpg we just did a kfree on.

2. Tpg dir removal hang:

This patch fixes an issue where we cannot remove a LIO/target layer
tpg (and structs above it like the target) dir due to the refcount
dropping to -1.

The problem is that if vhost_scsi_set_endpoint detects a tpg is already
in the vs->vs_tpg array or if the tpg has been removed so
target_depend_item fails, the undepend goto handler will do
target_undepend_item on all tpgs in the vs_tpg array dropping their
refcount to 0. At this time vs_tpg contains both the tpgs we have added
in the current vhost_scsi_set_endpoint call as well as tpgs we added in
previous calls which are also in vs->vs_tpg.

Later, when vhost_scsi_clear_endpoint runs it will do
target_undepend_item on all the tpgs in the vs->vs_tpg which will drop
their refcount to -1. Userspace will then not be able to remove the tpg
and will hang when it tries to do rmdir on the tpg dir.

3. Tpg leak:

This fixes a bug where we can leak tpgs and cause them to be
un-removable because the target name is overwritten when
vhost_scsi_set_endpoint is called multiple times but with different
target names.

The bug occurs if a user has called VHOST_SCSI_SET_ENDPOINT and setup
a vhost-scsi device to target/tpg mapping, then calls
VHOST_SCSI_SET_ENDPOINT again with a new target name that has tpgs we
haven't seen before (target1 has tpg1 but target2 has tpg2). When this
happens we don't teardown the old target tpg mapping and just overwrite
the target name and the vs->vs_tpg array. Later when we do
vhost_scsi_clear_endpoint, we are passed in either target1 or target2's
name and we will only match that target's tpgs when we loop over the
vs->vs_tpg. We will then return from the function without doing
target_undepend_item on the tpgs.

Because of all these bugs, it looks like being able to call
vhost_scsi_set_endpoint multiple times was never supported. The major
user, QEMU, already has checks to prevent this use case. So to fix the
issues, this patch prevents vhost_scsi_set_endpoint from being called
if it's already successfully added tpgs. To add, remove or change the
tpg config or target name, you must do a vhost_scsi_clear_endpoint
first.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b34bdc42df047794542f3e220fe989124e4499a
  - https://git.kernel.org/stable/c/3a19eb3d9818e28f14c818a18dc913344a52ca92
  - https://git.kernel.org/stable/c/3fd054baf382a426bbf5135ede0fc5673db74d3e
  - https://git.kernel.org/stable/c/5dd639a1646ef5fe8f4bf270fad47c5c3755b9b6
  - https://git.kernel.org/stable/c/63b449f73ab0dcc0ba11ceaa4c5c70bc86ccf03c

------------------------------------------------------------

CVE ID: CVE-2025-22084
Description: In the Linux kernel, the following vulnerability has been resolved:

w1: fix NULL pointer dereference in probe

The w1_uart_probe() function calls w1_uart_serdev_open() (which includes
devm_serdev_device_open()) before setting the client ops via
serdev_device_set_client_ops(). This ordering can trigger a NULL pointer
dereference in the serdev controller's receive_buf handler, as it assumes
serdev->ops is valid when SERPORT_ACTIVE is set.

This is similar to the issue fixed in commit 5e700b384ec1
("platform/chrome: cros_ec_uart: properly fix race condition") where
devm_serdev_device_open() was called before fully initializing the
device.

Fix the race by ensuring client ops are set before enabling the port via
w1_uart_serdev_open().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0dd6770a72f138dabea9eae87f3da6ffa68f0d06
  - https://git.kernel.org/stable/c/4f750b84628080ff0d67bf1af67a4967b740acf2
  - https://git.kernel.org/stable/c/64ab50577c59bb7049bec6b5c42d1c38e4029f29
  - https://git.kernel.org/stable/c/cc6b0ec7cccbf66ef3621e9e93296b7bd1f52298

------------------------------------------------------------

CVE ID: CVE-2025-22085
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/core: Fix use-after-free when rename device name

Syzbot reported a slab-use-after-free with the following call trace:

==================================================================
BUG: KASAN: slab-use-after-free in nla_put+0xd3/0x150 lib/nlattr.c:1099
Read of size 5 at addr ffff888140ea1c60 by task syz.0.988/10025

CPU: 0 UID: 0 PID: 10025 Comm: syz.0.988
Not tainted 6.14.0-rc4-syzkaller-00859-gf77f12010f67 #0
Hardware name: Google Compute Engine, BIOS Google 02/12/2025
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:408 [inline]
 print_report+0x16e/0x5b0 mm/kasan/report.c:521
 kasan_report+0x143/0x180 mm/kasan/report.c:634
 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189
 __asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105
 nla_put+0xd3/0x150 lib/nlattr.c:1099
 nla_put_string include/net/netlink.h:1621 [inline]
 fill_nldev_handle+0x16e/0x200 drivers/infiniband/core/nldev.c:265
 rdma_nl_notify_event+0x561/0xef0 drivers/infiniband/core/nldev.c:2857
 ib_device_notify_register+0x22/0x230 drivers/infiniband/core/device.c:1344
 ib_register_device+0x1292/0x1460 drivers/infiniband/core/device.c:1460
 rxe_register_device+0x233/0x350 drivers/infiniband/sw/rxe/rxe_verbs.c:1540
 rxe_net_add+0x74/0xf0 drivers/infiniband/sw/rxe/rxe_net.c:550
 rxe_newlink+0xde/0x1a0 drivers/infiniband/sw/rxe/rxe.c:212
 nldev_newlink+0x5ea/0x680 drivers/infiniband/core/nldev.c:1795
 rdma_nl_rcv_skb drivers/infiniband/core/netlink.c:239 [inline]
 rdma_nl_rcv+0x6dd/0x9e0 drivers/infiniband/core/netlink.c:259
 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]
 netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1339
 netlink_sendmsg+0x8de/0xcb0 net/netlink/af_netlink.c:1883
 sock_sendmsg_nosec net/socket.c:709 [inline]
 __sock_sendmsg+0x221/0x270 net/socket.c:724
 ____sys_sendmsg+0x53a/0x860 net/socket.c:2564
 ___sys_sendmsg net/socket.c:2618 [inline]
 __sys_sendmsg+0x269/0x350 net/socket.c:2650
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7f42d1b8d169
Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 ...
RSP: 002b:00007f42d2960038 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
RAX: ffffffffffffffda RBX: 00007f42d1da6320 RCX: 00007f42d1b8d169
RDX: 0000000000000000 RSI: 00004000000002c0 RDI: 000000000000000c
RBP: 00007f42d1c0e2a0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
R13: 0000000000000000 R14: 00007f42d1da6320 R15: 00007ffe399344a8
 </TASK>

Allocated by task 10025:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x3f/0x80 mm/kasan/common.c:68
 poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
 __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __do_kmalloc_node mm/slub.c:4294 [inline]
 __kmalloc_node_track_caller_noprof+0x28b/0x4c0 mm/slub.c:4313
 __kmemdup_nul mm/util.c:61 [inline]
 kstrdup+0x42/0x100 mm/util.c:81
 kobject_set_name_vargs+0x61/0x120 lib/kobject.c:274
 dev_set_name+0xd5/0x120 drivers/base/core.c:3468
 assign_name drivers/infiniband/core/device.c:1202 [inline]
 ib_register_device+0x178/0x1460 drivers/infiniband/core/device.c:1384
 rxe_register_device+0x233/0x350 drivers/infiniband/sw/rxe/rxe_verbs.c:1540
 rxe_net_add+0x74/0xf0 drivers/infiniband/sw/rxe/rxe_net.c:550
 rxe_newlink+0xde/0x1a0 drivers/infiniband/sw/rxe/rxe.c:212
 nldev_newlink+0x5ea/0x680 drivers/infiniband/core/nldev.c:1795
 rdma_nl_rcv_skb drivers/infiniband/core/netlink.c:239 [inline]
 rdma_nl_rcv+0x6dd/0x9e0 drivers/infiniband/core/netlink.c:259
 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]
 netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1339
 netlink_sendmsg+0x8de/0xcb0 net
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0d6460b9d2a3ee380940bdf47680751ef91cb88e
  - https://git.kernel.org/stable/c/1d6a9e7449e2a0c1e2934eee7880ba8bd1e464cd
  - https://git.kernel.org/stable/c/56ec8580be5174b2b9774066e60f1aad56d201db
  - https://git.kernel.org/stable/c/edf6b543e81ba68c6dbac2499ab362098a5a9716

------------------------------------------------------------

CVE ID: CVE-2025-22086
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix mlx5_poll_one() cur_qp update flow

When cur_qp isn't NULL, in order to avoid fetching the QP from
the radix tree again we check if the next cqe QP is identical to
the one we already have.

The bug however is that we are checking if the QP is identical by
checking the QP number inside the CQE against the QP number inside the
mlx5_ib_qp, but that's wrong since the QP number from the CQE is from
FW so it should be matched against mlx5_core_qp which is our FW QP
number.

Otherwise we could use the wrong QP when handling a CQE which could
cause the kernel trace below.

This issue is mainly noticeable over QPs 0 & 1, since for now they are
the only QPs in our driver whereas the QP number inside mlx5_ib_qp
doesn't match the QP number inside mlx5_core_qp.

BUG: kernel NULL pointer dereference, address: 0000000000000012
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 0 P4D 0
 Oops: Oops: 0000 [#1] SMP
 CPU: 0 UID: 0 PID: 7927 Comm: kworker/u62:1 Not tainted 6.14.0-rc3+ #189
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
 Workqueue: ib-comp-unb-wq ib_cq_poll_work [ib_core]
 RIP: 0010:mlx5_ib_poll_cq+0x4c7/0xd90 [mlx5_ib]
 Code: 03 00 00 8d 58 ff 21 cb 66 39 d3 74 39 48 c7 c7 3c 89 6e a0 0f b7 db e8 b7 d2 b3 e0 49 8b 86 60 03 00 00 48 c7 c7 4a 89 6e a0 <0f> b7 5c 98 02 e8 9f d2 b3 e0 41 0f b7 86 78 03 00 00 83 e8 01 21
 RSP: 0018:ffff88810511bd60 EFLAGS: 00010046
 RAX: 0000000000000010 RBX: 0000000000000000 RCX: 0000000000000000
 RDX: 0000000000000000 RSI: ffff88885fa1b3c0 RDI: ffffffffa06e894a
 RBP: 00000000000000b0 R08: 0000000000000000 R09: ffff88810511bc10
 R10: 0000000000000001 R11: 0000000000000001 R12: ffff88810d593000
 R13: ffff88810e579108 R14: ffff888105146000 R15: 00000000000000b0
 FS:  0000000000000000(0000) GS:ffff88885fa00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000000000012 CR3: 00000001077e6001 CR4: 0000000000370eb0
 Call Trace:
  <TASK>
  ? __die+0x20/0x60
  ? page_fault_oops+0x150/0x3e0
  ? exc_page_fault+0x74/0x130
  ? asm_exc_page_fault+0x22/0x30
  ? mlx5_ib_poll_cq+0x4c7/0xd90 [mlx5_ib]
  __ib_process_cq+0x5a/0x150 [ib_core]
  ib_cq_poll_work+0x31/0x90 [ib_core]
  process_one_work+0x169/0x320
  worker_thread+0x288/0x3a0
  ? work_busy+0xb0/0xb0
  kthread+0xd7/0x1f0
  ? kthreads_online_cpu+0x130/0x130
  ? kthreads_online_cpu+0x130/0x130
  ret_from_fork+0x2d/0x50
  ? kthreads_online_cpu+0x130/0x130
  ret_from_fork_asm+0x11/0x20
  </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3b97d77049856865ac5ce8ffbc6e716928310f7f
  - https://git.kernel.org/stable/c/55c65a64aefa6267b964d90e9a4039cb68ec73a5
  - https://git.kernel.org/stable/c/5ed3b0cb3f827072e93b4c5b6e2b8106fd7cccbd
  - https://git.kernel.org/stable/c/7c51a6964b45b6d40027abd77e89cef30d26dc5a
  - https://git.kernel.org/stable/c/856d9e5d72dc44eca6d5a153581c58fbd84e92e1
  - https://git.kernel.org/stable/c/cad677085274ecf9c7565b5bfc5d2e49acbf174c
  - https://git.kernel.org/stable/c/d52636eb13ccba448a752964cc6fc49970912874
  - https://git.kernel.org/stable/c/dc7139b7031d877acd73d7eff55670f22f48cd5e
  - https://git.kernel.org/stable/c/f0447ceb8a31d79bee7144f98f9a13f765531e1a

------------------------------------------------------------

CVE ID: CVE-2025-22087
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix array bounds error with may_goto

may_goto uses an additional 8 bytes on the stack, which causes the
interpreters[] array to go out of bounds when calculating index by
stack_size.

1. If a BPF program is rewritten, re-evaluate the stack size. For non-JIT
cases, reject loading directly.

2. For non-JIT cases, calculating interpreters[idx] may still cause
out-of-bounds array access, and just warn about it.

3. For jit_requested cases, the execution of bpf_func also needs to be
warned. So move the definition of function __bpf_prog_ret0_warn out of
the macro definition CONFIG_BPF_JIT_ALWAYS_ON.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/19e6817f84000d0b06f09fd69ebd56217842c122
  - https://git.kernel.org/stable/c/1a86ae57b2600e5749f5f674e9d4296ac00c69a8
  - https://git.kernel.org/stable/c/4524b7febdd55fb99ae2e1f48db64019fa69e643
  - https://git.kernel.org/stable/c/6ebc5030e0c5a698f1dd9a6684cddf6ccaed64a0

------------------------------------------------------------

CVE ID: CVE-2025-22088
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/erdma: Prevent use-after-free in erdma_accept_newconn()

After the erdma_cep_put(new_cep) being called, new_cep will be freed,
and the following dereference will cause a UAF problem. Fix this issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/667a628ab67d359166799fad89b3c6909599558a
  - https://git.kernel.org/stable/c/78411a133312ce7d8a3239c76a8fd85bca1cc10f
  - https://git.kernel.org/stable/c/7aa6bb5276d9fec98deb05615a086eeb893854ad
  - https://git.kernel.org/stable/c/83437689249e6a17b25e27712fbee292e42e7855
  - https://git.kernel.org/stable/c/a114d25d584c14019d31dbf2163780c47415a187
  - https://git.kernel.org/stable/c/bc1db4d8f1b0dc480d7d745a60a8cc94ce2badd4

------------------------------------------------------------

CVE ID: CVE-2025-22089
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/core: Don't expose hw_counters outside of init net namespace

Commit 467f432a521a ("RDMA/core: Split port and device counter sysfs
attributes") accidentally almost exposed hw counters to non-init net
namespaces. It didn't expose them fully, as an attempt to read any of
those counters leads to a crash like this one:

[42021.807566] BUG: kernel NULL pointer dereference, address: 0000000000000028
[42021.814463] #PF: supervisor read access in kernel mode
[42021.819549] #PF: error_code(0x0000) - not-present page
[42021.824636] PGD 0 P4D 0
[42021.827145] Oops: 0000 [#1] SMP PTI
[42021.830598] CPU: 82 PID: 2843922 Comm: switchto-defaul Kdump: loaded Tainted: G S      W I        XXX
[42021.841697] Hardware name: XXX
[42021.849619] RIP: 0010:hw_stat_device_show+0x1e/0x40 [ib_core]
[42021.855362] Code: 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 49 89 d0 4c 8b 5e 20 48 8b 8f b8 04 00 00 48 81 c7 f0 fa ff ff <48> 8b 41 28 48 29 ce 48 83 c6 d0 48 c1 ee 04 69 d6 ab aa aa aa 48
[42021.873931] RSP: 0018:ffff97fe90f03da0 EFLAGS: 00010287
[42021.879108] RAX: ffff9406988a8c60 RBX: ffff940e1072d438 RCX: 0000000000000000
[42021.886169] RDX: ffff94085f1aa000 RSI: ffff93c6cbbdbcb0 RDI: ffff940c7517aef0
[42021.893230] RBP: ffff97fe90f03e70 R08: ffff94085f1aa000 R09: 0000000000000000
[42021.900294] R10: ffff94085f1aa000 R11: ffffffffc0775680 R12: ffffffff87ca2530
[42021.907355] R13: ffff940651602840 R14: ffff93c6cbbdbcb0 R15: ffff94085f1aa000
[42021.914418] FS:  00007fda1a3b9700(0000) GS:ffff94453fb80000(0000) knlGS:0000000000000000
[42021.922423] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[42021.928130] CR2: 0000000000000028 CR3: 00000042dcfb8003 CR4: 00000000003726f0
[42021.935194] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[42021.942257] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[42021.949324] Call Trace:
[42021.951756]  <TASK>
[42021.953842]  [<ffffffff86c58674>] ? show_regs+0x64/0x70
[42021.959030]  [<ffffffff86c58468>] ? __die+0x78/0xc0
[42021.963874]  [<ffffffff86c9ef75>] ? page_fault_oops+0x2b5/0x3b0
[42021.969749]  [<ffffffff87674b92>] ? exc_page_fault+0x1a2/0x3c0
[42021.975549]  [<ffffffff87801326>] ? asm_exc_page_fault+0x26/0x30
[42021.981517]  [<ffffffffc0775680>] ? __pfx_show_hw_stats+0x10/0x10 [ib_core]
[42021.988482]  [<ffffffffc077564e>] ? hw_stat_device_show+0x1e/0x40 [ib_core]
[42021.995438]  [<ffffffff86ac7f8e>] dev_attr_show+0x1e/0x50
[42022.000803]  [<ffffffff86a3eeb1>] sysfs_kf_seq_show+0x81/0xe0
[42022.006508]  [<ffffffff86a11134>] seq_read_iter+0xf4/0x410
[42022.011954]  [<ffffffff869f4b2e>] vfs_read+0x16e/0x2f0
[42022.017058]  [<ffffffff869f50ee>] ksys_read+0x6e/0xe0
[42022.022073]  [<ffffffff8766f1ca>] do_syscall_64+0x6a/0xa0
[42022.027441]  [<ffffffff8780013b>] entry_SYSCALL_64_after_hwframe+0x78/0xe2

The problem can be reproduced using the following steps:
  ip netns add foo
  ip netns exec foo bash
  cat /sys/class/infiniband/mlx4_0/hw_counters/*

The panic occurs because of casting the device pointer into an
ib_device pointer using container_of() in hw_stat_device_show() is
wrong and leads to a memory corruption.

However the real problem is that hw counters should never been exposed
outside of the non-init net namespace.

Fix this by saving the index of the corresponding attribute group
(it might be 1 or 2 depending on the presence of driver-specific
attributes) and zeroing the pointer to hw_counters group for compat
devices during the initialization.

With this fix applied hw_counters are not available in a non-init
net namespace:
  find /sys/class/infiniband/mlx4_0/ -name hw_counters
    /sys/class/infiniband/mlx4_0/ports/1/hw_counters
    /sys/class/infiniband/mlx4_0/ports/2/hw_counters
    /sys/class/infiniband/mlx4_0/hw_counters

  ip netns add foo
  ip netns exec foo bash
  find /sys/class/infiniband/mlx4_0/ -name hw_counters
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0cf80f924aecb5b2bebd4f4ad11b2efc676a0b78
  - https://git.kernel.org/stable/c/6682da5d8fd578a5068531d01633c9d2e4c8f12b
  - https://git.kernel.org/stable/c/9a5b7f8842a90a5e6eeff37f9f6d814e61ea3529
  - https://git.kernel.org/stable/c/a1ecb30f90856b0be4168ad51b8875148e285c1f
  - https://git.kernel.org/stable/c/c14d9704f5d77a7c7fa46e2114b64a4f75b64e17
  - https://git.kernel.org/stable/c/d5212b99649c5740154f307e9e3d7fee9bf62773
  - https://git.kernel.org/stable/c/df45ae2a4f1cdfda00c032839e12092e1f32c05e

------------------------------------------------------------

CVE ID: CVE-2025-22090
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/mm/pat: Fix VM_PAT handling when fork() fails in copy_page_range()

If track_pfn_copy() fails, we already added the dst VMA to the maple
tree. As fork() fails, we'll cleanup the maple tree, and stumble over
the dst VMA for which we neither performed any reservation nor copied
any page tables.

Consequently untrack_pfn() will see VM_PAT and try obtaining the
PAT information from the page table -- which fails because the page
table was not copied.

The easiest fix would be to simply clear the VM_PAT flag of the dst VMA
if track_pfn_copy() fails. However, the whole thing is about "simply"
clearing the VM_PAT flag is shaky as well: if we passed track_pfn_copy()
and performed a reservation, but copying the page tables fails, we'll
simply clear the VM_PAT flag, not properly undoing the reservation ...
which is also wrong.

So let's fix it properly: set the VM_PAT flag only if the reservation
succeeded (leaving it clear initially), and undo the reservation if
anything goes wrong while copying the page tables: clearing the VM_PAT
flag after undoing the reservation.

Note that any copied page table entries will get zapped when the VMA will
get removed later, after copy_page_range() succeeded; as VM_PAT is not set
then, we won't try cleaning VM_PAT up once more and untrack_pfn() will be
happy. Note that leaving these page tables in place without a reservation
is not a problem, as we are aborting fork(); this process will never run.

A reproducer can trigger this usually at the first try:

  https://gitlab.com/davidhildenbrand/scratchspace/-/raw/main/reproducers/pat_fork.c

  WARNING: CPU: 26 PID: 11650 at arch/x86/mm/pat/memtype.c:983 get_pat_info+0xf6/0x110
  Modules linked in: ...
  CPU: 26 UID: 0 PID: 11650 Comm: repro3 Not tainted 6.12.0-rc5+ #92
  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014
  RIP: 0010:get_pat_info+0xf6/0x110
  ...
  Call Trace:
   <TASK>
   ...
   untrack_pfn+0x52/0x110
   unmap_single_vma+0xa6/0xe0
   unmap_vmas+0x105/0x1f0
   exit_mmap+0xf6/0x460
   __mmput+0x4b/0x120
   copy_process+0x1bf6/0x2aa0
   kernel_clone+0xab/0x440
   __do_sys_clone+0x66/0x90
   do_syscall_64+0x95/0x180

Likely this case was missed in:

  d155df53f310 ("x86/mm/pat: clear VM_PAT if copy_p4d_range failed")

... and instead of undoing the reservation we simply cleared the VM_PAT flag.

Keep the documentation of these functions in include/linux/pgtable.h,
one place is more than sufficient -- we should clean that up for the other
functions like track_pfn_remap/untrack_pfn separately.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8d6373f83f367dbed316ddeb178130a3a64b5b67
  - https://git.kernel.org/stable/c/b07398e8a5da517083f5c3f2daa8f6681b48ab28
  - https://git.kernel.org/stable/c/da381c33f3aa6406406c9fdf07b8b0b63e0ce722
  - https://git.kernel.org/stable/c/dc84bc2aba85a1508f04a936f9f9a15f64ebfb31
  - https://git.kernel.org/stable/c/de6185b8892d88142ef69768fe4077cbf40109c0

------------------------------------------------------------

CVE ID: CVE-2025-22091
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/mlx5: Fix page_size variable overflow

Change all variables storing mlx5_umem_mkc_find_best_pgsz() result to
unsigned long to support values larger than 31 and avoid overflow.

For example: If we try to register 4GB of memory that is contiguous in
physical memory, the driver will optimize the page_size and try to use
an mkey with 4GB entity size. The 'unsigned int' page_size variable will
overflow to '0' and we'll hit the WARN_ON() in alloc_cacheable_mr().

WARNING: CPU: 2 PID: 1203 at drivers/infiniband/hw/mlx5/mr.c:1124 alloc_cacheable_mr+0x22/0x580 [mlx5_ib]
Modules linked in: mlx5_ib mlx5_core bonding ip6_gre ip6_tunnel tunnel6 ip_gre gre rdma_rxe rdma_ucm ib_uverbs ib_ipoib ib_umad rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm fuse ib_core [last unloaded: mlx5_core]
CPU: 2 UID: 70878 PID: 1203 Comm: rdma_resource_l Tainted: G        W          6.14.0-rc4-dirty #43
Tainted: [W]=WARN
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
RIP: 0010:alloc_cacheable_mr+0x22/0x580 [mlx5_ib]
Code: 90 90 90 90 90 90 90 90 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 41 55 41 54 41 52 53 48 83 ec 30 f6 46 28 04 4c 8b 77 08 75 21 <0f> 0b 49 c7 c2 ea ff ff ff 48 8d 65 d0 4c 89 d0 5b 41 5a 41 5c 41
RSP: 0018:ffffc900006ffac8 EFLAGS: 00010246
RAX: 0000000004c0d0d0 RBX: ffff888217a22000 RCX: 0000000000100001
RDX: 00007fb7ac480000 RSI: ffff8882037b1240 RDI: ffff8882046f0600
RBP: ffffc900006ffb28 R08: 0000000000000001 R09: 0000000000000000
R10: 00000000000007e0 R11: ffffea0008011d40 R12: ffff8882037b1240
R13: ffff8882046f0600 R14: ffff888217a22000 R15: ffffc900006ffe00
FS:  00007fb7ed013340(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fb7ed1d8000 CR3: 00000001fd8f6006 CR4: 0000000000772eb0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 <TASK>
 ? __warn+0x81/0x130
 ? alloc_cacheable_mr+0x22/0x580 [mlx5_ib]
 ? report_bug+0xfc/0x1e0
 ? handle_bug+0x55/0x90
 ? exc_invalid_op+0x17/0x70
 ? asm_exc_invalid_op+0x1a/0x20
 ? alloc_cacheable_mr+0x22/0x580 [mlx5_ib]
 create_real_mr+0x54/0x150 [mlx5_ib]
 ib_uverbs_reg_mr+0x17f/0x2a0 [ib_uverbs]
 ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0xca/0x140 [ib_uverbs]
 ib_uverbs_run_method+0x6d0/0x780 [ib_uverbs]
 ? __pfx_ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x10/0x10 [ib_uverbs]
 ib_uverbs_cmd_verbs+0x19b/0x360 [ib_uverbs]
 ? walk_system_ram_range+0x79/0xd0
 ? ___pte_offset_map+0x1b/0x110
 ? __pte_offset_map_lock+0x80/0x100
 ib_uverbs_ioctl+0xac/0x110 [ib_uverbs]
 __x64_sys_ioctl+0x94/0xb0
 do_syscall_64+0x50/0x110
 entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7fb7ecf0737b
Code: ff ff ff 85 c0 79 9b 49 c7 c4 ff ff ff ff 5b 5d 4c 89 e0 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 7d 2a 0f 00 f7 d8 64 89 01 48
RSP: 002b:00007ffdbe03ecc8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007ffdbe03edb8 RCX: 00007fb7ecf0737b
RDX: 00007ffdbe03eda0 RSI: 00000000c0181b01 RDI: 0000000000000003
RBP: 00007ffdbe03ed80 R08: 00007fb7ecc84010 R09: 00007ffdbe03eed4
R10: 0000000000000009 R11: 0000000000000246 R12: 00007ffdbe03eed4
R13: 000000000000000c R14: 000000000000000c R15: 00007fb7ecc84150
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01fd737776ca0f17a96d83cd7f0840ce130b9a02
  - https://git.kernel.org/stable/c/05b215d5e219c0228b9c7082ba9bcf176c576646
  - https://git.kernel.org/stable/c/e0c09f639ca0e102f250df8787740c2013e9d1b3
  - https://git.kernel.org/stable/c/f0c2427412b43cdf1b7b0944749ea17ddb97d5a5

------------------------------------------------------------

CVE ID: CVE-2025-22092
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: Fix NULL dereference in SR-IOV VF creation error path

Clean up when virtfn setup fails to prevent NULL pointer dereference
during device removal. The kernel oops below occurred due to incorrect
error handling flow when pci_setup_device() fails.

Add pci_iov_scan_device(), which handles virtfn allocation and setup and
cleans up if pci_setup_device() fails, so pci_iov_add_virtfn() doesn't need
to call pci_stop_and_remove_bus_device().  This prevents accessing
partially initialized virtfn devices during removal.

  BUG: kernel NULL pointer dereference, address: 00000000000000d0
  RIP: 0010:device_del+0x3d/0x3d0
  Call Trace:
   pci_remove_bus_device+0x7c/0x100
   pci_iov_add_virtfn+0xfa/0x200
   sriov_enable+0x208/0x420
   mlx5_core_sriov_configure+0x6a/0x160 [mlx5_core]
   sriov_numvfs_store+0xae/0x1a0

[bhelgaas: commit log, return ERR_PTR(-ENOMEM) directly]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/04d50d953ab46d96b0b32d5ad955fceaa28622db
  - https://git.kernel.org/stable/c/c67a233834b778b8c78f8b62c072ccf87a9eb6d0
  - https://git.kernel.org/stable/c/ef421b4d206f0d3681804b8f94f06a8458a53aaf

------------------------------------------------------------

CVE ID: CVE-2025-22093
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: avoid NPD when ASIC does not support DMUB

ctx->dmub_srv will de NULL if the ASIC does not support DMUB, which is
tested in dm_dmub_sw_init.

However, it will be dereferenced in dmub_hw_lock_mgr_cmd if
should_use_dmub_lock returns true.

This has been the case since dmub support has been added for PSR1.

Fix this by checking for dmub_srv in should_use_dmub_lock.

[   37.440832] BUG: kernel NULL pointer dereference, address: 0000000000000058
[   37.447808] #PF: supervisor read access in kernel mode
[   37.452959] #PF: error_code(0x0000) - not-present page
[   37.458112] PGD 0 P4D 0
[   37.460662] Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
[   37.465553] CPU: 2 UID: 1000 PID: 1745 Comm: DrmThread Not tainted 6.14.0-rc1-00003-gd62e938120f0 #23 99720e1cb1e0fc4773b8513150932a07de3c6e88
[   37.478324] Hardware name: Google Morphius/Morphius, BIOS Google_Morphius.13434.858.0 10/26/2023
[   37.487103] RIP: 0010:dmub_hw_lock_mgr_cmd+0x77/0xb0
[   37.492074] Code: 44 24 0e 00 00 00 00 48 c7 04 24 45 00 00 0c 40 88 74 24 0d 0f b6 02 88 44 24 0c 8b 01 89 44 24 08 85 f6 75 05 c6 44 24 0e 01 <48> 8b 7f 58 48 89 e6 ba 01 00 00 00 e8 08 3c 2a 00 65 48 8b 04 5
[   37.510822] RSP: 0018:ffff969442853300 EFLAGS: 00010202
[   37.516052] RAX: 0000000000000000 RBX: ffff92db03000000 RCX: ffff969442853358
[   37.523185] RDX: ffff969442853368 RSI: 0000000000000001 RDI: 0000000000000000
[   37.530322] RBP: 0000000000000001 R08: 00000000000004a7 R09: 00000000000004a5
[   37.537453] R10: 0000000000000476 R11: 0000000000000062 R12: ffff92db0ade8000
[   37.544589] R13: ffff92da01180ae0 R14: ffff92da011802a8 R15: ffff92db03000000
[   37.551725] FS:  0000784a9cdfc6c0(0000) GS:ffff92db2af00000(0000) knlGS:0000000000000000
[   37.559814] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   37.565562] CR2: 0000000000000058 CR3: 0000000112b1c000 CR4: 00000000003506f0
[   37.572697] Call Trace:
[   37.575152]  <TASK>
[   37.577258]  ? __die_body+0x66/0xb0
[   37.580756]  ? page_fault_oops+0x3e7/0x4a0
[   37.584861]  ? exc_page_fault+0x3e/0xe0
[   37.588706]  ? exc_page_fault+0x5c/0xe0
[   37.592550]  ? asm_exc_page_fault+0x22/0x30
[   37.596742]  ? dmub_hw_lock_mgr_cmd+0x77/0xb0
[   37.601107]  dcn10_cursor_lock+0x1e1/0x240
[   37.605211]  program_cursor_attributes+0x81/0x190
[   37.609923]  commit_planes_for_stream+0x998/0x1ef0
[   37.614722]  update_planes_and_stream_v2+0x41e/0x5c0
[   37.619703]  dc_update_planes_and_stream+0x78/0x140
[   37.624588]  amdgpu_dm_atomic_commit_tail+0x4362/0x49f0
[   37.629832]  ? srso_return_thunk+0x5/0x5f
[   37.633847]  ? mark_held_locks+0x6d/0xd0
[   37.637774]  ? _raw_spin_unlock_irq+0x24/0x50
[   37.642135]  ? srso_return_thunk+0x5/0x5f
[   37.646148]  ? lockdep_hardirqs_on+0x95/0x150
[   37.650510]  ? srso_return_thunk+0x5/0x5f
[   37.654522]  ? _raw_spin_unlock_irq+0x2f/0x50
[   37.658883]  ? srso_return_thunk+0x5/0x5f
[   37.662897]  ? wait_for_common+0x186/0x1c0
[   37.666998]  ? srso_return_thunk+0x5/0x5f
[   37.671009]  ? drm_crtc_next_vblank_start+0xc3/0x170
[   37.675983]  commit_tail+0xf5/0x1c0
[   37.679478]  drm_atomic_helper_commit+0x2a2/0x2b0
[   37.684186]  drm_atomic_commit+0xd6/0x100
[   37.688199]  ? __cfi___drm_printfn_info+0x10/0x10
[   37.692911]  drm_atomic_helper_update_plane+0xe5/0x130
[   37.698054]  drm_mode_cursor_common+0x501/0x670
[   37.702600]  ? __cfi_drm_mode_cursor_ioctl+0x10/0x10
[   37.707572]  drm_mode_cursor_ioctl+0x48/0x70
[   37.711851]  drm_ioctl_kernel+0xf2/0x150
[   37.715781]  drm_ioctl+0x363/0x590
[   37.719189]  ? __cfi_drm_mode_cursor_ioctl+0x10/0x10
[   37.724165]  amdgpu_drm_ioctl+0x41/0x80
[   37.728013]  __se_sys_ioctl+0x7f/0xd0
[   37.731685]  do_syscall_64+0x87/0x100
[   37.735355]  ? vma_end_read+0x12/0xe0
[   37.739024]  ? srso_return_thunk+0x5/0x5f
[   37.743041]  ? find_held_lock+0x47/0xf0
[   37.746884]  ? vma_end_read+0x12/0xe0
[   37.750552]  ? srso_return_thunk+0x5/0
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3453bcaf2ca92659346bf8504c2b52b3993fbd79
  - https://git.kernel.org/stable/c/35ad39afd007eddf34b3307bebb715c26891cc96
  - https://git.kernel.org/stable/c/42d9d7bed270247f134190ba0cb05bbd072f58c2
  - https://git.kernel.org/stable/c/5e4b1e04740cdb28de189285007366d99a92f1ce
  - https://git.kernel.org/stable/c/b3a93a2407ad23c8d5bacabaf7cecbb4c6cdd461
  - https://git.kernel.org/stable/c/d953e2cd59ab466569c6f9da460e01caf1c83559

------------------------------------------------------------

CVE ID: CVE-2025-22094
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/perf: Fix ref-counting on the PMU 'vpa_pmu'

Commit 176cda0619b6 ("powerpc/perf: Add perf interface to expose vpa
counters") introduced 'vpa_pmu' to expose Book3s-HV nested APIv2 provided
L1<->L2 context switch latency counters to L1 user-space via
perf-events. However the newly introduced PMU named 'vpa_pmu' doesn't
assign ownership of the PMU to the module 'vpa_pmu'. Consequently the
module 'vpa_pmu' can be unloaded while one of the perf-events are still
active, which can lead to kernel oops and panic of the form below on a
Pseries-LPAR:

BUG: Kernel NULL pointer dereference on read at 0x00000058
<snip>
 NIP [c000000000506cb8] event_sched_out+0x40/0x258
 LR [c00000000050e8a4] __perf_remove_from_context+0x7c/0x2b0
 Call Trace:
 [c00000025fc3fc30] [c00000025f8457a8] 0xc00000025f8457a8 (unreliable)
 [c00000025fc3fc80] [fffffffffffffee0] 0xfffffffffffffee0
 [c00000025fc3fcd0] [c000000000501e70] event_function+0xa8/0x120
<snip>
 Kernel panic - not syncing: Aiee, killing interrupt handler!

Fix this by adding the module ownership to 'vpa_pmu' so that the module
'vpa_pmu' is ref-counted and prevented from being unloaded when perf-events
are initialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6cf045b51e2c5721db7e55305f09ee32741e00f9
  - https://git.kernel.org/stable/c/70ea7c5189197c6f5acdcfd8a2651be2c41e2faa
  - https://git.kernel.org/stable/c/ff99d5b6a246715f2257123cdf6c4a29cb33aa78

------------------------------------------------------------

CVE ID: CVE-2025-22095
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: brcmstb: Fix error path after a call to regulator_bulk_get()

If the regulator_bulk_get() returns an error and no regulators
are created, we need to set their number to zero.

If we don't do this and the PCIe link up fails, a call to the
regulator_bulk_free() will result in a kernel panic.

While at it, print the error value, as we cannot return an error
upwards as the kernel will WARN() on an error from add_bus().

[kwilczynski: commit log, use comma in the message to match style with
other similar messages]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3651ad5249c51cf7eee078e12612557040a6bdb4
  - https://git.kernel.org/stable/c/6f44e1fdb006db61394aa4d4c25728ada00842e7
  - https://git.kernel.org/stable/c/7842e842a9bf6bd5866c84f588353711d131ab1a
  - https://git.kernel.org/stable/c/99a0efba9f903acbdece548862b6b4cbe7d999e1
  - https://git.kernel.org/stable/c/df63321a40cc98e52313cffbff376b8ae9ceffa7
  - https://git.kernel.org/stable/c/eedd054834930b8d678f0776cd4b091b8fffbb4a

------------------------------------------------------------

CVE ID: CVE-2025-22096
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/gem: Fix error code msm_parse_deps()

The SUBMIT_ERROR() macro turns the error code negative.  This extra '-'
operation turns it back to positive EINVAL again.  The error code is
passed to ERR_PTR() and since positive values are not an IS_ERR() it
eventually will lead to an oops.  Delete the '-'.

Patchwork: https://patchwork.freedesktop.org/patch/637625/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b305b7cadce835505bd93183a599acb1f800a05
  - https://git.kernel.org/stable/c/efe759dcf3352d8379a1adad7b4d14044a4c41a7

------------------------------------------------------------

CVE ID: CVE-2025-22097
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/vkms: Fix use after free and double free on init error

If the driver initialization fails, the vkms_exit() function might
access an uninitialized or freed default_config pointer and it might
double free it.

Fix both possible errors by initializing default_config only when the
driver initialization succeeded.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/1f68f1cf09d06061eb549726ff8339e064eddebd
  - https://git.kernel.org/stable/c/49a69f67f53518bdd9b7eeebf019a2da6cc0e954
  - https://git.kernel.org/stable/c/561fc0c5cf41f646f3e9e61784cbc0fc832fb936
  - https://git.kernel.org/stable/c/79d138d137b80eeb0a83244d1cff29e64cf91067
  - https://git.kernel.org/stable/c/b8a18bb53e06d6d3c1fd03d12533d6e333ba8853
  - https://git.kernel.org/stable/c/d5eb8e347905ab17788a7903fa1d3d06747355f5
  - https://git.kernel.org/stable/c/ed15511a773df86205bda66c37193569575ae828

------------------------------------------------------------

CVE ID: CVE-2025-22098
Description: In the Linux kernel, the following vulnerability has been resolved:

drm: zynqmp_dp: Fix a deadlock in zynqmp_dp_ignore_hpd_set()

Instead of attempting the same mutex twice, lock and unlock it.

This bug has been detected by the Clang thread-safety analyzer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3f988cd2f65175e79349961a43a9deb115174784
  - https://git.kernel.org/stable/c/7a8d53aa5b7d2a89cda598239d08423bd66920f1
  - https://git.kernel.org/stable/c/f887685ee0eb4ef716391355568181230338f6eb

------------------------------------------------------------

CVE ID: CVE-2025-22099
Description: In the Linux kernel, the following vulnerability has been resolved:

drm: xlnx: zynqmp_dpsub: Add NULL check in zynqmp_audio_init

devm_kasprintf() calls can return null pointers on failure.
But some return values were not checked in zynqmp_audio_init().

Add NULL check in zynqmp_audio_init(), avoid referencing null
pointers in the subsequent code.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/066d6f22e7d84953db6bbf2dae507401157660c6
  - https://git.kernel.org/stable/c/d0660f9c588a1246a1a543c91a1e3cad910237da

------------------------------------------------------------

CVE ID: CVE-2025-22100
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/panthor: Fix race condition when gathering fdinfo group samples

Commit e16635d88fa0 ("drm/panthor: add DRM fdinfo support") failed to
protect access to groups with an xarray lock, which could lead to
use-after-free errors.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0590c94c3596d6c1a3d549ae611366f2ad4e1d8d
  - https://git.kernel.org/stable/c/6d98c83ad67e7bd86a47494fd6c3863e7bb26db9
  - https://git.kernel.org/stable/c/e9d45f42a64a400adba59ee83d03e6db662530b4

------------------------------------------------------------

CVE ID: CVE-2025-22101
Description: In the Linux kernel, the following vulnerability has been resolved:

net: libwx: fix Tx L4 checksum

The hardware only supports L4 checksum offload for TCP/UDP/SCTP protocol.
There was a bug to set Tx checksum flag for the other protocol that results
in Tx ring hang. Fix to compute software checksum for these packets.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5f583e059eced1857f41e221ef5951e029e632bd
  - https://git.kernel.org/stable/c/c7d82913d5f9e97860772ee4051eaa66b56a6273

------------------------------------------------------------

CVE ID: CVE-2025-22102
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btnxpuart: Fix kernel panic during FW release

This fixes a kernel panic seen during release FW in a stress test
scenario where WLAN and BT FW download occurs simultaneously, and due to
a HW bug, chip sends out only 1 bootloader signatures.

When driver receives the bootloader signature, it enters FW download
mode, but since no consequtive bootloader signatures seen, FW file is
not requested.

After 60 seconds, when FW download times out, release_firmware causes a
kernel panic.

[ 2601.949184] Unable to handle kernel paging request at virtual address 0000312e6f006573
[ 2601.992076] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000111802000
[ 2601.992080] [0000312e6f006573] pgd=0000000000000000, p4d=0000000000000000
[ 2601.992087] Internal error: Oops: 0000000096000021 [#1] PREEMPT SMP
[ 2601.992091] Modules linked in: algif_hash algif_skcipher af_alg btnxpuart(O) pciexxx(O) mlan(O) overlay fsl_jr_uio caam_jr caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine authenc libdes crct10dif_ce polyval_ce snd_soc_fsl_easrc snd_soc_fsl_asoc_card imx8_media_dev(C) snd_soc_fsl_micfil polyval_generic snd_soc_fsl_xcvr snd_soc_fsl_sai snd_soc_imx_audmux snd_soc_fsl_asrc snd_soc_imx_card snd_soc_imx_hdmi snd_soc_fsl_aud2htx snd_soc_fsl_utils imx_pcm_dma dw_hdmi_cec flexcan can_dev
[ 2602.001825] CPU: 2 PID: 20060 Comm: hciconfig Tainted: G         C O       6.6.23-lts-next-06236-gb586a521770e #1
[ 2602.010182] Hardware name: NXP i.MX8MPlus EVK board (DT)
[ 2602.010185] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[ 2602.010191] pc : _raw_spin_lock+0x34/0x68
[ 2602.010201] lr : free_fw_priv+0x20/0xfc
[ 2602.020561] sp : ffff800089363b30
[ 2602.020563] x29: ffff800089363b30 x28: ffff0000d0eb5880 x27: 0000000000000000
[ 2602.020570] x26: 0000000000000000 x25: ffff0000d728b330 x24: 0000000000000000
[ 2602.020577] x23: ffff0000dc856f38
[ 2602.033797] x22: ffff800089363b70 x21: ffff0000dc856000
[ 2602.033802] x20: ff00312e6f006573 x19: ffff0000d0d9ea80 x18: 0000000000000000
[ 2602.033809] x17: 0000000000000000 x16: 0000000000000000 x15: 0000aaaad80dd480
[ 2602.083320] x14: 0000000000000000 x13: 00000000000001b9 x12: 0000000000000002
[ 2602.083326] x11: 0000000000000000 x10: 0000000000000a60 x9 : ffff800089363a30
[ 2602.083333] x8 : ffff0001793d75c0 x7 : ffff0000d6dbc400 x6 : 0000000000000000
[ 2602.083339] x5 : 00000000410fd030 x4 : 0000000000000000 x3 : 0000000000000001
[ 2602.083346] x2 : 0000000000000000 x1 : 0000000000000001 x0 : ff00312e6f006573
[ 2602.083354] Call trace:
[ 2602.083356]  _raw_spin_lock+0x34/0x68
[ 2602.083364]  release_firmware+0x48/0x6c
[ 2602.083370]  nxp_setup+0x3c4/0x540 [btnxpuart]
[ 2602.083383]  hci_dev_open_sync+0xf0/0xa34
[ 2602.083391]  hci_dev_open+0xd8/0x178
[ 2602.083399]  hci_sock_ioctl+0x3b0/0x590
[ 2602.083405]  sock_do_ioctl+0x60/0x118
[ 2602.083413]  sock_ioctl+0x2f4/0x374
[ 2602.091430]  __arm64_sys_ioctl+0xac/0xf0
[ 2602.091437]  invoke_syscall+0x48/0x110
[ 2602.091445]  el0_svc_common.constprop.0+0xc0/0xe0
[ 2602.091452]  do_el0_svc+0x1c/0x28
[ 2602.091457]  el0_svc+0x40/0xe4
[ 2602.091465]  el0t_64_sync_handler+0x120/0x12c
[ 2602.091470]  el0t_64_sync+0x190/0x194
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1f77c05408c96bc0b58ae476a9cadc9e5b9cfd0f
  - https://git.kernel.org/stable/c/6749cf49eff7ce6dadcb603c5c8db70b28079a5d

------------------------------------------------------------

CVE ID: CVE-2025-22103
Description: In the Linux kernel, the following vulnerability has been resolved:

net: fix NULL pointer dereference in l3mdev_l3_rcv

When delete l3s ipvlan:

    ip link del link eth0 ipvlan1 type ipvlan mode l3s

This may cause a null pointer dereference:

    Call trace:
     ip_rcv_finish+0x48/0xd0
     ip_rcv+0x5c/0x100
     __netif_receive_skb_one_core+0x64/0xb0
     __netif_receive_skb+0x20/0x80
     process_backlog+0xb4/0x204
     napi_poll+0xe8/0x294
     net_rx_action+0xd8/0x22c
     __do_softirq+0x12c/0x354

This is because l3mdev_l3_rcv() visit dev->l3mdev_ops after
ipvlan_l3s_unregister() assign the dev->l3mdev_ops to NULL. The process
like this:

    (CPU1)                     | (CPU2)
    l3mdev_l3_rcv()            |
      check dev->priv_flags:   |
        master = skb->dev;     |
                               |
                               | ipvlan_l3s_unregister()
                               |   set dev->priv_flags
                               |   dev->l3mdev_ops = NULL;
                               |
      visit master->l3mdev_ops |

To avoid this by do not set dev->l3mdev_ops when unregister l3s ipvlan.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0032c99e83b9ce6d5995d65900aa4b6ffb501cce
  - https://git.kernel.org/stable/c/f9dff65140efc289f01bcf39c3ca66a8806b6132

------------------------------------------------------------

CVE ID: CVE-2025-22104
Description: In the Linux kernel, the following vulnerability has been resolved:

ibmvnic: Use kernel helpers for hex dumps

Previously, when the driver was printing hex dumps, the buffer was cast
to an 8 byte long and printed using string formatters. If the buffer
size was not a multiple of 8 then a read buffer overflow was possible.

Therefore, create a new ibmvnic function that loops over a buffer and
calls hex_dump_to_buffer instead.

This patch address KASAN reports like the one below:
  ibmvnic 30000003 env3: Login Buffer:
  ibmvnic 30000003 env3: 01000000af000000
  <...>
  ibmvnic 30000003 env3: 2e6d62692e736261
  ibmvnic 30000003 env3: 65050003006d6f63
  ==================================================================
  BUG: KASAN: slab-out-of-bounds in ibmvnic_login+0xacc/0xffc [ibmvnic]
  Read of size 8 at addr c0000001331a9aa8 by task ip/17681
  <...>
  Allocated by task 17681:
  <...>
  ibmvnic_login+0x2f0/0xffc [ibmvnic]
  ibmvnic_open+0x148/0x308 [ibmvnic]
  __dev_open+0x1ac/0x304
  <...>
  The buggy address is located 168 bytes inside of
                allocated 175-byte region [c0000001331a9a00, c0000001331a9aaf)
  <...>
  =================================================================
  ibmvnic 30000003 env3: 000000000033766e
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/ae6b1d6c1acee3a2000394d83ec9f1028321e207
  - https://git.kernel.org/stable/c/d93a6caab5d7d9b5ce034d75b1e1e993338e3852

------------------------------------------------------------

CVE ID: CVE-2025-22105
Description: In the Linux kernel, the following vulnerability has been resolved:

bonding: check xdp prog when set bond mode

Following operations can trigger a warning[1]:

    ip netns add ns1
    ip netns exec ns1 ip link add bond0 type bond mode balance-rr
    ip netns exec ns1 ip link set dev bond0 xdp obj af_xdp_kern.o sec xdp
    ip netns exec ns1 ip link set bond0 type bond mode broadcast
    ip netns del ns1

When delete the namespace, dev_xdp_uninstall() is called to remove xdp
program on bond dev, and bond_xdp_set() will check the bond mode. If bond
mode is changed after attaching xdp program, the warning may occur.

Some bond modes (broadcast, etc.) do not support native xdp. Set bond mode
with xdp program attached is not good. Add check for xdp program when set
bond mode.

    [1]
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 11 at net/core/dev.c:9912 unregister_netdevice_many_notify+0x8d9/0x930
    Modules linked in:
    CPU: 0 UID: 0 PID: 11 Comm: kworker/u4:0 Not tainted 6.14.0-rc4 #107
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.15.0-0-g2dd4b9b3f840-prebuilt.qemu.org 04/01/2014
    Workqueue: netns cleanup_net
    RIP: 0010:unregister_netdevice_many_notify+0x8d9/0x930
    Code: 00 00 48 c7 c6 6f e3 a2 82 48 c7 c7 d0 b3 96 82 e8 9c 10 3e ...
    RSP: 0018:ffffc90000063d80 EFLAGS: 00000282
    RAX: 00000000ffffffa1 RBX: ffff888004959000 RCX: 00000000ffffdfff
    RDX: 0000000000000000 RSI: 00000000ffffffea RDI: ffffc90000063b48
    RBP: ffffc90000063e28 R08: ffffffff82d39b28 R09: 0000000000009ffb
    R10: 0000000000000175 R11: ffffffff82d09b40 R12: ffff8880049598e8
    R13: 0000000000000001 R14: dead000000000100 R15: ffffc90000045000
    FS:  0000000000000000(0000) GS:ffff888007a00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 000000000d406b60 CR3: 000000000483e000 CR4: 00000000000006f0
    Call Trace:
     <TASK>
     ? __warn+0x83/0x130
     ? unregister_netdevice_many_notify+0x8d9/0x930
     ? report_bug+0x18e/0x1a0
     ? handle_bug+0x54/0x90
     ? exc_invalid_op+0x18/0x70
     ? asm_exc_invalid_op+0x1a/0x20
     ? unregister_netdevice_many_notify+0x8d9/0x930
     ? bond_net_exit_batch_rtnl+0x5c/0x90
     cleanup_net+0x237/0x3d0
     process_one_work+0x163/0x390
     worker_thread+0x293/0x3b0
     ? __pfx_worker_thread+0x10/0x10
     kthread+0xec/0x1e0
     ? __pfx_kthread+0x10/0x10
     ? __pfx_kthread+0x10/0x10
     ret_from_fork+0x2f/0x50
     ? __pfx_kthread+0x10/0x10
     ret_from_fork_asm+0x1a/0x30
     </TASK>
    ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/094ee6017ea09c11d6af187935a949df32803ce0
  - https://git.kernel.org/stable/c/0dd4fac43bdea23cfe4bb2a3eabb76d752ac32fb

------------------------------------------------------------

CVE ID: CVE-2025-22106
Description: In the Linux kernel, the following vulnerability has been resolved:

vmxnet3: unregister xdp rxq info in the reset path

vmxnet3 does not unregister xdp rxq info in the
vmxnet3_reset_work() code path as vmxnet3_rq_destroy()
is not invoked in this code path. So, we get below message with a
backtrace.

Missing unregister, handled but fix driver
WARNING: CPU:48 PID: 500 at net/core/xdp.c:182
__xdp_rxq_info_reg+0x93/0xf0

This patch fixes the problem by moving the unregister
code of XDP from vmxnet3_rq_destroy() to vmxnet3_rq_cleanup().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0dd765fae295832934bf28e45dd5a355e0891ed4
  - https://git.kernel.org/stable/c/9908541a9e235b7c5e2fbdd59910eaf9c32c3075

------------------------------------------------------------

CVE ID: CVE-2025-22107
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: sja1105: fix kasan out-of-bounds warning in sja1105_table_delete_entry()

There are actually 2 problems:
- deleting the last element doesn't require the memmove of elements
  [i + 1, end) over it. Actually, element i+1 is out of bounds.
- The memmove itself should move size - i - 1 elements, because the last
  element is out of bounds.

The out-of-bounds element still remains out of bounds after being
accessed, so the problem is only that we touch it, not that it becomes
in active use. But I suppose it can lead to issues if the out-of-bounds
element is part of an unmapped page.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/59b97641de03c081f26b3a8876628c765b5faa25
  - https://git.kernel.org/stable/c/5f2b28b79d2d1946ee36ad8b3dc0066f73c90481

------------------------------------------------------------

CVE ID: CVE-2025-22108
Description: In the Linux kernel, the following vulnerability has been resolved:

bnxt_en: Mask the bd_cnt field in the TX BD properly

The bd_cnt field in the TX BD specifies the total number of BDs for
the TX packet.  The bd_cnt field has 5 bits and the maximum number
supported is 32 with the value 0.

CONFIG_MAX_SKB_FRAGS can be modified and the total number of SKB
fragments can approach or exceed the maximum supported by the chip.
Add a macro to properly mask the bd_cnt field so that the value 32
will be properly masked and set to 0 in the bd_cnd field.

Without this patch, the out-of-range bd_cnt value will corrupt the
TX BD and may cause TX timeout.

The next patch will check for values exceeding 32.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/107b25db61122d8f990987895c2912927b8b6e3f
  - https://git.kernel.org/stable/c/f60b41b815826f15c4d0323f923f398c423178d0

------------------------------------------------------------

CVE ID: CVE-2025-22109
Description: In the Linux kernel, the following vulnerability has been resolved:

ax25: Remove broken autobind

Binding AX25 socket by using the autobind feature leads to memory leaks
in ax25_connect() and also refcount leaks in ax25_release(). Memory
leak was detected with kmemleak:

================================================================
unreferenced object 0xffff8880253cd680 (size 96):
backtrace:
__kmalloc_node_track_caller_noprof (./include/linux/kmemleak.h:43)
kmemdup_noprof (mm/util.c:136)
ax25_rt_autobind (net/ax25/ax25_route.c:428)
ax25_connect (net/ax25/af_ax25.c:1282)
__sys_connect_file (net/socket.c:2045)
__sys_connect (net/socket.c:2064)
__x64_sys_connect (net/socket.c:2067)
do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)
entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)
================================================================

When socket is bound, refcounts must be incremented the way it is done
in ax25_bind() and ax25_setsockopt() (SO_BINDTODEVICE). In case of
autobind, the refcounts are not incremented.

This bug leads to the following issue reported by Syzkaller:

================================================================
ax25_connect(): syz-executor318 uses autobind, please contact jreuter@yaina.de
------------[ cut here ]------------
refcount_t: decrement hit 0; leaking memory.
WARNING: CPU: 0 PID: 5317 at lib/refcount.c:31 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31
Modules linked in:
CPU: 0 UID: 0 PID: 5317 Comm: syz-executor318 Not tainted 6.14.0-rc4-syzkaller-00278-gece144f151ac #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
RIP: 0010:refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31
...
Call Trace:
 <TASK>
 __refcount_dec include/linux/refcount.h:336 [inline]
 refcount_dec include/linux/refcount.h:351 [inline]
 ref_tracker_free+0x6af/0x7e0 lib/ref_tracker.c:236
 netdev_tracker_free include/linux/netdevice.h:4302 [inline]
 netdev_put include/linux/netdevice.h:4319 [inline]
 ax25_release+0x368/0x960 net/ax25/af_ax25.c:1080
 __sock_release net/socket.c:647 [inline]
 sock_close+0xbc/0x240 net/socket.c:1398
 __fput+0x3e9/0x9f0 fs/file_table.c:464
 __do_sys_close fs/open.c:1580 [inline]
 __se_sys_close fs/open.c:1565 [inline]
 __x64_sys_close+0x7f/0x110 fs/open.c:1565
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
 ...
 </TASK>
================================================================

Considering the issues above and the comments left in the code that say:
"check if we can remove this feature. It is broken."; "autobinding in this
may or may not work"; - it is better to completely remove this feature than
to fix it because it is broken and leads to various kinds of memory bugs.

Now calling connect() without first binding socket will result in an
error (-EINVAL). Userspace software that relies on the autobind feature
might get broken. However, this feature does not seem widely used with
this specific driver as it was not reliable at any point of time, and it
is already broken anyway. E.g. ax25-tools and ax25-apps packages for
popular distributions do not use the autobind feature for AF_AX25.

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2f6efbabceb6b2914ee9bafb86d9a51feae9cce8
  - https://git.kernel.org/stable/c/61203fdd3e35519db9a98b6ff8983c620ffc4696

------------------------------------------------------------

CVE ID: CVE-2025-22110
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nfnetlink_queue: Initialize ctx to avoid memory allocation error

It is possible that ctx in nfqnl_build_packet_message() could be used
before it is properly initialize, which is only initialized
by nfqnl_get_sk_secctx().

This patch corrects this problem by initializing the lsmctx to a safe
value when it is declared.

This is similar to the commit 35fcac7a7c25
("audit: Initialize lsmctx to avoid memory allocation error").
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/778b09d91baafb13408470c721d034d6515cfa5a
  - https://git.kernel.org/stable/c/ddbf7e1d82a1d0c1d3425931a6cb1b83f8454759

------------------------------------------------------------

CVE ID: CVE-2025-22111
Description: In the Linux kernel, the following vulnerability has been resolved:

net: Remove RTNL dance for SIOCBRADDIF and SIOCBRDELIF.

SIOCBRDELIF is passed to dev_ioctl() first and later forwarded to
br_ioctl_call(), which causes unnecessary RTNL dance and the splat
below [0] under RTNL pressure.

Let's say Thread A is trying to detach a device from a bridge and
Thread B is trying to remove the bridge.

In dev_ioctl(), Thread A bumps the bridge device's refcnt by
netdev_hold() and releases RTNL because the following br_ioctl_call()
also re-acquires RTNL.

In the race window, Thread B could acquire RTNL and try to remove
the bridge device.  Then, rtnl_unlock() by Thread B will release RTNL
and wait for netdev_put() by Thread A.

Thread A, however, must hold RTNL after the unlock in dev_ifsioc(),
which may take long under RTNL pressure, resulting in the splat by
Thread B.

  Thread A (SIOCBRDELIF)           Thread B (SIOCBRDELBR)
  ----------------------           ----------------------
  sock_ioctl                       sock_ioctl
  `- sock_do_ioctl                 `- br_ioctl_call
     `- dev_ioctl                     `- br_ioctl_stub
        |- rtnl_lock                     |
        |- dev_ifsioc                    '
        '  |- dev = __dev_get_by_name(...)
           |- netdev_hold(dev, ...)      .
       /   |- rtnl_unlock  ------.       |
       |   |- br_ioctl_call       `--->  |- rtnl_lock
  Race |   |  `- br_ioctl_stub           |- br_del_bridge
  Window   |     |                       |  |- dev = __dev_get_by_name(...)
       |   |     |  May take long        |  `- br_dev_delete(dev, ...)
       |   |     |  under RTNL pressure  |     `- unregister_netdevice_queue(dev, ...)
       |   |     |               |       `- rtnl_unlock
       \   |     |- rtnl_lock  <-'          `- netdev_run_todo
           |     |- ...                        `- netdev_run_todo
           |     `- rtnl_unlock                   |- __rtnl_unlock
           |                                      |- netdev_wait_allrefs_any
           |- netdev_put(dev, ...)  <----------------'
                                                Wait refcnt decrement
                                                and log splat below

To avoid blocking SIOCBRDELBR unnecessarily, let's not call
dev_ioctl() for SIOCBRADDIF and SIOCBRDELIF.

In the dev_ioctl() path, we do the following:

  1. Copy struct ifreq by get_user_ifreq in sock_do_ioctl()
  2. Check CAP_NET_ADMIN in dev_ioctl()
  3. Call dev_load() in dev_ioctl()
  4. Fetch the master dev from ifr.ifr_name in dev_ifsioc()

3. can be done by request_module() in br_ioctl_call(), so we move
1., 2., and 4. to br_ioctl_stub().

Note that 2. is also checked later in add_del_if(), but it's better
performed before RTNL.

SIOCBRADDIF and SIOCBRDELIF have been processed in dev_ioctl() since
the pre-git era, and there seems to be no specific reason to process
them there.

[0]:
unregister_netdevice: waiting for wpan3 to become free. Usage count = 2
ref_tracker: wpan3@ffff8880662d8608 has 1/1 users at
     __netdev_tracker_alloc include/linux/netdevice.h:4282 [inline]
     netdev_hold include/linux/netdevice.h:4311 [inline]
     dev_ifsioc+0xc6a/0x1160 net/core/dev_ioctl.c:624
     dev_ioctl+0x255/0x10c0 net/core/dev_ioctl.c:826
     sock_do_ioctl+0x1ca/0x260 net/socket.c:1213
     sock_ioctl+0x23a/0x6c0 net/socket.c:1318
     vfs_ioctl fs/ioctl.c:51 [inline]
     __do_sys_ioctl fs/ioctl.c:906 [inline]
     __se_sys_ioctl fs/ioctl.c:892 [inline]
     __x64_sys_ioctl+0x1a4/0x210 fs/ioctl.c:892
     do_syscall_x64 arch/x86/entry/common.c:52 [inline]
     do_syscall_64+0xcb/0x250 arch/x86/entry/common.c:83
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/00fe0ac64efd1f5373b3dd9f1f84b19235371e39
  - https://git.kernel.org/stable/c/ed3ba9b6e280e14cc3148c1b226ba453f02fa76c

------------------------------------------------------------

CVE ID: CVE-2025-22112
Description: In the Linux kernel, the following vulnerability has been resolved:

eth: bnxt: fix out-of-range access of vnic_info array

The bnxt_queue_{start | stop}() access vnic_info as much as allocated,
which indicates bp->nr_vnics.
So, it should not reach bp->vnic_info[bp->nr_vnics].
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/919f9f497dbcee75d487400e8f9815b74a6a37df
  - https://git.kernel.org/stable/c/b1e081d331ab3a0dea25425f2b6ddeb365fc9d22

------------------------------------------------------------

CVE ID: CVE-2025-22113
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: avoid journaling sb update on error if journal is destroying

Presently we always BUG_ON if trying to start a transaction on a journal marked
with JBD2_UNMOUNT, since this should never happen. However, while ltp running
stress tests, it was observed that in case of some error handling paths, it is
possible for update_super_work to start a transaction after the journal is
destroyed eg:

(umount)
ext4_kill_sb
  kill_block_super
    generic_shutdown_super
      sync_filesystem /* commits all txns */
      evict_inodes
        /* might start a new txn */
      ext4_put_super
	flush_work(&sbi->s_sb_upd_work) /* flush the workqueue */
        jbd2_journal_destroy
          journal_kill_thread
            journal->j_flags |= JBD2_UNMOUNT;
          jbd2_journal_commit_transaction
            jbd2_journal_get_descriptor_buffer
              jbd2_journal_bmap
                ext4_journal_bmap
                  ext4_map_blocks
                    ...
                    ext4_inode_error
                      ext4_handle_error
                        schedule_work(&sbi->s_sb_upd_work)

                                               /* work queue kicks in */
                                               update_super_work
                                                 jbd2_journal_start
                                                   start_this_handle
                                                     BUG_ON(journal->j_flags &
                                                            JBD2_UNMOUNT)

Hence, introduce a new mount flag to indicate journal is destroying and only do
a journaled (and deferred) update of sb if this flag is not set. Otherwise, just
fallback to an un-journaled commit.

Further, in the journal destroy path, we have the following sequence:

  1. Set mount flag indicating journal is destroying
  2. force a commit and wait for it
  3. flush pending sb updates

This sequence is important as it ensures that, after this point, there is no sb
update that might be journaled so it is safe to update the sb outside the
journal. (To avoid race discussed in 2d01ddc86606)

Also, we don't need a similar check in ext4_grp_locked_error since it is only
called from mballoc and AFAICT it would be always valid to schedule work here.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/ce2f26e73783b4a7c46a86e3af5b5c8de0971790
  - https://git.kernel.org/stable/c/db05767b5bc307143d99fe2afd8c43af58d2ebef

------------------------------------------------------------

CVE ID: CVE-2025-22114
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: don't clobber ret in btrfs_validate_super()

Commit 2a9bb78cfd36 ("btrfs: validate system chunk array at
btrfs_validate_super()") introduces a call to validate_sys_chunk_array()
in btrfs_validate_super(), which clobbers the value of ret set earlier.
This has the effect of negating the validity checks done earlier, making
it so btrfs could potentially try to mount invalid filesystems.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9db9c7dd5b4e1d3205137a094805980082c37716
  - https://git.kernel.org/stable/c/ef6800a2015e706e9852a5ec15263fec9990d012

------------------------------------------------------------

CVE ID: CVE-2025-22115
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix block group refcount race in btrfs_create_pending_block_groups()

Block group creation is done in two phases, which results in a slightly
unintuitive property: a block group can be allocated/deallocated from
after btrfs_make_block_group() adds it to the space_info with
btrfs_add_bg_to_space_info(), but before creation is completely completed
in btrfs_create_pending_block_groups(). As a result, it is possible for a
block group to go unused and have 'btrfs_mark_bg_unused' called on it
concurrently with 'btrfs_create_pending_block_groups'. This causes a
number of issues, which were fixed with the block group flag
'BLOCK_GROUP_FLAG_NEW'.

However, this fix is not quite complete. Since it does not use the
unused_bg_lock, it is possible for the following race to occur:

btrfs_create_pending_block_groups            btrfs_mark_bg_unused
                                           if list_empty // false
        list_del_init
        clear_bit
                                           else if (test_bit) // true
                                                list_move_tail

And we get into the exact same broken ref count and invalid new_bgs
state for transaction cleanup that BLOCK_GROUP_FLAG_NEW was designed to
prevent.

The broken refcount aspect will result in a warning like:

  [1272.943527] refcount_t: underflow; use-after-free.
  [1272.943967] WARNING: CPU: 1 PID: 61 at lib/refcount.c:28 refcount_warn_saturate+0xba/0x110
  [1272.944731] Modules linked in: btrfs virtio_net xor zstd_compress raid6_pq null_blk [last unloaded: btrfs]
  [1272.945550] CPU: 1 UID: 0 PID: 61 Comm: kworker/u32:1 Kdump: loaded Tainted: G        W          6.14.0-rc5+ #108
  [1272.946368] Tainted: [W]=WARN
  [1272.946585] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014
  [1272.947273] Workqueue: btrfs_discard btrfs_discard_workfn [btrfs]
  [1272.947788] RIP: 0010:refcount_warn_saturate+0xba/0x110
  [1272.949532] RSP: 0018:ffffbf1200247df0 EFLAGS: 00010282
  [1272.949901] RAX: 0000000000000000 RBX: ffffa14b00e3f800 RCX: 0000000000000000
  [1272.950437] RDX: 0000000000000000 RSI: ffffbf1200247c78 RDI: 00000000ffffdfff
  [1272.950986] RBP: ffffa14b00dc2860 R08: 00000000ffffdfff R09: ffffffff90526268
  [1272.951512] R10: ffffffff904762c0 R11: 0000000063666572 R12: ffffa14b00dc28c0
  [1272.952024] R13: 0000000000000000 R14: ffffa14b00dc2868 R15: 000001285dcd12c0
  [1272.952850] FS:  0000000000000000(0000) GS:ffffa14d33c40000(0000) knlGS:0000000000000000
  [1272.953458] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  [1272.953931] CR2: 00007f838cbda000 CR3: 000000010104e000 CR4: 00000000000006f0
  [1272.954474] Call Trace:
  [1272.954655]  <TASK>
  [1272.954812]  ? refcount_warn_saturate+0xba/0x110
  [1272.955173]  ? __warn.cold+0x93/0xd7
  [1272.955487]  ? refcount_warn_saturate+0xba/0x110
  [1272.955816]  ? report_bug+0xe7/0x120
  [1272.956103]  ? handle_bug+0x53/0x90
  [1272.956424]  ? exc_invalid_op+0x13/0x60
  [1272.956700]  ? asm_exc_invalid_op+0x16/0x20
  [1272.957011]  ? refcount_warn_saturate+0xba/0x110
  [1272.957399]  btrfs_discard_cancel_work.cold+0x26/0x2b [btrfs]
  [1272.957853]  btrfs_put_block_group.cold+0x5d/0x8e [btrfs]
  [1272.958289]  btrfs_discard_workfn+0x194/0x380 [btrfs]
  [1272.958729]  process_one_work+0x130/0x290
  [1272.959026]  worker_thread+0x2ea/0x420
  [1272.959335]  ? __pfx_worker_thread+0x10/0x10
  [1272.959644]  kthread+0xd7/0x1c0
  [1272.959872]  ? __pfx_kthread+0x10/0x10
  [1272.960172]  ret_from_fork+0x30/0x50
  [1272.960474]  ? __pfx_kthread+0x10/0x10
  [1272.960745]  ret_from_fork_asm+0x1a/0x30
  [1272.961035]  </TASK>
  [1272.961238] ---[ end trace 0000000000000000 ]---

Though we have seen them in the async discard workfn as well. It is
most likely to happen after a relocation finishes which cancels discard,
tears down the block group, etc.

Fix this fully by taking the lock arou
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d8e5168d48a91e7a802d3003e72afb4304bebfa
  - https://git.kernel.org/stable/c/9d383a6fc59271aaaf07a33b23b2eac5b9268b7a

------------------------------------------------------------

CVE ID: CVE-2025-22116
Description: In the Linux kernel, the following vulnerability has been resolved:

idpf: check error for register_netdev() on init

Current init logic ignores the error code from register_netdev(),
which will cause WARN_ON() on attempt to unregister it, if there was one,
and there is no info for the user that the creation of the netdev failed.

WARNING: CPU: 89 PID: 6902 at net/core/dev.c:11512 unregister_netdevice_many_notify+0x211/0x1a10
...
[ 3707.563641]  unregister_netdev+0x1c/0x30
[ 3707.563656]  idpf_vport_dealloc+0x5cf/0xce0 [idpf]
[ 3707.563684]  idpf_deinit_task+0xef/0x160 [idpf]
[ 3707.563712]  idpf_vc_core_deinit+0x84/0x320 [idpf]
[ 3707.563739]  idpf_remove+0xbf/0x780 [idpf]
[ 3707.563769]  pci_device_remove+0xab/0x1e0
[ 3707.563786]  device_release_driver_internal+0x371/0x530
[ 3707.563803]  driver_detach+0xbf/0x180
[ 3707.563816]  bus_remove_driver+0x11b/0x2a0
[ 3707.563829]  pci_unregister_driver+0x2a/0x250

Introduce an error check and log the vport number and error code.
On removal make sure to check VPORT_REG_NETDEV flag prior to calling
unregister and free on the netdev.

Add local variables for idx, vport_config and netdev for readability.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/680811c67906191b237bbafe7dabbbad64649b39
  - https://git.kernel.org/stable/c/89768e33752211b2240ec4c34138170c95f11f97

------------------------------------------------------------

CVE ID: CVE-2025-22117
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: fix using untrusted value of pkt_len in ice_vc_fdir_parse_raw()

Fix using the untrusted value of proto->raw.pkt_len in function
ice_vc_fdir_parse_raw() by verifying if it does not exceed the
VIRTCHNL_MAX_SIZE_RAW_PACKET value.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1388dd564183a5a18ec4a966748037736b5653c5
  - https://git.kernel.org/stable/c/362f704ba73a359db9cded567e891d9a8f081875

------------------------------------------------------------

CVE ID: CVE-2025-22118
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: validate queue quanta parameters to prevent OOB access

Add queue wraparound prevention in quanta configuration.
Ensure end_qid does not overflow by validating start_qid and num_queues.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4161cf3f4c11006507f4e02bedc048a215a4b81a
  - https://git.kernel.org/stable/c/e2f7d3f7331b92cb820da23e8c45133305da1e63

------------------------------------------------------------

CVE ID: CVE-2025-22119
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: init wiphy_work before allocating rfkill fails

syzbort reported a uninitialize wiphy_work_lock in cfg80211_dev_free. [1]

After rfkill allocation fails, the wiphy release process will be performed,
which will cause cfg80211_dev_free to access the uninitialized wiphy_work
related data.

Move the initialization of wiphy_work to before rfkill initialization to
avoid this issue.

[1]
INFO: trying to register non-static key.
The code is fine but needs lockdep annotation, or maybe
you didn't initialize this object before use?
turning off the locking correctness validator.
CPU: 0 UID: 0 PID: 5935 Comm: syz-executor550 Not tainted 6.14.0-rc6-syzkaller-00103-g4003c9e78778 #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120
 assign_lock_key kernel/locking/lockdep.c:983 [inline]
 register_lock_class+0xc39/0x1240 kernel/locking/lockdep.c:1297
 __lock_acquire+0x135/0x3c40 kernel/locking/lockdep.c:5103
 lock_acquire.part.0+0x11b/0x380 kernel/locking/lockdep.c:5851
 __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
 _raw_spin_lock_irqsave+0x3a/0x60 kernel/locking/spinlock.c:162
 cfg80211_dev_free+0x30/0x3d0 net/wireless/core.c:1196
 device_release+0xa1/0x240 drivers/base/core.c:2568
 kobject_cleanup lib/kobject.c:689 [inline]
 kobject_release lib/kobject.c:720 [inline]
 kref_put include/linux/kref.h:65 [inline]
 kobject_put+0x1e4/0x5a0 lib/kobject.c:737
 put_device+0x1f/0x30 drivers/base/core.c:3774
 wiphy_free net/wireless/core.c:1224 [inline]
 wiphy_new_nm+0x1c1f/0x2160 net/wireless/core.c:562
 ieee80211_alloc_hw_nm+0x1b7a/0x2260 net/mac80211/main.c:835
 mac80211_hwsim_new_radio+0x1d6/0x54e0 drivers/net/wireless/virtual/mac80211_hwsim.c:5185
 hwsim_new_radio_nl+0xb42/0x12b0 drivers/net/wireless/virtual/mac80211_hwsim.c:6242
 genl_family_rcv_msg_doit+0x202/0x2f0 net/netlink/genetlink.c:1115
 genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
 genl_rcv_msg+0x565/0x800 net/netlink/genetlink.c:1210
 netlink_rcv_skb+0x16b/0x440 net/netlink/af_netlink.c:2533
 genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219
 netlink_unicast_kernel net/netlink/af_netlink.c:1312 [inline]
 netlink_unicast+0x53c/0x7f0 net/netlink/af_netlink.c:1338
 netlink_sendmsg+0x8b8/0xd70 net/netlink/af_netlink.c:1882
 sock_sendmsg_nosec net/socket.c:718 [inline]
 __sock_sendmsg net/socket.c:733 [inline]
 ____sys_sendmsg+0xaaf/0xc90 net/socket.c:2573
 ___sys_sendmsg+0x135/0x1e0 net/socket.c:2627
 __sys_sendmsg+0x16e/0x220 net/socket.c:2659
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83

Close: https://syzkaller.appspot.com/bug?extid=aaf0488c83d1d5f4f029
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2617f60c3613ef105b8db2d514d2cac2a1836f7d
  - https://git.kernel.org/stable/c/fc88dee89d7b63eeb17699393eb659aadf9d9b7c

------------------------------------------------------------

CVE ID: CVE-2025-22120
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: goto right label 'out_mmap_sem' in ext4_setattr()

Otherwise, if ext4_inode_attach_jinode() fails, a hung task will
happen because filemap_invalidate_unlock() isn't called to unlock
mapping->invalidate_lock. Like this:

EXT4-fs error (device sda) in ext4_setattr:5557: Out of memory
INFO: task fsstress:374 blocked for more than 122 seconds.
      Not tainted 6.14.0-rc1-next-20250206-xfstests-dirty #726
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
task:fsstress state:D stack:0     pid:374   tgid:374   ppid:373
                                  task_flags:0x440140 flags:0x00000000
Call Trace:
 <TASK>
 __schedule+0x2c9/0x7f0
 schedule+0x27/0xa0
 schedule_preempt_disabled+0x15/0x30
 rwsem_down_read_slowpath+0x278/0x4c0
 down_read+0x59/0xb0
 page_cache_ra_unbounded+0x65/0x1b0
 filemap_get_pages+0x124/0x3e0
 filemap_read+0x114/0x3d0
 vfs_read+0x297/0x360
 ksys_read+0x6c/0xe0
 do_syscall_64+0x4b/0x110
 entry_SYSCALL_64_after_hwframe+0x76/0x7e
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/32d872e3905746ff1048078256cb00f946b97d8a
  - https://git.kernel.org/stable/c/45314999f950321a341033ae8f9ac12dce40669b
  - https://git.kernel.org/stable/c/551667f99bcf04fa58594d7d19aef73c861a1200
  - https://git.kernel.org/stable/c/7e91ae31e2d264155dfd102101afc2de7bd74a64

------------------------------------------------------------

CVE ID: CVE-2025-22121
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix out-of-bound read in ext4_xattr_inode_dec_ref_all()

There's issue as follows:
BUG: KASAN: use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790
Read of size 4 at addr ffff88807b003000 by task syz-executor.0/15172

CPU: 3 PID: 15172 Comm: syz-executor.0
Call Trace:
 __dump_stack lib/dump_stack.c:82 [inline]
 dump_stack+0xbe/0xfd lib/dump_stack.c:123
 print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c:400
 __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560
 kasan_report+0x3a/0x50 mm/kasan/report.c:585
 ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c:1137
 ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c:2896
 ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c:323
 evict+0x39f/0x880 fs/inode.c:622
 iput_final fs/inode.c:1746 [inline]
 iput fs/inode.c:1772 [inline]
 iput+0x525/0x6c0 fs/inode.c:1758
 ext4_orphan_cleanup fs/ext4/super.c:3298 [inline]
 ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c:5300
 mount_bdev+0x355/0x410 fs/super.c:1446
 legacy_get_tree+0xfe/0x220 fs/fs_context.c:611
 vfs_get_tree+0x8d/0x2f0 fs/super.c:1576
 do_new_mount fs/namespace.c:2983 [inline]
 path_mount+0x119a/0x1ad0 fs/namespace.c:3316
 do_mount+0xfc/0x110 fs/namespace.c:3329
 __do_sys_mount fs/namespace.c:3540 [inline]
 __se_sys_mount+0x219/0x2e0 fs/namespace.c:3514
 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46
 entry_SYSCALL_64_after_hwframe+0x67/0xd1

Memory state around the buggy address:
 ffff88807b002f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 ffff88807b002f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>ffff88807b003000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                   ^
 ffff88807b003080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
 ffff88807b003100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff

Above issue happens as ext4_xattr_delete_inode() isn't check xattr
is valid if xattr is in inode.
To solve above issue call xattr_check_inode() check if xattr if valid
in inode. In fact, we can directly verify in ext4_iget_extra_inode(),
so that there is no divergent verification.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c8fbb6ffb3c8f5164572ca88e4ccb6cd6a41ca8
  - https://git.kernel.org/stable/c/5701875f9609b000d91351eaa6bfd97fe2f157f4

------------------------------------------------------------

CVE ID: CVE-2025-22122
Description: In the Linux kernel, the following vulnerability has been resolved:

block: fix adding folio to bio

>4GB folio is possible on some ARCHs, such as aarch64, 16GB hugepage
is supported, then 'offset' of folio can't be held in 'unsigned int',
cause warning in bio_add_folio_nofail() and IO failure.

Fix it by adjusting 'page' & trimming 'offset' so that `->bi_offset` won't
be overflow, and folio can be added to bio successfully.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/26064d3e2b4d9a14df1072980e558c636fb023ea
  - https://git.kernel.org/stable/c/b96e0af1b1c99cb7e6188b6fa4963a4e47beb01e

------------------------------------------------------------

CVE ID: CVE-2025-22123
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to avoid accessing uninitialized curseg

syzbot reports a f2fs bug as below:

F2FS-fs (loop3): Stopped filesystem due to reason: 7
kworker/u8:7: attempt to access beyond end of device
BUG: unable to handle page fault for address: ffffed1604ea3dfa
RIP: 0010:get_ckpt_valid_blocks fs/f2fs/segment.h:361 [inline]
RIP: 0010:has_curseg_enough_space fs/f2fs/segment.h:570 [inline]
RIP: 0010:__get_secs_required fs/f2fs/segment.h:620 [inline]
RIP: 0010:has_not_enough_free_secs fs/f2fs/segment.h:633 [inline]
RIP: 0010:has_enough_free_secs+0x575/0x1660 fs/f2fs/segment.h:649
 <TASK>
 f2fs_is_checkpoint_ready fs/f2fs/segment.h:671 [inline]
 f2fs_write_inode+0x425/0x540 fs/f2fs/inode.c:791
 write_inode fs/fs-writeback.c:1525 [inline]
 __writeback_single_inode+0x708/0x10d0 fs/fs-writeback.c:1745
 writeback_sb_inodes+0x820/0x1360 fs/fs-writeback.c:1976
 wb_writeback+0x413/0xb80 fs/fs-writeback.c:2156
 wb_do_writeback fs/fs-writeback.c:2303 [inline]
 wb_workfn+0x410/0x1080 fs/fs-writeback.c:2343
 process_one_work kernel/workqueue.c:3236 [inline]
 process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317
 worker_thread+0x870/0xd30 kernel/workqueue.c:3398
 kthread+0x7a9/0x920 kernel/kthread.c:464
 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:148
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

Commit 8b10d3653735 ("f2fs: introduce FAULT_NO_SEGMENT") allows to trigger
no free segment fault in allocator, then it will update curseg->segno to
NULL_SEGNO, though, CP_ERROR_FLAG has been set, f2fs_write_inode() missed
to check the flag, and access invalid curseg->segno directly in below call
path, then resulting in panic:

- f2fs_write_inode
 - f2fs_is_checkpoint_ready
  - has_enough_free_secs
   - has_not_enough_free_secs
    - __get_secs_required
     - has_curseg_enough_space
      - get_ckpt_valid_blocks
      : access invalid curseg->segno

To avoid this issue, let's:
- check CP_ERROR_FLAG flag in prior to f2fs_is_checkpoint_ready() in
f2fs_write_inode().
- in has_curseg_enough_space(), save curseg->segno into a temp variable,
and verify its validation before use.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7f90e5d423cd2d4c74b2abb527872f335108637f
  - https://git.kernel.org/stable/c/986c50f6bca109c6cf362b4e2babcb85aba958f6

------------------------------------------------------------

CVE ID: CVE-2025-22124
Description: In the Linux kernel, the following vulnerability has been resolved:

md/md-bitmap: fix wrong bitmap_limit for clustermd when write sb

In clustermd, separate write-intent-bitmaps are used for each cluster
node:

0                    4k                     8k                    12k
-------------------------------------------------------------------
| idle                | md super            | bm super [0] + bits |
| bm bits[0, contd]   | bm super[1] + bits  | bm bits[1, contd]   |
| bm super[2] + bits  | bm bits [2, contd]  | bm super[3] + bits  |
| bm bits [3, contd]  |                     |                     |

So in node 1, pg_index in __write_sb_page() could equal to
bitmap->storage.file_pages. Then bitmap_limit will be calculated to
0. md_super_write() will be called with 0 size.
That means the first 4k sb area of node 1 will never be updated
through filemap_write_page().
This bug causes hang of mdadm/clustermd_tests/01r1_Grow_resize.

Here use (pg_index % bitmap->storage.file_pages) to make calculation
of bitmap_limit correct.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6130825f34d41718c98a9b1504a79a23e379701e
  - https://git.kernel.org/stable/c/bc3a9788961631359527763d7e1fcf26554c7cb1

------------------------------------------------------------

CVE ID: CVE-2025-22125
Description: In the Linux kernel, the following vulnerability has been resolved:

md/raid1,raid10: don't ignore IO flags

If blk-wbt is enabled by default, it's found that raid write performance
is quite bad because all IO are throttled by wbt of underlying disks,
due to flag REQ_IDLE is ignored. And turns out this behaviour exist since
blk-wbt is introduced.

Other than REQ_IDLE, other flags should not be ignored as well, for
example REQ_META can be set for filesystems, clearing it can cause priority
reverse problems; And REQ_NOWAIT should not be cleared as well, because
io will wait instead of failing directly in underlying disks.

Fix those problems by keep IO flags from master bio.

Fises: f51d46d0e7cb ("md: add support for REQ_NOWAIT")
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8a0adf3d778c4a0893c6d34a9e1b0082a6f1c495
  - https://git.kernel.org/stable/c/e879a0d9cb086c8e52ce6c04e5bfa63825a6213c

------------------------------------------------------------

CVE ID: CVE-2025-22126
Description: In the Linux kernel, the following vulnerability has been resolved:

md: fix mddev uaf while iterating all_mddevs list

While iterating all_mddevs list from md_notify_reboot() and md_exit(),
list_for_each_entry_safe is used, and this can race with deletint the
next mddev, causing UAF:

t1:
spin_lock
//list_for_each_entry_safe(mddev, n, ...)
 mddev_get(mddev1)
 // assume mddev2 is the next entry
 spin_unlock
            t2:
            //remove mddev2
            ...
            mddev_free
            spin_lock
            list_del
            spin_unlock
            kfree(mddev2)
 mddev_put(mddev1)
 spin_lock
 //continue dereference mddev2->all_mddevs

The old helper for_each_mddev() actually grab the reference of mddev2
while holding the lock, to prevent from being freed. This problem can be
fixed the same way, however, the code will be complex.

Hence switch to use list_for_each_entry, in this case mddev_put() can free
the mddev1 and it's not safe as well. Refer to md_seq_show(), also factor
out a helper mddev_put_locked() to fix this problem.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5462544ccbad3fc938a71b01fa5bd3a0dc2b750a
  - https://git.kernel.org/stable/c/8542870237c3a48ff049b6c5df5f50c8728284fa
  - https://git.kernel.org/stable/c/ca9f84de76723b358dfc0606668efdca54afc2e5
  - https://git.kernel.org/stable/c/d69a23d8e925f8052d657652a6875ec2712c7e33
  - https://git.kernel.org/stable/c/e2a9f73ee408a460f4c9dfe03b4741d6b11652b8

------------------------------------------------------------

CVE ID: CVE-2025-22127
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix potential deadloop in prepare_compress_overwrite()

Jan Prusakowski reported a kernel hang issue as below:

When running xfstests on linux-next kernel (6.14.0-rc3, 6.12) I
encountered a problem in generic/475 test where fsstress process
gets blocked in __f2fs_write_data_pages() and the test hangs.
The options I used are:

MKFS_OPTIONS  -- -O compression -O extra_attr -O project_quota -O quota /dev/vdc
MOUNT_OPTIONS -- -o acl,user_xattr -o discard,compress_extension=* /dev/vdc /vdc

INFO: task kworker/u8:0:11 blocked for more than 122 seconds.
      Not tainted 6.14.0-rc3-xfstests-lockdep #1
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
task:kworker/u8:0    state:D stack:0     pid:11    tgid:11    ppid:2      task_flags:0x4208160 flags:0x00004000
Workqueue: writeback wb_workfn (flush-253:0)
Call Trace:
 <TASK>
 __schedule+0x309/0x8e0
 schedule+0x3a/0x100
 schedule_preempt_disabled+0x15/0x30
 __mutex_lock+0x59a/0xdb0
 __f2fs_write_data_pages+0x3ac/0x400
 do_writepages+0xe8/0x290
 __writeback_single_inode+0x5c/0x360
 writeback_sb_inodes+0x22f/0x570
 wb_writeback+0xb0/0x410
 wb_do_writeback+0x47/0x2f0
 wb_workfn+0x5a/0x1c0
 process_one_work+0x223/0x5b0
 worker_thread+0x1d5/0x3c0
 kthread+0xfd/0x230
 ret_from_fork+0x31/0x50
 ret_from_fork_asm+0x1a/0x30
 </TASK>

The root cause is: once generic/475 starts toload error table to dm
device, f2fs_prepare_compress_overwrite() will loop reading compressed
cluster pages due to IO error, meanwhile it has held .writepages lock,
it can block all other writeback tasks.

Let's fix this issue w/ below changes:
- add f2fs_handle_page_eio() in prepare_compress_overwrite() to
detect IO error.
- detect cp_error earler in f2fs_read_multi_pages().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3147ee567dd9004a49826ddeaf0a4b12865d4409
  - https://git.kernel.org/stable/c/7215cf8ef54bdc9082dffac4662416d54961e258

------------------------------------------------------------

CVE ID: CVE-2025-22128
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath12k: Clear affinity hint before calling ath12k_pci_free_irq() in error path

If a shared IRQ is used by the driver due to platform limitation, then the
IRQ affinity hint is set right after the allocation of IRQ vectors in
ath12k_pci_msi_alloc(). This does no harm unless one of the functions
requesting the IRQ fails and attempt to free the IRQ.

This may end up with a warning from the IRQ core that is expecting the
affinity hint to be cleared before freeing the IRQ:

kernel/irq/manage.c:

	/* make sure affinity_hint is cleaned up */
	if (WARN_ON_ONCE(desc->affinity_hint))
		desc->affinity_hint = NULL;

So to fix this issue, clear the IRQ affinity hint before calling
ath12k_pci_free_irq() in the error path. The affinity will be cleared once
again further down the error path due to code organization, but that does
no harm.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/35b33ba76765ce9e72949d957f3cf1feafd2955c
  - https://git.kernel.org/stable/c/b43b1e2c52db77c872bd60d30cdcc72c47df70c7

------------------------------------------------------------

CVE ID: CVE-2025-23129
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath11k: Clear affinity hint before calling ath11k_pcic_free_irq() in error path

If a shared IRQ is used by the driver due to platform limitation, then the
IRQ affinity hint is set right after the allocation of IRQ vectors in
ath11k_pci_alloc_msi(). This does no harm unless one of the functions
requesting the IRQ fails and attempt to free the IRQ. This results in the
below warning:

WARNING: CPU: 7 PID: 349 at kernel/irq/manage.c:1929 free_irq+0x278/0x29c
Call trace:
 free_irq+0x278/0x29c
 ath11k_pcic_free_irq+0x70/0x10c [ath11k]
 ath11k_pci_probe+0x800/0x820 [ath11k_pci]
 local_pci_probe+0x40/0xbc

The warning is due to not clearing the affinity hint before freeing the
IRQs.

So to fix this issue, clear the IRQ affinity hint before calling
ath11k_pcic_free_irq() in the error path. The affinity will be cleared once
again further down the error path due to code organization, but that does
no harm.

Tested-on: QCA6390 hw2.0 PCI WLAN.HST.1.0.1-05266-QCAHSTSWPLZ_V2_TO_X86-1
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3fc42cfcc6e336f25dee79b34e57c4a63cd652a5
  - https://git.kernel.org/stable/c/68410c5bd381a81bcc92b808e7dc4e6b9ed25d11

------------------------------------------------------------

CVE ID: CVE-2025-23130
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to avoid panic once fallocation fails for pinfile

syzbot reports a f2fs bug as below:

------------[ cut here ]------------
kernel BUG at fs/f2fs/segment.c:2746!
CPU: 0 UID: 0 PID: 5323 Comm: syz.0.0 Not tainted 6.13.0-rc2-syzkaller-00018-g7cb1b4663150 #0
RIP: 0010:get_new_segment fs/f2fs/segment.c:2746 [inline]
RIP: 0010:new_curseg+0x1f52/0x1f70 fs/f2fs/segment.c:2876
Call Trace:
 <TASK>
 __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3210
 f2fs_allocate_new_section fs/f2fs/segment.c:3224 [inline]
 f2fs_allocate_pinning_section+0xfa/0x4e0 fs/f2fs/segment.c:3238
 f2fs_expand_inode_data+0x696/0xca0 fs/f2fs/file.c:1830
 f2fs_fallocate+0x537/0xa10 fs/f2fs/file.c:1940
 vfs_fallocate+0x569/0x6e0 fs/open.c:327
 do_vfs_ioctl+0x258c/0x2e40 fs/ioctl.c:885
 __do_sys_ioctl fs/ioctl.c:904 [inline]
 __se_sys_ioctl+0x80/0x170 fs/ioctl.c:892
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

Concurrent pinfile allocation may run out of free section, result in
panic in get_new_segment(), let's expand pin_sem lock coverage to
include f2fs_gc(), so that we can make sure to reclaim enough free
space for following allocation.

In addition, do below changes to enhance error path handling:
- call f2fs_bug_on() only in non-pinfile allocation path in
get_new_segment().
- call reset_curseg_fields() to reset all fields of curseg in
new_curseg()
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/48ea8b200414ac69ea96f4c231f5c7ef1fbeffef
  - https://git.kernel.org/stable/c/9392862608d081a8346a3b841f862d732fce954b

------------------------------------------------------------

CVE ID: CVE-2025-23131
Description: In the Linux kernel, the following vulnerability has been resolved:

dlm: prevent NPD when writing a positive value to event_done

do_uevent returns the value written to event_done. In case it is a
positive value, new_lockspace would undo all the work, and lockspace
would not be set. __dlm_new_lockspace, however, would treat that
positive value as a success due to commit 8511a2728ab8 ("dlm: fix use
count with multiple joins").

Down the line, device_create_lockspace would pass that NULL lockspace to
dlm_find_lockspace_local, leading to a NULL pointer dereference.

Treating such positive values as successes prevents the problem. Given
this has been broken for so long, this is unlikely to break userspace
expectations.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8e2bad543eca5c25cd02cbc63d72557934d45f13
  - https://git.kernel.org/stable/c/b73c4ad4d387fe5bc988145bd9f1bc0de76afd5c

------------------------------------------------------------

CVE ID: CVE-2025-23132
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: quota: fix to avoid warning in dquot_writeback_dquots()

F2FS-fs (dm-59): checkpoint=enable has some unwritten data.

------------[ cut here ]------------
WARNING: CPU: 6 PID: 8013 at fs/quota/dquot.c:691 dquot_writeback_dquots+0x2fc/0x308
pc : dquot_writeback_dquots+0x2fc/0x308
lr : f2fs_quota_sync+0xcc/0x1c4
Call trace:
dquot_writeback_dquots+0x2fc/0x308
f2fs_quota_sync+0xcc/0x1c4
f2fs_write_checkpoint+0x3d4/0x9b0
f2fs_issue_checkpoint+0x1bc/0x2c0
f2fs_sync_fs+0x54/0x150
f2fs_do_sync_file+0x2f8/0x814
__f2fs_ioctl+0x1960/0x3244
f2fs_ioctl+0x54/0xe0
__arm64_sys_ioctl+0xa8/0xe4
invoke_syscall+0x58/0x114

checkpoint and f2fs_remount may race as below, resulting triggering warning
in dquot_writeback_dquots().

atomic write                                    remount
                                                - do_remount
                                                 - down_write(&sb->s_umount);
                                                  - f2fs_remount
- ioctl
 - f2fs_do_sync_file
  - f2fs_sync_fs
   - f2fs_write_checkpoint
    - block_operations
     - locked = down_read_trylock(&sbi->sb->s_umount)
       : fail to lock due to the write lock was held by remount
                                                 - up_write(&sb->s_umount);
     - f2fs_quota_sync
      - dquot_writeback_dquots
       - WARN_ON_ONCE(!rwsem_is_locked(&sb->s_umount))
       : trigger warning because s_umount lock was unlocked by remount

If checkpoint comes from mount/umount/remount/freeze/quotactl, caller of
checkpoint has already held s_umount lock, calling dquot_writeback_dquots()
in the context should be safe.

So let's record task to sbi->umount_lock_holder, so that checkpoint can
know whether the lock has held in the context or not by checking current
w/ it.

In addition, in order to not misrepresent caller of checkpoint, we should
not allow to trigger async checkpoint for those callers: mount/umount/remount/
freeze/quotactl.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/d7acf0a6c87aa282c86a36dbaa2f92fda88c5884
  - https://git.kernel.org/stable/c/eb85c2410d6f581e957cd03a644ff6ddbe592af9

------------------------------------------------------------

CVE ID: CVE-2025-23133
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath11k: update channel list in reg notifier instead reg worker

Currently when ath11k gets a new channel list, it will be processed
according to the following steps:
1. update new channel list to cfg80211 and queue reg_work.
2. cfg80211 handles new channel list during reg_work.
3. update cfg80211's handled channel list to firmware by
ath11k_reg_update_chan_list().

But ath11k will immediately execute step 3 after reg_work is just
queued. Since step 2 is asynchronous, cfg80211 may not have completed
handling the new channel list, which may leading to an out-of-bounds
write error:
BUG: KASAN: slab-out-of-bounds in ath11k_reg_update_chan_list
Call Trace:
    ath11k_reg_update_chan_list+0xbfe/0xfe0 [ath11k]
    kfree+0x109/0x3a0
    ath11k_regd_update+0x1cf/0x350 [ath11k]
    ath11k_regd_update_work+0x14/0x20 [ath11k]
    process_one_work+0xe35/0x14c0

Should ensure step 2 is completely done before executing step 3. Thus
Wen raised patch[1]. When flag NL80211_REGDOM_SET_BY_DRIVER is set,
cfg80211 will notify ath11k after step 2 is done.

So enable the flag NL80211_REGDOM_SET_BY_DRIVER then cfg80211 will
notify ath11k after step 2 is done. At this time, there will be no
KASAN bug during the execution of the step 3.

[1] https://patchwork.kernel.org/project/linux-wireless/patch/20230201065313.27203-1-quic_wgong@quicinc.com/

Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/933ab187e679e6fbdeea1835ae39efcc59c022d2
  - https://git.kernel.org/stable/c/f952fb83c9c6f908d27500764c4aee1df04b9d3f

------------------------------------------------------------

CVE ID: CVE-2025-23134
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: timer: Don't take register_mutex with copy_from/to_user()

The infamous mmap_lock taken in copy_from/to_user() can be often
problematic when it's called inside another mutex, as they might lead
to deadlocks.

In the case of ALSA timer code, the bad pattern is with
guard(mutex)(&register_mutex) that covers copy_from/to_user() -- which
was mistakenly introduced at converting to guard(), and it had been
carefully worked around in the past.

This patch fixes those pieces simply by moving copy_from/to_user() out
of the register mutex lock again.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/15291b561d8cc835a2eea76b394070cf8e072771
  - https://git.kernel.org/stable/c/296f7a9e15aab276db11206cbc1e2ae1215d7862
  - https://git.kernel.org/stable/c/3424c8f53bc63c87712a7fc22dc13d0cc85fb0d6
  - https://git.kernel.org/stable/c/b074f47e55df93832bbbca1b524c501e6fea1c0d

------------------------------------------------------------

CVE ID: CVE-2025-23135
Description: In the Linux kernel, the following vulnerability has been resolved:

RISC-V: KVM: Teardown riscv specific bits after kvm_exit

During a module removal, kvm_exit invokes arch specific disable
call which disables AIA. However, we invoke aia_exit before kvm_exit
resulting in the following warning. KVM kernel module can't be inserted
afterwards due to inconsistent state of IRQ.

[25469.031389] percpu IRQ 31 still enabled on CPU0!
[25469.031732] WARNING: CPU: 3 PID: 943 at kernel/irq/manage.c:2476 __free_percpu_irq+0xa2/0x150
[25469.031804] Modules linked in: kvm(-)
[25469.031848] CPU: 3 UID: 0 PID: 943 Comm: rmmod Not tainted 6.14.0-rc5-06947-g91c763118f47-dirty #2
[25469.031905] Hardware name: riscv-virtio,qemu (DT)
[25469.031928] epc : __free_percpu_irq+0xa2/0x150
[25469.031976]  ra : __free_percpu_irq+0xa2/0x150
[25469.032197] epc : ffffffff8007db1e ra : ffffffff8007db1e sp : ff2000000088bd50
[25469.032241]  gp : ffffffff8131cef8 tp : ff60000080b96400 t0 : ff2000000088baf8
[25469.032285]  t1 : fffffffffffffffc t2 : 5249207570637265 s0 : ff2000000088bd90
[25469.032329]  s1 : ff60000098b21080 a0 : 037d527a15eb4f00 a1 : 037d527a15eb4f00
[25469.032372]  a2 : 0000000000000023 a3 : 0000000000000001 a4 : ffffffff8122dbf8
[25469.032410]  a5 : 0000000000000fff a6 : 0000000000000000 a7 : ffffffff8122dc10
[25469.032448]  s2 : ff60000080c22eb0 s3 : 0000000200000022 s4 : 000000000000001f
[25469.032488]  s5 : ff60000080c22e00 s6 : ffffffff80c351c0 s7 : 0000000000000000
[25469.032582]  s8 : 0000000000000003 s9 : 000055556b7fb490 s10: 00007ffff0e12fa0
[25469.032621]  s11: 00007ffff0e13e9a t3 : ffffffff81354ac7 t4 : ffffffff81354ac7
[25469.032664]  t5 : ffffffff81354ac8 t6 : ffffffff81354ac7
[25469.032698] status: 0000000200000100 badaddr: ffffffff8007db1e cause: 0000000000000003
[25469.032738] [<ffffffff8007db1e>] __free_percpu_irq+0xa2/0x150
[25469.032797] [<ffffffff8007dbfc>] free_percpu_irq+0x30/0x5e
[25469.032856] [<ffffffff013a57dc>] kvm_riscv_aia_exit+0x40/0x42 [kvm]
[25469.033947] [<ffffffff013b4e82>] cleanup_module+0x10/0x32 [kvm]
[25469.035300] [<ffffffff8009b150>] __riscv_sys_delete_module+0x18e/0x1fc
[25469.035374] [<ffffffff8000c1ca>] syscall_handler+0x3a/0x46
[25469.035456] [<ffffffff809ec9a4>] do_trap_ecall_u+0x72/0x134
[25469.035536] [<ffffffff809f5e18>] handle_exception+0x148/0x156

Invoke aia_exit and other arch specific cleanup functions after kvm_exit
so that disable gets a chance to be called first before exit.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1521cc04f0b6e737ff30105aa57fa9dde8493231
  - https://git.kernel.org/stable/c/1edb2de48616b11ee05e9a65d74c70abcb6d9939
  - https://git.kernel.org/stable/c/2d117e67f318303f6ab699a5511d1fac3f170545

------------------------------------------------------------

CVE ID: CVE-2025-23136
Description: In the Linux kernel, the following vulnerability has been resolved:

thermal: int340x: Add NULL check for adev

Not all devices have an ACPI companion fwnode, so adev might be NULL.
This is similar to the commit cd2fd6eab480
("platform/x86: int3472: Check for adev == NULL").

Add a check for adev not being set and return -ENODEV in that case to
avoid a possible NULL pointer deref in int3402_thermal_probe().

Note, under the same directory, int3400_thermal_probe() has such a
check.

[ rjw: Subject edit, added Fixes: ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.18, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0c49f12c77b77a706fd41370c11910635e491845
  - https://git.kernel.org/stable/c/2542a3f70e563a9e70e7ded314286535a3321bdb
  - https://git.kernel.org/stable/c/3155d5261b518776d1b807d9d922669991bbee56
  - https://git.kernel.org/stable/c/6a810c462f099353e908c70619638884cb82229c
  - https://git.kernel.org/stable/c/8e8f1ddf4186731649df8bc9646017369eb19186
  - https://git.kernel.org/stable/c/953d28a4f459fcbde2d08f51aeca19d6b0f179f3
  - https://git.kernel.org/stable/c/ac2eb7378319e3836cdf3a2c15a0bdf04c50e81d
  - https://git.kernel.org/stable/c/bc7b5f782d28942dbdfda70df30ce132694a06de
  - https://git.kernel.org/stable/c/d0d21c8e44216fa9afdb3809edf213f3c0a8c060

------------------------------------------------------------

CVE ID: CVE-2025-23137
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq/amd-pstate: Add missing NULL ptr check in amd_pstate_update

Check if policy is NULL before dereferencing it in amd_pstate_update.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/426db24d4db2e4f0d6720aeb7795eafcb9e82640
  - https://git.kernel.org/stable/c/b99c1c63d88c75a4dc5487c3696cda38697b8d35

------------------------------------------------------------

CVE ID: CVE-2025-23138
Description: In the Linux kernel, the following vulnerability has been resolved:

watch_queue: fix pipe accounting mismatch

Currently, watch_queue_set_size() modifies the pipe buffers charged to
user->pipe_bufs without updating the pipe->nr_accounted on the pipe
itself, due to the if (!pipe_has_watch_queue()) test in
pipe_resize_ring(). This means that when the pipe is ultimately freed,
we decrement user->pipe_bufs by something other than what than we had
charged to it, potentially leading to an underflow. This in turn can
cause subsequent too_many_pipe_buffers_soft() tests to fail with -EPERM.

To remedy this, explicitly account for the pipe usage in
watch_queue_set_size() to match the number set via account_pipe_buffers()

(It's unclear why watch_queue_set_size() does not update nr_accounted;
it may be due to intentional overprovisioning in watch_queue_set_size()?)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/205028ebba838938d3b264dda1d0708fa7fe1ade
  - https://git.kernel.org/stable/c/2d680b988656bb556c863d8b46d9b9096842bf3d
  - https://git.kernel.org/stable/c/471c89b7d4f58bd6082f7c1fe14d4ca15c7f1284
  - https://git.kernel.org/stable/c/56ec918e6c86c1536870e4373e91eddd0c44245f
  - https://git.kernel.org/stable/c/6dafa27764183738dc5368b669b71e3d0d154f12
  - https://git.kernel.org/stable/c/8658c75343ed00e5e154ebbe24335f51ba8db547
  - https://git.kernel.org/stable/c/d40e3537265dea9e3c33021874437ff26dc18787
  - https://git.kernel.org/stable/c/f13abc1e8e1a3b7455511c4e122750127f6bc9b0

------------------------------------------------------------

CVE ID: CVE-2025-2073
Description: Out-of-Bounds Read in netfilter/ipset in Linux Kernel ChromeOS [6.1, 5.15, 5.10, 5.4, 4.19] allows a local attacker with low privileges to trigger an out-of-bounds read, potentially leading to information disclosure
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://issues.chromium.org/issues/b/380043638
  - https://issuetracker.google.com/issues/380043638

------------------------------------------------------------

CVE ID: CVE-2020-36789
Description: In the Linux kernel, the following vulnerability has been resolved:

can: dev: can_get_echo_skb(): prevent call to kfree_skb() in hard IRQ context

If a driver calls can_get_echo_skb() during a hardware IRQ (which is often, but
not always, the case), the 'WARN_ON(in_irq)' in
net/core/skbuff.c#skb_release_head_state() might be triggered, under network
congestion circumstances, together with the potential risk of a NULL pointer
dereference.

The root cause of this issue is the call to kfree_skb() instead of
dev_kfree_skb_irq() in net/core/dev.c#enqueue_to_backlog().

This patch prevents the skb to be freed within the call to netif_rx() by
incrementing its reference count with skb_get(). The skb is finally freed by
one of the in-irq-context safe functions: dev_consume_skb_any() or
dev_kfree_skb_any(). The "any" version is used because some drivers might call
can_get_echo_skb() in a normal context.

The reason for this issue to occur is that initially, in the core network
stack, loopback skb were not supposed to be received in hardware IRQ context.
The CAN stack is an exeption.

This bug was previously reported back in 2017 in [1] but the proposed patch
never got accepted.

While [1] directly modifies net/core/dev.c, we try to propose here a
smoother modification local to CAN network stack (the assumption
behind is that only CAN devices are affected by this issue).

[1] http://lore.kernel.org/r/57a3ffb6-3309-3ad5-5a34-e93c3fe3614d@cetitec.com
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.31, Last Version (Excluding): 4.4.244
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.5, Last Version (Excluding): 4.9.244
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.207
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.158
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.9.9
  - Vendor: linux, Product: linux_kernel, Version: 5.10, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.10, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2283f79b22684d2812e5c76fc2280aae00390365
  - https://git.kernel.org/stable/c/248b71ce92d4f3a574b2537f9838f48e892618f4
  - https://git.kernel.org/stable/c/3a922a85701939624484e7f2fd07d32beed00d25
  - https://git.kernel.org/stable/c/451187b20431924d13fcfecc500d7cd2d9951bac
  - https://git.kernel.org/stable/c/7e4cf2ec0ca236c3e5f904239cec6efe1f3baf22
  - https://git.kernel.org/stable/c/87530b557affe01c764de32dbeb58cdf47234574
  - https://git.kernel.org/stable/c/ab46748bf98864f9c3f5559060bf8caf9df2b41e

------------------------------------------------------------

CVE ID: CVE-2021-47668
Description: In the Linux kernel, the following vulnerability has been resolved:

can: dev: can_restart: fix use after free bug

After calling netif_rx_ni(skb), dereferencing skb is unsafe.
Especially, the can_frame cf which aliases skb memory is accessed
after the netif_rx_ni() in:
      stats->rx_bytes += cf->len;

Reordering the lines solves the issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.31, Last Version (Excluding): 4.4.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.5, Last Version (Excluding): 4.9.254
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.218
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.171
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.11
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/03f16c5075b22c8902d2af739969e878b0879c94
  - https://git.kernel.org/stable/c/08ab951787098ae0b6c0364aeea7a8138226f234
  - https://git.kernel.org/stable/c/260925a0b7d2da5449f8ecfd02c1405e0c8a45b8
  - https://git.kernel.org/stable/c/593c072b7b3c4d7044416eb039d9ad706bedd67a
  - https://git.kernel.org/stable/c/92668d28c7e6a7a2ba07df287669ffcdf650c421
  - https://git.kernel.org/stable/c/ac48ef15826e83f4206c47add61072e8fc76d328
  - https://git.kernel.org/stable/c/bbc6847b9b8978b520f62fbc7c68c54ef0f8d282

------------------------------------------------------------

CVE ID: CVE-2021-47669
Description: In the Linux kernel, the following vulnerability has been resolved:

can: vxcan: vxcan_xmit: fix use after free bug

After calling netif_rx_ni(skb), dereferencing skb is unsafe.
Especially, the canfd_frame cfd which aliases skb memory is accessed
after the netif_rx_ni().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 4.14.218
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.171
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.11
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/6d6dcf2399cdd26f7f5426ca8dd8366b7f2ca105
  - https://git.kernel.org/stable/c/75854cad5d80976f6ea0f0431f8cedd3bcc475cb
  - https://git.kernel.org/stable/c/9b820875a32a3443d67bfd368e93038354e98052
  - https://git.kernel.org/stable/c/a24476b37167816e6352ca1a2cf3769847774f70
  - https://git.kernel.org/stable/c/e771a874076115df8bff27d325edfd2340e4ec69

------------------------------------------------------------

CVE ID: CVE-2021-47670
Description: In the Linux kernel, the following vulnerability has been resolved:

can: peak_usb: fix use after free bugs

After calling peak_usb_netif_rx_ni(skb), dereferencing skb is unsafe.
Especially, the can_frame cf which aliases skb memory is accessed
after the peak_usb_netif_rx_ni().

Reordering the lines solves the issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.0, Last Version (Excluding): 4.19.171
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.93
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.11
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 5.11, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/50aca891d7a554db0901b245167cd653d73aaa71
  - https://git.kernel.org/stable/c/5408824636fa0dfedb9ecb0d94abd573131bfbbe
  - https://git.kernel.org/stable/c/ddd1416f44130377798c1430b76503513b7497c2
  - https://git.kernel.org/stable/c/ec939c13c3fff2114479769c8380b7f1a54feca9

------------------------------------------------------------

CVE ID: CVE-2021-47671
Description: In the Linux kernel, the following vulnerability has been resolved:

can: etas_es58x: es58x_rx_err_msg(): fix memory leak in error path

In es58x_rx_err_msg(), if can->do_set_mode() fails, the function
directly returns without calling netif_rx(skb). This means that the
skb previously allocated by alloc_can_err_skb() is not freed. In other
terms, this is a memory leak.

This patch simply removes the return statement in the error branch and
let the function continue.

Issue was found with GCC -fanalyzer, please follow the link below for
details.
Severity:
  - CVSS Version: 3.1
  - Base Score: 3.3
  - Base Severity: LOW
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.14.19
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.3
References:
  - https://git.kernel.org/stable/c/4f389e1276a5389c92cef860c9fde8e1c802a871
  - https://git.kernel.org/stable/c/7eb0881aec26099089f12ae850aebd93190b1dfe
  - https://git.kernel.org/stable/c/d9447f768bc8c60623e4bb3ce65b8f4654d33a50

------------------------------------------------------------

CVE ID: CVE-2025-37785
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix OOB read when checking dotdot dir

Mounting a corrupted filesystem with directory which contains '.' dir
entry with rec_len == block size results in out-of-bounds read (later
on, when the corrupted directory is removed).

ext4_empty_dir() assumes every ext4 directory contains at least '.'
and '..' as directory entries in the first data block. It first loads
the '.' dir entry, performs sanity checks by calling ext4_check_dir_entry()
and then uses its rec_len member to compute the location of '..' dir
entry (in ext4_next_entry). It assumes the '..' dir entry fits into the
same data block.

If the rec_len of '.' is precisely one block (4KB), it slips through the
sanity checks (it is considered the last directory entry in the data
block) and leaves "struct ext4_dir_entry_2 *de" point exactly past the
memory slot allocated to the data block. The following call to
ext4_check_dir_entry() on new value of de then dereferences this pointer
which results in out-of-bounds mem access.

Fix this by extending __ext4_check_dir_entry() to check for '.' dir
entries that reach the end of data block. Make sure to ignore the phony
dir entries for checksum (by checking name_len for non-zero).

Note: This is reported by KASAN as use-after-free in case another
structure was recently freed from the slot past the bound, but it is
really an OOB read.

This issue was found by syzkaller tool.

Call Trace:
[   38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710
[   38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375
[   38.595158]
[   38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1
[   38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
[   38.595304] Call Trace:
[   38.595308]  <TASK>
[   38.595311]  dump_stack_lvl+0xa7/0xd0
[   38.595325]  print_address_description.constprop.0+0x2c/0x3f0
[   38.595339]  ? __ext4_check_dir_entry+0x67e/0x710
[   38.595349]  print_report+0xaa/0x250
[   38.595359]  ? __ext4_check_dir_entry+0x67e/0x710
[   38.595368]  ? kasan_addr_to_slab+0x9/0x90
[   38.595378]  kasan_report+0xab/0xe0
[   38.595389]  ? __ext4_check_dir_entry+0x67e/0x710
[   38.595400]  __ext4_check_dir_entry+0x67e/0x710
[   38.595410]  ext4_empty_dir+0x465/0x990
[   38.595421]  ? __pfx_ext4_empty_dir+0x10/0x10
[   38.595432]  ext4_rmdir.part.0+0x29a/0xd10
[   38.595441]  ? __dquot_initialize+0x2a7/0xbf0
[   38.595455]  ? __pfx_ext4_rmdir.part.0+0x10/0x10
[   38.595464]  ? __pfx___dquot_initialize+0x10/0x10
[   38.595478]  ? down_write+0xdb/0x140
[   38.595487]  ? __pfx_down_write+0x10/0x10
[   38.595497]  ext4_rmdir+0xee/0x140
[   38.595506]  vfs_rmdir+0x209/0x670
[   38.595517]  ? lookup_one_qstr_excl+0x3b/0x190
[   38.595529]  do_rmdir+0x363/0x3c0
[   38.595537]  ? __pfx_do_rmdir+0x10/0x10
[   38.595544]  ? strncpy_from_user+0x1ff/0x2e0
[   38.595561]  __x64_sys_unlinkat+0xf0/0x130
[   38.595570]  do_syscall_64+0x5b/0x180
[   38.595583]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.19, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/14da7dbecb430e35b5889da8dae7bef33173b351
  - https://git.kernel.org/stable/c/52a5509ab19a5d3afe301165d9b5787bba34d842
  - https://git.kernel.org/stable/c/53bc45da8d8da92ec07877f5922b130562eb4b00
  - https://git.kernel.org/stable/c/89503e5eae64637d0fa2218912b54660effe7d93
  - https://git.kernel.org/stable/c/ac28c5684c1cdab650a7e5065b19e91577d37a4b
  - https://git.kernel.org/stable/c/b47584c556444cf7acb66b26a62cbc348eb92b78
  - https://git.kernel.org/stable/c/b7531a4f99c3887439d778afaf418d1a01a5f01b
  - https://git.kernel.org/stable/c/d5e206778e96e8667d3bde695ad372c296dc9353
  - https://git.kernel.org/stable/c/e47f472a664d70a3d104a6c2a035cdff55a719b4

------------------------------------------------------------

CVE ID: CVE-2025-37860
Description: In the Linux kernel, the following vulnerability has been resolved:

sfc: fix NULL dereferences in ef100_process_design_param()

Since cited commit, ef100_probe_main() and hence also
 ef100_check_design_params() run before efx->net_dev is created;
 consequently, we cannot netif_set_tso_max_size() or _segs() at this
 point.
Move those netif calls to ef100_probe_netdev(), and also replace
 netif_err within the design params code with pci_err.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/8241ecec1cdc6699ae197d52d58e76bddd995fa5
  - https://git.kernel.org/stable/c/e56391011381d6d029da377a65ac314cb3d5def2

------------------------------------------------------------

CVE ID: CVE-2025-37893
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: BPF: Fix off-by-one error in build_prologue()

Vincent reported that running BPF progs with tailcalls on LoongArch
causes kernel hard lockup. Debugging the issues shows that the JITed
image missing a jirl instruction at the end of the epilogue.

There are two passes in JIT compiling, the first pass set the flags and
the second pass generates JIT code based on those flags. With BPF progs
mixing bpf2bpf and tailcalls, build_prologue() generates N insns in the
first pass and then generates N+1 insns in the second pass. This makes
epilogue_offset off by one and we will jump to some unexpected insn and
cause lockup. Fix this by inserting a nop insn.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/205a2182c51ffebaef54d643e3745e720cded08b
  - https://git.kernel.org/stable/c/48b904de2408af5f936f0e03f48dfcddeab58aa0
  - https://git.kernel.org/stable/c/7e2586991e36663c9bc48c828b83eab180ad30a9
  - https://git.kernel.org/stable/c/b3ffad2f02db4aace6799fe0049508b8925eae45
  - https://git.kernel.org/stable/c/c74d95a5679741ef428974ab788f5b0758dc78ae

------------------------------------------------------------

CVE ID: CVE-2025-37925
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: reject on-disk inodes of an unsupported type

Syzbot has reported the following BUG:

kernel BUG at fs/inode.c:668!
Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
CPU: 3 UID: 0 PID: 139 Comm: jfsCommit Not tainted 6.12.0-rc4-syzkaller-00085-g4e46774408d9 #0
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014
RIP: 0010:clear_inode+0x168/0x190
Code: 4c 89 f7 e8 ba fe e5 ff e9 61 ff ff ff 44 89 f1 80 e1 07 80 c1 03 38 c1 7c c1 4c 89 f7 e8 90 ff e5 ff eb b7
 0b e8 01 5d 7f ff 90 0f 0b e8 f9 5c 7f ff 90 0f 0b e8 f1 5c 7f
RSP: 0018:ffffc900027dfae8 EFLAGS: 00010093
RAX: ffffffff82157a87 RBX: 0000000000000001 RCX: ffff888104d4b980
RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000000
RBP: ffffc900027dfc90 R08: ffffffff82157977 R09: fffff520004fbf38
R10: dffffc0000000000 R11: fffff520004fbf38 R12: dffffc0000000000
R13: ffff88811315bc00 R14: ffff88811315bda8 R15: ffff88811315bb80
FS:  0000000000000000(0000) GS:ffff888135f00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00005565222e0578 CR3: 0000000026ef0000 CR4: 00000000000006f0
Call Trace:
 <TASK>
 ? __die_body+0x5f/0xb0
 ? die+0x9e/0xc0
 ? do_trap+0x15a/0x3a0
 ? clear_inode+0x168/0x190
 ? do_error_trap+0x1dc/0x2c0
 ? clear_inode+0x168/0x190
 ? __pfx_do_error_trap+0x10/0x10
 ? report_bug+0x3cd/0x500
 ? handle_invalid_op+0x34/0x40
 ? clear_inode+0x168/0x190
 ? exc_invalid_op+0x38/0x50
 ? asm_exc_invalid_op+0x1a/0x20
 ? clear_inode+0x57/0x190
 ? clear_inode+0x167/0x190
 ? clear_inode+0x168/0x190
 ? clear_inode+0x167/0x190
 jfs_evict_inode+0xb5/0x440
 ? __pfx_jfs_evict_inode+0x10/0x10
 evict+0x4ea/0x9b0
 ? __pfx_evict+0x10/0x10
 ? iput+0x713/0xa50
 txUpdateMap+0x931/0xb10
 ? __pfx_txUpdateMap+0x10/0x10
 jfs_lazycommit+0x49a/0xb80
 ? _raw_spin_unlock_irqrestore+0x8f/0x140
 ? lockdep_hardirqs_on+0x99/0x150
 ? __pfx_jfs_lazycommit+0x10/0x10
 ? __pfx_default_wake_function+0x10/0x10
 ? __kthread_parkme+0x169/0x1d0
 ? __pfx_jfs_lazycommit+0x10/0x10
 kthread+0x2f2/0x390
 ? __pfx_jfs_lazycommit+0x10/0x10
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x4d/0x80
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK>

This happens when 'clear_inode()' makes an attempt to finalize an underlying
JFS inode of unknown type. According to JFS layout description from
https://jfs.sourceforge.net/project/pub/jfslayout.pdf, inode types from 5 to
15 are reserved for future extensions and should not be encountered on a valid
filesystem. So add an extra check for valid inode type in 'copy_from_dinode()'.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.1, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/8987891c4653874d5e3f5d11f063912f4e0b58eb
  - https://git.kernel.org/stable/c/8c3f9a70d2d4dd6c640afe294b05c6a0a45434d9

------------------------------------------------------------

CVE ID: CVE-2025-38049
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/resctrl: Fix allocation of cleanest CLOSID on platforms with no monitors

Commit

  6eac36bb9eb0 ("x86/resctrl: Allocate the cleanest CLOSID by searching closid_num_dirty_rmid")

added logic that causes resctrl to search for the CLOSID with the fewest dirty
cache lines when creating a new control group, if requested by the arch code.
This depends on the values read from the llc_occupancy counters. The logic is
applicable to architectures where the CLOSID effectively forms part of the
monitoring identifier and so do not allow complete freedom to choose an unused
monitoring identifier for a given CLOSID.

This support missed that some platforms may not have these counters.  This
causes a NULL pointer dereference when creating a new control group as the
array was not allocated by dom_data_init().

As this feature isn't necessary on platforms that don't have cache occupancy
monitors, add this to the check that occurs when a new control group is
allocated.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.9, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/93a418fc61da13d1ee4047d4d1327990f7a2816a
  - https://git.kernel.org/stable/c/a121798ae669351ec0697c94f71c3a692b2a755b
  - https://git.kernel.org/stable/c/a8a1bcc27d4607227088d80483164289b5348293
  - https://git.kernel.org/stable/c/ed5addb55e403ad6598102bcf546e068ae01fef6

------------------------------------------------------------

CVE ID: CVE-2025-38104
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Replace Mutex with Spinlock for RLCG register access to avoid Priority Inversion in SRIOV

RLCG Register Access is a way for virtual functions to safely access GPU
registers in a virtualized environment., including TLB flushes and
register reads. When multiple threads or VFs try to access the same
registers simultaneously, it can lead to race conditions. By using the
RLCG interface, the driver can serialize access to the registers. This
means that only one thread can access the registers at a time,
preventing conflicts and ensuring that operations are performed
correctly. Additionally, when a low-priority task holds a mutex that a
high-priority task needs, ie., If a thread holding a spinlock tries to
acquire a mutex, it can lead to priority inversion. register access in
amdgpu_virt_rlcg_reg_rw especially in a fast code path is critical.

The call stack shows that the function amdgpu_virt_rlcg_reg_rw is being
called, which attempts to acquire the mutex. This function is invoked
from amdgpu_sriov_wreg, which in turn is called from
gmc_v11_0_flush_gpu_tlb.

The [ BUG: Invalid wait context ] indicates that a thread is trying to
acquire a mutex while it is in a context that does not allow it to sleep
(like holding a spinlock).

Fixes the below:

[  253.013423] =============================
[  253.013434] [ BUG: Invalid wait context ]
[  253.013446] 6.12.0-amdstaging-drm-next-lol-050225 #14 Tainted: G     U     OE
[  253.013464] -----------------------------
[  253.013475] kworker/0:1/10 is trying to lock:
[  253.013487] ffff9f30542e3cf8 (&adev->virt.rlcg_reg_lock){+.+.}-{3:3}, at: amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu]
[  253.013815] other info that might help us debug this:
[  253.013827] context-{4:4}
[  253.013835] 3 locks held by kworker/0:1/10:
[  253.013847]  #0: ffff9f3040050f58 ((wq_completion)events){+.+.}-{0:0}, at: process_one_work+0x3f5/0x680
[  253.013877]  #1: ffffb789c008be40 ((work_completion)(&wfc.work)){+.+.}-{0:0}, at: process_one_work+0x1d6/0x680
[  253.013905]  #2: ffff9f3054281838 (&adev->gmc.invalidate_lock){+.+.}-{2:2}, at: gmc_v11_0_flush_gpu_tlb+0x198/0x4f0 [amdgpu]
[  253.014154] stack backtrace:
[  253.014164] CPU: 0 UID: 0 PID: 10 Comm: kworker/0:1 Tainted: G     U     OE      6.12.0-amdstaging-drm-next-lol-050225 #14
[  253.014189] Tainted: [U]=USER, [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
[  253.014203] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 11/18/2024
[  253.014224] Workqueue: events work_for_cpu_fn
[  253.014241] Call Trace:
[  253.014250]  <TASK>
[  253.014260]  dump_stack_lvl+0x9b/0xf0
[  253.014275]  dump_stack+0x10/0x20
[  253.014287]  __lock_acquire+0xa47/0x2810
[  253.014303]  ? srso_alias_return_thunk+0x5/0xfbef5
[  253.014321]  lock_acquire+0xd1/0x300
[  253.014333]  ? amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu]
[  253.014562]  ? __lock_acquire+0xa6b/0x2810
[  253.014578]  __mutex_lock+0x85/0xe20
[  253.014591]  ? amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu]
[  253.014782]  ? sched_clock_noinstr+0x9/0x10
[  253.014795]  ? srso_alias_return_thunk+0x5/0xfbef5
[  253.014808]  ? local_clock_noinstr+0xe/0xc0
[  253.014822]  ? amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu]
[  253.015012]  ? srso_alias_return_thunk+0x5/0xfbef5
[  253.015029]  mutex_lock_nested+0x1b/0x30
[  253.015044]  ? mutex_lock_nested+0x1b/0x30
[  253.015057]  amdgpu_virt_rlcg_reg_rw+0xf6/0x330 [amdgpu]
[  253.015249]  amdgpu_sriov_wreg+0xc5/0xd0 [amdgpu]
[  253.015435]  gmc_v11_0_flush_gpu_tlb+0x44b/0x4f0 [amdgpu]
[  253.015667]  gfx_v11_0_hw_init+0x499/0x29c0 [amdgpu]
[  253.015901]  ? __pfx_smu_v13_0_update_pcie_parameters+0x10/0x10 [amdgpu]
[  253.016159]  ? srso_alias_return_thunk+0x5/0xfbef5
[  253.016173]  ? smu_hw_init+0x18d/0x300 [amdgpu]
[  253.016403]  amdgpu_device_init+0x29ad/0x36a0 [amdgpu]
[  253.016614]  amdgpu_driver_load_kms+0x1a/0xc0 [amdgpu]
[  253.0170
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c0378830e42c98acd69e0289882c8637d92f285
  - https://git.kernel.org/stable/c/5c1741a0c176ae11675a64cb7f2dd21d72db6b91
  - https://git.kernel.org/stable/c/dc0297f3198bd60108ccbd167ee5d9fa4af31ed0

------------------------------------------------------------

CVE ID: CVE-2025-38152
Description: In the Linux kernel, the following vulnerability has been resolved:

remoteproc: core: Clear table_sz when rproc_shutdown

There is case as below could trigger kernel dump:
Use U-Boot to start remote processor(rproc) with resource table
published to a fixed address by rproc. After Kernel boots up,
stop the rproc, load a new firmware which doesn't have resource table
,and start rproc.

When starting rproc with a firmware not have resource table,
`memcpy(loaded_table, rproc->cached_table, rproc->table_sz)` will
trigger dump, because rproc->cache_table is set to NULL during the last
stop operation, but rproc->table_sz is still valid.

This issue is found on i.MX8MP and i.MX9.

Dump as below:
Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
Mem abort info:
  ESR = 0x0000000096000004
  EC = 0x25: DABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
  FSC = 0x04: level 0 translation fault
Data abort info:
  ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000
  CM = 0, WnR = 0, TnD = 0, TagAccess = 0
  GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
user pgtable: 4k pages, 48-bit VAs, pgdp=000000010af63000
[0000000000000000] pgd=0000000000000000, p4d=0000000000000000
Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
Modules linked in:
CPU: 2 UID: 0 PID: 1060 Comm: sh Not tainted 6.14.0-rc7-next-20250317-dirty #38
Hardware name: NXP i.MX8MPlus EVK board (DT)
pstate: a0000005 (NzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : __pi_memcpy_generic+0x110/0x22c
lr : rproc_start+0x88/0x1e0
Call trace:
 __pi_memcpy_generic+0x110/0x22c (P)
 rproc_boot+0x198/0x57c
 state_store+0x40/0x104
 dev_attr_store+0x18/0x2c
 sysfs_kf_write+0x7c/0x94
 kernfs_fop_write_iter+0x120/0x1cc
 vfs_write+0x240/0x378
 ksys_write+0x70/0x108
 __arm64_sys_write+0x1c/0x28
 invoke_syscall+0x48/0x10c
 el0_svc_common.constprop.0+0xc0/0xe0
 do_el0_svc+0x1c/0x28
 el0_svc+0x30/0xcc
 el0t_64_sync_handler+0x10c/0x138
 el0t_64_sync+0x198/0x19c

Clear rproc->table_sz to address the issue.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.13, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/068f6648ff5b0c7adeb6c363fae7fb188aa178fa
  - https://git.kernel.org/stable/c/2df19f5f6f72da6f6ebab7cdb3a3b9f7686bb476
  - https://git.kernel.org/stable/c/6e66bca8cd51ebedd5d32426906a38e4a3c69c5f
  - https://git.kernel.org/stable/c/7c6bb82a6f3da6ab2d3fbea03901482231708b98
  - https://git.kernel.org/stable/c/8e0fd2a3b9852ac3cf540edb06ccc0153b38b5af
  - https://git.kernel.org/stable/c/e6015ca453b82ec54aec9682dcc38773948fcc48
  - https://git.kernel.org/stable/c/efdde3d73ab25cef4ff2d06783b0aad8b093c0e4

------------------------------------------------------------

CVE ID: CVE-2025-38240
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/mediatek: dp: drm_err => dev_err in HPD path to avoid NULL ptr

The function mtk_dp_wait_hpd_asserted() may be called before the
`mtk_dp->drm_dev` pointer is assigned in mtk_dp_bridge_attach().
Specifically it can be called via this callpath:
 - mtk_edp_wait_hpd_asserted
 - [panel probe]
 - dp_aux_ep_probe

Using "drm" level prints anywhere in this callpath causes a NULL
pointer dereference. Change the error message directly in
mtk_dp_wait_hpd_asserted() to dev_err() to avoid this. Also change the
error messages in mtk_dp_parse_capabilities(), which is called by
mtk_dp_wait_hpd_asserted().

While touching these prints, also add the error code to them to make
future debugging easier.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/106a6de46cf4887d535018185ec528ce822d6d84
  - https://git.kernel.org/stable/c/13ec849fd2eab808ee8eba2625df7ebea3b85edf
  - https://git.kernel.org/stable/c/149a5c38436c229950cf1020992ce65c9549bc19
  - https://git.kernel.org/stable/c/2fda391ef7a701748abd7fa32232981b522c1e07
  - https://git.kernel.org/stable/c/57a9fb47551b33cde7b76d17c0072c3b394f4620

------------------------------------------------------------

CVE ID: CVE-2025-38479
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: fsl-edma: free irq correctly in remove path

Add fsl_edma->txirq/errirq check to avoid below warning because no
errirq at i.MX9 platform. Otherwise there will be kernel dump:
WARNING: CPU: 0 PID: 11 at kernel/irq/devres.c:144 devm_free_irq+0x74/0x80
Modules linked in:
CPU: 0 UID: 0 PID: 11 Comm: kworker/u8:0 Not tainted 6.12.0-rc7#18
Hardware name: NXP i.MX93 11X11 EVK board (DT)
Workqueue: events_unbound deferred_probe_work_func
pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : devm_free_irq+0x74/0x80
lr : devm_free_irq+0x48/0x80
Call trace:
 devm_free_irq+0x74/0x80 (P)
 devm_free_irq+0x48/0x80 (L)
 fsl_edma_remove+0xc4/0xc8
 platform_remove+0x28/0x44
 device_remove+0x4c/0x80
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/38ff8769074db27387cb2323aaa751e59d168e6a
  - https://git.kernel.org/stable/c/55e2dbe2ba787d4fc2306f6bb2f43fb32176e184
  - https://git.kernel.org/stable/c/f3834d2d68749e4760c27325149765930ad876fd
  - https://git.kernel.org/stable/c/fa70c4c3c580c239a0f9e83a14770ab026e8d820

------------------------------------------------------------

CVE ID: CVE-2025-38575
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: use aead_request_free to match aead_request_alloc

Use aead_request_free() instead of kfree() to properly free memory
allocated by aead_request_alloc(). This ensures sensitive crypto data
is zeroed before being freed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1de7fec4d3012672e31eeb6679ea60f7ca010ef9
  - https://git.kernel.org/stable/c/3e341dbd5f5a6e5a558e67da80731dc38a7f758c
  - https://git.kernel.org/stable/c/46caeae23035192b9cc41872c827f30d0233f16e
  - https://git.kernel.org/stable/c/571b342d4688801fc1f6a1934389dac09425dc93
  - https://git.kernel.org/stable/c/6171063e9d046ffa46f51579b2ca4a43caef581a
  - https://git.kernel.org/stable/c/a6b594868268c3a7bfaeced912525cd2c445529a
  - https://git.kernel.org/stable/c/aef10ccd74512c52e30c5ee19d0031850973e78d

------------------------------------------------------------

CVE ID: CVE-2025-38637
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: skbprio: Remove overly strict queue assertions

In the current implementation, skbprio enqueue/dequeue contains an assertion
that fails under certain conditions when SKBPRIO is used as a child qdisc under
TBF with specific parameters. The failure occurs because TBF sometimes peeks at
packets in the child qdisc without actually dequeuing them when tokens are
unavailable.

This peek operation creates a discrepancy between the parent and child qdisc
queue length counters. When TBF later receives a high-priority packet,
SKBPRIO's queue length may show a different value than what's reflected in its
internal priority queue tracking, triggering the assertion.

The fix removes this overly strict assertions in SKBPRIO, they are not
necessary at all.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/034b293bf17c124fec0f0e663f81203b00aa7a50
  - https://git.kernel.org/stable/c/1284733bab736e598341f1d3f3b94e2a322864a8
  - https://git.kernel.org/stable/c/1dcc144c322a8d526b791135604c0663f1af9d85
  - https://git.kernel.org/stable/c/2286770b07cb5268c03d11274b8efd43dff0d380
  - https://git.kernel.org/stable/c/2f35b7673a3aa3d09b3eb05811669622ebaa98ca
  - https://git.kernel.org/stable/c/32ee79682315e6d3c99947b3f38b078a09a66919
  - https://git.kernel.org/stable/c/7abc8318ce0712182bf0783dcfdd9a6a8331160e
  - https://git.kernel.org/stable/c/864ca690ff135078d374bd565b9872f161c614bc
  - https://git.kernel.org/stable/c/ce8fe975fd99b49c29c42e50f2441ba53112b2e8

------------------------------------------------------------

CVE ID: CVE-2025-39688
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: allow SC_STATUS_FREEABLE when searching via nfs4_lookup_stateid()

The pynfs DELEG8 test fails when run against nfsd. It acquires a
delegation and then lets the lease time out. It then tries to use the
deleg stateid and expects to see NFS4ERR_DELEG_REVOKED, but it gets
bad NFS4ERR_BAD_STATEID instead.

When a delegation is revoked, it's initially marked with
SC_STATUS_REVOKED, or SC_STATUS_ADMIN_REVOKED and later, it's marked
with the SC_STATUS_FREEABLE flag, which denotes that it is waiting for
s FREE_STATEID call.

nfs4_lookup_stateid() accepts a statusmask that includes the status
flags that a found stateid is allowed to have. Currently, that mask
never includes SC_STATUS_FREEABLE, which means that revoked delegations
are (almost) never found.

Add SC_STATUS_FREEABLE to the always-allowed status flags, and remove it
from nfsd4_delegreturn() since it's now always implied.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/52e209203c35a4fbff8af23cd3613efe5df40102
  - https://git.kernel.org/stable/c/5bcb44e650bc4ec7eac23df90c5e011a77fa2beb
  - https://git.kernel.org/stable/c/d1bc15b147d35b4cb7ca99a9a7d79d41ca342c13
  - https://git.kernel.org/stable/c/dc6f3295905d7185e71091870119a8c11c3808cc

------------------------------------------------------------

CVE ID: CVE-2025-39728
Description: In the Linux kernel, the following vulnerability has been resolved:

clk: samsung: Fix UBSAN panic in samsung_clk_init()

With UBSAN_ARRAY_BOUNDS=y, I'm hitting the below panic due to
dereferencing `ctx->clk_data.hws` before setting
`ctx->clk_data.num = nr_clks`. Move that up to fix the crash.

  UBSAN: array index out of bounds: 00000000f2005512 [#1] PREEMPT SMP
  <snip>
  Call trace:
   samsung_clk_init+0x110/0x124 (P)
   samsung_clk_init+0x48/0x124 (L)
   samsung_cmu_register_one+0x3c/0xa0
   exynos_arm64_register_cmu+0x54/0x64
   __gs101_cmu_top_of_clk_init_declare+0x28/0x60
   ...
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/00307934eb94aaa0a99addfb37b9fe206f945004
  - https://git.kernel.org/stable/c/0fef48f4a70e45a93e73c39023c3a6ea624714d6
  - https://git.kernel.org/stable/c/157de9e48007a20c65d02fc0229a16f38134a72d
  - https://git.kernel.org/stable/c/24307866e0ac0a5ddb462e766ceda5e27a6fbbe3
  - https://git.kernel.org/stable/c/4d29a6dcb51e346595a15b49693eeb728925ca43
  - https://git.kernel.org/stable/c/a1500b98cd81a32fdfb9bc63c33bb9f0c2a0a1bf
  - https://git.kernel.org/stable/c/d19d7345a7bcdb083b65568a11b11adffe0687af
  - https://git.kernel.org/stable/c/d974e177369c034984cece9d7d4fada9f8b9c740

------------------------------------------------------------

CVE ID: CVE-2025-39735
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: fix slab-out-of-bounds read in ea_get()

During the "size_check" label in ea_get(), the code checks if the extended
attribute list (xattr) size matches ea_size. If not, it logs
"ea_get: invalid extended attribute" and calls print_hex_dump().

Here, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds
INT_MAX (2,147,483,647). Then ea_size is clamped:

	int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));

Although clamp_t aims to bound ea_size between 0 and 4110417968, the upper
limit is treated as an int, causing an overflow above 2^31 - 1. This leads
"size" to wrap around and become negative (-184549328).

The "size" is then passed to print_hex_dump() (called "len" in
print_hex_dump()), it is passed as type size_t (an unsigned
type), this is then stored inside a variable called
"int remaining", which is then assigned to "int linelen" which
is then passed to hex_dump_to_buffer(). In print_hex_dump()
the for loop, iterates through 0 to len-1, where len is
18446744073525002176, calling hex_dump_to_buffer()
on each iteration:

	for (i = 0; i < len; i += rowsize) {
		linelen = min(remaining, rowsize);
		remaining -= rowsize;

		hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
				   linebuf, sizeof(linebuf), ascii);

		...
	}

The expected stopping condition (i < len) is effectively broken
since len is corrupted and very large. This eventually leads to
the "ptr+i" being passed to hex_dump_to_buffer() to get closer
to the end of the actual bounds of "ptr", eventually an out of
bounds access is done in hex_dump_to_buffer() in the following
for loop:

	for (j = 0; j < len; j++) {
			if (linebuflen < lx + 2)
				goto overflow2;
			ch = ptr[j];
		...
	}

To fix this we should validate "EALIST_SIZE(ea_buf->xattr)"
before it is utilised.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.325, Last Version (Excluding): 4.20
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.287, Last Version (Excluding): 5.4.292
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.231, Last Version (Excluding): 5.10.236
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.174, Last Version (Excluding): 5.15.180
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1.120, Last Version (Excluding): 6.1.134
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6.64, Last Version (Excluding): 6.6.87
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11.11, Last Version (Excluding): 6.12
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.12.2, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0beddc2a3f9b9cf7d8887973041e36c2d0fa3652
  - https://git.kernel.org/stable/c/16d3d36436492aa248b2d8045e75585ebcc2f34d
  - https://git.kernel.org/stable/c/3d6fd5b9c6acbc005e53d0211c7381f566babec1
  - https://git.kernel.org/stable/c/46e2c031aa59ea65128991cbca474bd5c0c2ecdb
  - https://git.kernel.org/stable/c/50afcee7011155933d8d5e8832f52eeee018cfd3
  - https://git.kernel.org/stable/c/5263822558a8a7c0d0248d5679c2dcf4d5cda61f
  - https://git.kernel.org/stable/c/78c9cbde8880ec02d864c166bcb4fe989ce1d95f
  - https://git.kernel.org/stable/c/a8c31808925b11393a6601f534bb63bac5366bab
  - https://git.kernel.org/stable/c/fdf480da5837c23b146c4743c18de97202fcab37

------------------------------------------------------------

CVE ID: CVE-2025-39755
Description: In the Linux kernel, the following vulnerability has been resolved:

staging: gpib: Fix cb7210 pcmcia Oops

The  pcmcia_driver struct was still only using the old .name
initialization in the drv field. This led to a NULL pointer
deref Oops in strcmp called from pcmcia_register_driver.

Initialize the pcmcia_driver struct name field.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/7ec50077d7f6647cb6ba3a2a20a6c26f51259c7d
  - https://git.kernel.org/stable/c/c1baf6528bcfd6a86842093ff3f8ff8caf309c12
  - https://git.kernel.org/stable/c/c82ae06f49e70d1c14ee9c76c392345856d050c9

------------------------------------------------------------

CVE ID: CVE-2025-39778
Description: In the Linux kernel, the following vulnerability has been resolved:

objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show()

The csts_state_names[] array only has six sparse entries, but the
iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a
potential out-of-bounds stack read.  Fix that.

Fixes the following warning with an UBSAN kernel:

  vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.11, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/0cc0efc58d6c741b2868d4af24874d7fec28a575
  - https://git.kernel.org/stable/c/107a23185d990e3df6638d9a84c835f963fe30a6
  - https://git.kernel.org/stable/c/1adc93a525fdee8e2b311e6d5fd93eb69714ca05
  - https://git.kernel.org/stable/c/8fbf37a3577b4d64c150cafde338eee17b2f2ea4

------------------------------------------------------------

CVE ID: CVE-2025-39930
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: simple-card-utils: Don't use __free(device_node) at graph_util_parse_dai()

commit 419d1918105e ("ASoC: simple-card-utils: use __free(device_node) for
device node") uses __free(device_node) for dlc->of_node, but we need to
keep it while driver is in use.

Don't use __free(device_node) in graph_util_parse_dai().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/232a32e8a7e9be8a2ee238df9b5304eed2f4e195
  - https://git.kernel.org/stable/c/de74ec718e0788e1998eb7289ad07970e27cae27

------------------------------------------------------------

CVE ID: CVE-2025-39989
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/mce: use is_copy_from_user() to determine copy-from-user context

Patch series "mm/hwpoison: Fix regressions in memory failure handling",
v4.

## 1. What am I trying to do:

This patchset resolves two critical regressions related to memory failure
handling that have appeared in the upstream kernel since version 5.17, as
compared to 5.10 LTS.

    - copyin case: poison found in user page while kernel copying from user space
    - instr case: poison found while instruction fetching in user space

## 2. What is the expected outcome and why

- For copyin case:

Kernel can recover from poison found where kernel is doing get_user() or
copy_from_user() if those places get an error return and the kernel return
-EFAULT to the process instead of crashing.  More specifily, MCE handler
checks the fixup handler type to decide whether an in kernel #MC can be
recovered.  When EX_TYPE_UACCESS is found, the PC jumps to recovery code
specified in _ASM_EXTABLE_FAULT() and return a -EFAULT to user space.

- For instr case:

If a poison found while instruction fetching in user space, full recovery
is possible.  User process takes #PF, Linux allocates a new page and fills
by reading from storage.


## 3. What actually happens and why

- For copyin case: kernel panic since v5.17

Commit 4c132d1d844a ("x86/futex: Remove .fixup usage") introduced a new
extable fixup type, EX_TYPE_EFAULT_REG, and later patches updated the
extable fixup type for copy-from-user operations, changing it from
EX_TYPE_UACCESS to EX_TYPE_EFAULT_REG.  It breaks previous EX_TYPE_UACCESS
handling when posion found in get_user() or copy_from_user().

- For instr case: user process is killed by a SIGBUS signal due to #CMCI
  and #MCE race

When an uncorrected memory error is consumed there is a race between the
CMCI from the memory controller reporting an uncorrected error with a UCNA
signature, and the core reporting and SRAR signature machine check when
the data is about to be consumed.

### Background: why *UN*corrected errors tied to *C*MCI in Intel platform [1]

Prior to Icelake memory controllers reported patrol scrub events that
detected a previously unseen uncorrected error in memory by signaling a
broadcast machine check with an SRAO (Software Recoverable Action
Optional) signature in the machine check bank.  This was overkill because
it's not an urgent problem that no core is on the verge of consuming that
bad data.  It's also found that multi SRAO UCE may cause nested MCE
interrupts and finally become an IERR.

Hence, Intel downgrades the machine check bank signature of patrol scrub
from SRAO to UCNA (Uncorrected, No Action required), and signal changed to
#CMCI.  Just to add to the confusion, Linux does take an action (in
uc_decode_notifier()) to try to offline the page despite the UC*NA*
signature name.

### Background: why #CMCI and #MCE race when poison is consuming in
    Intel platform [1]

Having decided that CMCI/UCNA is the best action for patrol scrub errors,
the memory controller uses it for reads too.  But the memory controller is
executing asynchronously from the core, and can't tell the difference
between a "real" read and a speculative read.  So it will do CMCI/UCNA if
an error is found in any read.

Thus:

1) Core is clever and thinks address A is needed soon, issues a
   speculative read.

2) Core finds it is going to use address A soon after sending the read
   request

3) The CMCI from the memory controller is in a race with MCE from the
   core that will soon try to retire the load from address A.

Quite often (because speculation has got better) the CMCI from the memory
controller is delivered before the core is committed to the instruction
reading address A, so the interrupt is taken, and Linux offlines the page
(marking it as poison).


## Why user process is killed for instr case

Commit 046545a661af ("mm/hwpoison: fix error page recovered but reported
"not
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b8388e97ba6a8c033f9a8b5565af41af07f9345
  - https://git.kernel.org/stable/c/1a15bb8303b6b104e78028b6c68f76a0d4562134
  - https://git.kernel.org/stable/c/3e3d8169c0950a0b3cd5105f6403a78350dcac80
  - https://git.kernel.org/stable/c/449413da90a337f343cc5a73070cbd68e92e8a54
  - https://git.kernel.org/stable/c/5724654a084f701dc64b08d34a0e800f22f0e6e4

------------------------------------------------------------

CVE ID: CVE-2025-40014
Description: In the Linux kernel, the following vulnerability has been resolved:

objtool, spi: amd: Fix out-of-bounds stack access in amd_set_spi_freq()

If speed_hz < AMD_SPI_MIN_HZ, amd_set_spi_freq() iterates over the
entire amd_spi_freq array without breaking out early, causing 'i' to go
beyond the array bounds.

Fix that by stopping the loop when it gets to the last entry, so the low
speed_hz value gets clamped up to AMD_SPI_MIN_HZ.

Fixes the following warning with an UBSAN kernel:

  drivers/spi/spi-amd.o: error: objtool: amd_set_spi_freq() falls through to next function amd_spi_set_opcode()
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.1, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/76e51db43fe4aaaebcc5ddda67b0807f7c9bdecc
  - https://git.kernel.org/stable/c/7f2c746e09a3746bf937bc708129dc8af61d8f19

------------------------------------------------------------

CVE ID: CVE-2025-40114
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: light: Add check for array bounds in veml6075_read_int_time_ms

The array contains only 5 elements, but the index calculated by
veml6075_read_int_time_index can range from 0 to 7,
which could lead to out-of-bounds access. The check prevents this issue.

Coverity Issue
CID 1574309: (#1 of 1): Out-of-bounds read (OVERRUN)
overrun-local: Overrunning array veml6075_it_ms of 5 4-byte
elements at element index 7 (byte offset 31) using
index int_index (which evaluates to 7)

This is hardening against potentially broken hardware. Good to have
but not necessary to backport.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.8, Last Version (Excluding): 6.12.23
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.11
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.2
References:
  - https://git.kernel.org/stable/c/18a08b5632809faa671279b3cd27d5f96cc5a3f0
  - https://git.kernel.org/stable/c/7a40b52d4442178bee0cf1c36bc450ab951cef0f
  - https://git.kernel.org/stable/c/9c40a68b7f97fa487e6c7e67fcf4f846a1f96692
  - https://git.kernel.org/stable/c/ee735aa33db16c1fb5ebccbaf84ad38f5583f3cc

------------------------------------------------------------

CVE ID: CVE-2025-40325
Description: In the Linux kernel, the following vulnerability has been resolved:

md/raid10: wait barrier before returning discard request with REQ_NOWAIT

raid10_handle_discard should wait barrier before returning a discard bio
which has REQ_NOWAIT. And there is no need to print warning calltrace
if a discard bio has REQ_NOWAIT flag. Quality engineer usually checks
dmesg and reports error if dmesg has warning/error calltrace.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/31d3156efe909b53ba174861a3da880c688f5edc
  - https://git.kernel.org/stable/c/3db4404435397a345431b45f57876a3df133f3b4

------------------------------------------------------------

CVE ID: CVE-2025-40364
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring: fix io_req_prep_async with provided buffers

io_req_prep_async() can import provided buffers, commit the ring state
by giving up on that before, it'll be reimported later if needed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a1b17713b32c75a90132ea2f92b1257f3bbc20f3
  - https://git.kernel.org/stable/c/a94592ec30ff67dc36c424327f1e0a9ceeeb9bd3

------------------------------------------------------------

CVE ID: CVE-2025-37838
Description: In the Linux kernel, the following vulnerability has been resolved:

HSI: ssi_protocol: Fix use after free vulnerability in ssi_protocol Driver Due to Race Condition

In the ssi_protocol_probe() function, &ssi->work is bound with
ssip_xmit_work(), In ssip_pn_setup(), the ssip_pn_xmit() function
within the ssip_pn_ops structure is capable of starting the
work.

If we remove the module which will call ssi_protocol_remove()
to make a cleanup, it will free ssi through kfree(ssi),
while the work mentioned above will be used. The sequence
of operations that may lead to a UAF bug is as follows:

CPU0                                    CPU1

                        | ssip_xmit_work
ssi_protocol_remove     |
kfree(ssi);             |
                        | struct hsi_client *cl = ssi->cl;
                        | // use ssi

Fix it by ensuring that the work is canceled before proceeding
with the cleanup in ssi_protocol_remove().
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 6.1.135
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.2, Last Version (Excluding): 6.6.88
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.12.24
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.13, Last Version (Excluding): 6.13.12
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.14, Last Version (Excluding): 6.14.3
References:
  - https://git.kernel.org/stable/c/4a8c29beb8a02b5a0a9d77d608aa14b6f88a6b86
  - https://git.kernel.org/stable/c/4b4194c9a7a8f92db39e8e86c85f4fb12ebbec4f
  - https://git.kernel.org/stable/c/58eb29dba712ab0f13af59ca2fe545f5ce360e78
  - https://git.kernel.org/stable/c/72972552d0d0bfeb2dec5daf343a19018db36ffa
  - https://git.kernel.org/stable/c/834e602d0cc7c743bfce734fad4a46cefc0f9ab1
  - https://git.kernel.org/stable/c/ae5a6a0b425e8f76a9f0677e50796e494e89b088
  - https://git.kernel.org/stable/c/d03abc1c2b21324550fa71e12d53e7d3498e0af6
  - https://git.kernel.org/stable/c/d58493832e284f066e559b8da5ab20c15a2801d3
  - https://git.kernel.org/stable/c/e3f88665a78045fe35c7669d2926b8d97b892c11

------------------------------------------------------------

CVE ID: CVE-2024-12862
Description: Incorrect Authorization vulnerability in the OpenText Content Server REST API on Windows, Linux allows users without the appropriate permissions to remove external collaborators.This issue affects Content Server: 20.2-24.4.
Severity:
  - CVSS Version: 4.0
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:4.0/AV:N/AC:H/AT:P/PR:H/UI:N/VC:L/VI:L/VA:N/SC:H/SI:H/SA:H/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - No CPE data available.
References:
  - https://support.opentext.com/csm?id=ot_kb_unauthenticated&sysparm_article=KB0839115

------------------------------------------------------------

CVE ID: CVE-2024-12863
Description: Stored XSS in Discussions in OpenText Content Management CE 20.2 to 25.1 on Windows and Linux allows authenticated malicious users to inject code into the system.
Severity:
  - CVSS Version: 4.0
  - Base Score: 5.6
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:4.0/AV:N/AC:L/AT:P/PR:H/UI:A/VC:L/VI:H/VA:N/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - No CPE data available.
References:
  - https://support.opentext.com/csm?id=ot_kb_unauthenticated&sysparm_article=KB0839121

------------------------------------------------------------

CVE ID: CVE-2024-12543
Description: User Enumeration and Data Integrity in Barcode functionality in OpenText Content Management versions 24.3-25.1on Windows and Linux allows a malicous authenticated attacker to potentially alter barcode attributes.
Severity:
  - CVSS Version: 4.0
  - Base Score: 5.9
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:4.0/AV:N/AC:H/AT:P/PR:H/UI:N/VC:L/VI:H/VA:N/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - No CPE data available.
References:
  - https://support.opentext.com/csm?id=ot_kb_unauthenticated&sysparm_article=KB0839119

------------------------------------------------------------

CVE ID: CVE-2025-1731
Description: An incorrect permission assignment vulnerability in the PostgreSQL commands of the USG FLEX H series uOS firmware versions from V1.20 through V1.31 could allow an authenticated local attacker with low privileges to gain access to the Linux shell and escalate their privileges by crafting malicious scripts or modifying system configurations with administrator-level access through a stolen token. Modifying the system configuration is only possible if the administrator has not logged out and the token remains valid.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://www.zyxel.com/global/en/support/security-advisories/zyxel-security-advisory-for-incorrect-permission-assignment-and-improper-privilege-management-vulnerabilities-in-usg-flex-h-series-firewalls-04-22-2025
  - http://seclists.org/fulldisclosure/2025/Apr/27

------------------------------------------------------------

CVE ID: CVE-2025-3928
Description: Commvault Web Server has an unspecified vulnerability that can be exploited by a remote, authenticated attacker. According to the Commvault advisory: "Webservers can be compromised through bad actors creating and executing webshells." Fixed in version 11.36.46, 11.32.89, 11.28.141, and 11.20.217 for Windows and Linux platforms. This vulnerability was added to the CISA Known Exploited Vulnerabilities (KEV) Catalog on 2025-04-28.
Severity:
  - CVSS Version: 4.0
  - Base Score: 8.7
  - Base Severity: HIGH
  - CVSS Vector: CVSS:4.0/AV:N/AC:L/AT:N/PR:L/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X
CPEs:
  - Vendor: commvault, Product: commvault, Version: *, First Version (Including): 11.20.0, Last Version (Excluding): 11.20.217
  - Vendor: commvault, Product: commvault, Version: *, First Version (Including): 11.28.0, Last Version (Excluding): 11.28.141
  - Vendor: commvault, Product: commvault, Version: *, First Version (Including): 11.32.0, Last Version (Excluding): 11.32.89
  - Vendor: commvault, Product: commvault, Version: *, First Version (Including): 11.36.0, Last Version (Excluding): 11.36.46
  - Vendor: linux, Product: linux_kernel, Version: -, First Version (Including): None, Last Version (Excluding): None
  - Vendor: microsoft, Product: windows, Version: -, First Version (Including): None, Last Version (Excluding): None
References:
  - https://documentation.commvault.com/securityadvisories/CV_2025_03_1.html
  - https://www.cisa.gov/known-exploited-vulnerabilities-catalog?search_api_fulltext=CVE-2025-3928
  - https://www.commvault.com/blogs/notice-security-advisory-update
  - https://www.commvault.com/blogs/security-advisory-march-7-2025
  - https://www.bleepingcomputer.com/news/security/commvault-says-recent-breach-didnt-impact-customer-backup-data/

------------------------------------------------------------

CVE ID: CVE-2025-46326
Description: snowflake-connector-net is the Snowflake Connector for .NET. Versions starting from 2.1.2 to before 4.4.1, are vulnerable to a Time-of-Check to Time-of-Use (TOCTOU) race condition. When using the Easy Logging feature on Linux and macOS, the Connector reads logging configuration from a user-provided file. On Linux and macOS, the Connector verifies that the configuration file can be written to only by its owner. That check was vulnerable to a TOCTOU race condition and failed to verify that the file owner matches the user running the Connector. This could allow a local attacker with write access to the configuration file or the directory containing it to overwrite the configuration and gain control over logging level and output location. This issue has been patched in version 4.4.1.
Severity:
  - CVSS Version: 3.1
  - Base Score: 3.3
  - Base Severity: LOW
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N
CPEs:
  - Vendor: snowflake, Product: snowflake_connector, Version: *, First Version (Including): 2.1.2, Last Version (Excluding): 4.4.1
References:
  - https://github.com/snowflakedb/snowflake-connector-net/commit/393aad3cfa81045a05dd488944db45256e861bff
  - https://github.com/snowflakedb/snowflake-connector-net/releases/tag/v4.4.1
  - https://github.com/snowflakedb/snowflake-connector-net/security/advisories/GHSA-c82r-c9f7-f5mj

------------------------------------------------------------

CVE ID: CVE-2025-46327
Description: gosnowflake is the Snowflake Golang driver. Versions starting from 1.7.0 to before 1.13.3, are vulnerable to a Time-of-Check to Time-of-Use (TOCTOU) race condition. When using the Easy Logging feature on Linux and macOS, the Driver reads logging configuration from a user-provided file. On Linux and macOS the Driver verifies that the configuration file can be written to only by its owner. That check was vulnerable to a TOCTOU race condition and failed to verify that the file owner matches the user running the Driver. This could allow a local attacker with write access to the configuration file or the directory containing it to overwrite the configuration and gain control over logging level and output location. This issue has been patched in version 1.13.3.
Severity:
  - CVSS Version: 3.1
  - Base Score: 3.3
  - Base Severity: LOW
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N
CPEs:
  - Vendor: snowflake, Product: gosnowflake, Version: *, First Version (Including): 1.7.0, Last Version (Excluding): 1.13.3
References:
  - https://github.com/snowflakedb/gosnowflake/commit/ba94a4800e23621eff558ef18ce4b96ec5489ff0
  - https://github.com/snowflakedb/gosnowflake/security/advisories/GHSA-6jgm-j7h2-2fqg

------------------------------------------------------------

CVE ID: CVE-2025-46328
Description: snowflake-connector-nodejs is a NodeJS driver for Snowflake. Versions starting from 1.10.0 to before 2.0.4, are vulnerable to a Time-of-Check to Time-of-Use (TOCTOU) race condition. When using the Easy Logging feature on Linux and macOS the Driver reads logging configuration from a user-provided file. On Linux and macOS the Driver verifies that the configuration file can be written to only by its owner. That check was vulnerable to a TOCTOU race condition and failed to verify that the file owner matches the user running the Driver. This could allow a local attacker with write access to the configuration file or the directory containing it to overwrite the configuration and gain control over logging level and output location. This issue has been patched in version 2.0.4.
Severity:
  - CVSS Version: 3.1
  - Base Score: 3.3
  - Base Severity: LOW
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N
CPEs:
  - Vendor: snowflake, Product: snowflake_connector, Version: *, First Version (Including): 1.10.0, Last Version (Excluding): 2.0.4
References:
  - https://github.com/snowflakedb/snowflake-connector-nodejs/commit/e94c24112271e1f44c271634bf29a3188acc68d0
  - https://github.com/snowflakedb/snowflake-connector-nodejs/security/advisories/GHSA-wmjq-jrm2-9wfr

------------------------------------------------------------

CVE ID: CVE-2024-58099
Description: In the Linux kernel, the following vulnerability has been resolved:

vmxnet3: Fix packet corruption in vmxnet3_xdp_xmit_frame

Andrew and Nikolay reported connectivity issues with Cilium's service
load-balancing in case of vmxnet3.

If a BPF program for native XDP adds an encapsulation header such as
IPIP and transmits the packet out the same interface, then in case
of vmxnet3 a corrupted packet is being sent and subsequently dropped
on the path.

vmxnet3_xdp_xmit_frame() which is called e.g. via vmxnet3_run_xdp()
through vmxnet3_xdp_xmit_back() calculates an incorrect DMA address:

  page = virt_to_page(xdpf->data);
  tbi->dma_addr = page_pool_get_dma_addr(page) +
                  VMXNET3_XDP_HEADROOM;
  dma_sync_single_for_device(&adapter->pdev->dev,
                             tbi->dma_addr, buf_size,
                             DMA_TO_DEVICE);

The above assumes a fixed offset (VMXNET3_XDP_HEADROOM), but the XDP
BPF program could have moved xdp->data. While the passed buf_size is
correct (xdpf->len), the dma_addr needs to have a dynamic offset which
can be calculated as xdpf->data - (void *)xdpf, that is, xdp->data -
xdp->data_hard_start.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.6, Last Version (Excluding): 6.6.59
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.7, Last Version (Excluding): 6.11.6
  - Vendor: linux, Product: linux_kernel, Version: 6.12, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.12, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.12, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4678adf94da4a9e9683817b246b58ce15fb81782
  - https://git.kernel.org/stable/c/59ba6cdadb9c26b606a365eb9c9b25eb2052622d
  - https://git.kernel.org/stable/c/f82eb34fb59a8fb96c19f4f492c20eb774140bb5

------------------------------------------------------------

CVE ID: CVE-2025-29906
Description: Finit is a fast init for Linux systems. Versions starting from 3.0-rc1 and prior to version 4.11 bundle an implementation of getty for the `tty` configuration directive that can bypass `/bin/login`, i.e., a user can log in as any user without authentication. This issue has been patched in version 4.11.
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.6
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://github.com/troglobit/finit/commit/6528628b5c771c25ffa0cb1a46c6c89d9d0d69e0
  - https://github.com/troglobit/finit/security/advisories/GHSA-563g-p98j-mc9q

------------------------------------------------------------

CVE ID: CVE-2025-47153
Description: Certain build processes for libuv and Node.js for 32-bit systems, such as for the nodejs binary package through nodejs_20.19.0+dfsg-2_i386.deb for Debian GNU/Linux, have an inconsistent off_t size (e.g., building on i386 Debian always uses _FILE_OFFSET_BITS=64 for the libuv dynamic library, but uses the _FILE_OFFSET_BITS global system default of 32 for nodejs), leading to out-of-bounds access. NOTE: this is not a problem in the Node.js software itself. In particular, the Node.js website's download page does not offer prebuilt Node.js for Linux on i386.
Severity:
  - CVSS Version: 3.1
  - Base Score: 6.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:L
CPEs:
  - No CPE data available.
References:
  - https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1076350
  - https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=922075
  - https://bugzilla.redhat.com/show_bug.cgi?id=892601
  - https://github.com/nodejs/node-v0.x-archive/issues/4549
  - http://www.openwall.com/lists/oss-security/2025/05/02/2
  - https://lists.debian.org/debian-lts-announce/2025/05/msg00003.html

------------------------------------------------------------

CVE ID: CVE-2025-23140
Description: In the Linux kernel, the following vulnerability has been resolved:

misc: pci_endpoint_test: Avoid issue of interrupts remaining after request_irq error

After devm_request_irq() fails with error in pci_endpoint_test_request_irq(),
the pci_endpoint_test_free_irq_vectors() is called assuming that all IRQs
have been released.

However, some requested IRQs remain unreleased, so there are still
/proc/irq/* entries remaining, and this results in WARN() with the
following message:

  remove_proc_entry: removing non-empty directory 'irq/30', leaking at least 'pci-endpoint-test.0'
  WARNING: CPU: 0 PID: 202 at fs/proc/generic.c:719 remove_proc_entry +0x190/0x19c

To solve this issue, set the number of remaining IRQs to test->num_irqs,
and release IRQs in advance by calling pci_endpoint_test_release_irq().

[kwilczynski: commit log]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0557e70e2aeba8647bf5a950820b67cfb86533db
  - https://git.kernel.org/stable/c/54c9f299ad7d7c4be5d271ed12d01a59e95b8907
  - https://git.kernel.org/stable/c/5a4b7181213268c9b07bef8800905528435db44a
  - https://git.kernel.org/stable/c/705be96504779e4a333ea042b4779ea941f0ace9
  - https://git.kernel.org/stable/c/770407f6173f4f39f4e2c1b54422b79ce6c98bdb
  - https://git.kernel.org/stable/c/9d5118b107b1a2353ed0dff24404aee2e6b7ca0a
  - https://git.kernel.org/stable/c/e516e187bf32d8decc7c7d0025ae4857cad13c0e
  - https://git.kernel.org/stable/c/f6cb7828c8e17520d4f5afb416515d3fae1af9a9

------------------------------------------------------------

CVE ID: CVE-2025-23141
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Acquire SRCU in KVM_GET_MP_STATE to protect guest memory accesses

Acquire a lock on kvm->srcu when userspace is getting MP state to handle a
rather extreme edge case where "accepting" APIC events, i.e. processing
pending INIT or SIPI, can trigger accesses to guest memory.  If the vCPU
is in L2 with INIT *and* a TRIPLE_FAULT request pending, then getting MP
state will trigger a nested VM-Exit by way of ->check_nested_events(), and
emuating the nested VM-Exit can access guest memory.

The splat was originally hit by syzkaller on a Google-internal kernel, and
reproduced on an upstream kernel by hacking the triple_fault_event_test
selftest to stuff a pending INIT, store an MSR on VM-Exit (to generate a
memory access on VMX), and do vcpu_mp_state_get() to trigger the scenario.

  =============================
  WARNING: suspicious RCU usage
  6.14.0-rc3-b112d356288b-vmx/pi_lockdep_false_pos-lock #3 Not tainted
  -----------------------------
  include/linux/kvm_host.h:1058 suspicious rcu_dereference_check() usage!

  other info that might help us debug this:

  rcu_scheduler_active = 2, debug_locks = 1
  1 lock held by triple_fault_ev/1256:
   #0: ffff88810df5a330 (&vcpu->mutex){+.+.}-{4:4}, at: kvm_vcpu_ioctl+0x8b/0x9a0 [kvm]

  stack backtrace:
  CPU: 11 UID: 1000 PID: 1256 Comm: triple_fault_ev Not tainted 6.14.0-rc3-b112d356288b-vmx #3
  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015
  Call Trace:
   <TASK>
   dump_stack_lvl+0x7f/0x90
   lockdep_rcu_suspicious+0x144/0x190
   kvm_vcpu_gfn_to_memslot+0x156/0x180 [kvm]
   kvm_vcpu_read_guest+0x3e/0x90 [kvm]
   read_and_check_msr_entry+0x2e/0x180 [kvm_intel]
   __nested_vmx_vmexit+0x550/0xde0 [kvm_intel]
   kvm_check_nested_events+0x1b/0x30 [kvm]
   kvm_apic_accept_events+0x33/0x100 [kvm]
   kvm_arch_vcpu_ioctl_get_mpstate+0x30/0x1d0 [kvm]
   kvm_vcpu_ioctl+0x33e/0x9a0 [kvm]
   __x64_sys_ioctl+0x8b/0xb0
   do_syscall_64+0x6c/0x170
   entry_SYSCALL_64_after_hwframe+0x4b/0x53
   </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0357c8406dfa09430dd9858ebe813feb65524b6e
  - https://git.kernel.org/stable/c/592e040572f216d916f465047c8ce4a308fcca44
  - https://git.kernel.org/stable/c/7bc5c360375d28ba5ef6298b0d53e735c81d66a1
  - https://git.kernel.org/stable/c/8a3df0aa1087a89f5ce55f4aba816bfcb1ecf1be
  - https://git.kernel.org/stable/c/ef01cac401f18647d62720cf773d7bb0541827da
  - https://git.kernel.org/stable/c/f5cbe725b7477b4cd677be1b86b4e08f90572997

------------------------------------------------------------

CVE ID: CVE-2025-23142
Description: In the Linux kernel, the following vulnerability has been resolved:

sctp: detect and prevent references to a freed transport in sendmsg

sctp_sendmsg() re-uses associations and transports when possible by
doing a lookup based on the socket endpoint and the message destination
address, and then sctp_sendmsg_to_asoc() sets the selected transport in
all the message chunks to be sent.

There's a possible race condition if another thread triggers the removal
of that selected transport, for instance, by explicitly unbinding an
address with setsockopt(SCTP_SOCKOPT_BINDX_REM), after the chunks have
been set up and before the message is sent. This can happen if the send
buffer is full, during the period when the sender thread temporarily
releases the socket lock in sctp_wait_for_sndbuf().

This causes the access to the transport data in
sctp_outq_select_transport(), when the association outqueue is flushed,
to result in a use-after-free read.

This change avoids this scenario by having sctp_transport_free() signal
the freeing of the transport, tagging it as "dead". In order to do this,
the patch restores the "dead" bit in struct sctp_transport, which was
removed in
commit 47faa1e4c50e ("sctp: remove the dead field of sctp_transport").

Then, in the scenario where the sender thread has released the socket
lock in sctp_wait_for_sndbuf(), the bit is checked again after
re-acquiring the socket lock to detect the deletion. This is done while
holding a reference to the transport to prevent it from being freed in
the process.

If the transport was deleted while the socket lock was relinquished,
sctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry the
send.

The bug was found by a private syzbot instance (see the error report [1]
and the C reproducer that triggers it [2]).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0f7df4899299ce4662e5f95badb9dbc57cc37fa5
  - https://git.kernel.org/stable/c/2e5068b7e0ae0a54f6cfd03a2f80977da657f1ee
  - https://git.kernel.org/stable/c/3257386be6a7eb8a8bfc9cbfb746df4eb4fc70e8
  - https://git.kernel.org/stable/c/547762250220325d350d0917a7231480e0f4142b
  - https://git.kernel.org/stable/c/5bc83bdf5f5b8010d1ca5a4555537e62413ab4e2
  - https://git.kernel.org/stable/c/7a63f4fb0efb4e69efd990cbb740a848679ec4b0
  - https://git.kernel.org/stable/c/9e7c37fadb3be1fc33073fcf10aa96d166caa697
  - https://git.kernel.org/stable/c/c6fefcb71d246baaf3bacdad1af7ff50ebcfe652
  - https://git.kernel.org/stable/c/f1a69a940de58b16e8249dff26f74c8cc59b32be

------------------------------------------------------------

CVE ID: CVE-2025-23143
Description: In the Linux kernel, the following vulnerability has been resolved:

net: Fix null-ptr-deref by sock_lock_init_class_and_name() and rmmod.

When I ran the repro [0] and waited a few seconds, I observed two
LOCKDEP splats: a warning immediately followed by a null-ptr-deref. [1]

Reproduction Steps:

  1) Mount CIFS
  2) Add an iptables rule to drop incoming FIN packets for CIFS
  3) Unmount CIFS
  4) Unload the CIFS module
  5) Remove the iptables rule

At step 3), the CIFS module calls sock_release() for the underlying
TCP socket, and it returns quickly.  However, the socket remains in
FIN_WAIT_1 because incoming FIN packets are dropped.

At this point, the module's refcnt is 0 while the socket is still
alive, so the following rmmod command succeeds.

  # ss -tan
  State      Recv-Q Send-Q Local Address:Port  Peer Address:Port
  FIN-WAIT-1 0      477        10.0.2.15:51062   10.0.0.137:445

  # lsmod | grep cifs
  cifs                 1159168  0

This highlights a discrepancy between the lifetime of the CIFS module
and the underlying TCP socket.  Even after CIFS calls sock_release()
and it returns, the TCP socket does not die immediately in order to
close the connection gracefully.

While this is generally fine, it causes an issue with LOCKDEP because
CIFS assigns a different lock class to the TCP socket's sk->sk_lock
using sock_lock_init_class_and_name().

Once an incoming packet is processed for the socket or a timer fires,
sk->sk_lock is acquired.

Then, LOCKDEP checks the lock context in check_wait_context(), where
hlock_class() is called to retrieve the lock class.  However, since
the module has already been unloaded, hlock_class() logs a warning
and returns NULL, triggering the null-ptr-deref.

If LOCKDEP is enabled, we must ensure that a module calling
sock_lock_init_class_and_name() (CIFS, NFS, etc) cannot be unloaded
while such a socket is still alive to prevent this issue.

Let's hold the module reference in sock_lock_init_class_and_name()
and release it when the socket is freed in sk_prot_free().

Note that sock_lock_init() clears sk->sk_owner for svc_create_socket()
that calls sock_lock_init_class_and_name() for a listening socket,
which clones a socket by sk_clone_lock() without GFP_ZERO.

[0]:
CIFS_SERVER="10.0.0.137"
CIFS_PATH="//${CIFS_SERVER}/Users/Administrator/Desktop/CIFS_TEST"
DEV="enp0s3"
CRED="/root/WindowsCredential.txt"

MNT=$(mktemp -d /tmp/XXXXXX)
mount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0,credentials=${CRED},cache=none,echo_interval=1

iptables -A INPUT -s ${CIFS_SERVER} -j DROP

for i in $(seq 10);
do
    umount ${MNT}
    rmmod cifs
    sleep 1
done

rm -r ${MNT}

iptables -D INPUT -s ${CIFS_SERVER} -j DROP

[1]:
DEBUG_LOCKS_WARN_ON(1)
WARNING: CPU: 10 PID: 0 at kernel/locking/lockdep.c:234 hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223)
Modules linked in: cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded: cifs]
CPU: 10 UID: 0 PID: 0 Comm: swapper/10 Not tainted 6.14.0 #36
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
RIP: 0010:hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223)
...
Call Trace:
 <IRQ>
 __lock_acquire (kernel/locking/lockdep.c:4853 kernel/locking/lockdep.c:5178)
 lock_acquire (kernel/locking/lockdep.c:469 kernel/locking/lockdep.c:5853 kernel/locking/lockdep.c:5816)
 _raw_spin_lock_nested (kernel/locking/spinlock.c:379)
 tcp_v4_rcv (./include/linux/skbuff.h:1678 ./include/net/tcp.h:2547 net/ipv4/tcp_ipv4.c:2350)
...

BUG: kernel NULL pointer dereference, address: 00000000000000c4
 PF: supervisor read access in kernel mode
 PF: error_code(0x0000) - not-present page
PGD 0
Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
CPU: 10 UID: 0 PID: 0 Comm: swapper/10 Tainted: G        W          6.14.0 #36
Tainted: [W]=WARN
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
RIP: 0010:__lock_acquire (kernel/
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0bb2f7a1ad1f11d861f58e5ee5051c8974ff9569
  - https://git.kernel.org/stable/c/2155802d3313d7b8365935c6b8d6edc0ddd7eb94
  - https://git.kernel.org/stable/c/5f7f6abd92b6c8dc8f19625ef93c3a18549ede04
  - https://git.kernel.org/stable/c/c11247a21aab4b50a23c8b696727d7483de2f1e1

------------------------------------------------------------

CVE ID: CVE-2025-23144
Description: In the Linux kernel, the following vulnerability has been resolved:

backlight: led_bl: Hold led_access lock when calling led_sysfs_disable()

Lockdep detects the following issue on led-backlight removal:
  [  142.315935] ------------[ cut here ]------------
  [  142.315954] WARNING: CPU: 2 PID: 292 at drivers/leds/led-core.c:455 led_sysfs_enable+0x54/0x80
  ...
  [  142.500725] Call trace:
  [  142.503176]  led_sysfs_enable+0x54/0x80 (P)
  [  142.507370]  led_bl_remove+0x80/0xa8 [led_bl]
  [  142.511742]  platform_remove+0x30/0x58
  [  142.515501]  device_remove+0x54/0x90
  ...

Indeed, led_sysfs_enable() has to be called with the led_access
lock held.

Hold the lock when calling led_sysfs_disable().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11d128f7eacec276c75cf4712880a6307ca9c885
  - https://git.kernel.org/stable/c/1c82f5a393d8b9a5c1ea032413719862098afd4b
  - https://git.kernel.org/stable/c/276822a00db3c1061382b41e72cafc09d6a0ec30
  - https://git.kernel.org/stable/c/61a5c565fd2442d3128f3bab5f022658adc3a4e6
  - https://git.kernel.org/stable/c/74c7d67a3c305fc1fa03c32a838e8446fb7aee14
  - https://git.kernel.org/stable/c/87d947a0607be384bfe7bb0935884a711e35ca07
  - https://git.kernel.org/stable/c/b447885ec9130cf86f355e011dc6b94d6ccfb5b7
  - https://git.kernel.org/stable/c/b8ddf5107f53789448900f04fa220f34cd2f777e

------------------------------------------------------------

CVE ID: CVE-2025-23145
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: fix NULL pointer in can_accept_new_subflow

When testing valkey benchmark tool with MPTCP, the kernel panics in
'mptcp_can_accept_new_subflow' because subflow_req->msk is NULL.

Call trace:

  mptcp_can_accept_new_subflow (./net/mptcp/subflow.c:63 (discriminator 4)) (P)
  subflow_syn_recv_sock (./net/mptcp/subflow.c:854)
  tcp_check_req (./net/ipv4/tcp_minisocks.c:863)
  tcp_v4_rcv (./net/ipv4/tcp_ipv4.c:2268)
  ip_protocol_deliver_rcu (./net/ipv4/ip_input.c:207)
  ip_local_deliver_finish (./net/ipv4/ip_input.c:234)
  ip_local_deliver (./net/ipv4/ip_input.c:254)
  ip_rcv_finish (./net/ipv4/ip_input.c:449)
  ...

According to the debug log, the same req received two SYN-ACK in a very
short time, very likely because the client retransmits the syn ack due
to multiple reasons.

Even if the packets are transmitted with a relevant time interval, they
can be processed by the server on different CPUs concurrently). The
'subflow_req->msk' ownership is transferred to the subflow the first,
and there will be a risk of a null pointer dereference here.

This patch fixes this issue by moving the 'subflow_req->msk' under the
`own_req == true` conditional.

Note that the !msk check in subflow_hmac_valid() can be dropped, because
the same check already exists under the own_req mpj branch where the
code has been moved to.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/443041deb5ef6a1289a99ed95015ec7442f141dc
  - https://git.kernel.org/stable/c/4b2649b9717678aeb097893cc49f59311a1ecab0
  - https://git.kernel.org/stable/c/7f9ae060ed64aef8f174c5f1ea513825b1be9af1
  - https://git.kernel.org/stable/c/855bf0aacd51fced11ea9aa0d5101ee0febaeadb
  - https://git.kernel.org/stable/c/8cf7fef1bb2ffea7792bcbf71ca00216cecc725d
  - https://git.kernel.org/stable/c/b3088bd2a6790c8efff139d86d7a9d0b1305977b
  - https://git.kernel.org/stable/c/dc81e41a307df523072186b241fa8244fecd7803
  - https://git.kernel.org/stable/c/efd58a8dd9e7a709a90ee486a4247c923d27296f

------------------------------------------------------------

CVE ID: CVE-2025-23146
Description: In the Linux kernel, the following vulnerability has been resolved:

mfd: ene-kb3930: Fix a potential NULL pointer dereference

The off_gpios could be NULL. Add missing check in the kb3930_probe().
This is similar to the issue fixed in commit b1ba8bcb2d1f
("backlight: hx8357: Fix potential NULL pointer dereference").

This was detected by our static analysis tool.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2edb5b29b197d90b4d08cd45e911c0bcf24cb895
  - https://git.kernel.org/stable/c/4cdf1d2a816a93fa02f7b6b5492dc7f55af2a199
  - https://git.kernel.org/stable/c/6dc88993ee3fa8365ff6a5d6514702f70ba6863a
  - https://git.kernel.org/stable/c/76d0f4199bc5b51acb7b96c6663a8953543733ad
  - https://git.kernel.org/stable/c/7b47df6498f223c8956bfe0d994a0e42a520dfcd
  - https://git.kernel.org/stable/c/90ee23c2514a22a9c2bb39a540cbe1c9acb27d0b
  - https://git.kernel.org/stable/c/b1758417310d2cc77e52cd15103497e52e2614f6
  - https://git.kernel.org/stable/c/ea07760676bba49319d553af80c239da053b5fb1

------------------------------------------------------------

CVE ID: CVE-2025-23147
Description: In the Linux kernel, the following vulnerability has been resolved:

i3c: Add NULL pointer check in i3c_master_queue_ibi()

The I3C master driver may receive an IBI from a target device that has not
been probed yet. In such cases, the master calls `i3c_master_queue_ibi()`
to queue an IBI work task, leading to "Unable to handle kernel read from
unreadable memory" and resulting in a kernel panic.

Typical IBI handling flow:
1. The I3C master scans target devices and probes their respective drivers.
2. The target device driver calls `i3c_device_request_ibi()` to enable IBI
   and assigns `dev->ibi = ibi`.
3. The I3C master receives an IBI from the target device and calls
   `i3c_master_queue_ibi()` to queue the target device driver’s IBI
   handler task.

However, since target device events are asynchronous to the I3C probe
sequence, step 3 may occur before step 2, causing `dev->ibi` to be `NULL`,
leading to a kernel panic.

Add a NULL pointer check in `i3c_master_queue_ibi()` to prevent accessing
an uninitialized `dev->ibi`, ensuring stability.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09359e7c8751961937cb5fc50220969b0a4e1058
  - https://git.kernel.org/stable/c/1b54faa5f47fa7c642179744aeff03f0810dc62e
  - https://git.kernel.org/stable/c/3ba402610843d7d15c7f3966a461deeeaff7fba4
  - https://git.kernel.org/stable/c/6871a676aa534e8f218279672e0445c725f81026
  - https://git.kernel.org/stable/c/bd496a44f041da9ef3afe14d1d6193d460424e91
  - https://git.kernel.org/stable/c/d83b0c03ef8fbea2f03029a1cc1f5041f0e1d47f
  - https://git.kernel.org/stable/c/e6bba328578feb58c614c11868c259b40484c5fa
  - https://git.kernel.org/stable/c/fe4a4fc179b7898055555a11685915473588392e
  - https://git.kernel.org/stable/c/ff9d61db59bb27d16d3f872bff2620d50856b80c

------------------------------------------------------------

CVE ID: CVE-2025-23148
Description: In the Linux kernel, the following vulnerability has been resolved:

soc: samsung: exynos-chipid: Add NULL pointer check in exynos_chipid_probe()

soc_dev_attr->revision could be NULL, thus,
a pointer check is added to prevent potential NULL pointer dereference.
This is similar to the fix in commit 3027e7b15b02
("ice: Fix some null pointer dereference issues in ice_ptp.c").

This issue is found by our static analysis tool.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4129760e462f45f14e61b10408ace61aa7c2ed30
  - https://git.kernel.org/stable/c/44a2572a0fdcf3e7565763690d579b998a8f0562
  - https://git.kernel.org/stable/c/475b9b45dc32eba58ab794b5d47ac689fc018398
  - https://git.kernel.org/stable/c/4f51d169fd0d4821bce775618db024062b09a3f7
  - https://git.kernel.org/stable/c/5f80fd2ff8bfd13e41554741740e0ca8e6445ded
  - https://git.kernel.org/stable/c/8ce469d23205249bb17c1135ccadea879576adfc
  - https://git.kernel.org/stable/c/8ee067cf0cf82429e9b204283c7d0d8d6891d10e
  - https://git.kernel.org/stable/c/c8222ef6cf29dd7cad21643228f96535cc02b327

------------------------------------------------------------

CVE ID: CVE-2025-23149
Description: In the Linux kernel, the following vulnerability has been resolved:

tpm: do not start chip while suspended

Checking TPM_CHIP_FLAG_SUSPENDED after the call to tpm_find_get_ops() can
lead to a spurious tpm_chip_start() call:

[35985.503771] i2c i2c-1: Transfer while suspended
[35985.503796] WARNING: CPU: 0 PID: 74 at drivers/i2c/i2c-core.h:56 __i2c_transfer+0xbe/0x810
[35985.503802] Modules linked in:
[35985.503808] CPU: 0 UID: 0 PID: 74 Comm: hwrng Tainted: G        W          6.13.0-next-20250203-00005-gfa0cb5642941 #19 9c3d7f78192f2d38e32010ac9c90fdc71109ef6f
[35985.503814] Tainted: [W]=WARN
[35985.503817] Hardware name: Google Morphius/Morphius, BIOS Google_Morphius.13434.858.0 10/26/2023
[35985.503819] RIP: 0010:__i2c_transfer+0xbe/0x810
[35985.503825] Code: 30 01 00 00 4c 89 f7 e8 40 fe d8 ff 48 8b 93 80 01 00 00 48 85 d2 75 03 49 8b 16 48 c7 c7 0a fb 7c a7 48 89 c6 e8 32 ad b0 fe <0f> 0b b8 94 ff ff ff e9 33 04 00 00 be 02 00 00 00 83 fd 02 0f 5
[35985.503828] RSP: 0018:ffffa106c0333d30 EFLAGS: 00010246
[35985.503833] RAX: 074ba64aa20f7000 RBX: ffff8aa4c1167120 RCX: 0000000000000000
[35985.503836] RDX: 0000000000000000 RSI: ffffffffa77ab0e4 RDI: 0000000000000001
[35985.503838] RBP: 0000000000000001 R08: 0000000000000001 R09: 0000000000000000
[35985.503841] R10: 0000000000000004 R11: 00000001000313d5 R12: ffff8aa4c10f1820
[35985.503843] R13: ffff8aa4c0e243c0 R14: ffff8aa4c1167250 R15: ffff8aa4c1167120
[35985.503846] FS:  0000000000000000(0000) GS:ffff8aa4eae00000(0000) knlGS:0000000000000000
[35985.503849] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[35985.503852] CR2: 00007fab0aaf1000 CR3: 0000000105328000 CR4: 00000000003506f0
[35985.503855] Call Trace:
[35985.503859]  <TASK>
[35985.503863]  ? __warn+0xd4/0x260
[35985.503868]  ? __i2c_transfer+0xbe/0x810
[35985.503874]  ? report_bug+0xf3/0x210
[35985.503882]  ? handle_bug+0x63/0xb0
[35985.503887]  ? exc_invalid_op+0x16/0x50
[35985.503892]  ? asm_exc_invalid_op+0x16/0x20
[35985.503904]  ? __i2c_transfer+0xbe/0x810
[35985.503913]  tpm_cr50_i2c_transfer_message+0x24/0xf0
[35985.503920]  tpm_cr50_i2c_read+0x8e/0x120
[35985.503928]  tpm_cr50_request_locality+0x75/0x170
[35985.503935]  tpm_chip_start+0x116/0x160
[35985.503942]  tpm_try_get_ops+0x57/0x90
[35985.503948]  tpm_find_get_ops+0x26/0xd0
[35985.503955]  tpm_get_random+0x2d/0x80

Don't move forward with tpm_chip_start() inside tpm_try_get_ops(), unless
TPM_CHIP_FLAG_SUSPENDED is not set. tpm_find_get_ops() will return NULL in
such a failure case.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1404dff1e11bf927b70ac25e1de97bed9742ede4
  - https://git.kernel.org/stable/c/17d253af4c2c8a2acf84bb55a0c2045f150b7dfd
  - https://git.kernel.org/stable/c/e74e2394eed90aff5c3a08c1f51f476d4de71d02
  - https://git.kernel.org/stable/c/f1044e995b64d70ef90ef6f2b89955b127497702
  - https://git.kernel.org/stable/c/f3cb81cb96d587f9f235a11789d1ec0992643078

------------------------------------------------------------

CVE ID: CVE-2025-23150
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix off-by-one error in do_split

Syzkaller detected a use-after-free issue in ext4_insert_dentry that was
caused by out-of-bounds access due to incorrect splitting in do_split.

BUG: KASAN: use-after-free in ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c:2109
Write of size 251 at addr ffff888074572f14 by task syz-executor335/5847

CPU: 0 UID: 0 PID: 5847 Comm: syz-executor335 Not tainted 6.12.0-rc6-syzkaller-00318-ga9cda7c0ffed #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:377 [inline]
 print_report+0x169/0x550 mm/kasan/report.c:488
 kasan_report+0x143/0x180 mm/kasan/report.c:601
 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189
 __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106
 ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c:2109
 add_dirent_to_buf+0x3d9/0x750 fs/ext4/namei.c:2154
 make_indexed_dir+0xf98/0x1600 fs/ext4/namei.c:2351
 ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c:2455
 ext4_add_nondir+0x8d/0x290 fs/ext4/namei.c:2796
 ext4_symlink+0x920/0xb50 fs/ext4/namei.c:3431
 vfs_symlink+0x137/0x2e0 fs/namei.c:4615
 do_symlinkat+0x222/0x3a0 fs/namei.c:4641
 __do_sys_symlink fs/namei.c:4662 [inline]
 __se_sys_symlink fs/namei.c:4660 [inline]
 __x64_sys_symlink+0x7a/0x90 fs/namei.c:4660
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
 </TASK>

The following loop is located right above 'if' statement.

for (i = count-1; i >= 0; i--) {
	/* is more than half of this entry in 2nd half of the block? */
	if (size + map[i].size/2 > blocksize/2)
		break;
	size += map[i].size;
	move++;
}

'i' in this case could go down to -1, in which case sum of active entries
wouldn't exceed half the block size, but previous behaviour would also do
split in half if sum would exceed at the very last block, which in case of
having too many long name files in a single block could lead to
out-of-bounds access and following use-after-free.

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/16d9067f00e3a7d1df7c3aa9c20d214923d27e10
  - https://git.kernel.org/stable/c/17df39f455f1289319d4d09e4826aa46852ffd17
  - https://git.kernel.org/stable/c/2883e9e74f73f9265e5f8d1aaaa89034b308e433
  - https://git.kernel.org/stable/c/2eeb1085bf7bd5c7ba796ca4119925fa5d336a3f
  - https://git.kernel.org/stable/c/35d0aa6db9d93307085871ceab8a729594a98162
  - https://git.kernel.org/stable/c/515c34cff899eb5dae6aa7eee01c1295b07d81af
  - https://git.kernel.org/stable/c/94824ac9a8aaf2fb3c54b4bdde842db80ffa555d
  - https://git.kernel.org/stable/c/ab0cc5c25552ae0d20eae94b40a93be11b080fc5
  - https://git.kernel.org/stable/c/b96bd2c3db26ad0daec5b78c85c098b53900e2e1

------------------------------------------------------------

CVE ID: CVE-2025-23151
Description: In the Linux kernel, the following vulnerability has been resolved:

bus: mhi: host: Fix race between unprepare and queue_buf

A client driver may use mhi_unprepare_from_transfer() to quiesce
incoming data during the client driver's tear down. The client driver
might also be processing data at the same time, resulting in a call to
mhi_queue_buf() which will invoke mhi_gen_tre(). If mhi_gen_tre() runs
after mhi_unprepare_from_transfer() has torn down the channel, a panic
will occur due to an invalid dereference leading to a page fault.

This occurs because mhi_gen_tre() does not verify the channel state
after locking it. Fix this by having mhi_gen_tre() confirm the channel
state is valid, or return error to avoid accessing deinitialized data.

[mani: added stable tag]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0686a818d77a431fc3ba2fab4b46bbb04e8c9380
  - https://git.kernel.org/stable/c/178e5657c8fd285125cc6743a81b513bce099760
  - https://git.kernel.org/stable/c/3e7ecf181cbdde9753204ada3883ca1704d8702b
  - https://git.kernel.org/stable/c/5f084993c90d9d0b4a52a349ede5120f992a7ca1
  - https://git.kernel.org/stable/c/899d0353ea69681f474b6bc9de32c663b89672da
  - https://git.kernel.org/stable/c/a77955f7704b2a00385e232cbcc1cb06b5c7a425
  - https://git.kernel.org/stable/c/ee1fce83ed56450087309b9b74ad9bcb2b010fa6

------------------------------------------------------------

CVE ID: CVE-2025-23152
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64/crc-t10dif: fix use of out-of-scope array in crc_t10dif_arch()

Fix a silly bug where an array was used outside of its scope.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/bd9e1a03e579a01dfa66dbaa53d0219c33cbc463
  - https://git.kernel.org/stable/c/d48b663f410f8b35b8ba9bd597bafaa00f53293b

------------------------------------------------------------

CVE ID: CVE-2025-23153
Description: In the Linux kernel, the following vulnerability has been resolved:

arm/crc-t10dif: fix use of out-of-scope array in crc_t10dif_arch()

Fix a silly bug where an array was used outside of its scope.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3371f569223c4e8d36edbb0ba789ee5f5cb7316f
  - https://git.kernel.org/stable/c/d8eba735be74e74776f9f6d9c691bdb75b08b29c

------------------------------------------------------------

CVE ID: CVE-2025-23154
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring/net: fix io_req_post_cqe abuse by send bundle

[  114.987980][ T5313] WARNING: CPU: 6 PID: 5313 at io_uring/io_uring.c:872 io_req_post_cqe+0x12e/0x4f0
[  114.991597][ T5313] RIP: 0010:io_req_post_cqe+0x12e/0x4f0
[  115.001880][ T5313] Call Trace:
[  115.002222][ T5313]  <TASK>
[  115.007813][ T5313]  io_send+0x4fe/0x10f0
[  115.009317][ T5313]  io_issue_sqe+0x1a6/0x1740
[  115.012094][ T5313]  io_wq_submit_work+0x38b/0xed0
[  115.013223][ T5313]  io_worker_handle_work+0x62a/0x1600
[  115.013876][ T5313]  io_wq_worker+0x34f/0xdf0

As the comment states, io_req_post_cqe() should only be used by
multishot requests, i.e. REQ_F_APOLL_MULTISHOT, which bundled sends are
not. Add a flag signifying whether a request wants to post multiple
CQEs. Eventually REQ_F_APOLL_MULTISHOT should imply the new flag, but
that's left out for simplicity.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6889ae1b4df1579bcdffef023e2ea9a982565dff
  - https://git.kernel.org/stable/c/7888c9fc0b2d3636f2e821ed1ad3c6920fa8e378
  - https://git.kernel.org/stable/c/9aa804e6b9696998308095fb9d335046a71550f1
  - https://git.kernel.org/stable/c/b7c6d081c19a5e11bbd77bb97a62cff2b6b21cb5

------------------------------------------------------------

CVE ID: CVE-2025-23155
Description: In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: Fix accessing freed irq affinity_hint

The cpumask should not be a local variable, since its pointer is saved
to irq_desc and may be accessed from procfs.
To fix it, use the persistent mask cpumask_of(cpu#).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9e51a6a44e2c4de780a26e8fe110d708e806a8cd
  - https://git.kernel.org/stable/c/c60d101a226f18e9a8f01bb4c6ca2b47dfcb15ef
  - https://git.kernel.org/stable/c/e148266e104fce396ad624079a6812ac3a9982ef

------------------------------------------------------------

CVE ID: CVE-2025-23156
Description: In the Linux kernel, the following vulnerability has been resolved:

media: venus: hfi_parser: refactor hfi packet parsing logic

words_count denotes the number of words in total payload, while data
points to payload of various property within it. When words_count
reaches last word, data can access memory beyond the total payload. This
can lead to OOB access. With this patch, the utility api for handling
individual properties now returns the size of data consumed. Accordingly
remaining bytes are calculated before parsing the payload, thereby
eliminates the OOB access possibilities.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/05b07e52a0d08239147ba3460045855f4fb398de
  - https://git.kernel.org/stable/c/0beabe9b49190a02321b02792b29fc0f0e28b51f
  - https://git.kernel.org/stable/c/0f9a4bab7d83738963365372e4745854938eab2d
  - https://git.kernel.org/stable/c/6d278c5548d840c4d85d445347b2a5c31b2ab3a0
  - https://git.kernel.org/stable/c/9edaaa8e3e15aab1ca413ab50556de1975bcb329
  - https://git.kernel.org/stable/c/a736c72d476d1c7ca7be5018f2614ee61168ad01
  - https://git.kernel.org/stable/c/bb3fd8b7906a12dc2b61389abb742bf6542d97fb
  - https://git.kernel.org/stable/c/f195e94c7af921d99abd79f57026a218d191d2c7

------------------------------------------------------------

CVE ID: CVE-2025-23157
Description: In the Linux kernel, the following vulnerability has been resolved:

media: venus: hfi_parser: add check to avoid out of bound access

There is a possibility that init_codecs is invoked multiple times during
manipulated payload from video firmware. In such case, if codecs_count
can get incremented to value more than MAX_CODEC_NUM, there can be OOB
access. Reset the count so that it always starts from beginning.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/172bf5a9ef70a399bb227809db78442dc01d9e48
  - https://git.kernel.org/stable/c/1ad6aa1464b8a5ce5c194458315021e8d216108e
  - https://git.kernel.org/stable/c/26bbedd06d85770581fda5d78e78539bb088fad1
  - https://git.kernel.org/stable/c/2b8b9ea4e26a501eb220ea189e42b4527e65bdfa
  - https://git.kernel.org/stable/c/53e376178ceacca3ef1795038b22fc9ef45ff1d3
  - https://git.kernel.org/stable/c/b2541e29d82da8a0df728aadec3e0a8db55d517b
  - https://git.kernel.org/stable/c/cb5be9039f91979f8a2fac29f529f746d7848f3e
  - https://git.kernel.org/stable/c/d4d88ece4ba91df5b02f1d3f599650f9e9fc0f45
  - https://git.kernel.org/stable/c/e5133a0b25463674903fdc0528e0a29b7267130e

------------------------------------------------------------

CVE ID: CVE-2025-23158
Description: In the Linux kernel, the following vulnerability has been resolved:

media: venus: hfi: add check to handle incorrect queue size

qsize represents size of shared queued between driver and video
firmware. Firmware can modify this value to an invalid large value. In
such situation, empty_space will be bigger than the space actually
available. Since new_wr_idx is not checked, so the following code will
result in an OOB write.
...
qsize = qhdr->q_size

if (wr_idx >= rd_idx)
 empty_space = qsize - (wr_idx - rd_idx)
....
if (new_wr_idx < qsize) {
 memcpy(wr_ptr, packet, dwords << 2) --> OOB write

Add check to ensure qsize is within the allocated size while
reading and writing packets into the queue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/101a86619aab42bb61f2253bbf720121022eab86
  - https://git.kernel.org/stable/c/1b86c1917e16bafbbb08ab90baaff533aa36c62d
  - https://git.kernel.org/stable/c/32af5c1fdb9bc274f52ee0472d3b060b18e4aab4
  - https://git.kernel.org/stable/c/40084302f639b3fe954398c5ba5ee556b7242b54
  - https://git.kernel.org/stable/c/679424f8b31446f90080befd0300ea915485b096
  - https://git.kernel.org/stable/c/69baf245b23e20efda0079238b27fc63ecf13de1
  - https://git.kernel.org/stable/c/a45957bcde529169188929816775a575de77d84f
  - https://git.kernel.org/stable/c/cf5f7bb4e0d786f4d9d50ae6b5963935eab71d75
  - https://git.kernel.org/stable/c/edb89d69b1438681daaf5ca90aed3242df94cc96

------------------------------------------------------------

CVE ID: CVE-2025-23159
Description: In the Linux kernel, the following vulnerability has been resolved:

media: venus: hfi: add a check to handle OOB in sfr region

sfr->buf_size is in shared memory and can be modified by malicious user.
OOB write is possible when the size is made higher than actual sfr data
buffer. Cap the size to allocated size for such cases.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b8fb257234e7d2d4b3f48af07c5aa5e11c71634
  - https://git.kernel.org/stable/c/4dd109038d513b92d4d33524ffc89ba32e02ba48
  - https://git.kernel.org/stable/c/4e95233af57715d81830fe82b408c633edff59f4
  - https://git.kernel.org/stable/c/530f623f56a6680792499a8404083e17f8ec51f4
  - https://git.kernel.org/stable/c/5af611c70fb889d46d2f654b8996746e59556750
  - https://git.kernel.org/stable/c/8879397c0da5e5ec1515262995e82cdfd61b282a
  - https://git.kernel.org/stable/c/a062d8de0be5525ec8c52f070acf7607ec8cbfe4
  - https://git.kernel.org/stable/c/d78a8388a27b265fcb2b8d064f088168ac9356b0
  - https://git.kernel.org/stable/c/f4b211714bcc70effa60c34d9fa613d182e3ef1e

------------------------------------------------------------

CVE ID: CVE-2025-23160
Description: In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Fix a resource leak related to the scp device in FW initialization

On Mediatek devices with a system companion processor (SCP) the mtk_scp
structure has to be removed explicitly to avoid a resource leak.
Free the structure in case the allocation of the firmware structure fails
during the firmware initialization.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4936cd5817af35d23e4d283f48fa59a18ef481e4
  - https://git.kernel.org/stable/c/9f009fa823c54ca0857c81f7525ea5a5d32de29c
  - https://git.kernel.org/stable/c/ac94e1db4b2053059779472eb58a64d504964240
  - https://git.kernel.org/stable/c/d6cb086aa52bd51378a4c9e2b25d2def97770205
  - https://git.kernel.org/stable/c/fd7bb97ede487b9f075707b7408a9073e0d474b1

------------------------------------------------------------

CVE ID: CVE-2025-23161
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: vmd: Make vmd_dev::cfg_lock a raw_spinlock_t type

The access to the PCI config space via pci_ops::read and pci_ops::write is
a low-level hardware access. The functions can be accessed with disabled
interrupts even on PREEMPT_RT. The pci_lock is a raw_spinlock_t for this
purpose.

A spinlock_t becomes a sleeping lock on PREEMPT_RT, so it cannot be
acquired with disabled interrupts. The vmd_dev::cfg_lock is accessed in
the same context as the pci_lock.

Make vmd_dev::cfg_lock a raw_spinlock_t type so it can be used with
interrupts disabled.

This was reported as:

  BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48
  Call Trace:
   rt_spin_lock+0x4e/0x130
   vmd_pci_read+0x8d/0x100 [vmd]
   pci_user_read_config_byte+0x6f/0xe0
   pci_read_config+0xfe/0x290
   sysfs_kf_bin_read+0x68/0x90

[bigeasy: reword commit message]
Tested-off-by: Luis Claudio R. Goncalves <lgoncalv@redhat.com>
[kwilczynski: commit log]
[bhelgaas: add back report info from
https://lore.kernel.org/lkml/20241218115951.83062-1-ryotkkr98@gmail.com/]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/13e5148f70e81991acbe0bab5b1b50ba699116e7
  - https://git.kernel.org/stable/c/18056a48669a040bef491e63b25896561ee14d90
  - https://git.kernel.org/stable/c/20d0a9062c031068fa39f725a32f182b709b5525
  - https://git.kernel.org/stable/c/2358046ead696ca5c7c628d6c0e2c6792619a3e5
  - https://git.kernel.org/stable/c/5c3cfcf0b4bf43530788b08a8eaf7896ec567484
  - https://git.kernel.org/stable/c/c250262d6485ca333e9821f85b07eb383ec546b1
  - https://git.kernel.org/stable/c/c2968c812339593ac6e2bdd5cc3adabe3f05fa53

------------------------------------------------------------

CVE ID: CVE-2025-23162
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe/vf: Don't try to trigger a full GT reset if VF

VFs don't have access to the GDRST(0x941c) register that driver
uses to reset a GT. Attempt to trigger a reset using debugfs:

 $ cat /sys/kernel/debug/dri/0000:00:02.1/gt0/force_reset

or due to a hang condition detected by the driver leads to:

 [ ] xe 0000:00:02.1: [drm] GT0: trying reset from force_reset [xe]
 [ ] xe 0000:00:02.1: [drm] GT0: reset queued
 [ ] xe 0000:00:02.1: [drm] GT0: reset started
 [ ] ------------[ cut here ]------------
 [ ] xe 0000:00:02.1: [drm] GT0: VF is trying to write 0x1 to an inaccessible register 0x941c+0x0
 [ ] WARNING: CPU: 3 PID: 3069 at drivers/gpu/drm/xe/xe_gt_sriov_vf.c:996 xe_gt_sriov_vf_write32+0xc6/0x580 [xe]
 [ ] RIP: 0010:xe_gt_sriov_vf_write32+0xc6/0x580 [xe]
 [ ] Call Trace:
 [ ]  <TASK>
 [ ]  ? show_regs+0x6c/0x80
 [ ]  ? __warn+0x93/0x1c0
 [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]
 [ ]  ? report_bug+0x182/0x1b0
 [ ]  ? handle_bug+0x6e/0xb0
 [ ]  ? exc_invalid_op+0x18/0x80
 [ ]  ? asm_exc_invalid_op+0x1b/0x20
 [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]
 [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]
 [ ]  ? xe_gt_tlb_invalidation_reset+0xef/0x110 [xe]
 [ ]  ? __mutex_unlock_slowpath+0x41/0x2e0
 [ ]  xe_mmio_write32+0x64/0x150 [xe]
 [ ]  do_gt_reset+0x2f/0xa0 [xe]
 [ ]  gt_reset_worker+0x14e/0x1e0 [xe]
 [ ]  process_one_work+0x21c/0x740
 [ ]  worker_thread+0x1db/0x3c0

Fix that by sending H2G VF_RESET(0x5507) action instead.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2eec2fa8666dcecebae33a565a818c9de9af8b50
  - https://git.kernel.org/stable/c/459777724d306315070d24608fcd89aea85516d6
  - https://git.kernel.org/stable/c/90b16edb3213e4ae4a3138bb20703ae367e88a01
  - https://git.kernel.org/stable/c/a9bc61a61372897886f58fdaa5582e3f7bf9a50b

------------------------------------------------------------

CVE ID: CVE-2025-23163
Description: In the Linux kernel, the following vulnerability has been resolved:

net: vlan: don't propagate flags on open

With the device instance lock, there is now a possibility of a deadlock:

[    1.211455] ============================================
[    1.211571] WARNING: possible recursive locking detected
[    1.211687] 6.14.0-rc5-01215-g032756b4ca7a-dirty #5 Not tainted
[    1.211823] --------------------------------------------
[    1.211936] ip/184 is trying to acquire lock:
[    1.212032] ffff8881024a4c30 (&dev->lock){+.+.}-{4:4}, at: dev_set_allmulti+0x4e/0xb0
[    1.212207]
[    1.212207] but task is already holding lock:
[    1.212332] ffff8881024a4c30 (&dev->lock){+.+.}-{4:4}, at: dev_open+0x50/0xb0
[    1.212487]
[    1.212487] other info that might help us debug this:
[    1.212626]  Possible unsafe locking scenario:
[    1.212626]
[    1.212751]        CPU0
[    1.212815]        ----
[    1.212871]   lock(&dev->lock);
[    1.212944]   lock(&dev->lock);
[    1.213016]
[    1.213016]  *** DEADLOCK ***
[    1.213016]
[    1.213143]  May be due to missing lock nesting notation
[    1.213143]
[    1.213294] 3 locks held by ip/184:
[    1.213371]  #0: ffffffff838b53e0 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_nets_lock+0x1b/0xa0
[    1.213543]  #1: ffffffff84e5fc70 (&net->rtnl_mutex){+.+.}-{4:4}, at: rtnl_nets_lock+0x37/0xa0
[    1.213727]  #2: ffff8881024a4c30 (&dev->lock){+.+.}-{4:4}, at: dev_open+0x50/0xb0
[    1.213895]
[    1.213895] stack backtrace:
[    1.213991] CPU: 0 UID: 0 PID: 184 Comm: ip Not tainted 6.14.0-rc5-01215-g032756b4ca7a-dirty #5
[    1.213993] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014
[    1.213994] Call Trace:
[    1.213995]  <TASK>
[    1.213996]  dump_stack_lvl+0x8e/0xd0
[    1.214000]  print_deadlock_bug+0x28b/0x2a0
[    1.214020]  lock_acquire+0xea/0x2a0
[    1.214027]  __mutex_lock+0xbf/0xd40
[    1.214038]  dev_set_allmulti+0x4e/0xb0 # real_dev->flags & IFF_ALLMULTI
[    1.214040]  vlan_dev_open+0xa5/0x170 # ndo_open on vlandev
[    1.214042]  __dev_open+0x145/0x270
[    1.214046]  __dev_change_flags+0xb0/0x1e0
[    1.214051]  netif_change_flags+0x22/0x60 # IFF_UP vlandev
[    1.214053]  dev_change_flags+0x61/0xb0 # for each device in group from dev->vlan_info
[    1.214055]  vlan_device_event+0x766/0x7c0 # on netdevsim0
[    1.214058]  notifier_call_chain+0x78/0x120
[    1.214062]  netif_open+0x6d/0x90
[    1.214064]  dev_open+0x5b/0xb0 # locks netdevsim0
[    1.214066]  bond_enslave+0x64c/0x1230
[    1.214075]  do_set_master+0x175/0x1e0 # on netdevsim0
[    1.214077]  do_setlink+0x516/0x13b0
[    1.214094]  rtnl_newlink+0xaba/0xb80
[    1.214132]  rtnetlink_rcv_msg+0x440/0x490
[    1.214144]  netlink_rcv_skb+0xeb/0x120
[    1.214150]  netlink_unicast+0x1f9/0x320
[    1.214153]  netlink_sendmsg+0x346/0x3f0
[    1.214157]  __sock_sendmsg+0x86/0xb0
[    1.214160]  ____sys_sendmsg+0x1c8/0x220
[    1.214164]  ___sys_sendmsg+0x28f/0x2d0
[    1.214179]  __x64_sys_sendmsg+0xef/0x140
[    1.214184]  do_syscall_64+0xec/0x1d0
[    1.214190]  entry_SYSCALL_64_after_hwframe+0x77/0x7f
[    1.214191] RIP: 0033:0x7f2d1b4a7e56

Device setup:

     netdevsim0 (down)
     ^        ^
  bond        netdevsim1.100@netdevsim1 allmulticast=on (down)

When we enslave the lower device (netdevsim0) which has a vlan, we
propagate vlan's allmuti/promisc flags during ndo_open. This causes
(re)locking on of the real_dev.

Propagate allmulti/promisc on flags change, not on the open. There
is a slight semantics change that vlans that are down now propagate
the flags, but this seems unlikely to result in the real issues.

Reproducer:

  echo 0 1 > /sys/bus/netdevsim/new_device

  dev_path=$(ls -d /sys/bus/netdevsim/devices/netdevsim0/net/*)
  dev=$(echo $dev_path | rev | cut -d/ -f1 | rev)

  ip link set dev $dev name netdevsim0
  ip link set dev netdevsim0 up

  ip link add link netdevsim0 name netdevsim0.100 type vlan id 100
  ip link set dev netdevsim0.100 allm
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/27b918007d96402aba10ed52a6af8015230f1793
  - https://git.kernel.org/stable/c/299d7d27af6b5844cda06a0fdfa635705e1bc50f
  - https://git.kernel.org/stable/c/523fa0979d842443aa14b80002e45b471cbac137
  - https://git.kernel.org/stable/c/538b43aa21e3b17c110104efd218b966d2eda5f8
  - https://git.kernel.org/stable/c/53fb25e90c0a503a17c639341ba5e755cb2feb5c
  - https://git.kernel.org/stable/c/8980018a9806743d9b80837330d46f06ecf78516
  - https://git.kernel.org/stable/c/a32f1d4f1f4c9d978698f3c718621f6198f2e7ac
  - https://git.kernel.org/stable/c/b1e3eeb037256a2f1206a8d69810ec47eb152026
  - https://git.kernel.org/stable/c/d537859e56bcc3091805c524484a4c85386b3cc8

------------------------------------------------------------

CVE ID: CVE-2025-37738
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: ignore xattrs past end

Once inside 'ext4_xattr_inode_dec_ref_all' we should
ignore xattrs entries past the 'end' entry.

This fixes the following KASAN reported issue:

==================================================================
BUG: KASAN: slab-use-after-free in ext4_xattr_inode_dec_ref_all+0xb8c/0xe90
Read of size 4 at addr ffff888012c120c4 by task repro/2065

CPU: 1 UID: 0 PID: 2065 Comm: repro Not tainted 6.13.0-rc2+ #11
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
Call Trace:
 <TASK>
 dump_stack_lvl+0x1fd/0x300
 ? tcp_gro_dev_warn+0x260/0x260
 ? _printk+0xc0/0x100
 ? read_lock_is_recursive+0x10/0x10
 ? irq_work_queue+0x72/0xf0
 ? __virt_addr_valid+0x17b/0x4b0
 print_address_description+0x78/0x390
 print_report+0x107/0x1f0
 ? __virt_addr_valid+0x17b/0x4b0
 ? __virt_addr_valid+0x3ff/0x4b0
 ? __phys_addr+0xb5/0x160
 ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90
 kasan_report+0xcc/0x100
 ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90
 ext4_xattr_inode_dec_ref_all+0xb8c/0xe90
 ? ext4_xattr_delete_inode+0xd30/0xd30
 ? __ext4_journal_ensure_credits+0x5f0/0x5f0
 ? __ext4_journal_ensure_credits+0x2b/0x5f0
 ? inode_update_timestamps+0x410/0x410
 ext4_xattr_delete_inode+0xb64/0xd30
 ? ext4_truncate+0xb70/0xdc0
 ? ext4_expand_extra_isize_ea+0x1d20/0x1d20
 ? __ext4_mark_inode_dirty+0x670/0x670
 ? ext4_journal_check_start+0x16f/0x240
 ? ext4_inode_is_fast_symlink+0x2f2/0x3a0
 ext4_evict_inode+0xc8c/0xff0
 ? ext4_inode_is_fast_symlink+0x3a0/0x3a0
 ? do_raw_spin_unlock+0x53/0x8a0
 ? ext4_inode_is_fast_symlink+0x3a0/0x3a0
 evict+0x4ac/0x950
 ? proc_nr_inodes+0x310/0x310
 ? trace_ext4_drop_inode+0xa2/0x220
 ? _raw_spin_unlock+0x1a/0x30
 ? iput+0x4cb/0x7e0
 do_unlinkat+0x495/0x7c0
 ? try_break_deleg+0x120/0x120
 ? 0xffffffff81000000
 ? __check_object_size+0x15a/0x210
 ? strncpy_from_user+0x13e/0x250
 ? getname_flags+0x1dc/0x530
 __x64_sys_unlinkat+0xc8/0xf0
 do_syscall_64+0x65/0x110
 entry_SYSCALL_64_after_hwframe+0x67/0x6f
RIP: 0033:0x434ffd
Code: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 8
RSP: 002b:00007ffc50fa7b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000107
RAX: ffffffffffffffda RBX: 00007ffc50fa7e18 RCX: 0000000000434ffd
RDX: 0000000000000000 RSI: 0000000020000240 RDI: 0000000000000005
RBP: 00007ffc50fa7be0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001
R13: 00007ffc50fa7e08 R14: 00000000004bbf30 R15: 0000000000000001
 </TASK>

The buggy address belongs to the object at ffff888012c12000
 which belongs to the cache filp of size 360
The buggy address is located 196 bytes inside of
 freed 360-byte region [ffff888012c12000, ffff888012c12168)

The buggy address belongs to the physical page:
page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x12c12
head: order:1 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0
flags: 0x40(head|node=0|zone=0)
page_type: f5(slab)
raw: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004
raw: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000
head: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004
head: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000
head: 0000000000000001 ffffea00004b0481 ffffffffffffffff 0000000000000000
head: 0000000000000002 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 ffff888012c11f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 ffff888012c12000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
> ffff888012c12080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                           ^
 ffff888012c12100: fb fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc
 ffff888012c12180: fc fc fc fc fc fc fc fc fc
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/362a90cecd36e8a5c415966d0b75b04a0270e4dd
  - https://git.kernel.org/stable/c/3bc6317033f365ce578eb6039445fb66162722fd
  - https://git.kernel.org/stable/c/6aff941cb0f7d0c897c3698ad2e30672709135e3
  - https://git.kernel.org/stable/c/76c365fa7e2a8bb85f0190cdb4b8cdc99b2fdce3
  - https://git.kernel.org/stable/c/836e625b03a666cf93ff5be328c8cb30336db872
  - https://git.kernel.org/stable/c/c8e008b60492cf6fd31ef127aea6d02fd3d314cd
  - https://git.kernel.org/stable/c/cf9291a3449b04688b81e32621e88de8f4314b54
  - https://git.kernel.org/stable/c/eb59cc31b6ea076021d14b04e7faab1636b87d0e
  - https://git.kernel.org/stable/c/f737418b6de31c962c7192777ee4018906975383

------------------------------------------------------------

CVE ID: CVE-2025-37739
Description: In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to avoid out-of-bounds access in f2fs_truncate_inode_blocks()

syzbot reports an UBSAN issue as below:

------------[ cut here ]------------
UBSAN: array-index-out-of-bounds in fs/f2fs/node.h:381:10
index 18446744073709550692 is out of range for type '__le32[5]' (aka 'unsigned int[5]')
CPU: 0 UID: 0 PID: 5318 Comm: syz.0.0 Not tainted 6.14.0-rc3-syzkaller-00060-g6537cfb395f3 #0
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 ubsan_epilogue lib/ubsan.c:231 [inline]
 __ubsan_handle_out_of_bounds+0x121/0x150 lib/ubsan.c:429
 get_nid fs/f2fs/node.h:381 [inline]
 f2fs_truncate_inode_blocks+0xa5e/0xf60 fs/f2fs/node.c:1181
 f2fs_do_truncate_blocks+0x782/0x1030 fs/f2fs/file.c:808
 f2fs_truncate_blocks+0x10d/0x300 fs/f2fs/file.c:836
 f2fs_truncate+0x417/0x720 fs/f2fs/file.c:886
 f2fs_file_write_iter+0x1bdb/0x2550 fs/f2fs/file.c:5093
 aio_write+0x56b/0x7c0 fs/aio.c:1633
 io_submit_one+0x8a7/0x18a0 fs/aio.c:2052
 __do_sys_io_submit fs/aio.c:2111 [inline]
 __se_sys_io_submit+0x171/0x2e0 fs/aio.c:2081
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7f238798cde9

index 18446744073709550692 (decimal, unsigned long long)
= 0xfffffffffffffc64 (hexadecimal, unsigned long long)
= -924 (decimal, long long)

In f2fs_truncate_inode_blocks(), UBSAN detects that get_nid() tries to
access .i_nid[-924], it means both offset[0] and level should zero.

The possible case should be in f2fs_do_truncate_blocks(), we try to
truncate inode size to zero, however, dn.ofs_in_node is zero and
dn.node_page is not an inode page, so it fails to truncate inode page,
and then pass zeroed free_from to f2fs_truncate_inode_blocks(), result
in this issue.

	if (dn.ofs_in_node || IS_INODE(dn.node_page)) {
		f2fs_truncate_data_blocks_range(&dn, count);
		free_from += count;
	}

I guess the reason why dn.node_page is not an inode page could be: there
are multiple nat entries share the same node block address, once the node
block address was reused, f2fs_get_node_page() may load a non-inode block.

Let's add a sanity check for such condition to avoid out-of-bounds access
issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/67e16ccba74dd8de0a7b10062f1e02d77432f573
  - https://git.kernel.org/stable/c/6ba8b41d0aa4b82f90f0c416cb53fcef9696525d
  - https://git.kernel.org/stable/c/8b5e5aac44fee122947a269f9034c048e4c295de
  - https://git.kernel.org/stable/c/98dbf2af63de0b551082c9bc48333910e009b09f
  - https://git.kernel.org/stable/c/a67e1bf03c609a751d1740a1789af25e599966fa
  - https://git.kernel.org/stable/c/d7242fd7946d4cba0411effb6b5048ca55125747
  - https://git.kernel.org/stable/c/e6494977bd4a83862118a05f57a8df40256951c0
  - https://git.kernel.org/stable/c/ecc461331604b07cdbdb7360dbdf78471653264c

------------------------------------------------------------

CVE ID: CVE-2025-37740
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: add sanity check for agwidth in dbMount

The width in dmapctl of the AG is zero, it trigger a divide error when
calculating the control page level in dbAllocAG.

To avoid this issue, add a check for agwidth in dbAllocAG.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/722e72f7f9c69fcb3ab7988c2471feff7a4c8de1
  - https://git.kernel.org/stable/c/a065cec230aa807c18828a3eee82f1c8592c2adf
  - https://git.kernel.org/stable/c/a260bf14cd347878f01f70739ba829442a474a16
  - https://git.kernel.org/stable/c/a741f29ac8b6374c9904be8b7ac7cdfcd7e7e4fa
  - https://git.kernel.org/stable/c/c8c96a9e7660e5e5eea445978fe8f2e432d91c1f
  - https://git.kernel.org/stable/c/cc0bc4cb62ce5fa0c383e3bf0765d01f46bd49ac
  - https://git.kernel.org/stable/c/ccd97c8a4f90810f228ee40d1055148fa146dd57
  - https://git.kernel.org/stable/c/ddf2846f22e8575d6b4b6a66f2100f168b8cd73d
  - https://git.kernel.org/stable/c/e3f85edb03183fb06539e5b50dd2c4bb42b869f0

------------------------------------------------------------

CVE ID: CVE-2025-37741
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: Prevent copying of nlink with value 0 from disk inode

syzbot report a deadlock in diFree. [1]

When calling "ioctl$LOOP_SET_STATUS64", the offset value passed in is 4,
which does not match the mounted loop device, causing the mapping of the
mounted loop device to be invalidated.

When creating the directory and creating the inode of iag in diReadSpecial(),
read the page of fixed disk inode (AIT) in raw mode in read_metapage(), the
metapage data it returns is corrupted, which causes the nlink value of 0 to be
assigned to the iag inode when executing copy_from_dinode(), which ultimately
causes a deadlock when entering diFree().

To avoid this, first check the nlink value of dinode before setting iag inode.

[1]
WARNING: possible recursive locking detected
6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0 Not tainted
--------------------------------------------
syz-executor301/5309 is trying to acquire lock:
ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3}, at: diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889

but task is already holding lock:
ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630

other info that might help us debug this:
 Possible unsafe locking scenario:

       CPU0
       ----
  lock(&(imap->im_aglock[index]));
  lock(&(imap->im_aglock[index]));

 *** DEADLOCK ***

 May be due to missing lock nesting notation

5 locks held by syz-executor301/5309:
 #0: ffff8880422a4420 (sb_writers#9){.+.+}-{0:0}, at: mnt_want_write+0x3f/0x90 fs/namespace.c:515
 #1: ffff88804755b390 (&type->i_mutex_dir_key#6/1){+.+.}-{3:3}, at: inode_lock_nested include/linux/fs.h:850 [inline]
 #1: ffff88804755b390 (&type->i_mutex_dir_key#6/1){+.+.}-{3:3}, at: filename_create+0x260/0x540 fs/namei.c:4026
 #2: ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3}, at: diAlloc+0x1b6/0x1630
 #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2460 [inline]
 #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]
 #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3}, at: diAllocAG+0x4b7/0x1e50 fs/jfs/jfs_imap.c:1669
 #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3}, at: diNewIAG fs/jfs/jfs_imap.c:2477 [inline]
 #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3}, at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]
 #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3}, at: diAllocAG+0x869/0x1e50 fs/jfs/jfs_imap.c:1669

stack backtrace:
CPU: 0 UID: 0 PID: 5309 Comm: syz-executor301 Not tainted 6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 print_deadlock_bug+0x483/0x620 kernel/locking/lockdep.c:3037
 check_deadlock kernel/locking/lockdep.c:3089 [inline]
 validate_chain+0x15e2/0x5920 kernel/locking/lockdep.c:3891
 __lock_acquire+0x1384/0x2050 kernel/locking/lockdep.c:5202
 lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825
 __mutex_lock_common kernel/locking/mutex.c:608 [inline]
 __mutex_lock+0x136/0xd70 kernel/locking/mutex.c:752
 diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889
 jfs_evict_inode+0x32d/0x440 fs/jfs/inode.c:156
 evict+0x4e8/0x9b0 fs/inode.c:725
 diFreeSpecial fs/jfs/jfs_imap.c:552 [inline]
 duplicateIXtree+0x3c6/0x550 fs/jfs/jfs_imap.c:3022
 diNewIAG fs/jfs/jfs_imap.c:2597 [inline]
 diAllocExt fs/jfs/jfs_imap.c:1905 [inline]
 diAllocAG+0x17dc/0x1e50 fs/jfs/jfs_imap.c:1669
 diAlloc+0x1d2/0x1630 fs/jfs/jfs_imap.c:1590
 ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56
 jfs_mkdir+0x1c5/0xba0 fs/jfs/namei.c:225
 vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257
 do_mkdirat+0x264/0x3a0 fs/namei.c:4280
 __do_sys_mkdirat fs/namei.c:4295 [inline]
 __se_sys_mkdirat fs/namei.c:4293 [inline]
 __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293
 do_syscall_x64 arch/x86/en
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5b2f26d3fba4e9aac314f8bc0963b3fc28c0e456
  - https://git.kernel.org/stable/c/86bfeaa18f9e4615b97f2d613e0fcc4ced196527
  - https://git.kernel.org/stable/c/8b5ce75f8bd3ddf480cc0a240d7ff5cdea0444f9
  - https://git.kernel.org/stable/c/994787341358816d91b2fded288ecb7f129f2b27
  - https://git.kernel.org/stable/c/a2b560815528ae8e266fca6038bb5585d13aaef4
  - https://git.kernel.org/stable/c/aeb926e605f97857504bdf748f575e40617e2ef9
  - https://git.kernel.org/stable/c/b3c4884b987e5d8d0ec061a4d52653c4f4b9c37e
  - https://git.kernel.org/stable/c/b61e69bb1c049cf507e3c654fa3dc1568231bd07
  - https://git.kernel.org/stable/c/c9541c2bd0edbdbc5c1148a84d3b48dc8d1b8af2

------------------------------------------------------------

CVE ID: CVE-2025-37742
Description: In the Linux kernel, the following vulnerability has been resolved:

jfs: Fix uninit-value access of imap allocated in the diMount() function

syzbot reports that hex_dump_to_buffer is using uninit-value:

=====================================================
BUG: KMSAN: uninit-value in hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171
hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171
print_hex_dump+0x13d/0x3e0 lib/hexdump.c:276
diFree+0x5ba/0x4350 fs/jfs/jfs_imap.c:876
jfs_evict_inode+0x510/0x550 fs/jfs/inode.c:156
evict+0x723/0xd10 fs/inode.c:796
iput_final fs/inode.c:1946 [inline]
iput+0x97b/0xdb0 fs/inode.c:1972
txUpdateMap+0xf3e/0x1150 fs/jfs/jfs_txnmgr.c:2367
txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]
jfs_lazycommit+0x627/0x11d0 fs/jfs/jfs_txnmgr.c:2733
kthread+0x6b9/0xef0 kernel/kthread.c:464
ret_from_fork+0x6d/0x90 arch/x86/kernel/process.c:148
ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

Uninit was created at:
slab_post_alloc_hook mm/slub.c:4121 [inline]
slab_alloc_node mm/slub.c:4164 [inline]
__kmalloc_cache_noprof+0x8e3/0xdf0 mm/slub.c:4320
kmalloc_noprof include/linux/slab.h:901 [inline]
diMount+0x61/0x7f0 fs/jfs/jfs_imap.c:105
jfs_mount+0xa8e/0x11d0 fs/jfs/jfs_mount.c:176
jfs_fill_super+0xa47/0x17c0 fs/jfs/super.c:523
get_tree_bdev_flags+0x6ec/0x910 fs/super.c:1636
get_tree_bdev+0x37/0x50 fs/super.c:1659
jfs_get_tree+0x34/0x40 fs/jfs/super.c:635
vfs_get_tree+0xb1/0x5a0 fs/super.c:1814
do_new_mount+0x71f/0x15e0 fs/namespace.c:3560
path_mount+0x742/0x1f10 fs/namespace.c:3887
do_mount fs/namespace.c:3900 [inline]
__do_sys_mount fs/namespace.c:4111 [inline]
__se_sys_mount+0x71f/0x800 fs/namespace.c:4088
__x64_sys_mount+0xe4/0x150 fs/namespace.c:4088
x64_sys_call+0x39bf/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:166
do_syscall_x64 arch/x86/entry/common.c:52 [inline]
do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83
entry_SYSCALL_64_after_hwframe+0x77/0x7f
=====================================================

The reason is that imap is not properly initialized after memory
allocation. It will cause the snprintf() function to write uninitialized
data into linebuf within hex_dump_to_buffer().

Fix this by using kzalloc instead of kmalloc to clear its content at the
beginning in diMount().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/067347e00a3a7d04afed93f080c6c131e5dd15ee
  - https://git.kernel.org/stable/c/4f10732712fce33e53703ffe5ed9155f23814097
  - https://git.kernel.org/stable/c/63148ce4904faa668daffdd1d3c1199ae315ef2c
  - https://git.kernel.org/stable/c/7057f3aab47629d38e54eae83505813cf0da1e4b
  - https://git.kernel.org/stable/c/9629d7d66c621671d9a47afe27ca9336bfc8a9ea
  - https://git.kernel.org/stable/c/cab1852368dd74d629ee02abdbc559218ca64dde
  - https://git.kernel.org/stable/c/d0d7eca253ccd0619b3d2b683ffe32218ebca9ac

------------------------------------------------------------

CVE ID: CVE-2025-37743
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath12k: Avoid memory leak while enabling statistics

Driver uses monitor destination rings for extended statistics mode and
standalone monitor mode. In extended statistics mode, TLVs are parsed from
the buffer received from the monitor destination ring and assigned to the
ppdu_info structure to update per-packet statistics. In standalone monitor
mode, along with per-packet statistics, the packet data (payload) is
captured, and the driver updates per MSDU to mac80211.

When the AP interface is enabled, only extended statistics mode is
activated. As part of enabling monitor rings for collecting statistics,
the driver subscribes to HAL_RX_MPDU_START TLV in the filter
configuration. This TLV is received from the monitor destination ring, and
kzalloc for the mon_mpdu object occurs, which is not freed, leading to a
memory leak. The kzalloc for the mon_mpdu object is only required while
enabling the standalone monitor interface. This causes a memory leak while
enabling extended statistics mode in the driver.

Fix this memory leak by removing the kzalloc for the mon_mpdu object in
the HAL_RX_MPDU_START TLV handling. Additionally, remove the standalone
monitor mode handlings in the HAL_MON_BUF_ADDR and HAL_RX_MSDU_END TLVs.
These TLV tags will be handled properly when enabling standalone monitor
mode in the future.

Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/286bab0fc7b9db728dab8c63cadf6be9b3facf8c
  - https://git.kernel.org/stable/c/ecfc131389923405be8e7a6f4408fd9321e4d19b

------------------------------------------------------------

CVE ID: CVE-2025-37744
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: ath12k: fix memory leak in ath12k_pci_remove()

Kmemleak reported this error:

  unreferenced object 0xffff1c165cec3060 (size 32):
    comm "insmod", pid 560, jiffies 4296964570 (age 235.596s)
    backtrace:
      [<000000005434db68>] __kmem_cache_alloc_node+0x1f4/0x2c0
      [<000000001203b155>] kmalloc_trace+0x40/0x88
      [<0000000028adc9c8>] _request_firmware+0xb8/0x608
      [<00000000cad1aef7>] firmware_request_nowarn+0x50/0x80
      [<000000005011a682>] local_pci_probe+0x48/0xd0
      [<00000000077cd295>] pci_device_probe+0xb4/0x200
      [<0000000087184c94>] really_probe+0x150/0x2c0

The firmware memory was allocated in ath12k_pci_probe(), but not
freed in ath12k_pci_remove() in case ATH12K_FLAG_QMI_FAIL bit is
set. So call ath12k_fw_unmap() to free the memory.

Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.2.0-02280-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b24394ed5c8a8d8f7b9e3aa9044c31495d46f2e
  - https://git.kernel.org/stable/c/3cb47b50926a5b9eef8c06506a14cdc0f3d95c53
  - https://git.kernel.org/stable/c/52e3132e62c31b5ade43dc4495fa81175e6e8398
  - https://git.kernel.org/stable/c/cb8f4c5f9c487d82a566672b5ed0c9f05e40659b

------------------------------------------------------------

CVE ID: CVE-2025-37745
Description: In the Linux kernel, the following vulnerability has been resolved:

PM: hibernate: Avoid deadlock in hibernate_compressor_param_set()

syzbot reported a deadlock in lock_system_sleep() (see below).

The write operation to "/sys/module/hibernate/parameters/compressor"
conflicts with the registration of ieee80211 device, resulting in a deadlock
when attempting to acquire system_transition_mutex under param_lock.

To avoid this deadlock, change hibernate_compressor_param_set() to use
mutex_trylock() for attempting to acquire system_transition_mutex and
return -EBUSY when it fails.

Task flags need not be saved or adjusted before calling
mutex_trylock(&system_transition_mutex) because the caller is not going
to end up waiting for this mutex and if it runs concurrently with system
suspend in progress, it will be frozen properly when it returns to user
space.

syzbot report:

syz-executor895/5833 is trying to acquire lock:
ffffffff8e0828c8 (system_transition_mutex){+.+.}-{4:4}, at: lock_system_sleep+0x87/0xa0 kernel/power/main.c:56

but task is already holding lock:
ffffffff8e07dc68 (param_lock){+.+.}-{4:4}, at: kernel_param_lock kernel/params.c:607 [inline]
ffffffff8e07dc68 (param_lock){+.+.}-{4:4}, at: param_attr_store+0xe6/0x300 kernel/params.c:586

which lock already depends on the new lock.

the existing dependency chain (in reverse order) is:

-> #3 (param_lock){+.+.}-{4:4}:
       __mutex_lock_common kernel/locking/mutex.c:585 [inline]
       __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730
       ieee80211_rate_control_ops_get net/mac80211/rate.c:220 [inline]
       rate_control_alloc net/mac80211/rate.c:266 [inline]
       ieee80211_init_rate_ctrl_alg+0x18d/0x6b0 net/mac80211/rate.c:1015
       ieee80211_register_hw+0x20cd/0x4060 net/mac80211/main.c:1531
       mac80211_hwsim_new_radio+0x304e/0x54e0 drivers/net/wireless/virtual/mac80211_hwsim.c:5558
       init_mac80211_hwsim+0x432/0x8c0 drivers/net/wireless/virtual/mac80211_hwsim.c:6910
       do_one_initcall+0x128/0x700 init/main.c:1257
       do_initcall_level init/main.c:1319 [inline]
       do_initcalls init/main.c:1335 [inline]
       do_basic_setup init/main.c:1354 [inline]
       kernel_init_freeable+0x5c7/0x900 init/main.c:1568
       kernel_init+0x1c/0x2b0 init/main.c:1457
       ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:148
       ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

-> #2 (rtnl_mutex){+.+.}-{4:4}:
       __mutex_lock_common kernel/locking/mutex.c:585 [inline]
       __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730
       wg_pm_notification drivers/net/wireguard/device.c:80 [inline]
       wg_pm_notification+0x49/0x180 drivers/net/wireguard/device.c:64
       notifier_call_chain+0xb7/0x410 kernel/notifier.c:85
       notifier_call_chain_robust kernel/notifier.c:120 [inline]
       blocking_notifier_call_chain_robust kernel/notifier.c:345 [inline]
       blocking_notifier_call_chain_robust+0xc9/0x170 kernel/notifier.c:333
       pm_notifier_call_chain_robust+0x27/0x60 kernel/power/main.c:102
       snapshot_open+0x189/0x2b0 kernel/power/user.c:77
       misc_open+0x35a/0x420 drivers/char/misc.c:179
       chrdev_open+0x237/0x6a0 fs/char_dev.c:414
       do_dentry_open+0x735/0x1c40 fs/open.c:956
       vfs_open+0x82/0x3f0 fs/open.c:1086
       do_open fs/namei.c:3830 [inline]
       path_openat+0x1e88/0x2d80 fs/namei.c:3989
       do_filp_open+0x20c/0x470 fs/namei.c:4016
       do_sys_openat2+0x17a/0x1e0 fs/open.c:1428
       do_sys_open fs/open.c:1443 [inline]
       __do_sys_openat fs/open.c:1459 [inline]
       __se_sys_openat fs/open.c:1454 [inline]
       __x64_sys_openat+0x175/0x210 fs/open.c:1454
       do_syscall_x64 arch/x86/entry/common.c:52 [inline]
       do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
       entry_SYSCALL_64_after_hwframe+0x77/0x7f

-> #1 ((pm_chain_head).rwsem){++++}-{4:4}:
       down_read+0x9a/0x330 kernel/locking/rwsem.c:1524
       blocking_notifier_call_chain_robust kerne
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11ae4fec1f4b4ee06770a572c37d89cbaecbf66e
  - https://git.kernel.org/stable/c/3b2c3806ef4253595dfcb8b58352cfab55c9bfb0
  - https://git.kernel.org/stable/c/52323ed1444ea5c2a5f1754ea0a2d9c8c216ccdf
  - https://git.kernel.org/stable/c/6dbaa8583af74814a5aae03a337cb1722c414808

------------------------------------------------------------

CVE ID: CVE-2025-37746
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/dwc_pcie: fix duplicate pci_dev devices

During platform_device_register, wrongly using struct device
pci_dev as platform_data caused a kmemdup copy of pci_dev. Worse
still, accessing the duplicated device leads to list corruption as its
mutex content (e.g., list, magic) remains the same as the original.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7f35b429802a8065aa61e2a3f567089649f4d98e
  - https://git.kernel.org/stable/c/a71c6fc87b2b9905dc2e38887fe4122287216be9

------------------------------------------------------------

CVE ID: CVE-2025-37747
Description: In the Linux kernel, the following vulnerability has been resolved:

perf: Fix hang while freeing sigtrap event

Perf can hang while freeing a sigtrap event if a related deferred
signal hadn't managed to be sent before the file got closed:

perf_event_overflow()
   task_work_add(perf_pending_task)

fput()
   task_work_add(____fput())

task_work_run()
    ____fput()
        perf_release()
            perf_event_release_kernel()
                _free_event()
                    perf_pending_task_sync()
                        task_work_cancel() -> FAILED
                        rcuwait_wait_event()

Once task_work_run() is running, the list of pending callbacks is
removed from the task_struct and from this point on task_work_cancel()
can't remove any pending and not yet started work items, hence the
task_work_cancel() failure and the hang on rcuwait_wait_event().

Task work could be changed to remove one work at a time, so a work
running on the current task can always cancel a pending one, however
the wait / wake design is still subject to inverted dependencies when
remote targets are involved, as pictured by Oleg:

T1                                                      T2

fd = perf_event_open(pid => T2->pid);                  fd = perf_event_open(pid => T1->pid);
close(fd)                                              close(fd)
    <IRQ>                                                  <IRQ>
    perf_event_overflow()                                  perf_event_overflow()
       task_work_add(perf_pending_task)                        task_work_add(perf_pending_task)
    </IRQ>                                                 </IRQ>
    fput()                                                 fput()
        task_work_add(____fput())                              task_work_add(____fput())

    task_work_run()                                        task_work_run()
        ____fput()                                             ____fput()
            perf_release()                                         perf_release()
                perf_event_release_kernel()                            perf_event_release_kernel()
                    _free_event()                                          _free_event()
                        perf_pending_task_sync()                               perf_pending_task_sync()
                            rcuwait_wait_event()                                   rcuwait_wait_event()

Therefore the only option left is to acquire the event reference count
upon queueing the perf task work and release it from the task work, just
like it was done before 3a5465418f5f ("perf: Fix event leak upon exec and file release")
but without the leaks it fixed.

Some adjustments are necessary to make it work:

* A child event might dereference its parent upon freeing. Care must be
  taken to release the parent last.

* Some places assuming the event doesn't have any reference held and
  therefore can be freed right away must instead put the reference and
  let the reference counting to its job.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1267bd38f161c1a27d9b722de017027167a225a0
  - https://git.kernel.org/stable/c/56799bc035658738f362acec3e7647bb84e68933
  - https://git.kernel.org/stable/c/665b87b8f8b3aeb49083ef3b65c4953e7753fc12
  - https://git.kernel.org/stable/c/fa1827fa968c0674e9b6fca223fa9fb4da4493eb

------------------------------------------------------------

CVE ID: CVE-2025-37748
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/mediatek: Fix NULL pointer deference in mtk_iommu_device_group

Currently, mtk_iommu calls during probe iommu_device_register before
the hw_list from driver data is initialized. Since iommu probing issue
fix, it leads to NULL pointer dereference in mtk_iommu_device_group when
hw_list is accessed with list_first_entry (not null safe).

So, change the call order to ensure iommu_device_register is called
after the driver data are initialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2f75cb27bef43c8692b0f5e471e5632f6a9beb99
  - https://git.kernel.org/stable/c/38e8844005e6068f336a3ad45451a562a0040ca1
  - https://git.kernel.org/stable/c/69f9d2d37d1207c5a73dac52a4ce1361ead707f5
  - https://git.kernel.org/stable/c/6abd09bed43b8d83d461e0fb5b9a200a06aa8a27
  - https://git.kernel.org/stable/c/a0842539e8ef9386c070156103aff888e558a60c
  - https://git.kernel.org/stable/c/ce7d3b2f6f393fa35f0ea12861b83a1ca28b295c

------------------------------------------------------------

CVE ID: CVE-2025-37749
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ppp: Add bound checking for skb data on ppp_sync_txmung

Ensure we have enough data in linear buffer from skb before accessing
initial bytes. This prevents potential out-of-bounds accesses
when processing short packets.

When ppp_sync_txmung receives an incoming package with an empty
payload:
(remote) gef➤  p *(struct pppoe_hdr *) (skb->head + skb->network_header)
$18 = {
	type = 0x1,
	ver = 0x1,
	code = 0x0,
	sid = 0x2,
        length = 0x0,
	tag = 0xffff8880371cdb96
}

from the skb struct (trimmed)
      tail = 0x16,
      end = 0x140,
      head = 0xffff88803346f400 "4",
      data = 0xffff88803346f416 ":\377",
      truesize = 0x380,
      len = 0x0,
      data_len = 0x0,
      mac_len = 0xe,
      hdr_len = 0x0,

it is not safe to access data[2].

[pabeni@redhat.com: fixed subj typo]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1f6eb9fa87a781d5370c0de7794ae242f1a95ee5
  - https://git.kernel.org/stable/c/529401c8f12ecc35f9ea5d946d5a5596cf172b48
  - https://git.kernel.org/stable/c/6e8a6bf43cea4347121ab21bb1ed8d7bef7e732e
  - https://git.kernel.org/stable/c/99aa698dec342a07125d733e39aab4394b3b7e05
  - https://git.kernel.org/stable/c/aabc6596ffb377c4c9c8f335124b92ea282c9821
  - https://git.kernel.org/stable/c/b4c836d33ca888695b2f2665f948bc1b34fbd533
  - https://git.kernel.org/stable/c/b78f2b458f56a5a4d976c8e01c43dbf58d3ea2ca
  - https://git.kernel.org/stable/c/de5a4f0cba58625e88b7bebd88f780c8c0150997
  - https://git.kernel.org/stable/c/fbaffe8bccf148ece8ad67eb5d7aa852cabf59c8

------------------------------------------------------------

CVE ID: CVE-2025-37750
Description: In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix UAF in decryption with multichannel

After commit f7025d861694 ("smb: client: allocate crypto only for
primary server") and commit b0abcd65ec54 ("smb: client: fix UAF in
async decryption"), the channels started reusing AEAD TFM from primary
channel to perform synchronous decryption, but that can't done as
there could be multiple cifsd threads (one per channel) simultaneously
accessing it to perform decryption.

This fixes the following KASAN splat when running fstest generic/249
with 'vers=3.1.1,multichannel,max_channels=4,seal' against Windows
Server 2022:

BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xba/0x110
Read of size 8 at addr ffff8881046c18a0 by task cifsd/986
CPU: 3 UID: 0 PID: 986 Comm: cifsd Not tainted 6.15.0-rc1 #1
PREEMPT(voluntary)
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-3.fc41
04/01/2014
Call Trace:
 <TASK>
 dump_stack_lvl+0x5d/0x80
 print_report+0x156/0x528
 ? gf128mul_4k_lle+0xba/0x110
 ? __virt_addr_valid+0x145/0x300
 ? __phys_addr+0x46/0x90
 ? gf128mul_4k_lle+0xba/0x110
 kasan_report+0xdf/0x1a0
 ? gf128mul_4k_lle+0xba/0x110
 gf128mul_4k_lle+0xba/0x110
 ghash_update+0x189/0x210
 shash_ahash_update+0x295/0x370
 ? __pfx_shash_ahash_update+0x10/0x10
 ? __pfx_shash_ahash_update+0x10/0x10
 ? __pfx_extract_iter_to_sg+0x10/0x10
 ? ___kmalloc_large_node+0x10e/0x180
 ? __asan_memset+0x23/0x50
 crypto_ahash_update+0x3c/0xc0
 gcm_hash_assoc_remain_continue+0x93/0xc0
 crypt_message+0xe09/0xec0 [cifs]
 ? __pfx_crypt_message+0x10/0x10 [cifs]
 ? _raw_spin_unlock+0x23/0x40
 ? __pfx_cifs_readv_from_socket+0x10/0x10 [cifs]
 decrypt_raw_data+0x229/0x380 [cifs]
 ? __pfx_decrypt_raw_data+0x10/0x10 [cifs]
 ? __pfx_cifs_read_iter_from_socket+0x10/0x10 [cifs]
 smb3_receive_transform+0x837/0xc80 [cifs]
 ? __pfx_smb3_receive_transform+0x10/0x10 [cifs]
 ? __pfx___might_resched+0x10/0x10
 ? __pfx_smb3_is_transform_hdr+0x10/0x10 [cifs]
 cifs_demultiplex_thread+0x692/0x1570 [cifs]
 ? __pfx_cifs_demultiplex_thread+0x10/0x10 [cifs]
 ? rcu_is_watching+0x20/0x50
 ? rcu_lockdep_current_cpu_online+0x62/0xb0
 ? find_held_lock+0x32/0x90
 ? kvm_sched_clock_read+0x11/0x20
 ? local_clock_noinstr+0xd/0xd0
 ? trace_irq_enable.constprop.0+0xa8/0xe0
 ? __pfx_cifs_demultiplex_thread+0x10/0x10 [cifs]
 kthread+0x1fe/0x380
 ? kthread+0x10f/0x380
 ? __pfx_kthread+0x10/0x10
 ? local_clock_noinstr+0xd/0xd0
 ? ret_from_fork+0x1b/0x60
 ? local_clock+0x15/0x30
 ? lock_release+0x29b/0x390
 ? rcu_is_watching+0x20/0x50
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x31/0x60
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9502dd5c7029902f4a425bf959917a5a9e7c0e50
  - https://git.kernel.org/stable/c/950557922c1298464749c216d8763e97faf5d0a6
  - https://git.kernel.org/stable/c/aa5a1e4b882964eb79d5b5d1d1e8a1a5efbb1d15
  - https://git.kernel.org/stable/c/e859b216d94668bc66330e61be201234f4413d1a

------------------------------------------------------------

CVE ID: CVE-2025-37751
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/cpu: Avoid running off the end of an AMD erratum table

The NULL array terminator at the end of erratum_1386_microcode was
removed during the switch from x86_cpu_desc to x86_cpu_id. This
causes readers to run off the end of the array.

Replace the NULL.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b518f73f1b6f59e083ec33dea22d9a1a275a970
  - https://git.kernel.org/stable/c/f0df00ebc57f803603f2a2e0df197e51f06fbe90

------------------------------------------------------------

CVE ID: CVE-2025-37752
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: sch_sfq: move the limit validation

It is not sufficient to directly validate the limit on the data that
the user passes as it can be updated based on how the other parameters
are changed.

Move the check at the end of the configuration update process to also
catch scenarios where the limit is indirectly updated, for example
with the following configurations:

tc qdisc add dev dummy0 handle 1: root sfq limit 2 flows 1 depth 1
tc qdisc add dev dummy0 handle 1: root sfq limit 2 flows 1 divisor 1

This fixes the following syzkaller reported crash:

------------[ cut here ]------------
UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:203:6
index 65535 is out of range for type 'struct sfq_head[128]'
CPU: 1 UID: 0 PID: 3037 Comm: syz.2.16 Not tainted 6.14.0-rc2-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 12/27/2024
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x201/0x300 lib/dump_stack.c:120
 ubsan_epilogue lib/ubsan.c:231 [inline]
 __ubsan_handle_out_of_bounds+0xf5/0x120 lib/ubsan.c:429
 sfq_link net/sched/sch_sfq.c:203 [inline]
 sfq_dec+0x53c/0x610 net/sched/sch_sfq.c:231
 sfq_dequeue+0x34e/0x8c0 net/sched/sch_sfq.c:493
 sfq_reset+0x17/0x60 net/sched/sch_sfq.c:518
 qdisc_reset+0x12e/0x600 net/sched/sch_generic.c:1035
 tbf_reset+0x41/0x110 net/sched/sch_tbf.c:339
 qdisc_reset+0x12e/0x600 net/sched/sch_generic.c:1035
 dev_reset_queue+0x100/0x1b0 net/sched/sch_generic.c:1311
 netdev_for_each_tx_queue include/linux/netdevice.h:2590 [inline]
 dev_deactivate_many+0x7e5/0xe70 net/sched/sch_generic.c:1375
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1348214fa042a71406964097e743c87a42c85a49
  - https://git.kernel.org/stable/c/5e5e1fcc1b8ed57f902c424c5d9b328a3a19073d
  - https://git.kernel.org/stable/c/b36a68192037d1614317a09b0d78c7814e2eecf9
  - https://git.kernel.org/stable/c/b3bf8f63e6179076b57c9de660c9f80b5abefe70
  - https://git.kernel.org/stable/c/d2718324f9e329b10ddc091fba5a0ba2b9d4d96a
  - https://git.kernel.org/stable/c/f86293adce0c201cfabb283ef9d6f21292089bb8

------------------------------------------------------------

CVE ID: CVE-2025-37753
Description: In the Linux kernel, the following vulnerability has been resolved:

s390/cpumf: Fix double free on error in cpumf_pmu_event_init()

In PMU event initialization functions
 - cpumsf_pmu_event_init()
 - cpumf_pmu_event_init()
 - cfdiag_event_init()
the partially created event had to be removed when an error was detected.
The event::event_init() member function had to release all resources
it allocated in case of error. event::destroy() had to be called
on freeing an event after it was successfully created and
event::event_init() returned success.

With

commit c70ca298036c ("perf/core: Simplify the perf_event_alloc() error path")

this is not necessary anymore. The performance subsystem common
code now always calls event::destroy() to clean up the allocated
resources created during event initialization.

Remove the event::destroy() invocation in PMU event initialization
or that function is called twice for each event that runs into an
error condition in event creation.

This is the kernel log entry which shows up without the fix:

------------[ cut here ]------------
refcount_t: underflow; use-after-free.
WARNING: CPU: 0 PID: 43388 at lib/refcount.c:87	refcount_dec_not_one+0x74/0x90
CPU: 0 UID: 0 PID: 43388 Comm: perf Not tainted 6.15.0-20250407.rc1.git0.300.fc41.s390x+git #1 NONE
Hardware name: IBM 3931 A01 704 (LPAR)
Krnl PSW : 0704c00180000000 00000209cb2c1b88 (refcount_dec_not_one+0x78/0x90)
           R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:0 PM:0 RI:0 EA:3
Krnl GPRS: 0000020900000027 0000020900000023 0000000000000026 0000018900000000
           00000004a2200a00 0000000000000000 0000000000000057 ffffffffffffffea
           00000002b386c600 00000002b3f5b3e0 00000209cc51f140 00000209cc7fc550
           0000000001449d38 ffffffffffffffff 00000209cb2c1b84 00000189d67dfb80
Krnl Code: 00000209cb2c1b78: c02000506727	larl	%r2,00000209cbcce9c6
           00000209cb2c1b7e: c0e5ffbd4431	brasl	%r14,00000209caa6a3e0
          #00000209cb2c1b84: af000000		mc	0,0
          >00000209cb2c1b88: a7480001		lhi	%r4,1
           00000209cb2c1b8c: ebeff0a00004	lmg	%r14,%r15,160(%r15)
           00000209cb2c1b92: ec243fbf0055	risbg	%r2,%r4,63,191,0
           00000209cb2c1b98: 07fe		bcr	15,%r14
           00000209cb2c1b9a: 47000700		bc	0,1792
Call Trace:
 [<00000209cb2c1b88>] refcount_dec_not_one+0x78/0x90
 [<00000209cb2c1dc4>] refcount_dec_and_mutex_lock+0x24/0x90
 [<00000209caa3c29e>] hw_perf_event_destroy+0x2e/0x80
 [<00000209cacaf8b4>] __free_event+0x74/0x270
 [<00000209cacb47c4>] perf_event_alloc.part.0+0x4a4/0x730
 [<00000209cacbf3e8>] __do_sys_perf_event_open+0x248/0xc20
 [<00000209cacc14a4>] __s390x_sys_perf_event_open+0x44/0x50
 [<00000209cb8114de>] __do_syscall+0x12e/0x260
 [<00000209cb81ce34>] system_call+0x74/0x98
Last Breaking-Event-Address:
 [<00000209caa6a4d2>] __warn_printk+0xf2/0x100
---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a3faf873db5dcd5d2622d8e2accb90af0a86c2d
  - https://git.kernel.org/stable/c/aa1ac98268cd1f380c713f07e39b1fa1d5c7650c
  - https://git.kernel.org/stable/c/bdbecb2bf531fadbbc9347a79009f7a58ea7eb03
  - https://git.kernel.org/stable/c/ddf60c1491102dab04491481bc3376d3e9cd139d

------------------------------------------------------------

CVE ID: CVE-2025-37754
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915/huc: Fix fence not released on early probe errors

HuC delayed loading fence, introduced with commit 27536e03271da
("drm/i915/huc: track delayed HuC load with a fence"), is registered with
object tracker early on driver probe but unregistered only from driver
remove, which is not called on early probe errors.  Since its memory is
allocated under devres, then released anyway, it may happen to be
allocated again to the fence and reused on future driver probes, resulting
in kernel warnings that taint the kernel:

<4> [309.731371] ------------[ cut here ]------------
<3> [309.731373] ODEBUG: init destroyed (active state 0) object: ffff88813d7dd2e0 object type: i915_sw_fence hint: sw_fence_dummy_notify+0x0/0x20 [i915]
<4> [309.731575] WARNING: CPU: 2 PID: 3161 at lib/debugobjects.c:612 debug_print_object+0x93/0xf0
...
<4> [309.731693] CPU: 2 UID: 0 PID: 3161 Comm: i915_module_loa Tainted: G     U             6.14.0-CI_DRM_16362-gf0fd77956987+ #1
...
<4> [309.731700] RIP: 0010:debug_print_object+0x93/0xf0
...
<4> [309.731728] Call Trace:
<4> [309.731730]  <TASK>
...
<4> [309.731949]  __debug_object_init+0x17b/0x1c0
<4> [309.731957]  debug_object_init+0x34/0x50
<4> [309.732126]  __i915_sw_fence_init+0x34/0x60 [i915]
<4> [309.732256]  intel_huc_init_early+0x4b/0x1d0 [i915]
<4> [309.732468]  intel_uc_init_early+0x61/0x680 [i915]
<4> [309.732667]  intel_gt_common_init_early+0x105/0x130 [i915]
<4> [309.732804]  intel_root_gt_init_early+0x63/0x80 [i915]
<4> [309.732938]  i915_driver_probe+0x1fa/0xeb0 [i915]
<4> [309.733075]  i915_pci_probe+0xe6/0x220 [i915]
<4> [309.733198]  local_pci_probe+0x44/0xb0
<4> [309.733203]  pci_device_probe+0xf4/0x270
<4> [309.733209]  really_probe+0xee/0x3c0
<4> [309.733215]  __driver_probe_device+0x8c/0x180
<4> [309.733219]  driver_probe_device+0x24/0xd0
<4> [309.733223]  __driver_attach+0x10f/0x220
<4> [309.733230]  bus_for_each_dev+0x7d/0xe0
<4> [309.733236]  driver_attach+0x1e/0x30
<4> [309.733239]  bus_add_driver+0x151/0x290
<4> [309.733244]  driver_register+0x5e/0x130
<4> [309.733247]  __pci_register_driver+0x7d/0x90
<4> [309.733251]  i915_pci_register_driver+0x23/0x30 [i915]
<4> [309.733413]  i915_init+0x34/0x120 [i915]
<4> [309.733655]  do_one_initcall+0x62/0x3f0
<4> [309.733667]  do_init_module+0x97/0x2a0
<4> [309.733671]  load_module+0x25ff/0x2890
<4> [309.733688]  init_module_from_file+0x97/0xe0
<4> [309.733701]  idempotent_init_module+0x118/0x330
<4> [309.733711]  __x64_sys_finit_module+0x77/0x100
<4> [309.733715]  x64_sys_call+0x1f37/0x2650
<4> [309.733719]  do_syscall_64+0x91/0x180
<4> [309.733763]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
<4> [309.733792]  </TASK>
...
<4> [309.733806] ---[ end trace 0000000000000000 ]---

That scenario is most easily reproducible with
igt@i915_module_load@reload-with-fault-injection.

Fix the issue by moving the cleanup step to driver release path.

(cherry picked from commit 795dbde92fe5c6996a02a5b579481de73035e7bf)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4bd4bf79bcfe101f0385ab81dbabb6e3f7d96c00
  - https://git.kernel.org/stable/c/9f5ef4a5eaa61a7a4ed31231da45deb85065397a
  - https://git.kernel.org/stable/c/c5a906806162aea62dbe5d327760ce3b7117ca17
  - https://git.kernel.org/stable/c/e3ea2eae70692a455e256787e4f54153fb739b90
  - https://git.kernel.org/stable/c/f104ef4db9f8f3923cc06ed1fafb3da38df6006d

------------------------------------------------------------

CVE ID: CVE-2025-37755
Description: In the Linux kernel, the following vulnerability has been resolved:

net: libwx: handle page_pool_dev_alloc_pages error

page_pool_dev_alloc_pages could return NULL. There was a WARN_ON(!page)
but it would still proceed to use the NULL pointer and then crash.

This is similar to commit 001ba0902046
("net: fec: handle page_pool_dev_alloc_pages error").

This is found by our static analysis tool KNighter.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1dd13c60348f515acd8c6f25a561b9c4e3b04fea
  - https://git.kernel.org/stable/c/7f1ff1b38a7c8b872382b796023419d87d78c47e
  - https://git.kernel.org/stable/c/90bec7cef8805f9a23145e070dff28a02bb584eb
  - https://git.kernel.org/stable/c/ad81d666e114ebf989fc9994d4c93d451dc60056
  - https://git.kernel.org/stable/c/c17ef974bfcf1a50818168b47c4606b425a957c4

------------------------------------------------------------

CVE ID: CVE-2025-37756
Description: In the Linux kernel, the following vulnerability has been resolved:

net: tls: explicitly disallow disconnect

syzbot discovered that it can disconnect a TLS socket and then
run into all sort of unexpected corner cases. I have a vague
recollection of Eric pointing this out to us a long time ago.
Supporting disconnect is really hard, for one thing if offload
is enabled we'd need to wait for all packets to be _acked_.
Disconnect is not commonly used, disallow it.

The immediate problem syzbot run into is the warning in the strp,
but that's just the easiest bug to trigger:

  WARNING: CPU: 0 PID: 5834 at net/tls/tls_strp.c:486 tls_strp_msg_load+0x72e/0xa80 net/tls/tls_strp.c:486
  RIP: 0010:tls_strp_msg_load+0x72e/0xa80 net/tls/tls_strp.c:486
  Call Trace:
   <TASK>
   tls_rx_rec_wait+0x280/0xa60 net/tls/tls_sw.c:1363
   tls_sw_recvmsg+0x85c/0x1c30 net/tls/tls_sw.c:2043
   inet6_recvmsg+0x2c9/0x730 net/ipv6/af_inet6.c:678
   sock_recvmsg_nosec net/socket.c:1023 [inline]
   sock_recvmsg+0x109/0x280 net/socket.c:1045
   __sys_recvfrom+0x202/0x380 net/socket.c:2237
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2bcad8fefcecdd5f005d8c550b25d703c063c34a
  - https://git.kernel.org/stable/c/5071a1e606b30c0c11278d3c6620cd6a24724cf6
  - https://git.kernel.org/stable/c/7bdcf5bc35ae59fc4a0fa23276e84b4d1534a3cf
  - https://git.kernel.org/stable/c/8513411ec321942bd3cfed53d5bb700665c67d86
  - https://git.kernel.org/stable/c/9fcbca0f801580cbb583e9cb274e2c7fbe766ca6
  - https://git.kernel.org/stable/c/ac91c6125468be720eafde9c973994cb45b61d44
  - https://git.kernel.org/stable/c/c665bef891e8972e1d3ce5bbc0d42a373346a2c3
  - https://git.kernel.org/stable/c/f3ce4d3f874ab7919edca364c147ac735f9f1d04

------------------------------------------------------------

CVE ID: CVE-2025-37757
Description: In the Linux kernel, the following vulnerability has been resolved:

tipc: fix memory leak in tipc_link_xmit

In case the backlog transmit queue for system-importance messages is overloaded,
tipc_link_xmit() returns -ENOBUFS but the skb list is not purged. This leads to
memory leak and failure when a skb is allocated.

This commit fixes this issue by purging the skb list before tipc_link_xmit()
returns.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09c2dcda2c551bba30710c33f6ac678ae7395389
  - https://git.kernel.org/stable/c/24e6280cdd7f8d01fc6b9b365fb800c2fb7ea9bb
  - https://git.kernel.org/stable/c/69ae94725f4fc9e75219d2d69022029c5b24bc9a
  - https://git.kernel.org/stable/c/7c5957f7905b4aede9d7a559d271438f3ca9e852
  - https://git.kernel.org/stable/c/84895f5ce3829d9fc030e5ec2d8729da4c0c9d08
  - https://git.kernel.org/stable/c/a40cbfbb8f95c325430f017883da669b2aa927d4
  - https://git.kernel.org/stable/c/d0e02d3d27a0b4dcb13f954f537ca1dd8f282dcf
  - https://git.kernel.org/stable/c/d4d40e437adb376be16b3a12dd5c63f0fa768247
  - https://git.kernel.org/stable/c/ed06675d3b8cd37120b447646d53f7cd3e6fcd63

------------------------------------------------------------

CVE ID: CVE-2025-37758
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: pata_pxa: Fix potential NULL pointer dereference in pxa_ata_probe()

devm_ioremap() returns NULL on error. Currently, pxa_ata_probe() does
not check for this case, which can result in a NULL pointer dereference.

Add NULL check after devm_ioremap() to prevent this issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/17d5e6e915fad5a261db3698c9c5bbe702102d7c
  - https://git.kernel.org/stable/c/2ba9e4c69207777bb0775c7c091800ecd69de144
  - https://git.kernel.org/stable/c/2dc53c7a0c1f57b082931facafa804a7ca32a9a6
  - https://git.kernel.org/stable/c/5b09bf6243b0bc0ae58bd9efdf6f0de5546f8d06
  - https://git.kernel.org/stable/c/a551f75401793ba8075d7f46ffc931ce5151f03f
  - https://git.kernel.org/stable/c/ad320e408a8c95a282ab9c05cdf0c9b95e317985
  - https://git.kernel.org/stable/c/c022287f6e599422511aa227dc6da37b58d9ceac
  - https://git.kernel.org/stable/c/d0d720f9282839b9db625a376c02a1426a16b0ae
  - https://git.kernel.org/stable/c/ee2b0301d6bfe16b35d57947687c664ecb815775

------------------------------------------------------------

CVE ID: CVE-2025-37759
Description: In the Linux kernel, the following vulnerability has been resolved:

ublk: fix handling recovery & reissue in ublk_abort_queue()

Commit 8284066946e6 ("ublk: grab request reference when the request is handled
by userspace") doesn't grab request reference in case of recovery reissue.
Then the request can be requeued & re-dispatch & failed when canceling
uring command.

If it is one zc request, the request can be freed before io_uring
returns the zc buffer back, then cause kernel panic:

[  126.773061] BUG: kernel NULL pointer dereference, address: 00000000000000c8
[  126.773657] #PF: supervisor read access in kernel mode
[  126.774052] #PF: error_code(0x0000) - not-present page
[  126.774455] PGD 0 P4D 0
[  126.774698] Oops: Oops: 0000 [#1] SMP NOPTI
[  126.775034] CPU: 13 UID: 0 PID: 1612 Comm: kworker/u64:55 Not tainted 6.14.0_blk+ #182 PREEMPT(full)
[  126.775676] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 04/01/2014
[  126.776275] Workqueue: iou_exit io_ring_exit_work
[  126.776651] RIP: 0010:ublk_io_release+0x14/0x130 [ublk_drv]

Fixes it by always grabbing request reference for aborting the request.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a21d259ca4d6310fdfcc0284ebbc000e66cbf70
  - https://git.kernel.org/stable/c/5d34a30efac9c9c93e150130caa940c0df6053c1
  - https://git.kernel.org/stable/c/6ee6bd5d4fce502a5b5a2ea805e9ff16e6aa890f
  - https://git.kernel.org/stable/c/caa5c8a2358604f38bf0a4afaa5eacda13763067

------------------------------------------------------------

CVE ID: CVE-2025-23244
Description: NVIDIA GPU Display Driver for Linux contains a vulnerability which could allow an unprivileged attacker to escalate permissions. A successful exploit of this vulnerability might lead to code execution, denial of service, escalation of privileges, information disclosure, and data tampering.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://nvidia.custhelp.com/app/answers/detail/a_id/5630

------------------------------------------------------------

CVE ID: CVE-2025-23245
Description: NVIDIA vGPU software for Windows and Linux contains a vulnerability in the Virtual GPU Manager (vGPU plugin), where it allows a guest to access global resources. A successful exploit of this vulnerability might lead to denial of service.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://nvidia.custhelp.com/app/answers/detail/a_id/5630

------------------------------------------------------------

CVE ID: CVE-2025-37760
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/vma: add give_up_on_oom option on modify/merge, use in uffd release

Currently, if a VMA merge fails due to an OOM condition arising on commit
merge or a failure to duplicate anon_vma's, we report this so the caller
can handle it.

However there are cases where the caller is only ostensibly trying a
merge, and doesn't mind if it fails due to this condition.

Since we do not want to introduce an implicit assumption that we only
actually modify VMAs after OOM conditions might arise, add a 'give up on
oom' option and make an explicit contract that, should this flag be set, we
absolutely will not modify any VMAs should OOM arise and just bail out.

Since it'd be very unusual for a user to try to vma_modify() with this flag
set but be specifying a range within a VMA which ends up being split (which
can fail due to rlimit issues, not only OOM), we add a debug warning for
this condition.

The motivating reason for this is uffd release - syzkaller (and Pedro
Falcato's VERY astute analysis) found a way in which an injected fault on
allocation, triggering an OOM condition on commit merge, would result in
uffd code becoming confused and treating an error value as if it were a VMA
pointer.

To avoid this, we make use of this new VMG flag to ensure that this never
occurs, utilising the fact that, should we be clearing entire VMAs, we do
not wish an OOM event to be reported to us.

Many thanks to Pedro Falcato for his excellent analysis and Jann Horn for
his insightful and intelligent analysis of the situation, both of whom were
instrumental in this fix.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/41e6ddcaa0f18dda4c3fadf22533775a30d6f72f
  - https://git.kernel.org/stable/c/b906c1ad25adce6ff35be19b65a1aa7d960fe1d7
  - https://git.kernel.org/stable/c/c103a75c61648203d731e3b97a6fbeea4003cb15

------------------------------------------------------------

CVE ID: CVE-2025-37761
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe: Fix an out-of-bounds shift when invalidating TLB

When the size of the range invalidated is larger than
rounddown_pow_of_two(ULONG_MAX),
The function macro roundup_pow_of_two(length) will hit an out-of-bounds
shift [1].

Use a full TLB invalidation for such cases.
v2:
- Use a define for the range size limit over which we use a full
  TLB invalidation. (Lucas)
- Use a better calculation of the limit.

[1]:
[   39.202421] ------------[ cut here ]------------
[   39.202657] UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13
[   39.202673] shift exponent 64 is too large for 64-bit type 'long unsigned int'
[   39.202688] CPU: 8 UID: 0 PID: 3129 Comm: xe_exec_system_ Tainted: G     U             6.14.0+ #10
[   39.202690] Tainted: [U]=USER
[   39.202690] Hardware name: ASUS System Product Name/PRIME B560M-A AC, BIOS 2001 02/01/2023
[   39.202691] Call Trace:
[   39.202692]  <TASK>
[   39.202695]  dump_stack_lvl+0x6e/0xa0
[   39.202699]  ubsan_epilogue+0x5/0x30
[   39.202701]  __ubsan_handle_shift_out_of_bounds.cold+0x61/0xe6
[   39.202705]  xe_gt_tlb_invalidation_range.cold+0x1d/0x3a [xe]
[   39.202800]  ? find_held_lock+0x2b/0x80
[   39.202803]  ? mark_held_locks+0x40/0x70
[   39.202806]  xe_svm_invalidate+0x459/0x700 [xe]
[   39.202897]  drm_gpusvm_notifier_invalidate+0x4d/0x70 [drm_gpusvm]
[   39.202900]  __mmu_notifier_release+0x1f5/0x270
[   39.202905]  exit_mmap+0x40e/0x450
[   39.202912]  __mmput+0x45/0x110
[   39.202914]  exit_mm+0xc5/0x130
[   39.202916]  do_exit+0x21c/0x500
[   39.202918]  ? lockdep_hardirqs_on_prepare+0xdb/0x190
[   39.202920]  do_group_exit+0x36/0xa0
[   39.202922]  get_signal+0x8f8/0x900
[   39.202926]  arch_do_signal_or_restart+0x35/0x100
[   39.202930]  syscall_exit_to_user_mode+0x1fc/0x290
[   39.202932]  do_syscall_64+0xa1/0x180
[   39.202934]  ? do_user_addr_fault+0x59f/0x8a0
[   39.202937]  ? lock_release+0xd2/0x2a0
[   39.202939]  ? do_user_addr_fault+0x5a9/0x8a0
[   39.202942]  ? trace_hardirqs_off+0x4b/0xc0
[   39.202944]  ? clear_bhb_loop+0x25/0x80
[   39.202946]  ? clear_bhb_loop+0x25/0x80
[   39.202947]  ? clear_bhb_loop+0x25/0x80
[   39.202950]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   39.202952] RIP: 0033:0x7fa945e543e1
[   39.202961] Code: Unable to access opcode bytes at 0x7fa945e543b7.
[   39.202962] RSP: 002b:00007ffca8fb4170 EFLAGS: 00000293
[   39.202963] RAX: 000000000000003d RBX: 0000000000000000 RCX: 00007fa945e543e3
[   39.202964] RDX: 0000000000000000 RSI: 00007ffca8fb41ac RDI: 00000000ffffffff
[   39.202964] RBP: 00007ffca8fb4190 R08: 0000000000000000 R09: 00007fa945f600a0
[   39.202965] R10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000000
[   39.202966] R13: 00007fa9460dd310 R14: 00007ffca8fb41ac R15: 0000000000000000
[   39.202970]  </TASK>
[   39.202970] ---[ end trace ]---

(cherry picked from commit b88f48f86500bc0b44b4f73ac66d500a40d320ad)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28477f701b63922ff88e9fb13f5519c11cd48b86
  - https://git.kernel.org/stable/c/7bcfeddb36b77f9fe3b010bb0b282b7618420bba
  - https://git.kernel.org/stable/c/e4715858f87b78ce58cfa03bbe140321edbbaf20

------------------------------------------------------------

CVE ID: CVE-2025-37762
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/virtio: Fix missed dmabuf unpinning in error path of prepare_fb()

Correct error handling in prepare_fb() to fix leaking resources when
error happens.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/395cc80051f8da267b27496a4029dd931a198855
  - https://git.kernel.org/stable/c/fe983e925bf7062d7b975357afcbc77bb7f354d8

------------------------------------------------------------

CVE ID: CVE-2025-37763
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/imagination: take paired job reference

For paired jobs, have the fragment job take a reference on the
geometry job, so that the geometry job cannot be freed until
the fragment job has finished with it.

The geometry job structure is accessed when the fragment job is being
prepared by the GPU scheduler. Taking the reference prevents the
geometry job being freed until the fragment job no longer requires it.

Fixes a use after free bug detected by KASAN:

[  124.256386] BUG: KASAN: slab-use-after-free in pvr_queue_prepare_job+0x108/0x868 [powervr]
[  124.264893] Read of size 1 at addr ffff0000084cb960 by task kworker/u16:4/63
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4ba2abe154ef68f9612eee9d6fbfe53a1736b064
  - https://git.kernel.org/stable/c/b5a6f97a78e2fc008fd6503b7040cb7e1120b873
  - https://git.kernel.org/stable/c/c90b95e12eb88d23740e5ea2c43d71675d17ac8d

------------------------------------------------------------

CVE ID: CVE-2025-37764
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/imagination: fix firmware memory leaks

Free the memory used to hold the results of firmware image processing
when the module is unloaded.

Fix the related issue of the same memory being leaked if processing
of the firmware image fails during module load.

Ensure all firmware GEM objects are destroyed if firmware image
processing fails.

Fixes memory leaks on powervr module unload detected by Kmemleak:

unreferenced object 0xffff000042e20000 (size 94208):
  comm "modprobe", pid 470, jiffies 4295277154
  hex dump (first 32 bytes):
    02 ae 7f ed bf 45 84 00 3c 5b 1f ed 9f 45 45 05  .....E..<[...EE.
    d5 4f 5d 14 6c 00 3d 23 30 d0 3a 4a 66 0e 48 c8  .O].l.=#0.:Jf.H.
  backtrace (crc dd329dec):
    kmemleak_alloc+0x30/0x40
    ___kmalloc_large_node+0x140/0x188
    __kmalloc_large_node_noprof+0x2c/0x13c
    __kmalloc_noprof+0x48/0x4c0
    pvr_fw_init+0xaa4/0x1f50 [powervr]

unreferenced object 0xffff000042d20000 (size 20480):
  comm "modprobe", pid 470, jiffies 4295277154
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 09 00 00 00 0b 00 00 00  ................
    00 00 00 00 00 00 00 00 07 00 00 00 08 00 00 00  ................
  backtrace (crc 395b02e3):
    kmemleak_alloc+0x30/0x40
    ___kmalloc_large_node+0x140/0x188
    __kmalloc_large_node_noprof+0x2c/0x13c
    __kmalloc_noprof+0x48/0x4c0
    pvr_fw_init+0xb0c/0x1f50 [powervr]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/490c30fd554597e78f66650044877e7defb5f83c
  - https://git.kernel.org/stable/c/891c12ba855ccb34c06a2e5da75c644683087036
  - https://git.kernel.org/stable/c/a5b230e7f3a55bd8bd8d012eec75a4b7baa671d5

------------------------------------------------------------

CVE ID: CVE-2025-37765
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/nouveau: prime: fix ttm_bo_delayed_delete oops

Fix an oops in ttm_bo_delayed_delete which results from dererencing a
dangling pointer:

Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b7b: 0000 [#1] PREEMPT SMP
CPU: 4 UID: 0 PID: 1082 Comm: kworker/u65:2 Not tainted 6.14.0-rc4-00267-g505460b44513-dirty #216
Hardware name: LENOVO 82N6/LNVNB161216, BIOS GKCN65WW 01/16/2024
Workqueue: ttm ttm_bo_delayed_delete [ttm]
RIP: 0010:dma_resv_iter_first_unlocked+0x55/0x290
Code: 31 f6 48 c7 c7 00 2b fa aa e8 97 bd 52 ff e8 a2 c1 53 00 5a 85 c0 74 48 e9 88 01 00 00 4c 89 63 20 4d 85 e4 0f 84 30 01 00 00 <41> 8b 44 24 10 c6 43 2c 01 48 89 df 89 43 28 e8 97 fd ff ff 4c 8b
RSP: 0018:ffffbf9383473d60 EFLAGS: 00010202
RAX: 0000000000000001 RBX: ffffbf9383473d88 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffffbf9383473d78 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000000 R12: 6b6b6b6b6b6b6b6b
R13: ffffa003bbf78580 R14: ffffa003a6728040 R15: 00000000000383cc
FS:  0000000000000000(0000) GS:ffffa00991c00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000758348024dd0 CR3: 000000012c259000 CR4: 0000000000f50ef0
PKRU: 55555554
Call Trace:
 <TASK>
 ? __die_body.cold+0x19/0x26
 ? die_addr+0x3d/0x70
 ? exc_general_protection+0x159/0x460
 ? asm_exc_general_protection+0x27/0x30
 ? dma_resv_iter_first_unlocked+0x55/0x290
 dma_resv_wait_timeout+0x56/0x100
 ttm_bo_delayed_delete+0x69/0xb0 [ttm]
 process_one_work+0x217/0x5c0
 worker_thread+0x1c8/0x3d0
 ? apply_wqattrs_cleanup.part.0+0xc0/0xc0
 kthread+0x10b/0x240
 ? kthreads_online_cpu+0x140/0x140
 ret_from_fork+0x40/0x70
 ? kthreads_online_cpu+0x140/0x140
 ret_from_fork_asm+0x11/0x20
 </TASK>

The cause of this is:

- drm_prime_gem_destroy calls dma_buf_put(dma_buf) which releases the
  reference to the shared dma_buf. The reference count is 0, so the
  dma_buf is destroyed, which in turn decrements the corresponding
  amdgpu_bo reference count to 0, and the amdgpu_bo is destroyed -
  calling drm_gem_object_release then dma_resv_fini (which destroys the
  reservation object), then finally freeing the amdgpu_bo.

- nouveau_bo obj->bo.base.resv is now a dangling pointer to the memory
  formerly allocated to the amdgpu_bo.

- nouveau_gem_object_del calls ttm_bo_put(&nvbo->bo) which calls
  ttm_bo_release, which schedules ttm_bo_delayed_delete.

- ttm_bo_delayed_delete runs and dereferences the dangling resv pointer,
  resulting in a general protection fault.

Fix this by moving the drm_prime_gem_destroy call from
nouveau_gem_object_del to nouveau_bo_del_ttm. This ensures that it will
be run after ttm_bo_delayed_delete.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/12b038d521c75e3521522503becf3bc162628469
  - https://git.kernel.org/stable/c/31e94c7989572f96926673614a3b958915a13ca9
  - https://git.kernel.org/stable/c/47761deabb69a5df0c2c4ec400d80bb3e072bd2e
  - https://git.kernel.org/stable/c/6b95947ee780f4e1fb26413a1437d05bcb99712b
  - https://git.kernel.org/stable/c/6e2c805996a49998d31ac522beb1534ca417e761
  - https://git.kernel.org/stable/c/706868a1a1072cffd8bd63f7e161d79141099849
  - https://git.kernel.org/stable/c/8ec0fbb28d049273bfd4f1e7a5ae4c74884beed3
  - https://git.kernel.org/stable/c/ada78110b2d3ec88b398a49703bd336d4cee7a08

------------------------------------------------------------

CVE ID: CVE-2025-37766
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm: Prevent division by zero

The user can set any speed value.
If speed is greater than UINT_MAX/8, division by zero is possible.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/068091b796480819bf70b159f17e222ad8bea900
  - https://git.kernel.org/stable/c/42f7b5d12c28b2a601a98d10a80c6db1fe1a2900
  - https://git.kernel.org/stable/c/4e3d9508c056d7e0a56b58d5c81253e2a0d22b6c
  - https://git.kernel.org/stable/c/6b9f9b998b107c7539f148a013d789ddb860c3b9
  - https://git.kernel.org/stable/c/80814924260cea431a8fc6137d11cc8cb331a10c
  - https://git.kernel.org/stable/c/affd2241927a1e74c0aecd50c2d920dc4213c56d
  - https://git.kernel.org/stable/c/ce773dd844ee19a605af27f11470887e0f2044a9
  - https://git.kernel.org/stable/c/ffd688804425579a472fbd2525bedb58b1d28bd9

------------------------------------------------------------

CVE ID: CVE-2025-37767
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm: Prevent division by zero

The user can set any speed value.
If speed is greater than UINT_MAX/8, division by zero is possible.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/327107bd7f052f4ee2d0c966c7ae879822f1814f
  - https://git.kernel.org/stable/c/8f7b5987e21e003cafac28f0e4d323e6496f83ba
  - https://git.kernel.org/stable/c/c3ff73e3bddf1a6c30d7effe4018d12ba0cadd2e
  - https://git.kernel.org/stable/c/f23e9116ebb71b63fe9cec0dcac792aa9af30b0c
  - https://git.kernel.org/stable/c/f2904fa2b9da943db6bef7c0f8b3fb4fc14acbc4
  - https://git.kernel.org/stable/c/fb803d4bb9ea0a61c21c4987505e4d4ae18f9fdc

------------------------------------------------------------

CVE ID: CVE-2025-37768
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm: Prevent division by zero

The user can set any speed value.
If speed is greater than UINT_MAX/8, division by zero is possible.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3cdd02cb70682d7d205ca6dc02a4d1eb76758d24
  - https://git.kernel.org/stable/c/5fc4fb54f6f064c25bfbbfd443aa861d3422dd4c
  - https://git.kernel.org/stable/c/7c246a05df51c52fe0852ce56ba10c41e6ed1f39
  - https://git.kernel.org/stable/c/8e9c4f8d197d5709c75effa5d58e80b4fa01981a
  - https://git.kernel.org/stable/c/9e4f1e21fe7b93a8ef57db433071266c2590e260
  - https://git.kernel.org/stable/c/b0742a709be7979c7a480772046a1f36d09dab00
  - https://git.kernel.org/stable/c/be0fffc4152aac4f0291ed2d793f3cfee788449d

------------------------------------------------------------

CVE ID: CVE-2025-37769
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm/smu11: Prevent division by zero

The user can set any speed value.
If speed is greater than UINT_MAX/8, division by zero is possible.

Found by Linux Verification Center (linuxtesting.org) with SVACE.

(cherry picked from commit da7dc714a8f8e1c9fc33c57cd63583779a3bef71)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/63a150400194592206817124268ff6f43947e8c9
  - https://git.kernel.org/stable/c/7ba88b5cccc1a99c1afb96e31e7eedac9907704c
  - https://git.kernel.org/stable/c/de2cba068c9c648503973b57696d035cfe58a9f6
  - https://git.kernel.org/stable/c/de6f8e0534cfabc528c969d453150ca90b24fb01
  - https://git.kernel.org/stable/c/fc9d55377353321e78f9e108d15f72a17e8c6ee2

------------------------------------------------------------

CVE ID: CVE-2025-37770
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm: Prevent division by zero

The user can set any speed value.
If speed is greater than UINT_MAX/8, division by zero is possible.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/05de66de280ea1bd0459c994bfd2dd332cfbc2a9
  - https://git.kernel.org/stable/c/0c02fcbe4a1393a3c02da6ae35e72493cfdb2155
  - https://git.kernel.org/stable/c/4b8c3c0d17c07f301011e2908fecd2ebdcfe3d1c
  - https://git.kernel.org/stable/c/587de3ca7875c06fe3c3aa4073a85c4eff46591f
  - https://git.kernel.org/stable/c/836a189fb422e7efb81c51d5160e47ec7bc11500
  - https://git.kernel.org/stable/c/bd4d90adbca1862d03e581e10e74ab73ec75e61b
  - https://git.kernel.org/stable/c/e109528bbf460e50074c156253d9080d223ee37f

------------------------------------------------------------

CVE ID: CVE-2025-37771
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/pm: Prevent division by zero

The user can set any speed value.
If speed is greater than UINT_MAX/8, division by zero is possible.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/402964994e8ece29702383b234fabcf04791ff95
  - https://git.kernel.org/stable/c/5096174074114f83c700a27869c54362cbb10f3e
  - https://git.kernel.org/stable/c/6413fed016208171592c88b5df002af8a1387e24
  - https://git.kernel.org/stable/c/7d641c2b83275d3b0424127b2e0d2d0f7dd82aef
  - https://git.kernel.org/stable/c/b7c41df4913789ebfe73cc1e17c6401d4c5eab69
  - https://git.kernel.org/stable/c/baa54adb5e0599299b8f088efb5544d876a3eb62

------------------------------------------------------------

CVE ID: CVE-2025-37772
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/cma: Fix workqueue crash in cma_netevent_work_handler

struct rdma_cm_id has member "struct work_struct net_work"
that is reused for enqueuing cma_netevent_work_handler()s
onto cma_wq.

Below crash[1] can occur if more than one call to
cma_netevent_callback() occurs in quick succession,
which further enqueues cma_netevent_work_handler()s for the
same rdma_cm_id, overwriting any previously queued work-item(s)
that was just scheduled to run i.e. there is no guarantee
the queued work item may run between two successive calls
to cma_netevent_callback() and the 2nd INIT_WORK would overwrite
the 1st work item (for the same rdma_cm_id), despite grabbing
id_table_lock during enqueue.

Also drgn analysis [2] indicates the work item was likely overwritten.

Fix this by moving the INIT_WORK() to __rdma_create_id(),
so that it doesn't race with any existing queue_work() or
its worker thread.

[1] Trimmed crash stack:
=============================================
BUG: kernel NULL pointer dereference, address: 0000000000000008
kworker/u256:6 ... 6.12.0-0...
Workqueue:  cma_netevent_work_handler [rdma_cm] (rdma_cm)
RIP: 0010:process_one_work+0xba/0x31a
Call Trace:
 worker_thread+0x266/0x3a0
 kthread+0xcf/0x100
 ret_from_fork+0x31/0x50
 ret_from_fork_asm+0x1a/0x30
=============================================

[2] drgn crash analysis:

>>> trace = prog.crashed_thread().stack_trace()
>>> trace
(0)  crash_setup_regs (./arch/x86/include/asm/kexec.h:111:15)
(1)  __crash_kexec (kernel/crash_core.c:122:4)
(2)  panic (kernel/panic.c:399:3)
(3)  oops_end (arch/x86/kernel/dumpstack.c:382:3)
...
(8)  process_one_work (kernel/workqueue.c:3168:2)
(9)  process_scheduled_works (kernel/workqueue.c:3310:3)
(10) worker_thread (kernel/workqueue.c:3391:4)
(11) kthread (kernel/kthread.c:389:9)

Line workqueue.c:3168 for this kernel version is in process_one_work():
3168	strscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);

>>> trace[8]["work"]
*(struct work_struct *)0xffff92577d0a21d8 = {
	.data = (atomic_long_t){
		.counter = (s64)536870912,    <=== Note
	},
	.entry = (struct list_head){
		.next = (struct list_head *)0xffff924d075924c0,
		.prev = (struct list_head *)0xffff924d075924c0,
	},
	.func = (work_func_t)cma_netevent_work_handler+0x0 = 0xffffffffc2cec280,
}

Suspicion is that pwq is NULL:
>>> trace[8]["pwq"]
(struct pool_workqueue *)<absent>

In process_one_work(), pwq is assigned from:
struct pool_workqueue *pwq = get_work_pwq(work);

and get_work_pwq() is:
static struct pool_workqueue *get_work_pwq(struct work_struct *work)
{
 	unsigned long data = atomic_long_read(&work->data);

 	if (data & WORK_STRUCT_PWQ)
 		return work_struct_pwq(data);
 	else
 		return NULL;
}

WORK_STRUCT_PWQ is 0x4:
>>> print(repr(prog['WORK_STRUCT_PWQ']))
Object(prog, 'enum work_flags', value=4)

But work->data is 536870912 which is 0x20000000.
So, get_work_pwq() returns NULL and we crash in process_one_work():
3168	strscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);
=============================================
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/45f5dcdd049719fb999393b30679605f16ebce14
  - https://git.kernel.org/stable/c/51003b2c872c63d28bcf5fbcc52cf7b05615f7b7
  - https://git.kernel.org/stable/c/b172a4a0de254f1fcce7591833a9a63547c2f447
  - https://git.kernel.org/stable/c/c2b169fc7a12665d8a675c1ff14bca1b9c63fb9a
  - https://git.kernel.org/stable/c/d23fd7a539ac078df119707110686a5b226ee3bb

------------------------------------------------------------

CVE ID: CVE-2025-37773
Description: In the Linux kernel, the following vulnerability has been resolved:

virtiofs: add filesystem context source name check

In certain scenarios, for example, during fuzz testing, the source
name may be NULL, which could lead to a kernel panic. Therefore, an
extra check for the source name should be added.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/599d1e2a6aecc44acf22fe7ea6f5e84a7e526abe
  - https://git.kernel.org/stable/c/5ee09cdaf3414f6c92960714af46d3d90eede2f3
  - https://git.kernel.org/stable/c/9d6dcf18a1b49990295ac8a05fd9bdfd27ccbf88
  - https://git.kernel.org/stable/c/a648d80f8d9b208beee03a2d9aa690cfacf1d41e
  - https://git.kernel.org/stable/c/a94fd938df2b1628da66b498aa0eeb89593bc7a2
  - https://git.kernel.org/stable/c/b84f13fdad10a543e2e65bab7e81b3f0bceabd67
  - https://git.kernel.org/stable/c/c3e31d613951c299487844c4d1686a933e8ee291
  - https://git.kernel.org/stable/c/f6ec52710dc5e156b774cbef5d0f5c99b1c53a80

------------------------------------------------------------

CVE ID: CVE-2025-37774
Description: In the Linux kernel, the following vulnerability has been resolved:

slab: ensure slab->obj_exts is clear in a newly allocated slab page

ktest recently reported crashes while running several buffered io tests
with __alloc_tagging_slab_alloc_hook() at the top of the crash call stack.
The signature indicates an invalid address dereference with low bits of
slab->obj_exts being set. The bits were outside of the range used by
page_memcg_data_flags and objext_flags and hence were not masked out
by slab_obj_exts() when obtaining the pointer stored in slab->obj_exts.
The typical crash log looks like this:

00510 Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010
00510 Mem abort info:
00510   ESR = 0x0000000096000045
00510   EC = 0x25: DABT (current EL), IL = 32 bits
00510   SET = 0, FnV = 0
00510   EA = 0, S1PTW = 0
00510   FSC = 0x05: level 1 translation fault
00510 Data abort info:
00510   ISV = 0, ISS = 0x00000045, ISS2 = 0x00000000
00510   CM = 0, WnR = 1, TnD = 0, TagAccess = 0
00510   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
00510 user pgtable: 4k pages, 39-bit VAs, pgdp=0000000104175000
00510 [0000000000000010] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000
00510 Internal error: Oops: 0000000096000045 [#1]  SMP
00510 Modules linked in:
00510 CPU: 10 UID: 0 PID: 7692 Comm: cat Not tainted 6.15.0-rc1-ktest-g189e17946605 #19327 NONE
00510 Hardware name: linux,dummy-virt (DT)
00510 pstate: 20001005 (nzCv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--)
00510 pc : __alloc_tagging_slab_alloc_hook+0xe0/0x190
00510 lr : __kmalloc_noprof+0x150/0x310
00510 sp : ffffff80c87df6c0
00510 x29: ffffff80c87df6c0 x28: 000000000013d1ff x27: 000000000013d200
00510 x26: ffffff80c87df9e0 x25: 0000000000000000 x24: 0000000000000001
00510 x23: ffffffc08041953c x22: 000000000000004c x21: ffffff80c0002180
00510 x20: fffffffec3120840 x19: ffffff80c4821000 x18: 0000000000000000
00510 x17: fffffffec3d02f00 x16: fffffffec3d02e00 x15: fffffffec3d00700
00510 x14: fffffffec3d00600 x13: 0000000000000200 x12: 0000000000000006
00510 x11: ffffffc080bb86c0 x10: 0000000000000000 x9 : ffffffc080201e58
00510 x8 : ffffff80c4821060 x7 : 0000000000000000 x6 : 0000000055555556
00510 x5 : 0000000000000001 x4 : 0000000000000010 x3 : 0000000000000060
00510 x2 : 0000000000000000 x1 : ffffffc080f50cf8 x0 : ffffff80d801d000
00510 Call trace:
00510  __alloc_tagging_slab_alloc_hook+0xe0/0x190 (P)
00510  __kmalloc_noprof+0x150/0x310
00510  __bch2_folio_create+0x5c/0xf8
00510  bch2_folio_create+0x2c/0x40
00510  bch2_readahead+0xc0/0x460
00510  read_pages+0x7c/0x230
00510  page_cache_ra_order+0x244/0x3a8
00510  page_cache_async_ra+0x124/0x170
00510  filemap_readahead.isra.0+0x58/0xa0
00510  filemap_get_pages+0x454/0x7b0
00510  filemap_read+0xdc/0x418
00510  bch2_read_iter+0x100/0x1b0
00510  vfs_read+0x214/0x300
00510  ksys_read+0x6c/0x108
00510  __arm64_sys_read+0x20/0x30
00510  invoke_syscall.constprop.0+0x54/0xe8
00510  do_el0_svc+0x44/0xc8
00510  el0_svc+0x18/0x58
00510  el0t_64_sync_handler+0x104/0x130
00510  el0t_64_sync+0x154/0x158
00510 Code: d5384100 f9401c01 b9401aa3 b40002e1 (f8227881)
00510 ---[ end trace 0000000000000000 ]---
00510 Kernel panic - not syncing: Oops: Fatal exception
00510 SMP: stopping secondary CPUs
00510 Kernel Offset: disabled
00510 CPU features: 0x0000,000000e0,00000410,8240500b
00510 Memory Limit: none

Investigation indicates that these bits are already set when we allocate
slab page and are not zeroed out after allocation. We are not yet sure
why these crashes start happening only recently but regardless of the
reason, not initializing a field that gets used later is wrong. Fix it
by initializing slab->obj_exts during slab page allocation.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28bef6622a1a874fe63aceeb0c684fab75afb3ae
  - https://git.kernel.org/stable/c/8baa747193591410a853bac9c3710142dfa4937b
  - https://git.kernel.org/stable/c/d2f5819b6ed357c0c350c0616b6b9f38be59adf6

------------------------------------------------------------

CVE ID: CVE-2025-37775
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix the warning from __kernel_write_iter

[ 2110.972290] ------------[ cut here ]------------
[ 2110.972301] WARNING: CPU: 3 PID: 735 at fs/read_write.c:599 __kernel_write_iter+0x21b/0x280

This patch doesn't allow writing to directory.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1ed343481ba6911178bc5ca7a51be319eafcc747
  - https://git.kernel.org/stable/c/2a879da5c34a1e5d971e815d5b30f27eb6d69efc
  - https://git.kernel.org/stable/c/44079e544c9f6e3e9fb43a16ddf8b08cf686d657
  - https://git.kernel.org/stable/c/b37f2f332b40ad1c27f18682a495850f2f04db0a
  - https://git.kernel.org/stable/c/b7ce8db490286c2e009758fa1416d66aeb333614

------------------------------------------------------------

CVE ID: CVE-2025-37776
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix use-after-free in smb_break_all_levII_oplock()

There is a room in smb_break_all_levII_oplock that can cause racy issues
when unlocking in the middle of the loop. This patch use read lock
to protect whole loop.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/18b4fac5ef17f77fed9417d22210ceafd6525fc7
  - https://git.kernel.org/stable/c/296cb5457cc6f4a754c4ae29855f8a253d52bcc6
  - https://git.kernel.org/stable/c/d54ab1520d43e95f9b2e22d7a05fc9614192e5a5
  - https://git.kernel.org/stable/c/d73686367ad68534257cd88a36ca3c52cb8b81d8

------------------------------------------------------------

CVE ID: CVE-2025-37777
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix use-after-free in __smb2_lease_break_noti()

Move tcp_transport free to ksmbd_conn_free. If ksmbd connection is
referenced when ksmbd server thread terminates, It will not be freed,
but conn->tcp_transport is freed. __smb2_lease_break_noti can be performed
asynchronously when the connection is disconnected. __smb2_lease_break_noti
calls ksmbd_conn_write, which can cause use-after-free
when conn->ksmbd_transport is already freed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1aec4d14cf81b7b3e7b69eb1cfa94144eed7138e
  - https://git.kernel.org/stable/c/21a4e47578d44c6b37c4fc4aba8ed7cc8dbb13de
  - https://git.kernel.org/stable/c/e59796fc80603bcd8569d4d2e10b213c1918edb4

------------------------------------------------------------

CVE ID: CVE-2025-37778
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: Fix dangling pointer in krb_authenticate

krb_authenticate frees sess->user and does not set the pointer
to NULL. It calls ksmbd_krb5_authenticate to reinitialise
sess->user but that function may return without doing so. If
that happens then smb2_sess_setup, which calls krb_authenticate,
will be accessing free'd memory when it later uses sess->user.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1db2451de23e98bc864c6a6e52aa0d82c91cb325
  - https://git.kernel.org/stable/c/1e440d5b25b7efccb3defe542a73c51005799a5f
  - https://git.kernel.org/stable/c/6e30c0e10210c714f3d4453dc258d4abcc70364e
  - https://git.kernel.org/stable/c/d5b554bc8d554ed6ddf443d3db2fad9f665cec10
  - https://git.kernel.org/stable/c/e83e39a5f6a01a81411a4558a59a10f87aa88dd6

------------------------------------------------------------

CVE ID: CVE-2025-37779
Description: In the Linux kernel, the following vulnerability has been resolved:

lib/iov_iter: fix to increase non slab folio refcount

When testing EROFS file-backed mount over v9fs on qemu, I encountered a
folio UAF issue.  The page sanity check reports the following call trace. 
The root cause is that pages in bvec are coalesced across a folio bounary.
The refcount of all non-slab folios should be increased to ensure
p9_releas_pages can put them correctly.

BUG: Bad page state in process md5sum  pfn:18300
page: refcount:0 mapcount:0 mapping:00000000d5ad8e4e index:0x60 pfn:0x18300
head: order:0 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0
aops:z_erofs_aops ino:30b0f dentry name(?):"GoogleExtServicesCn.apk"
flags: 0x100000000000041(locked|head|node=0|zone=1)
raw: 0100000000000041 dead000000000100 dead000000000122 ffff888014b13bd0
raw: 0000000000000060 0000000000000020 00000000ffffffff 0000000000000000
head: 0100000000000041 dead000000000100 dead000000000122 ffff888014b13bd0
head: 0000000000000060 0000000000000020 00000000ffffffff 0000000000000000
head: 0100000000000000 0000000000000000 ffffffffffffffff 0000000000000000
head: 0000000000000010 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
Call Trace:
 dump_stack_lvl+0x53/0x70
 bad_page+0xd4/0x220
 __free_pages_ok+0x76d/0xf30
 __folio_put+0x230/0x320
 p9_release_pages+0x179/0x1f0
 p9_virtio_zc_request+0xa2a/0x1230
 p9_client_zc_rpc.constprop.0+0x247/0x700
 p9_client_read_once+0x34d/0x810
 p9_client_read+0xf3/0x150
 v9fs_issue_read+0x111/0x360
 netfs_unbuffered_read_iter_locked+0x927/0x1390
 netfs_unbuffered_read_iter+0xa2/0xe0
 vfs_iocb_iter_read+0x2c7/0x460
 erofs_fileio_rq_submit+0x46b/0x5b0
 z_erofs_runqueue+0x1203/0x21e0
 z_erofs_readahead+0x579/0x8b0
 read_pages+0x19f/0xa70
 page_cache_ra_order+0x4ad/0xb80
 filemap_readahead.isra.0+0xe7/0x150
 filemap_get_pages+0x7aa/0x1890
 filemap_read+0x320/0xc80
 vfs_read+0x6c6/0xa30
 ksys_read+0xf9/0x1c0
 do_syscall_64+0x9e/0x1a0
 entry_SYSCALL_64_after_hwframe+0x71/0x79
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/770c8d55c42868239c748a3ebc57c9e37755f842
  - https://git.kernel.org/stable/c/d833f21162c4d536d729628f8cf1ee8d4110f2b7

------------------------------------------------------------

CVE ID: CVE-2025-37780
Description: In the Linux kernel, the following vulnerability has been resolved:

isofs: Prevent the use of too small fid

syzbot reported a slab-out-of-bounds Read in isofs_fh_to_parent. [1]

The handle_bytes value passed in by the reproducing program is equal to 12.
In handle_to_path(), only 12 bytes of memory are allocated for the structure
file_handle->f_handle member, which causes an out-of-bounds access when
accessing the member parent_block of the structure isofs_fid in isofs,
because accessing parent_block requires at least 16 bytes of f_handle.
Here, fh_len is used to indirectly confirm that the value of handle_bytes
is greater than 3 before accessing parent_block.

[1]
BUG: KASAN: slab-out-of-bounds in isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183
Read of size 4 at addr ffff0000cc030d94 by task syz-executor215/6466
CPU: 1 UID: 0 PID: 6466 Comm: syz-executor215 Not tainted 6.14.0-rc7-syzkaller-ga2392f333575 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025
Call trace:
 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C)
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0xe4/0x150 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:408 [inline]
 print_report+0x198/0x550 mm/kasan/report.c:521
 kasan_report+0xd8/0x138 mm/kasan/report.c:634
 __asan_report_load4_noabort+0x20/0x2c mm/kasan/report_generic.c:380
 isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183
 exportfs_decode_fh_raw+0x2dc/0x608 fs/exportfs/expfs.c:523
 do_handle_to_path+0xa0/0x198 fs/fhandle.c:257
 handle_to_path fs/fhandle.c:385 [inline]
 do_handle_open+0x8cc/0xb8c fs/fhandle.c:403
 __do_sys_open_by_handle_at fs/fhandle.c:443 [inline]
 __se_sys_open_by_handle_at fs/fhandle.c:434 [inline]
 __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434
 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]
 invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49
 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132
 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151
 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744
 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762
 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600

Allocated by task 6466:
 kasan_save_stack mm/kasan/common.c:47 [inline]
 kasan_save_track+0x40/0x78 mm/kasan/common.c:68
 kasan_save_alloc_info+0x40/0x50 mm/kasan/generic.c:562
 poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
 __kasan_kmalloc+0xac/0xc4 mm/kasan/common.c:394
 kasan_kmalloc include/linux/kasan.h:260 [inline]
 __do_kmalloc_node mm/slub.c:4294 [inline]
 __kmalloc_noprof+0x32c/0x54c mm/slub.c:4306
 kmalloc_noprof include/linux/slab.h:905 [inline]
 handle_to_path fs/fhandle.c:357 [inline]
 do_handle_open+0x5a4/0xb8c fs/fhandle.c:403
 __do_sys_open_by_handle_at fs/fhandle.c:443 [inline]
 __se_sys_open_by_handle_at fs/fhandle.c:434 [inline]
 __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434
 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]
 invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49
 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132
 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151
 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744
 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762
 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/007124c896e7d4614ac1f6bd4dedb975c35a2a8e
  - https://git.kernel.org/stable/c/0405d4b63d082861f4eaff9d39c78ee9dc34f845
  - https://git.kernel.org/stable/c/0fdafdaef796816a9ed0fd7ac812932d569d9beb
  - https://git.kernel.org/stable/c/56dfffea9fd3be0b3795a9ca6401e133a8427e0b
  - https://git.kernel.org/stable/c/5e7de55602c61c8ff28db075cc49c8dd6989d7e0
  - https://git.kernel.org/stable/c/63d5a3e207bf315a32c7d16de6c89753a759f95a
  - https://git.kernel.org/stable/c/952e7a7e317f126d0a2b879fc531b716932d5ffa
  - https://git.kernel.org/stable/c/ee01a309ebf598be1ff8174901ed6e91619f1749

------------------------------------------------------------

CVE ID: CVE-2025-37781
Description: In the Linux kernel, the following vulnerability has been resolved:

i2c: cros-ec-tunnel: defer probe if parent EC is not present

When i2c-cros-ec-tunnel and the EC driver are built-in, the EC parent
device will not be found, leading to NULL pointer dereference.

That can also be reproduced by unbinding the controller driver and then
loading i2c-cros-ec-tunnel module (or binding the device).

[  271.991245] BUG: kernel NULL pointer dereference, address: 0000000000000058
[  271.998215] #PF: supervisor read access in kernel mode
[  272.003351] #PF: error_code(0x0000) - not-present page
[  272.008485] PGD 0 P4D 0
[  272.011022] Oops: Oops: 0000 [#1] SMP NOPTI
[  272.015207] CPU: 0 UID: 0 PID: 3859 Comm: insmod Tainted: G S                  6.15.0-rc1-00004-g44722359ed83 #30 PREEMPT(full)  3c7fb39a552e7d949de2ad921a7d6588d3a4fdc5
[  272.030312] Tainted: [S]=CPU_OUT_OF_SPEC
[  272.034233] Hardware name: HP Berknip/Berknip, BIOS Google_Berknip.13434.356.0 05/17/2021
[  272.042400] RIP: 0010:ec_i2c_probe+0x2b/0x1c0 [i2c_cros_ec_tunnel]
[  272.048577] Code: 1f 44 00 00 41 57 41 56 41 55 41 54 53 48 83 ec 10 65 48 8b 05 06 a0 6c e7 48 89 44 24 08 4c 8d 7f 10 48 8b 47 50 4c 8b 60 78 <49> 83 7c 24 58 00 0f 84 2f 01 00 00 48 89 fb be 30 06 00 00 4c 9
[  272.067317] RSP: 0018:ffffa32082a03940 EFLAGS: 00010282
[  272.072541] RAX: ffff969580b6a810 RBX: ffff969580b68c10 RCX: 0000000000000000
[  272.079672] RDX: 0000000000000000 RSI: 0000000000000282 RDI: ffff969580b68c00
[  272.086804] RBP: 00000000fffffdfb R08: 0000000000000000 R09: 0000000000000000
[  272.093936] R10: 0000000000000000 R11: ffffffffc0600000 R12: 0000000000000000
[  272.101067] R13: ffffffffa666fbb8 R14: ffffffffc05b5528 R15: ffff969580b68c10
[  272.108198] FS:  00007b930906fc40(0000) GS:ffff969603149000(0000) knlGS:0000000000000000
[  272.116282] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  272.122024] CR2: 0000000000000058 CR3: 000000012631c000 CR4: 00000000003506f0
[  272.129155] Call Trace:
[  272.131606]  <TASK>
[  272.133709]  ? acpi_dev_pm_attach+0xdd/0x110
[  272.137985]  platform_probe+0x69/0xa0
[  272.141652]  really_probe+0x152/0x310
[  272.145318]  __driver_probe_device+0x77/0x110
[  272.149678]  driver_probe_device+0x1e/0x190
[  272.153864]  __driver_attach+0x10b/0x1e0
[  272.157790]  ? driver_attach+0x20/0x20
[  272.161542]  bus_for_each_dev+0x107/0x150
[  272.165553]  bus_add_driver+0x15d/0x270
[  272.169392]  driver_register+0x65/0x110
[  272.173232]  ? cleanup_module+0xa80/0xa80 [i2c_cros_ec_tunnel 3a00532f3f4af4a9eade753f86b0f8dd4e4e5698]
[  272.182617]  do_one_initcall+0x110/0x350
[  272.186543]  ? security_kernfs_init_security+0x49/0xd0
[  272.191682]  ? __kernfs_new_node+0x1b9/0x240
[  272.195954]  ? security_kernfs_init_security+0x49/0xd0
[  272.201093]  ? __kernfs_new_node+0x1b9/0x240
[  272.205365]  ? kernfs_link_sibling+0x105/0x130
[  272.209810]  ? kernfs_next_descendant_post+0x1c/0xa0
[  272.214773]  ? kernfs_activate+0x57/0x70
[  272.218699]  ? kernfs_add_one+0x118/0x160
[  272.222710]  ? __kernfs_create_file+0x71/0xa0
[  272.227069]  ? sysfs_add_bin_file_mode_ns+0xd6/0x110
[  272.232033]  ? internal_create_group+0x453/0x4a0
[  272.236651]  ? __vunmap_range_noflush+0x214/0x2d0
[  272.241355]  ? __free_frozen_pages+0x1dc/0x420
[  272.245799]  ? free_vmap_area_noflush+0x10a/0x1c0
[  272.250505]  ? load_module+0x1509/0x16f0
[  272.254431]  do_init_module+0x60/0x230
[  272.258181]  __se_sys_finit_module+0x27a/0x370
[  272.262627]  do_syscall_64+0x6a/0xf0
[  272.266206]  ? do_syscall_64+0x76/0xf0
[  272.269956]  ? irqentry_exit_to_user_mode+0x79/0x90
[  272.274836]  entry_SYSCALL_64_after_hwframe+0x55/0x5d
[  272.279887] RIP: 0033:0x7b9309168d39
[  272.283466] Code: 5b 41 5c 5d c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d af 40 0c 00 f7 d8 64 89 01 8
[  272.302210] RSP: 002b:00007fff50f1a288 EFLAGS: 00000246 ORIG_RAX: 000
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/092de5ac8cb2eaa9593a765fa92ba39d8173f984
  - https://git.kernel.org/stable/c/1355b5ca4782be85a2ef7275e4c508f770d0fb27
  - https://git.kernel.org/stable/c/3090cad5ccff8963b95160f4060068048a1e4c4c
  - https://git.kernel.org/stable/c/424eafe65647a8d6c690284536e711977153195a
  - https://git.kernel.org/stable/c/b66d4910a608427367c4e21499e149f085782df7
  - https://git.kernel.org/stable/c/cd83035b6f2a102c2d5acd3bfb2a11ff967aaba6
  - https://git.kernel.org/stable/c/da8edc9eb2516aface7f86be5fa6d09c0d07b9f8
  - https://git.kernel.org/stable/c/e89bf1311d4497c6743f3021e9c481b16c3a41c9

------------------------------------------------------------

CVE ID: CVE-2025-37782
Description: In the Linux kernel, the following vulnerability has been resolved:

hfs/hfsplus: fix slab-out-of-bounds in hfs_bnode_read_key

Syzbot reported an issue in hfs subsystem:

BUG: KASAN: slab-out-of-bounds in memcpy_from_page include/linux/highmem.h:423 [inline]
BUG: KASAN: slab-out-of-bounds in hfs_bnode_read fs/hfs/bnode.c:35 [inline]
BUG: KASAN: slab-out-of-bounds in hfs_bnode_read_key+0x314/0x450 fs/hfs/bnode.c:70
Write of size 94 at addr ffff8880123cd100 by task syz-executor237/5102

Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:94 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
 print_address_description mm/kasan/report.c:377 [inline]
 print_report+0x169/0x550 mm/kasan/report.c:488
 kasan_report+0x143/0x180 mm/kasan/report.c:601
 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189
 __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106
 memcpy_from_page include/linux/highmem.h:423 [inline]
 hfs_bnode_read fs/hfs/bnode.c:35 [inline]
 hfs_bnode_read_key+0x314/0x450 fs/hfs/bnode.c:70
 hfs_brec_insert+0x7f3/0xbd0 fs/hfs/brec.c:159
 hfs_cat_create+0x41d/0xa50 fs/hfs/catalog.c:118
 hfs_mkdir+0x6c/0xe0 fs/hfs/dir.c:232
 vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257
 do_mkdirat+0x264/0x3a0 fs/namei.c:4280
 __do_sys_mkdir fs/namei.c:4300 [inline]
 __se_sys_mkdir fs/namei.c:4298 [inline]
 __x64_sys_mkdir+0x6c/0x80 fs/namei.c:4298
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7fbdd6057a99

Add a check for key length in hfs_bnode_read_key to prevent
out-of-bounds memory access. If the key length is invalid, the
key buffer is cleared, improving stability and reliability.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0296f9733543c7c8e666e69da743cfffd32dd805
  - https://git.kernel.org/stable/c/8060afd77761eac2048db12fb0510d76ce0cf1f3
  - https://git.kernel.org/stable/c/84e8719c087e68c967975b78e67be54f697c957f
  - https://git.kernel.org/stable/c/9c93fb4ad8d3b730afe1a09949ebbea64d4f60eb
  - https://git.kernel.org/stable/c/9f77aa584a659b21211a794e53522e6fb16d4a16
  - https://git.kernel.org/stable/c/a33c035df01d1e008874607da74bf7cf45152f47
  - https://git.kernel.org/stable/c/bb5e07cb927724e0b47be371fa081141cfb14414
  - https://git.kernel.org/stable/c/f6651c04191d49907d40f0891bbe51ef9703c792

------------------------------------------------------------

CVE ID: CVE-2025-37783
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: Fix error pointers in dpu_plane_virtual_atomic_check

The function dpu_plane_virtual_atomic_check was dereferencing pointers
returned by drm_atomic_get_plane_state without checking for errors. This
could lead to undefined behavior if the function returns an error pointer.

This commit adds checks using IS_ERR to ensure that plane_state is
valid before dereferencing them.

Similar to commit da29abe71e16
("drm/amd/display: Fix error pointers in amdgpu_dm_crtc_mem_type_changed").

Patchwork: https://patchwork.freedesktop.org/patch/643132/
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5cb1b130e1cd04239cc9c26a98279f4660dce583
  - https://git.kernel.org/stable/c/a9670ed1cce3216778c89936d3ae91cf0d436035

------------------------------------------------------------

CVE ID: CVE-2025-37784
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ti: icss-iep: Fix possible NULL pointer dereference for perout request

The ICSS IEP driver tracks perout and pps enable state with flags.
Currently when disabling pps and perout signals during icss_iep_exit(),
results in NULL pointer dereference for perout.

To fix the null pointer dereference issue, the icss_iep_perout_enable_hw
function can be modified to directly clear the IEP CMP registers when
disabling PPS or PEROUT, without referencing the ptp_perout_request
structure, as its contents are irrelevant in this case.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7349c9e9979333abfce42da5f9025598083b59c9
  - https://git.kernel.org/stable/c/7891619d21f07a88e0275d6d43db74035aa74f69
  - https://git.kernel.org/stable/c/da5035d7aeadcfa44096dd34689bfed6c657f559
  - https://git.kernel.org/stable/c/eeec66327001421531b3fb1a2ac32efc8a2493b0

------------------------------------------------------------

CVE ID: CVE-2025-37786
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: free routing table on probe failure

If complete = true in dsa_tree_setup(), it means that we are the last
switch of the tree which is successfully probing, and we should be
setting up all switches from our probe path.

After "complete" becomes true, dsa_tree_setup_cpu_ports() or any
subsequent function may fail. If that happens, the entire tree setup is
in limbo: the first N-1 switches have successfully finished probing
(doing nothing but having allocated persistent memory in the tree's
dst->ports, and maybe dst->rtable), and switch N failed to probe, ending
the tree setup process before anything is tangible from the user's PoV.

If switch N fails to probe, its memory (ports) will be freed and removed
from dst->ports. However, the dst->rtable elements pointing to its ports,
as created by dsa_link_touch(), will remain there, and will lead to
use-after-free if dereferenced.

If dsa_tree_setup_switches() returns -EPROBE_DEFER, which is entirely
possible because that is where ds->ops->setup() is, we get a kasan
report like this:

==================================================================
BUG: KASAN: slab-use-after-free in mv88e6xxx_setup_upstream_port+0x240/0x568
Read of size 8 at addr ffff000004f56020 by task kworker/u8:3/42

Call trace:
 __asan_report_load8_noabort+0x20/0x30
 mv88e6xxx_setup_upstream_port+0x240/0x568
 mv88e6xxx_setup+0xebc/0x1eb0
 dsa_register_switch+0x1af4/0x2ae0
 mv88e6xxx_register_switch+0x1b8/0x2a8
 mv88e6xxx_probe+0xc4c/0xf60
 mdio_probe+0x78/0xb8
 really_probe+0x2b8/0x5a8
 __driver_probe_device+0x164/0x298
 driver_probe_device+0x78/0x258
 __device_attach_driver+0x274/0x350

Allocated by task 42:
 __kasan_kmalloc+0x84/0xa0
 __kmalloc_cache_noprof+0x298/0x490
 dsa_switch_touch_ports+0x174/0x3d8
 dsa_register_switch+0x800/0x2ae0
 mv88e6xxx_register_switch+0x1b8/0x2a8
 mv88e6xxx_probe+0xc4c/0xf60
 mdio_probe+0x78/0xb8
 really_probe+0x2b8/0x5a8
 __driver_probe_device+0x164/0x298
 driver_probe_device+0x78/0x258
 __device_attach_driver+0x274/0x350

Freed by task 42:
 __kasan_slab_free+0x48/0x68
 kfree+0x138/0x418
 dsa_register_switch+0x2694/0x2ae0
 mv88e6xxx_register_switch+0x1b8/0x2a8
 mv88e6xxx_probe+0xc4c/0xf60
 mdio_probe+0x78/0xb8
 really_probe+0x2b8/0x5a8
 __driver_probe_device+0x164/0x298
 driver_probe_device+0x78/0x258
 __device_attach_driver+0x274/0x350

The simplest way to fix the bug is to delete the routing table in its
entirety. dsa_tree_setup_routing_table() has no problem in regenerating
it even if we deleted links between ports other than those of switch N,
because dsa_link_touch() first checks whether the port pair already
exists in dst->rtable, allocating if not.

The deletion of the routing table in its entirety already exists in
dsa_tree_teardown(), so refactor that into a function that can also be
called from the tree setup error path.

In my analysis of the commit to blame, it is the one which added
dsa_link elements to dst->rtable. Prior to that, each switch had its own
ds->rtable which is freed when the switch fails to probe. But the tree
is potentially persistent memory.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5c8066fbdb9653c6e9a224bdcd8f9c91a484f0de
  - https://git.kernel.org/stable/c/8bf108d7161ffc6880ad13a0cc109de3cf631727
  - https://git.kernel.org/stable/c/a038f5f15af455dfe35bc68549e02b950978700a
  - https://git.kernel.org/stable/c/fb12b460ec46c9efad98de6d9ba349691db51dc7

------------------------------------------------------------

CVE ID: CVE-2025-37787
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: mv88e6xxx: avoid unregistering devlink regions which were never registered

Russell King reports that a system with mv88e6xxx dereferences a NULL
pointer when unbinding this driver:
https://lore.kernel.org/netdev/Z_lRkMlTJ1KQ0kVX@shell.armlinux.org.uk/

The crash seems to be in devlink_region_destroy(), which is not NULL
tolerant but is given a NULL devlink global region pointer.

At least on some chips, some devlink regions are conditionally registered
since the blamed commit, see mv88e6xxx_setup_devlink_regions_global():

		if (cond && !cond(chip))
			continue;

These are MV88E6XXX_REGION_STU and MV88E6XXX_REGION_PVT. If the chip
does not have an STU or PVT, it should crash like this.

To fix the issue, avoid unregistering those regions which are NULL, i.e.
were skipped at mv88e6xxx_setup_devlink_regions_global() time.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3665695e3572239dc233216f06b41f40cc771889
  - https://git.kernel.org/stable/c/5f5e95945bb1e08be7655da6acba648274db457d
  - https://git.kernel.org/stable/c/8ccdf5e24b276848eefb2755e05ff0f005a0c4a1
  - https://git.kernel.org/stable/c/b3c70dfe51f10df60db2646c08cebd24bcdc5247
  - https://git.kernel.org/stable/c/bbb80f004f7a90c3dcaacc982c59967457254a05
  - https://git.kernel.org/stable/c/c84f6ce918a9e6f4996597cbc62536bbf2247c96

------------------------------------------------------------

CVE ID: CVE-2025-37788
Description: In the Linux kernel, the following vulnerability has been resolved:

cxgb4: fix memory leak in cxgb4_init_ethtool_filters() error path

In the for loop used to allocate the loc_array and bmap for each port, a
memory leak is possible when the allocation for loc_array succeeds,
but the allocation for bmap fails. This is because when the control flow
goes to the label free_eth_finfo, only the allocations starting from
(i-1)th iteration are freed.

Fix that by freeing the loc_array in the bmap allocation error path.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/00ffb3724ce743578163f5ade2884374554ca021
  - https://git.kernel.org/stable/c/08aa59c0be768596467552c129e9f82166779a67
  - https://git.kernel.org/stable/c/118d05b530343cd9322607b9719405ba254a4183
  - https://git.kernel.org/stable/c/76deedea08899885f076aba0bb80bd1276446822
  - https://git.kernel.org/stable/c/dafb6e433ab2333b67be05433dc9c6ccbc7b1284
  - https://git.kernel.org/stable/c/e9de08e15aee35b96064960f95997bb6c1209c4b
  - https://git.kernel.org/stable/c/fa2d7708955e4f8212fd69bab1da604e60cb0b15

------------------------------------------------------------

CVE ID: CVE-2025-37789
Description: In the Linux kernel, the following vulnerability has been resolved:

net: openvswitch: fix nested key length validation in the set() action

It's not safe to access nla_len(ovs_key) if the data is smaller than
the netlink header.  Check that the attribute is OK first.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/03d7262dd53e8c404da35cc81aaa887fd901f76b
  - https://git.kernel.org/stable/c/1489c195c8eecd262aa6712761ba5288203e28ec
  - https://git.kernel.org/stable/c/54c6957d1123a2032099b9eab51c314800f677ce
  - https://git.kernel.org/stable/c/65d91192aa66f05710cfddf6a14b5a25ee554dba
  - https://git.kernel.org/stable/c/7fcaec0b2ab8fa5fbf0b45e5512364a168f445bd
  - https://git.kernel.org/stable/c/824a7c2df5127b2402b68a21a265d413e78dcad7
  - https://git.kernel.org/stable/c/a27526e6b48eee9e2d82efff502c4f272f1a91d4
  - https://git.kernel.org/stable/c/be80768d4f3b6fd13f421451cc3fee8778aba8bc

------------------------------------------------------------

CVE ID: CVE-2025-37790
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mctp: Set SOCK_RCU_FREE

Bind lookup runs under RCU, so ensure that a socket doesn't go away in
the middle of a lookup.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3f899bd6dd56ddc46509b526e23a8f0a97712a6d
  - https://git.kernel.org/stable/c/52024cd6ec71a6ca934d0cc12452bd8d49850679
  - https://git.kernel.org/stable/c/5c1313b93c8c2e3904a48aa88e2fa1db28c607ae
  - https://git.kernel.org/stable/c/a8a3b61ce140e2b0a72a779e8d70f60c0cf1e47a
  - https://git.kernel.org/stable/c/b9764ebebb007249fb733a131b6110ff333b6616
  - https://git.kernel.org/stable/c/e3b5edbdb45924a7d4206d13868a2aac71f1e53d

------------------------------------------------------------

CVE ID: CVE-2025-37791
Description: In the Linux kernel, the following vulnerability has been resolved:

ethtool: cmis_cdb: use correct rpl size in ethtool_cmis_module_poll()

rpl is passed as a pointer to ethtool_cmis_module_poll(), so the correct
size of rpl is sizeof(*rpl) which should be just 1 byte.  Using the
pointer size instead can cause stack corruption:

Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: ethtool_cmis_wait_for_cond+0xf4/0x100
CPU: 72 UID: 0 PID: 4440 Comm: kworker/72:2 Kdump: loaded Tainted: G           OE      6.11.0 #24
Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
Hardware name: Dell Inc. PowerEdge R760/04GWWM, BIOS 1.6.6 09/20/2023
Workqueue: events module_flash_fw_work
Call Trace:
 <TASK>
 panic+0x339/0x360
 ? ethtool_cmis_wait_for_cond+0xf4/0x100
 ? __pfx_status_success+0x10/0x10
 ? __pfx_status_fail+0x10/0x10
 __stack_chk_fail+0x10/0x10
 ethtool_cmis_wait_for_cond+0xf4/0x100
 ethtool_cmis_cdb_execute_cmd+0x1fc/0x330
 ? __pfx_status_fail+0x10/0x10
 cmis_cdb_module_features_get+0x6d/0xd0
 ethtool_cmis_cdb_init+0x8a/0xd0
 ethtool_cmis_fw_update+0x46/0x1d0
 module_flash_fw_work+0x17/0xa0
 process_one_work+0x179/0x390
 worker_thread+0x239/0x340
 ? __pfx_worker_thread+0x10/0x10
 kthread+0xcc/0x100
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x2d/0x50
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/61765e1b417a23371c3735e3cddf4ad9354ed2e9
  - https://git.kernel.org/stable/c/7eb0a0072f966bb0b01d8b7d529d9743a7187bd1
  - https://git.kernel.org/stable/c/f3fdd4fba16c74697d8bc730b82fb7c1eff7fab3

------------------------------------------------------------

CVE ID: CVE-2025-37792
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btrtl: Prevent potential NULL dereference

The btrtl_initialize() function checks that rtl_load_file() either
had an error or it loaded a zero length file.  However, if it loaded
a zero length file then the error code is not set correctly.  It
results in an error pointer vs NULL bug, followed by a NULL pointer
dereference.  This was detected by Smatch:

drivers/bluetooth/btrtl.c:592 btrtl_initialize() warn: passing zero to 'ERR_PTR'
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d7c60c2a38b4b461fa960ad0995136a6bfe0756
  - https://git.kernel.org/stable/c/324dddea321078a6eeb535c2bff5257be74c9799
  - https://git.kernel.org/stable/c/3db6605043b50c8bb768547b23e0222f67ceef3e
  - https://git.kernel.org/stable/c/53ceef799dcfc22c734d600811bfc9dd32eaea0a
  - https://git.kernel.org/stable/c/73dc99c0ea94abd22379b2d82cacbc73f3e18ec1
  - https://git.kernel.org/stable/c/aaf356f872a60db1e96fb762a62c4607fd22741f
  - https://git.kernel.org/stable/c/c3e9717276affe59fd8213706db021b493e81e34
  - https://git.kernel.org/stable/c/d8441818690d795232331bd8358545c5c95b6b72

------------------------------------------------------------

CVE ID: CVE-2025-37793
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: Intel: avs: Fix null-ptr-deref in avs_component_probe()

devm_kasprintf() returns NULL when memory allocation fails. Currently,
avs_component_probe() does not check for this case, which results in a
NULL pointer dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/23fde311ea1d0a6c36bf92ce48b90b77d0ece1a4
  - https://git.kernel.org/stable/c/95f723cf141b95e3b3a5b92cf2ea98a863fe7275
  - https://git.kernel.org/stable/c/aaa93b8846101461de815759d39979661b82d5a5
  - https://git.kernel.org/stable/c/c2825073271b6f15e669a424b363612082494863

------------------------------------------------------------

CVE ID: CVE-2025-37794
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: Purge vif txq in ieee80211_do_stop()

After ieee80211_do_stop() SKB from vif's txq could still be processed.
Indeed another concurrent vif schedule_and_wake_txq call could cause
those packets to be dequeued (see ieee80211_handle_wake_tx_queue())
without checking the sdata current state.

Because vif.drv_priv is now cleared in this function, this could lead to
driver crash.

For example in ath12k, ahvif is store in vif.drv_priv. Thus if
ath12k_mac_op_tx() is called after ieee80211_do_stop(), ahvif->ah can be
NULL, leading the ath12k_warn(ahvif->ah,...) call in this function to
trigger the NULL deref below.

  Unable to handle kernel paging request at virtual address dfffffc000000001
  KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]
  batman_adv: bat0: Interface deactivated: brbh1337
  Mem abort info:
    ESR = 0x0000000096000004
    EC = 0x25: DABT (current EL), IL = 32 bits
    SET = 0, FnV = 0
    EA = 0, S1PTW = 0
    FSC = 0x04: level 0 translation fault
  Data abort info:
    ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000
    CM = 0, WnR = 0, TnD = 0, TagAccess = 0
    GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
  [dfffffc000000001] address between user and kernel address ranges
  Internal error: Oops: 0000000096000004 [#1] SMP
  CPU: 1 UID: 0 PID: 978 Comm: lbd Not tainted 6.13.0-g633f875b8f1e #114
  Hardware name: HW (DT)
  pstate: 10000005 (nzcV daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : ath12k_mac_op_tx+0x6cc/0x29b8 [ath12k]
  lr : ath12k_mac_op_tx+0x174/0x29b8 [ath12k]
  sp : ffffffc086ace450
  x29: ffffffc086ace450 x28: 0000000000000000 x27: 1ffffff810d59ca4
  x26: ffffff801d05f7c0 x25: 0000000000000000 x24: 000000004000001e
  x23: ffffff8009ce4926 x22: ffffff801f9c0800 x21: ffffff801d05f7f0
  x20: ffffff8034a19f40 x19: 0000000000000000 x18: ffffff801f9c0958
  x17: ffffff800bc0a504 x16: dfffffc000000000 x15: ffffffc086ace4f8
  x14: ffffff801d05f83c x13: 0000000000000000 x12: ffffffb003a0bf03
  x11: 0000000000000000 x10: ffffffb003a0bf02 x9 : ffffff8034a19f40
  x8 : ffffff801d05f818 x7 : 1ffffff0069433dc x6 : ffffff8034a19ee0
  x5 : ffffff801d05f7f0 x4 : 0000000000000000 x3 : 0000000000000001
  x2 : 0000000000000000 x1 : dfffffc000000000 x0 : 0000000000000008
  Call trace:
   ath12k_mac_op_tx+0x6cc/0x29b8 [ath12k] (P)
   ieee80211_handle_wake_tx_queue+0x16c/0x260
   ieee80211_queue_skb+0xeec/0x1d20
   ieee80211_tx+0x200/0x2c8
   ieee80211_xmit+0x22c/0x338
   __ieee80211_subif_start_xmit+0x7e8/0xc60
   ieee80211_subif_start_xmit+0xc4/0xee0
   __ieee80211_subif_start_xmit_8023.isra.0+0x854/0x17a0
   ieee80211_subif_start_xmit_8023+0x124/0x488
   dev_hard_start_xmit+0x160/0x5a8
   __dev_queue_xmit+0x6f8/0x3120
   br_dev_queue_push_xmit+0x120/0x4a8
   __br_forward+0xe4/0x2b0
   deliver_clone+0x5c/0xd0
   br_flood+0x398/0x580
   br_dev_xmit+0x454/0x9f8
   dev_hard_start_xmit+0x160/0x5a8
   __dev_queue_xmit+0x6f8/0x3120
   ip6_finish_output2+0xc28/0x1b60
   __ip6_finish_output+0x38c/0x638
   ip6_output+0x1b4/0x338
   ip6_local_out+0x7c/0xa8
   ip6_send_skb+0x7c/0x1b0
   ip6_push_pending_frames+0x94/0xd0
   rawv6_sendmsg+0x1a98/0x2898
   inet_sendmsg+0x94/0xe0
   __sys_sendto+0x1e4/0x308
   __arm64_sys_sendto+0xc4/0x140
   do_el0_svc+0x110/0x280
   el0_svc+0x20/0x60
   el0t_64_sync_handler+0x104/0x138
   el0t_64_sync+0x154/0x158

To avoid that, empty vif's txq at ieee80211_do_stop() so no packet could
be dequeued after ieee80211_do_stop() (new packets cannot be queued
because SDATA_STATE_RUNNING is cleared at this point).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/305741e7e63234cbcf9b5c4e6aeca25ba0834be8
  - https://git.kernel.org/stable/c/378677eb8f44621ecc9ce659f7af61e5baa94d81
  - https://git.kernel.org/stable/c/5f6863dc407f25fcf23fc857f9ac51756a09ea2c
  - https://git.kernel.org/stable/c/8bc34db7f771a464ff8f686b6f8d4e04963fec27
  - https://git.kernel.org/stable/c/929ec2c9ad34248ef625e137b6118b6e965797d9
  - https://git.kernel.org/stable/c/a8df245b5b29f6de98d016dc18e2bb35ec70b0cb
  - https://git.kernel.org/stable/c/a932a5ce4eee0cbad20220f950fe7bd3534bcbc9
  - https://git.kernel.org/stable/c/c74b84544dee27298a71715b3ce2c40d372b5a23

------------------------------------------------------------

CVE ID: CVE-2025-37796
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: at76c50x: fix use after free access in at76_disconnect

The memory pointed to by priv is freed at the end of at76_delete_device
function (using ieee80211_free_hw). But the code then accesses the udev
field of the freed object to put the USB device. This may also lead to a
memory leak of the usb device. Fix this by using udev from interface.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/152721cbae42713ecfbca6847e0f102ee6b19546
  - https://git.kernel.org/stable/c/27c7e63b3cb1a20bb78ed4a36c561ea4579fd7da
  - https://git.kernel.org/stable/c/3c619aec1f538333b56746d2f796aab1bca5c9a5
  - https://git.kernel.org/stable/c/5e7df74745700f059dc117a620e566964a2e8f2c
  - https://git.kernel.org/stable/c/6e4ab3e574c2a335b40fa1f70d1c54fcb58ab33f
  - https://git.kernel.org/stable/c/7ca513631fa6ad3011b8b9197cdde0f351103704
  - https://git.kernel.org/stable/c/a9682bfef2cf3802515a902e964d774e137be1b9
  - https://git.kernel.org/stable/c/c731cdfddcf1be1590d5ba8c9b508f98e3a2b3d6

------------------------------------------------------------

CVE ID: CVE-2020-36790
Description: In the Linux kernel, the following vulnerability has been resolved:

nvmet: fix a memory leak

We forgot to free new_model_number
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/227064b2ca9e62270ed445665ae849c73f0dfb2c
  - https://git.kernel.org/stable/c/382fee1a8b623e2546a3e15e80517389e0e0673e

------------------------------------------------------------

CVE ID: CVE-2022-49762
Description: In the Linux kernel, the following vulnerability has been resolved:

ntfs: check overflow when iterating ATTR_RECORDs

Kernel iterates over ATTR_RECORDs in mft record in ntfs_attr_find(). 
Because the ATTR_RECORDs are next to each other, kernel can get the next
ATTR_RECORD from end address of current ATTR_RECORD, through current
ATTR_RECORD length field.

The problem is that during iteration, when kernel calculates the end
address of current ATTR_RECORD, kernel may trigger an integer overflow bug
in executing `a = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))`.  This
may wrap, leading to a forever iteration on 32bit systems.

This patch solves it by adding some checks on calculating end address
of current ATTR_RECORD during iteration.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/45683723f6b53e39e8a4cec0894e61fd6ec71989
  - https://git.kernel.org/stable/c/5559eb5809353a83a40a1e4e7f066431c7b83020
  - https://git.kernel.org/stable/c/63095f4f3af59322bea984a6ae44337439348fe0
  - https://git.kernel.org/stable/c/785b2af9654b8beac55644e36da0085c5d776361
  - https://git.kernel.org/stable/c/86f36de14dce5802856bb7a5921d74439db00b64
  - https://git.kernel.org/stable/c/957732a09c3828267c2819d31c425aa793dd475b
  - https://git.kernel.org/stable/c/b612f924f296408d7d02fb4cd01218afd4ed7184
  - https://git.kernel.org/stable/c/b63ddb3ba61e2d3539f87e095c881e552bc45dab

------------------------------------------------------------

CVE ID: CVE-2022-49763
Description: In the Linux kernel, the following vulnerability has been resolved:

ntfs: fix use-after-free in ntfs_attr_find()

Patch series "ntfs: fix bugs about Attribute", v2.

This patchset fixes three bugs relative to Attribute in record:

Patch 1 adds a sanity check to ensure that, attrs_offset field in first
mft record loading from disk is within bounds.

Patch 2 moves the ATTR_RECORD's bounds checking earlier, to avoid
dereferencing ATTR_RECORD before checking this ATTR_RECORD is within
bounds.

Patch 3 adds an overflow checking to avoid possible forever loop in
ntfs_attr_find().

Without patch 1 and patch 2, the kernel triggersa KASAN use-after-free
detection as reported by Syzkaller.

Although one of patch 1 or patch 2 can fix this, we still need both of
them.  Because patch 1 fixes the root cause, and patch 2 not only fixes
the direct cause, but also fixes the potential out-of-bounds bug.


This patch (of 3):

Syzkaller reported use-after-free read as follows:
==================================================================
BUG: KASAN: use-after-free in ntfs_attr_find+0xc02/0xce0 fs/ntfs/attrib.c:597
Read of size 2 at addr ffff88807e352009 by task syz-executor153/3607

[...]
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
 print_address_description mm/kasan/report.c:317 [inline]
 print_report.cold+0x2ba/0x719 mm/kasan/report.c:433
 kasan_report+0xb1/0x1e0 mm/kasan/report.c:495
 ntfs_attr_find+0xc02/0xce0 fs/ntfs/attrib.c:597
 ntfs_attr_lookup+0x1056/0x2070 fs/ntfs/attrib.c:1193
 ntfs_read_inode_mount+0x89a/0x2580 fs/ntfs/inode.c:1845
 ntfs_fill_super+0x1799/0x9320 fs/ntfs/super.c:2854
 mount_bdev+0x34d/0x410 fs/super.c:1400
 legacy_get_tree+0x105/0x220 fs/fs_context.c:610
 vfs_get_tree+0x89/0x2f0 fs/super.c:1530
 do_new_mount fs/namespace.c:3040 [inline]
 path_mount+0x1326/0x1e20 fs/namespace.c:3370
 do_mount fs/namespace.c:3383 [inline]
 __do_sys_mount fs/namespace.c:3591 [inline]
 __se_sys_mount fs/namespace.c:3568 [inline]
 __x64_sys_mount+0x27f/0x300 fs/namespace.c:3568
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
 [...]
 </TASK>

The buggy address belongs to the physical page:
page:ffffea0001f8d400 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x7e350
head:ffffea0001f8d400 order:3 compound_mapcount:0 compound_pincount:0
flags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)
raw: 00fff00000010200 0000000000000000 dead000000000122 ffff888011842140
raw: 0000000000000000 0000000000040004 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
Memory state around the buggy address:
 ffff88807e351f00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff88807e351f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff88807e352000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                      ^
 ffff88807e352080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff88807e352100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

Kernel will loads $MFT/$DATA's first mft record in
ntfs_read_inode_mount().

Yet the problem is that after loading, kernel doesn't check whether
attrs_offset field is a valid value.

To be more specific, if attrs_offset field is larger than bytes_allocated
field, then it may trigger the out-of-bounds read bug(reported as
use-after-free bug) in ntfs_attr_find(), when kernel tries to access the
corresponding mft record's attribute.

This patch solves it by adding the sanity check between attrs_offset field
and bytes_allocated field, after loading the first mft record.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/266bd5306286316758e6246ea0345133427b0f62
  - https://git.kernel.org/stable/c/4863f815463034f588a035cfd99cdca97a4f1069
  - https://git.kernel.org/stable/c/5330c423b86263ac7883fef0260b9e2229cb531e
  - https://git.kernel.org/stable/c/79f3ac7dcd12c05b7539239a4c6fa229a50d786c
  - https://git.kernel.org/stable/c/b825bfbbaafbe8da2037e3a778ad660c59f9e054
  - https://git.kernel.org/stable/c/d0006d739738a658a9c29b438444259d9f71dfa0
  - https://git.kernel.org/stable/c/d85a1bec8e8d552ab13163ca1874dcd82f3d1550
  - https://git.kernel.org/stable/c/fb2004bafd1932e08d21ca604ee5844f2b7f212d

------------------------------------------------------------

CVE ID: CVE-2022-49764
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Prevent bpf program recursion for raw tracepoint probes

We got report from sysbot [1] about warnings that were caused by
bpf program attached to contention_begin raw tracepoint triggering
the same tracepoint by using bpf_trace_printk helper that takes
trace_printk_lock lock.

 Call Trace:
  <TASK>
  ? trace_event_raw_event_bpf_trace_printk+0x5f/0x90
  bpf_trace_printk+0x2b/0xe0
  bpf_prog_a9aec6167c091eef_prog+0x1f/0x24
  bpf_trace_run2+0x26/0x90
  native_queued_spin_lock_slowpath+0x1c6/0x2b0
  _raw_spin_lock_irqsave+0x44/0x50
  bpf_trace_printk+0x3f/0xe0
  bpf_prog_a9aec6167c091eef_prog+0x1f/0x24
  bpf_trace_run2+0x26/0x90
  native_queued_spin_lock_slowpath+0x1c6/0x2b0
  _raw_spin_lock_irqsave+0x44/0x50
  bpf_trace_printk+0x3f/0xe0
  bpf_prog_a9aec6167c091eef_prog+0x1f/0x24
  bpf_trace_run2+0x26/0x90
  native_queued_spin_lock_slowpath+0x1c6/0x2b0
  _raw_spin_lock_irqsave+0x44/0x50
  bpf_trace_printk+0x3f/0xe0
  bpf_prog_a9aec6167c091eef_prog+0x1f/0x24
  bpf_trace_run2+0x26/0x90
  native_queued_spin_lock_slowpath+0x1c6/0x2b0
  _raw_spin_lock_irqsave+0x44/0x50
  __unfreeze_partials+0x5b/0x160
  ...

The can be reproduced by attaching bpf program as raw tracepoint on
contention_begin tracepoint. The bpf prog calls bpf_trace_printk
helper. Then by running perf bench the spin lock code is forced to
take slow path and call contention_begin tracepoint.

Fixing this by skipping execution of the bpf program if it's
already running, Using bpf prog 'active' field, which is being
currently used by trampoline programs for the same reason.

Moving bpf_prog_inc_misses_counter to syscall.c because
trampoline.c is compiled in just for CONFIG_BPF_JIT option.

[1] https://lore.kernel.org/bpf/YxhFe3EwqchC%2FfYf@krava/T/#t
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/05b24ff9b2cfabfcfd951daaa915a036ab53c9e1
  - https://git.kernel.org/stable/c/2e5399879024fedd6cdc41f73fbf9bbe7208f899

------------------------------------------------------------

CVE ID: CVE-2022-49765
Description: In the Linux kernel, the following vulnerability has been resolved:

net/9p: use a dedicated spinlock for trans_fd

Shamelessly copying the explanation from Tetsuo Handa's suggested
patch[1] (slightly reworded):
syzbot is reporting inconsistent lock state in p9_req_put()[2],
for p9_tag_remove() from p9_req_put() from IRQ context is using
spin_lock_irqsave() on "struct p9_client"->lock but trans_fd
(not from IRQ context) is using spin_lock().

Since the locks actually protect different things in client.c and in
trans_fd.c, just replace trans_fd.c's lock by a new one specific to the
transport (client.c's protect the idr for fid/tag allocations,
while trans_fd.c's protects its own req list and request status field
that acts as the transport's state machine)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/296ab4a813841ba1d5f40b03190fd1bd8f25aab0
  - https://git.kernel.org/stable/c/43bbadb7e4636dc02f6a283c2a39e6438e6173cd
  - https://git.kernel.org/stable/c/717b9b4f38703d7f5293059e3a242d16f76fa045

------------------------------------------------------------

CVE ID: CVE-2022-49766
Description: In the Linux kernel, the following vulnerability has been resolved:

netlink: Bounds-check struct nlmsgerr creation

In preparation for FORTIFY_SOURCE doing bounds-check on memcpy(),
switch from __nlmsg_put to nlmsg_put(), and explain the bounds check
for dealing with the memcpy() across a composite flexible array struct.
Avoids this future run-time warning:

  memcpy: detected field-spanning write (size 32) of single field "&errmsg->msg" at net/netlink/af_netlink.c:2447 (size 16)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/710d21fdff9a98d621cd4e64167f3ef8af4e2fd1
  - https://git.kernel.org/stable/c/aff4eb16f589c3af322a2582044bca365381fcd6

------------------------------------------------------------

CVE ID: CVE-2022-49767
Description: In the Linux kernel, the following vulnerability has been resolved:

9p/trans_fd: always use O_NONBLOCK read/write

syzbot is reporting hung task at p9_fd_close() [1], for p9_mux_poll_stop()
 from p9_conn_destroy() from p9_fd_close() is failing to interrupt already
started kernel_read() from p9_fd_read() from p9_read_work() and/or
kernel_write() from p9_fd_write() from p9_write_work() requests.

Since p9_socket_open() sets O_NONBLOCK flag, p9_mux_poll_stop() does not
need to interrupt kernel_read()/kernel_write(). However, since p9_fd_open()
does not set O_NONBLOCK flag, but pipe blocks unless signal is pending,
p9_mux_poll_stop() needs to interrupt kernel_read()/kernel_write() when
the file descriptor refers to a pipe. In other words, pipe file descriptor
needs to be handled as if socket file descriptor.

We somehow need to interrupt kernel_read()/kernel_write() on pipes.

A minimal change, which this patch is doing, is to set O_NONBLOCK flag
 from p9_fd_open(), for O_NONBLOCK flag does not affect reading/writing
of regular files. But this approach changes O_NONBLOCK flag on userspace-
supplied file descriptors (which might break userspace programs), and
O_NONBLOCK flag could be changed by userspace. It would be possible to set
O_NONBLOCK flag every time p9_fd_read()/p9_fd_write() is invoked, but still
remains small race window for clearing O_NONBLOCK flag.

If we don't want to manipulate O_NONBLOCK flag, we might be able to
surround kernel_read()/kernel_write() with set_thread_flag(TIF_SIGPENDING)
and recalc_sigpending(). Since p9_read_work()/p9_write_work() works are
processed by kernel threads which process global system_wq workqueue,
signals could not be delivered from remote threads when p9_mux_poll_stop()
 from p9_conn_destroy() from p9_fd_close() is called. Therefore, calling
set_thread_flag(TIF_SIGPENDING)/recalc_sigpending() every time would be
needed if we count on signals for making kernel_read()/kernel_write()
non-blocking.

[Dominique: add comment at Christian's suggestion]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b5e6bd72b8171364616841603a70e4ba9837063
  - https://git.kernel.org/stable/c/0e07032b4b4724b8ad1003698cb81083c1818999
  - https://git.kernel.org/stable/c/5af16182c5639349415118e9e9aecd8355f7a08b
  - https://git.kernel.org/stable/c/7abf40f06a76c0dff42eada10597917e9776fbd4
  - https://git.kernel.org/stable/c/9f8554615df668e4bf83294633ee9d232b28ce45
  - https://git.kernel.org/stable/c/a8e2fc8f7b41fa9d9ca5f624f4e4d34fce5b40a9
  - https://git.kernel.org/stable/c/b1ad04da7fe4515e2ce2d5f2dcab3b5b6d45614b
  - https://git.kernel.org/stable/c/ef575281b21e9a34dfae544a187c6aac2ae424a9

------------------------------------------------------------

CVE ID: CVE-2022-49768
Description: In the Linux kernel, the following vulnerability has been resolved:

9p: trans_fd/p9_conn_cancel: drop client lock earlier

syzbot reported a double-lock here and we no longer need this
lock after requests have been moved off to local list:
just drop the lock earlier.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/52f1c45dde9136f964d63a77d19826c8a74e2c7f
  - https://git.kernel.org/stable/c/612c977f5d481f551d03d83d0aef588845c1300c
  - https://git.kernel.org/stable/c/82825dbf393f7c7979d462f9609a15bde8092b3f
  - https://git.kernel.org/stable/c/96760723aae1b45f733f702abb4333137143909f
  - https://git.kernel.org/stable/c/a4f1a01b2e81378fce9ca528d4d8a049e4b58fcd
  - https://git.kernel.org/stable/c/e3031280fe4eaf61a09e60823331f81f321be8e1
  - https://git.kernel.org/stable/c/f14858bc77c567e089965962877ee726ffad0556
  - https://git.kernel.org/stable/c/fec1406f5e7ab20b71f6d231792b0040e3300aaf

------------------------------------------------------------

CVE ID: CVE-2022-49769
Description: In the Linux kernel, the following vulnerability has been resolved:

gfs2: Check sb_bsize_shift after reading superblock

Fuzzers like to scribble over sb_bsize_shift but in reality it's very
unlikely that this field would be corrupted on its own. Nevertheless it
should be checked to avoid the possibility of messy mount errors due to
bad calculations. It's always a fixed value based on the block size so
we can just check that it's the expected value.

Tested with:

    mkfs.gfs2 -O -p lock_nolock /dev/vdb
    for i in 0 -1 64 65 32 33; do
        gfs2_edit -p sb field sb_bsize_shift $i /dev/vdb
        mount /dev/vdb /mnt/test && umount /mnt/test
    done

Before this patch we get a withdraw after

[   76.413681] gfs2: fsid=loop0.0: fatal: invalid metadata block
[   76.413681]   bh = 19 (type: exp=5, found=4)
[   76.413681]   function = gfs2_meta_buffer, file = fs/gfs2/meta_io.c, line = 492

and with UBSAN configured we also get complaints like

[   76.373395] UBSAN: shift-out-of-bounds in fs/gfs2/ops_fstype.c:295:19
[   76.373815] shift exponent 4294967287 is too large for 64-bit type 'long unsigned int'

After the patch, these complaints don't appear, mount fails immediately
and we get an explanation in dmesg.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/15c83fa0fd659dd9fbdc940a560b61236e876a80
  - https://git.kernel.org/stable/c/16670534c7cff1acd918a6a5ec751b14e7436b76
  - https://git.kernel.org/stable/c/1ad197097343568066a8ffaa27ee7d0ae6d9f476
  - https://git.kernel.org/stable/c/28275a7c84d21c55ab3282d897f284d8d527173c
  - https://git.kernel.org/stable/c/5fa30be7ba81191b0a0c7239a89befc0c94286d5
  - https://git.kernel.org/stable/c/670f8ce56dd0632dc29a0322e188cc73ce3c6b92
  - https://git.kernel.org/stable/c/8b6534c9ae9dba5489703a19d8ba6c8f2cfa33c2
  - https://git.kernel.org/stable/c/d6b1e8ea6f3418c3b461ad5a35cdc93c996b2c87

------------------------------------------------------------

CVE ID: CVE-2022-49770
Description: In the Linux kernel, the following vulnerability has been resolved:

ceph: avoid putting the realm twice when decoding snaps fails

When decoding the snaps fails it maybe leaving the 'first_realm'
and 'realm' pointing to the same snaprealm memory. And then it'll
put it twice and could cause random use-after-free, BUG_ON, etc
issues.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/044bc6d3c2c0e9090b0841e7b723875756534b45
  - https://git.kernel.org/stable/c/274e4c79a3a2a24fba7cfe0e41113f1138785c37
  - https://git.kernel.org/stable/c/2f6e2de3a5289004650118b61f138fe7c28e1905
  - https://git.kernel.org/stable/c/51884d153f7ec85e18d607b2467820a90e0f4359
  - https://git.kernel.org/stable/c/cb7495fe957526555782ce0723f79ce92a6db22e
  - https://git.kernel.org/stable/c/fd879c83e87735ab8f00ef7755752cf0cbae24b2

------------------------------------------------------------

CVE ID: CVE-2022-49771
Description: In the Linux kernel, the following vulnerability has been resolved:

dm ioctl: fix misbehavior if list_versions races with module loading

__list_versions will first estimate the required space using the
"dm_target_iterate(list_version_get_needed, &needed)" call and then will
fill the space using the "dm_target_iterate(list_version_get_info,
&iter_info)" call. Each of these calls locks the targets using the
"down_read(&_lock)" and "up_read(&_lock)" calls, however between the first
and second "dm_target_iterate" there is no lock held and the target
modules can be loaded at this point, so the second "dm_target_iterate"
call may need more space than what was the first "dm_target_iterate"
returned.

The code tries to handle this overflow (see the beginning of
list_version_get_info), however this handling is incorrect.

The code sets "param->data_size = param->data_start + needed" and
"iter_info.end = (char *)vers+len" - "needed" is the size returned by the
first dm_target_iterate call; "len" is the size of the buffer allocated by
userspace.

"len" may be greater than "needed"; in this case, the code will write up
to "len" bytes into the buffer, however param->data_size is set to
"needed", so it may write data past the param->data_size value. The ioctl
interface copies only up to param->data_size into userspace, thus part of
the result will be truncated.

Fix this bug by setting "iter_info.end = (char *)vers + needed;" - this
guarantees that the second "dm_target_iterate" call will write only up to
the "needed" buffer and it will exit with "DM_BUFFER_FULL_FLAG" if it
overflows the "needed" space - in this case, userspace will allocate a
larger buffer and retry.

Note that there is also a bug in list_version_get_needed - we need to add
"strlen(tt->name) + 1" to the needed size, not "strlen(tt->name)".
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c8d4112df329bf3dfbf27693f918c3b08676538
  - https://git.kernel.org/stable/c/3a1c35d72dc0b34d1e746ed705790c0f630aa427
  - https://git.kernel.org/stable/c/4fe1ec995483737f3d2a14c3fe1d8fe634972979
  - https://git.kernel.org/stable/c/5398b8e275bf81a2517b327d216c0f37ac9ac5ae
  - https://git.kernel.org/stable/c/6a818db0d5aecf80d4ba9e10ac153f60adc629ca
  - https://git.kernel.org/stable/c/6ffce7a92ef5c68f7e5d6f4d722c2f96280c064b
  - https://git.kernel.org/stable/c/b545c0e1e4094d4de2bdfe9a3823f9154b0c0005
  - https://git.kernel.org/stable/c/f59f5a269ca5e43c567aca7f1f52500a0186e9b7

------------------------------------------------------------

CVE ID: CVE-2022-49772
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: usb-audio: Drop snd_BUG_ON() from snd_usbmidi_output_open()

snd_usbmidi_output_open() has a check of the NULL port with
snd_BUG_ON().  snd_BUG_ON() was used as this shouldn't have happened,
but in reality, the NULL port may be seen when the device gives an
invalid endpoint setup at the descriptor, hence the driver skips the
allocation.  That is, the check itself is valid and snd_BUG_ON()
should be dropped from there.  Otherwise it's confusing as if it were
a real bug, as recently syzbot stumbled on it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/00f5f1bbf815a39e9eecb468d12ca55d3360eb10
  - https://git.kernel.org/stable/c/02b94885b2fdf1808b1874e009bfb90753f8f4db
  - https://git.kernel.org/stable/c/368a01e5064c13946d032ab1d65ba95020a39cc5
  - https://git.kernel.org/stable/c/872c9314769e89d8bda74ff3ac584756a45ee752
  - https://git.kernel.org/stable/c/a80369c8ca50bc885d14386087a834659ec54a54
  - https://git.kernel.org/stable/c/ad72c3c3f6eb81d2cb189ec71e888316adada5df
  - https://git.kernel.org/stable/c/c43991065f36f7628cd124e037b8750c4617a7a7
  - https://git.kernel.org/stable/c/e7dc436aea80308a9268e6d2d85f910ff107de9b

------------------------------------------------------------

CVE ID: CVE-2022-49773
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix optc2_configure warning on dcn314

[Why]
dcn314 uses optc2_configure_crc() that wraps
optc1_configure_crc() + set additional registers
not applicable to dcn314.
It's not critical but when used leads to warning like:
WARNING: drivers/gpu/drm/amd/amdgpu/../display/dc/dc_helper.c
Call Trace:
<TASK>
generic_reg_set_ex+0x6d/0xe0 [amdgpu]
optc2_configure_crc+0x60/0x80 [amdgpu]
dc_stream_configure_crc+0x129/0x150 [amdgpu]
amdgpu_dm_crtc_configure_crc_source+0x5d/0xe0 [amdgpu]

[How]
Use optc1_configure_crc() directly
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/e7e4f77c991c9abf90924929a9d55f90b0bb78de
  - https://git.kernel.org/stable/c/f67ef5aa88e3db0a13ae3befab2ddf14ac00a91c

------------------------------------------------------------

CVE ID: CVE-2022-49774
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86/xen: Fix eventfd error handling in kvm_xen_eventfd_assign()

Should not call eventfd_ctx_put() in case of error.

[Introduce new goto target instead. - Paolo]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7353633814f6e5b4899fb9ee1483709d6bb0e1cd
  - https://git.kernel.org/stable/c/d76f46f47dfde220712d1420ee5dbc546c8fc674

------------------------------------------------------------

CVE ID: CVE-2022-49775
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: cdg: allow tcp_cdg_release() to be called multiple times

Apparently, mptcp is able to call tcp_disconnect() on an already
disconnected flow. This is generally fine, unless current congestion
control is CDG, because it might trigger a double-free [1]

Instead of fixing MPTCP, and future bugs, we can make tcp_disconnect()
more resilient.

[1]
BUG: KASAN: double-free in slab_free mm/slub.c:3539 [inline]
BUG: KASAN: double-free in kfree+0xe2/0x580 mm/slub.c:4567

CPU: 0 PID: 3645 Comm: kworker/0:7 Not tainted 6.0.0-syzkaller-02734-g0326074ff465 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022
Workqueue: events mptcp_worker
Call Trace:
<TASK>
__dump_stack lib/dump_stack.c:88 [inline]
dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
print_address_description mm/kasan/report.c:317 [inline]
print_report.cold+0x2ba/0x719 mm/kasan/report.c:433
kasan_report_invalid_free+0x81/0x190 mm/kasan/report.c:462
____kasan_slab_free+0x18b/0x1c0 mm/kasan/common.c:356
kasan_slab_free include/linux/kasan.h:200 [inline]
slab_free_hook mm/slub.c:1759 [inline]
slab_free_freelist_hook+0x8b/0x1c0 mm/slub.c:1785
slab_free mm/slub.c:3539 [inline]
kfree+0xe2/0x580 mm/slub.c:4567
tcp_disconnect+0x980/0x1e20 net/ipv4/tcp.c:3145
__mptcp_close_ssk+0x5ca/0x7e0 net/mptcp/protocol.c:2327
mptcp_do_fastclose net/mptcp/protocol.c:2592 [inline]
mptcp_worker+0x78c/0xff0 net/mptcp/protocol.c:2627
process_one_work+0x991/0x1610 kernel/workqueue.c:2289
worker_thread+0x665/0x1080 kernel/workqueue.c:2436
kthread+0x2e4/0x3a0 kernel/kthread.c:376
ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306
</TASK>

Allocated by task 3671:
kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38
kasan_set_track mm/kasan/common.c:45 [inline]
set_alloc_info mm/kasan/common.c:437 [inline]
____kasan_kmalloc mm/kasan/common.c:516 [inline]
____kasan_kmalloc mm/kasan/common.c:475 [inline]
__kasan_kmalloc+0xa9/0xd0 mm/kasan/common.c:525
kmalloc_array include/linux/slab.h:640 [inline]
kcalloc include/linux/slab.h:671 [inline]
tcp_cdg_init+0x10d/0x170 net/ipv4/tcp_cdg.c:380
tcp_init_congestion_control+0xab/0x550 net/ipv4/tcp_cong.c:193
tcp_reinit_congestion_control net/ipv4/tcp_cong.c:217 [inline]
tcp_set_congestion_control+0x96c/0xaa0 net/ipv4/tcp_cong.c:391
do_tcp_setsockopt+0x505/0x2320 net/ipv4/tcp.c:3513
tcp_setsockopt+0xd4/0x100 net/ipv4/tcp.c:3801
mptcp_setsockopt+0x35f/0x2570 net/mptcp/sockopt.c:844
__sys_setsockopt+0x2d6/0x690 net/socket.c:2252
__do_sys_setsockopt net/socket.c:2263 [inline]
__se_sys_setsockopt net/socket.c:2260 [inline]
__x64_sys_setsockopt+0xba/0x150 net/socket.c:2260
do_syscall_x64 arch/x86/entry/common.c:50 [inline]
do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
entry_SYSCALL_64_after_hwframe+0x63/0xcd

Freed by task 16:
kasan_save_stack+0x1e/0x40 mm/kasan/common.c:38
kasan_set_track+0x21/0x30 mm/kasan/common.c:45
kasan_set_free_info+0x20/0x30 mm/kasan/generic.c:370
____kasan_slab_free mm/kasan/common.c:367 [inline]
____kasan_slab_free+0x166/0x1c0 mm/kasan/common.c:329
kasan_slab_free include/linux/kasan.h:200 [inline]
slab_free_hook mm/slub.c:1759 [inline]
slab_free_freelist_hook+0x8b/0x1c0 mm/slub.c:1785
slab_free mm/slub.c:3539 [inline]
kfree+0xe2/0x580 mm/slub.c:4567
tcp_cleanup_congestion_control+0x70/0x120 net/ipv4/tcp_cong.c:226
tcp_v4_destroy_sock+0xdd/0x750 net/ipv4/tcp_ipv4.c:2254
tcp_v6_destroy_sock+0x11/0x20 net/ipv6/tcp_ipv6.c:1969
inet_csk_destroy_sock+0x196/0x440 net/ipv4/inet_connection_sock.c:1157
tcp_done+0x23b/0x340 net/ipv4/tcp.c:4649
tcp_rcv_state_process+0x40e7/0x4990 net/ipv4/tcp_input.c:6624
tcp_v6_do_rcv+0x3fc/0x13c0 net/ipv6/tcp_ipv6.c:1525
tcp_v6_rcv+0x2e8e/0x3830 net/ipv6/tcp_ipv6.c:1759
ip6_protocol_deliver_rcu+0x2db/0x1950 net/ipv6/ip6_input.c:439
ip6_input_finish+0x14c/0x2c0 net/ipv6/ip6_input.c:484
NF_HOOK include/linux/netfilter.h:302 [inline]
NF_HOOK include/linux/netfilter.h:296 [inline]
ip6_input+0x9c/0xd
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b19171439016a8e4c97eafe543670ac86e2b8fe
  - https://git.kernel.org/stable/c/1b639be27cbf428a5ca01dcf8b5d654194c956f8
  - https://git.kernel.org/stable/c/35309be06b6feded2ab2cafbc2bca8534c2fa41e
  - https://git.kernel.org/stable/c/4026033907cc6186d86b48daa4a252c860db2536
  - https://git.kernel.org/stable/c/72e560cb8c6f80fc2b4afc5d3634a32465e13a51
  - https://git.kernel.org/stable/c/78be2ee0112409ae4e9ee9e326151e0559b3d239
  - https://git.kernel.org/stable/c/9e481d87349d2282f400ee1d010a169c99f766b8
  - https://git.kernel.org/stable/c/b49026d9c86f35a4c5bfb8d7345c9c4379828c6b

------------------------------------------------------------

CVE ID: CVE-2022-49776
Description: In the Linux kernel, the following vulnerability has been resolved:

macvlan: enforce a consistent minimal mtu

macvlan should enforce a minimal mtu of 68, even at link creation.

This patch avoids the current behavior (which could lead to crashes
in ipv6 stack if the link is brought up)

$ ip link add macvlan1 link eno1 mtu 8 type macvlan  # This should fail !
$ ip link sh dev macvlan1
5: macvlan1@eno1: <BROADCAST,MULTICAST> mtu 8 qdisc noop
    state DOWN mode DEFAULT group default qlen 1000
    link/ether 02:47:6c:24:74:82 brd ff:ff:ff:ff:ff:ff
$ ip link set macvlan1 mtu 67
Error: mtu less than device minimum.
$ ip link set macvlan1 mtu 68
$ ip link set macvlan1 mtu 8
Error: mtu less than device minimum.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b055c719d8f94c15ec9b7659978133030c6a353
  - https://git.kernel.org/stable/c/650137a7c0b2892df2e5b0bc112d7b09a78c93c8
  - https://git.kernel.org/stable/c/a62aa84fe19eb24d083d600a074c009a0a66d4f3
  - https://git.kernel.org/stable/c/b64085b00044bdf3cd1c9825e9ef5b2e0feae91a
  - https://git.kernel.org/stable/c/d2fee7d121d189c6dc905b727d60e7043a6655bb
  - https://git.kernel.org/stable/c/e41cbf98df22d08402e65174d147cbb187fe1a33
  - https://git.kernel.org/stable/c/e929ec98c0c3b10d9c07f3776df0c1a02d7a763e

------------------------------------------------------------

CVE ID: CVE-2022-49777
Description: In the Linux kernel, the following vulnerability has been resolved:

Input: i8042 - fix leaking of platform device on module removal

Avoid resetting the module-wide i8042_platform_device pointer in
i8042_probe() or i8042_remove(), so that the device can be properly
destroyed by i8042_exit() on module unload.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3f25add5ecf88de0f8ff2b27b6c0731a1f1b38ed
  - https://git.kernel.org/stable/c/4f348b60c79671eee33c1389efe89109c93047da
  - https://git.kernel.org/stable/c/81cd7e8489278d28794e7b272950c3e00c344e44
  - https://git.kernel.org/stable/c/81df118e79b2136b5c016394f67a051dc508b7b6
  - https://git.kernel.org/stable/c/a32cd7feb0127bf629a82686b6e2c128139a86e5
  - https://git.kernel.org/stable/c/d5f7f6e63fed9c2ed09725d90059a28907e197e3

------------------------------------------------------------

CVE ID: CVE-2022-49778
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64/mm: fix incorrect file_map_count for non-leaf pmd/pud

The page table check trigger BUG_ON() unexpectedly when collapse hugepage:

 ------------[ cut here ]------------
 kernel BUG at mm/page_table_check.c:82!
 Internal error: Oops - BUG: 00000000f2000800 [#1] SMP
 Dumping ftrace buffer:
    (ftrace buffer empty)
 Modules linked in:
 CPU: 6 PID: 68 Comm: khugepaged Not tainted 6.1.0-rc3+ #750
 Hardware name: linux,dummy-virt (DT)
 pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
 pc : page_table_check_clear.isra.0+0x258/0x3f0
 lr : page_table_check_clear.isra.0+0x240/0x3f0
[...]
 Call trace:
  page_table_check_clear.isra.0+0x258/0x3f0
  __page_table_check_pmd_clear+0xbc/0x108
  pmdp_collapse_flush+0xb0/0x160
  collapse_huge_page+0xa08/0x1080
  hpage_collapse_scan_pmd+0xf30/0x1590
  khugepaged_scan_mm_slot.constprop.0+0x52c/0xac8
  khugepaged+0x338/0x518
  kthread+0x278/0x2f8
  ret_from_fork+0x10/0x20
[...]

Since pmd_user_accessible_page() doesn't check if a pmd is leaf, it
decrease file_map_count for a non-leaf pmd comes from collapse_huge_page().
and so trigger BUG_ON() unexpectedly.

Fix this problem by using pmd_leaf() insteal of pmd_present() in
pmd_user_accessible_page(). Moreover, use pud_leaf() for
pud_user_accessible_page() too.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d458046df634088611d44fd77f45465e833ef78
  - https://git.kernel.org/stable/c/5b47348fc0b18a78c96f8474cc90b7525ad1bbfe

------------------------------------------------------------

CVE ID: CVE-2022-49779
Description: In the Linux kernel, the following vulnerability has been resolved:

kprobes: Skip clearing aggrprobe's post_handler in kprobe-on-ftrace case

In __unregister_kprobe_top(), if the currently unregistered probe has
post_handler but other child probes of the aggrprobe do not have
post_handler, the post_handler of the aggrprobe is cleared. If this is
a ftrace-based probe, there is a problem. In later calls to
disarm_kprobe(), we will use kprobe_ftrace_ops because post_handler is
NULL. But we're armed with kprobe_ipmodify_ops. This triggers a WARN in
__disarm_kprobe_ftrace() and may even cause use-after-free:

  Failed to disarm kprobe-ftrace at kernel_clone+0x0/0x3c0 (error -2)
  WARNING: CPU: 5 PID: 137 at kernel/kprobes.c:1135 __disarm_kprobe_ftrace.isra.21+0xcf/0xe0
  Modules linked in: testKprobe_007(-)
  CPU: 5 PID: 137 Comm: rmmod Not tainted 6.1.0-rc4-dirty #18
  [...]
  Call Trace:
   <TASK>
   __disable_kprobe+0xcd/0xe0
   __unregister_kprobe_top+0x12/0x150
   ? mutex_lock+0xe/0x30
   unregister_kprobes.part.23+0x31/0xa0
   unregister_kprobe+0x32/0x40
   __x64_sys_delete_module+0x15e/0x260
   ? do_user_addr_fault+0x2cd/0x6b0
   do_syscall_64+0x3a/0x90
   entry_SYSCALL_64_after_hwframe+0x63/0xcd
   [...]

For the kprobe-on-ftrace case, we keep the post_handler setting to
identify this aggrprobe armed with kprobe_ipmodify_ops. This way we
can disarm it correctly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/55788ebbe8b365b4375bd56b4ba7db79d393a370
  - https://git.kernel.org/stable/c/5dd7caf0bdc5d0bae7cf9776b4d739fb09bd5ebb
  - https://git.kernel.org/stable/c/7b0007b28dd970176f2e297c06ae63eea2447127
  - https://git.kernel.org/stable/c/7d606ae1abcc3eab5408e42444d789dc7def51b8
  - https://git.kernel.org/stable/c/c49cc2c059b503e962c2f13a806c105f9b757df4

------------------------------------------------------------

CVE ID: CVE-2022-49780
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: target: tcm_loop: Fix possible name leak in tcm_loop_setup_hba_bus()

If device_register() fails in tcm_loop_setup_hba_bus(), the name allocated
by dev_set_name() need be freed. As comment of device_register() says, it
should use put_device() to give up the reference in the error path. So fix
this by calling put_device(), then the name can be freed in kobject_cleanup().
The 'tl_hba' will be freed in tcm_loop_release_adapter(), so it don't need
goto error label in this case.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28f7ff5e7559d226e63c7c5de74eb075a83d8c53
  - https://git.kernel.org/stable/c/41a6b8b527a5957fab41c3c05e25ad125268e2e9
  - https://git.kernel.org/stable/c/75205f1b47a88c3fac4f30bd7567e89b2887c7fd
  - https://git.kernel.org/stable/c/a636772988bafab89278e7bb3420d8e8eacfe912
  - https://git.kernel.org/stable/c/bc68e428d4963af0201e92159629ab96948f0893
  - https://git.kernel.org/stable/c/dce0589a3faec9e2e543e97bca7e62592ec85585

------------------------------------------------------------

CVE ID: CVE-2022-49781
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/x86/amd: Fix crash due to race between amd_pmu_enable_all, perf NMI and throttling

amd_pmu_enable_all() does:

      if (!test_bit(idx, cpuc->active_mask))
              continue;

      amd_pmu_enable_event(cpuc->events[idx]);

A perf NMI of another event can come between these two steps. Perf NMI
handler internally disables and enables _all_ events, including the one
which nmi-intercepted amd_pmu_enable_all() was in process of enabling.
If that unintentionally enabled event has very low sampling period and
causes immediate successive NMI, causing the event to be throttled,
cpuc->events[idx] and cpuc->active_mask gets cleared by x86_pmu_stop().
This will result in amd_pmu_enable_event() getting called with event=NULL
when amd_pmu_enable_all() resumes after handling the NMIs. This causes a
kernel crash:

  BUG: kernel NULL pointer dereference, address: 0000000000000198
  #PF: supervisor read access in kernel mode
  #PF: error_code(0x0000) - not-present page
  [...]
  Call Trace:
   <TASK>
   amd_pmu_enable_all+0x68/0xb0
   ctx_resched+0xd9/0x150
   event_function+0xb8/0x130
   ? hrtimer_start_range_ns+0x141/0x4a0
   ? perf_duration_warn+0x30/0x30
   remote_function+0x4d/0x60
   __flush_smp_call_function_queue+0xc4/0x500
   flush_smp_call_function_queue+0x11d/0x1b0
   do_idle+0x18f/0x2d0
   cpu_startup_entry+0x19/0x20
   start_secondary+0x121/0x160
   secondary_startup_64_no_verify+0xe5/0xeb
   </TASK>

amd_pmu_disable_all()/amd_pmu_enable_all() calls inside perf NMI handler
were recently added as part of BRS enablement but I'm not sure whether
we really need them. We can just disable BRS in the beginning and enable
it back while returning from NMI. This will solve the issue by not
enabling those events whose active_masks are set but are not yet enabled
in hw pmu.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/baa014b9543c8e5e94f5d15b66abfe60750b8284
  - https://git.kernel.org/stable/c/fd5e454b856ed86b090336e269695d9908609b71

------------------------------------------------------------

CVE ID: CVE-2022-49782
Description: In the Linux kernel, the following vulnerability has been resolved:

perf: Improve missing SIGTRAP checking

To catch missing SIGTRAP we employ a WARN in __perf_event_overflow(),
which fires if pending_sigtrap was already set: returning to user space
without consuming pending_sigtrap, and then having the event fire again
would re-enter the kernel and trigger the WARN.

This, however, seemed to miss the case where some events not associated
with progress in the user space task can fire and the interrupt handler
runs before the IRQ work meant to consume pending_sigtrap (and generate
the SIGTRAP).

syzbot gifted us this stack trace:

 | WARNING: CPU: 0 PID: 3607 at kernel/events/core.c:9313 __perf_event_overflow
 | Modules linked in:
 | CPU: 0 PID: 3607 Comm: syz-executor100 Not tainted 6.1.0-rc2-syzkaller-00073-g88619e77b33d #0
 | Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/11/2022
 | RIP: 0010:__perf_event_overflow+0x498/0x540 kernel/events/core.c:9313
 | <...>
 | Call Trace:
 |  <TASK>
 |  perf_swevent_hrtimer+0x34f/0x3c0 kernel/events/core.c:10729
 |  __run_hrtimer kernel/time/hrtimer.c:1685 [inline]
 |  __hrtimer_run_queues+0x1c6/0xfb0 kernel/time/hrtimer.c:1749
 |  hrtimer_interrupt+0x31c/0x790 kernel/time/hrtimer.c:1811
 |  local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1096 [inline]
 |  __sysvec_apic_timer_interrupt+0x17c/0x640 arch/x86/kernel/apic/apic.c:1113
 |  sysvec_apic_timer_interrupt+0x40/0xc0 arch/x86/kernel/apic/apic.c:1107
 |  asm_sysvec_apic_timer_interrupt+0x16/0x20 arch/x86/include/asm/idtentry.h:649
 | <...>
 |  </TASK>

In this case, syzbot produced a program with event type
PERF_TYPE_SOFTWARE and config PERF_COUNT_SW_CPU_CLOCK. The hrtimer
manages to fire again before the IRQ work got a chance to run, all while
never having returned to user space.

Improve the WARN to check for real progress in user space: approximate
this by storing a 32-bit hash of the current IP into pending_sigtrap,
and if an event fires while pending_sigtrap still matches the previous
IP, we assume no progress (false negatives are possible given we could
return to user space and trigger again on the same IP).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/35c60b4e8ca76712dd03bafe2598e31578248916
  - https://git.kernel.org/stable/c/b09221f1b4944d2866d06ac35e59d7a6f8916c9f
  - https://git.kernel.org/stable/c/bb88f9695460bec25aa30ba9072595025cf6c8af

------------------------------------------------------------

CVE ID: CVE-2022-49783
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/fpu: Drop fpregs lock before inheriting FPU permissions

Mike Galbraith reported the following against an old fork of preempt-rt
but the same issue also applies to the current preempt-rt tree.

   BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46
   in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: systemd
   preempt_count: 1, expected: 0
   RCU nest depth: 0, expected: 0
   Preemption disabled at:
   fpu_clone
   CPU: 6 PID: 1 Comm: systemd Tainted: G            E       (unreleased)
   Call Trace:
    <TASK>
    dump_stack_lvl
    ? fpu_clone
    __might_resched
    rt_spin_lock
    fpu_clone
    ? copy_thread
    ? copy_process
    ? shmem_alloc_inode
    ? kmem_cache_alloc
    ? kernel_clone
    ? __do_sys_clone
    ? do_syscall_64
    ? __x64_sys_rt_sigprocmask
    ? syscall_exit_to_user_mode
    ? do_syscall_64
    ? syscall_exit_to_user_mode
    ? do_syscall_64
    ? syscall_exit_to_user_mode
    ? do_syscall_64
    ? exc_page_fault
    ? entry_SYSCALL_64_after_hwframe
    </TASK>

Mike says:

  The splat comes from fpu_inherit_perms() being called under fpregs_lock(),
  and us reaching the spin_lock_irq() therein due to fpu_state_size_dynamic()
  returning true despite static key __fpu_state_size_dynamic having never
  been enabled.

Mike's assessment looks correct. fpregs_lock on a PREEMPT_RT kernel disables
preemption so calling spin_lock_irq() in fpu_inherit_perms() is unsafe. This
problem exists since commit

  9e798e9aa14c ("x86/fpu: Prepare fpu_clone() for dynamically enabled features").

Even though the original bug report should not have enabled the paths at
all, the bug still exists.

fpregs_lock is necessary when editing the FPU registers or a task's FP
state but it is not necessary for fpu_inherit_perms(). The only write
of any FP state in fpu_inherit_perms() is for the new child which is
not running yet and cannot context switch or be borrowed by a kernel
thread yet. Hence, fpregs_lock is not protecting anything in the new
child until clone() completes and can be dropped earlier. The siglock
still needs to be acquired by fpu_inherit_perms() as the read of the
parent's permissions has to be serialised.

  [ bp: Cleanup splat. ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/36b038791e1e2baea892e9276588815fd14894b4
  - https://git.kernel.org/stable/c/c6e8a7a1780af3da65e78a615f7d0874da6aabb0

------------------------------------------------------------

CVE ID: CVE-2022-49784
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/x86/amd/uncore: Fix memory leak for events array

When a CPU comes online, the per-CPU NB and LLC uncore contexts are
freed but not the events array within the context structure. This
causes a memory leak as identified by the kmemleak detector.

  [...]
  unreferenced object 0xffff8c5944b8e320 (size 32):
    comm "swapper/0", pid 1, jiffies 4294670387 (age 151.072s)
    hex dump (first 32 bytes):
      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    backtrace:
      [<000000000759fb79>] amd_uncore_cpu_up_prepare+0xaf/0x230
      [<00000000ddc9e126>] cpuhp_invoke_callback+0x2cf/0x470
      [<0000000093e727d4>] cpuhp_issue_call+0x14d/0x170
      [<0000000045464d54>] __cpuhp_setup_state_cpuslocked+0x11e/0x330
      [<0000000069f67cbd>] __cpuhp_setup_state+0x6b/0x110
      [<0000000015365e0f>] amd_uncore_init+0x260/0x321
      [<00000000089152d2>] do_one_initcall+0x3f/0x1f0
      [<000000002d0bd18d>] kernel_init_freeable+0x1ca/0x212
      [<0000000030be8dde>] kernel_init+0x11/0x120
      [<0000000059709e59>] ret_from_fork+0x22/0x30
  unreferenced object 0xffff8c5944b8dd40 (size 64):
    comm "swapper/0", pid 1, jiffies 4294670387 (age 151.072s)
    hex dump (first 32 bytes):
      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    backtrace:
      [<00000000306efe8b>] amd_uncore_cpu_up_prepare+0x183/0x230
      [<00000000ddc9e126>] cpuhp_invoke_callback+0x2cf/0x470
      [<0000000093e727d4>] cpuhp_issue_call+0x14d/0x170
      [<0000000045464d54>] __cpuhp_setup_state_cpuslocked+0x11e/0x330
      [<0000000069f67cbd>] __cpuhp_setup_state+0x6b/0x110
      [<0000000015365e0f>] amd_uncore_init+0x260/0x321
      [<00000000089152d2>] do_one_initcall+0x3f/0x1f0
      [<000000002d0bd18d>] kernel_init_freeable+0x1ca/0x212
      [<0000000030be8dde>] kernel_init+0x11/0x120
      [<0000000059709e59>] ret_from_fork+0x22/0x30
  [...]

Fix the problem by freeing the events array before freeing the uncore
context.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/bdfe34597139cfcecd47a2eb97fea44d77157491
  - https://git.kernel.org/stable/c/f75be9885d49e3717de962345c4572ddab52b178

------------------------------------------------------------

CVE ID: CVE-2022-49785
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/sgx: Add overflow check in sgx_validate_offset_length()

sgx_validate_offset_length() function verifies "offset" and "length"
arguments provided by userspace, but was missing an overflow check on
their addition. Add it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3b1c10fb754b0b67165e3f055a4208e5ba26dc89
  - https://git.kernel.org/stable/c/5277e3d633a5d4157987f4aff068caa55e36db19
  - https://git.kernel.org/stable/c/f0861f49bd946ff94fce4f82509c45e167f63690

------------------------------------------------------------

CVE ID: CVE-2022-49786
Description: In the Linux kernel, the following vulnerability has been resolved:

blk-cgroup: properly pin the parent in blkcg_css_online

blkcg_css_online is supposed to pin the blkcg of the parent, but
397c9f46ee4d refactored things and along the way, changed it to pin the
css instead.  This results in extra pins, and we end up leaking blkcgs
and cgroups.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/d118247e404d6338f7b90636a3c6b95a387ed163
  - https://git.kernel.org/stable/c/d7dbd43f4a828fa1d9a8614d5b0ac40aee6375fe

------------------------------------------------------------

CVE ID: CVE-2022-49787
Description: In the Linux kernel, the following vulnerability has been resolved:

mmc: sdhci-pci: Fix possible memory leak caused by missing pci_dev_put()

pci_get_device() will increase the reference count for the returned
pci_dev. We need to use pci_dev_put() to decrease the reference count
before amd_probe() returns. There is no problem for the 'smbus_dev ==
NULL' branch because pci_dev_put() can also handle the NULL input
parameter case.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/222cfa0118aa68687ace74aab8fdf77ce8fbd7e6
  - https://git.kernel.org/stable/c/27f712cd47d65e14cd52cc32a23d42aeef583d5d
  - https://git.kernel.org/stable/c/35bca18092685b488003509fef7055aa2d4f2ebc
  - https://git.kernel.org/stable/c/4423866d31a06a810db22062ed13389416a66b22
  - https://git.kernel.org/stable/c/5dbd6378dbf96787d6dbcca44156c511ae085ea3
  - https://git.kernel.org/stable/c/7570e5b5419ffd34b6dc45a88c51e113a9a187e3
  - https://git.kernel.org/stable/c/a99a547658e5d451f01ed307426286716b6f01bf

------------------------------------------------------------

CVE ID: CVE-2022-49788
Description: In the Linux kernel, the following vulnerability has been resolved:

misc/vmw_vmci: fix an infoleak in vmci_host_do_receive_datagram()

`struct vmci_event_qp` allocated by qp_notify_peer() contains padding,
which may carry uninitialized data to the userspace, as observed by
KMSAN:

  BUG: KMSAN: kernel-infoleak in instrument_copy_to_user ./include/linux/instrumented.h:121
   instrument_copy_to_user ./include/linux/instrumented.h:121
   _copy_to_user+0x5f/0xb0 lib/usercopy.c:33
   copy_to_user ./include/linux/uaccess.h:169
   vmci_host_do_receive_datagram drivers/misc/vmw_vmci/vmci_host.c:431
   vmci_host_unlocked_ioctl+0x33d/0x43d0 drivers/misc/vmw_vmci/vmci_host.c:925
   vfs_ioctl fs/ioctl.c:51
  ...

  Uninit was stored to memory at:
   kmemdup+0x74/0xb0 mm/util.c:131
   dg_dispatch_as_host drivers/misc/vmw_vmci/vmci_datagram.c:271
   vmci_datagram_dispatch+0x4f8/0xfc0 drivers/misc/vmw_vmci/vmci_datagram.c:339
   qp_notify_peer+0x19a/0x290 drivers/misc/vmw_vmci/vmci_queue_pair.c:1479
   qp_broker_attach drivers/misc/vmw_vmci/vmci_queue_pair.c:1662
   qp_broker_alloc+0x2977/0x2f30 drivers/misc/vmw_vmci/vmci_queue_pair.c:1750
   vmci_qp_broker_alloc+0x96/0xd0 drivers/misc/vmw_vmci/vmci_queue_pair.c:1940
   vmci_host_do_alloc_queuepair drivers/misc/vmw_vmci/vmci_host.c:488
   vmci_host_unlocked_ioctl+0x24fd/0x43d0 drivers/misc/vmw_vmci/vmci_host.c:927
  ...

  Local variable ev created at:
   qp_notify_peer+0x54/0x290 drivers/misc/vmw_vmci/vmci_queue_pair.c:1456
   qp_broker_attach drivers/misc/vmw_vmci/vmci_queue_pair.c:1662
   qp_broker_alloc+0x2977/0x2f30 drivers/misc/vmw_vmci/vmci_queue_pair.c:1750

  Bytes 28-31 of 48 are uninitialized
  Memory access of size 48 starts at ffff888035155e00
  Data copied to user address 0000000020000100

Use memset() to prevent the infoleaks.

Also speculatively fix qp_notify_peer_local(), which may suffer from the
same problem.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5a275528025ae4bc7e2232866856dfebf84b2fad
  - https://git.kernel.org/stable/c/62634b43d3c4e1bf62fd540196f7081bf0885c0a
  - https://git.kernel.org/stable/c/76c50d77b928a33e5290aaa9fdc10e88254ff8c7
  - https://git.kernel.org/stable/c/7ccf7229b96fadc3a185d1391f814a604c7ef609
  - https://git.kernel.org/stable/c/8e2f33c598370bcf828bab4d667d1d38bcd3c57d
  - https://git.kernel.org/stable/c/e5b0d06d9b10f5f43101bd6598b076c347f9295f
  - https://git.kernel.org/stable/c/e7061dd1fef2dfb6458cd521aef27aa66f510d31
  - https://git.kernel.org/stable/c/f04586c2315cfd03d72ad0395705435e7ed07b1a

------------------------------------------------------------

CVE ID: CVE-2022-49789
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: zfcp: Fix double free of FSF request when qdio send fails

We used to use the wrong type of integer in 'zfcp_fsf_req_send()' to cache
the FSF request ID when sending a new FSF request. This is used in case the
sending fails and we need to remove the request from our internal hash
table again (so we don't keep an invalid reference and use it when we free
the request again).

In 'zfcp_fsf_req_send()' we used to cache the ID as 'int' (signed and 32
bit wide), but the rest of the zfcp code (and the firmware specification)
handles the ID as 'unsigned long'/'u64' (unsigned and 64 bit wide [s390x
ELF ABI]).  For one this has the obvious problem that when the ID grows
past 32 bit (this can happen reasonably fast) it is truncated to 32 bit
when storing it in the cache variable and so doesn't match the original ID
anymore.  The second less obvious problem is that even when the original ID
has not yet grown past 32 bit, as soon as the 32nd bit is set in the
original ID (0x80000000 = 2'147'483'648) we will have a mismatch when we
cast it back to 'unsigned long'. As the cached variable is of a signed
type, the compiler will choose a sign-extending instruction to load the 32
bit variable into a 64 bit register (e.g.: 'lgf %r11,188(%r15)'). So once
we pass the cached variable into 'zfcp_reqlist_find_rm()' to remove the
request again all the leading zeros will be flipped to ones to extend the
sign and won't match the original ID anymore (this has been observed in
practice).

If we can't successfully remove the request from the hash table again after
'zfcp_qdio_send()' fails (this happens regularly when zfcp cannot notify
the adapter about new work because the adapter is already gone during
e.g. a ChpID toggle) we will end up with a double free.  We unconditionally
free the request in the calling function when 'zfcp_fsf_req_send()' fails,
but because the request is still in the hash table we end up with a stale
memory reference, and once the zfcp adapter is either reset during recovery
or shutdown we end up freeing the same memory twice.

The resulting stack traces vary depending on the kernel and have no direct
correlation to the place where the bug occurs. Here are three examples that
have been seen in practice:

  list_del corruption. next->prev should be 00000001b9d13800, but was 00000000dead4ead. (next=00000001bd131a00)
  ------------[ cut here ]------------
  kernel BUG at lib/list_debug.c:62!
  monitor event: 0040 ilc:2 [#1] PREEMPT SMP
  Modules linked in: ...
  CPU: 9 PID: 1617 Comm: zfcperp0.0.1740 Kdump: loaded
  Hardware name: ...
  Krnl PSW : 0704d00180000000 00000003cbeea1f8 (__list_del_entry_valid+0x98/0x140)
             R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 RI:0 EA:3
  Krnl GPRS: 00000000916d12f1 0000000080000000 000000000000006d 00000003cb665cd6
             0000000000000001 0000000000000000 0000000000000000 00000000d28d21e8
             00000000d3844000 00000380099efd28 00000001bd131a00 00000001b9d13800
             00000000d3290100 0000000000000000 00000003cbeea1f4 00000380099efc70
  Krnl Code: 00000003cbeea1e8: c020004f68a7        larl    %r2,00000003cc8d7336
             00000003cbeea1ee: c0e50027fd65        brasl   %r14,00000003cc3e9cb8
            #00000003cbeea1f4: af000000            mc      0,0
            >00000003cbeea1f8: c02000920440        larl    %r2,00000003cd12aa78
             00000003cbeea1fe: c0e500289c25        brasl   %r14,00000003cc3fda48
             00000003cbeea204: b9040043            lgr     %r4,%r3
             00000003cbeea208: b9040051            lgr     %r5,%r1
             00000003cbeea20c: b9040032            lgr     %r3,%r2
  Call Trace:
   [<00000003cbeea1f8>] __list_del_entry_valid+0x98/0x140
  ([<00000003cbeea1f4>] __list_del_entry_valid+0x94/0x140)
   [<000003ff7ff502fe>] zfcp_fsf_req_dismiss_all+0xde/0x150 [zfcp]
   [<000003ff7ff49cd0>] zfcp_erp_strategy_do_action+0x160/0x280 [zfcp]
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0954256e970ecf371b03a6c9af2cf91b9c4085ff
  - https://git.kernel.org/stable/c/11edbdee4399401f533adda9bffe94567aa08b96
  - https://git.kernel.org/stable/c/1bf8ed585501bb2dd0b5f67c824eab45adfbdccd
  - https://git.kernel.org/stable/c/90a49a6b015fa439cd62e45121390284c125a91f
  - https://git.kernel.org/stable/c/d2c7d8f58e9cde8ac8d1f75e9d66c2a813ffe0ab

------------------------------------------------------------

CVE ID: CVE-2022-49790
Description: In the Linux kernel, the following vulnerability has been resolved:

Input: iforce - invert valid length check when fetching device IDs

syzbot is reporting uninitialized value at iforce_init_device() [1], for
commit 6ac0aec6b0a6 ("Input: iforce - allow callers supply data buffer
when fetching device IDs") is checking that valid length is shorter than
bytes to read. Since iforce_get_id_packet() stores valid length when
returning 0, the caller needs to check that valid length is longer than or
equals to bytes to read.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/24cc679abbf31477d0cc6106ec83c2fbae6b3cdf
  - https://git.kernel.org/stable/c/5d53797ce7ce8fb1d95a5bebc5efa9418c4217a3
  - https://git.kernel.org/stable/c/6365569d62a75ddf53fb0c2936c16587a365984c
  - https://git.kernel.org/stable/c/b8ebf250997c5fb253582f42bfe98673801ebebd
  - https://git.kernel.org/stable/c/fdd57c20d4408cac3c3c535c120d244e083406c9

------------------------------------------------------------

CVE ID: CVE-2022-49791
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring: fix multishot accept request leaks

Having REQ_F_POLLED set doesn't guarantee that the request is
executed as a multishot from the polling path. Fortunately for us, if
the code thinks it's multishot issue when it's not, it can only ask to
skip completion so leaking the request. Use issue_flags to mark
multipoll issues.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e4626de856ef8f25ecd9c716e76d4f95ce95639
  - https://git.kernel.org/stable/c/91482864768a874c4290ef93b84a78f4f1dac51b

------------------------------------------------------------

CVE ID: CVE-2022-49792
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: adc: mp2629: fix potential array out of bound access

Add sentinel at end of maps to avoid potential array out of
bound access in iio core.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1678d4abb2dc2ca3b05b998a9d88616976e4f947
  - https://git.kernel.org/stable/c/399b2105a2240e730b9f3880bd8f154247539aa7
  - https://git.kernel.org/stable/c/ca1547ab15f48dc81624183ae17a2fd1bad06dfc
  - https://git.kernel.org/stable/c/d95b85c5084ad70011988861ee864529eefa1da0

------------------------------------------------------------

CVE ID: CVE-2022-49793
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: trigger: sysfs: fix possible memory leak in iio_sysfs_trig_init()

dev_set_name() allocates memory for name, it need be freed
when device_add() fails, call put_device() to give up the
reference that hold in device_initialize(), so that it can
be freed in kobject_cleanup() when the refcount hit to 0.

Fault injection test can trigger this:

unreferenced object 0xffff8e8340a7b4c0 (size 32):
  comm "modprobe", pid 243, jiffies 4294678145 (age 48.845s)
  hex dump (first 32 bytes):
    69 69 6f 5f 73 79 73 66 73 5f 74 72 69 67 67 65  iio_sysfs_trigge
    72 00 a7 40 83 8e ff ff 00 86 13 c4 f6 ee ff ff  r..@............
  backtrace:
    [<0000000074999de8>] __kmem_cache_alloc_node+0x1e9/0x360
    [<00000000497fd30b>] __kmalloc_node_track_caller+0x44/0x1a0
    [<000000003636c520>] kstrdup+0x2d/0x60
    [<0000000032f84da2>] kobject_set_name_vargs+0x1e/0x90
    [<0000000092efe493>] dev_set_name+0x4e/0x70
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0dd52e141afde089304de470148d311b05c14564
  - https://git.kernel.org/stable/c/2c4e65285bdea23fd36d2ff376006ac64db6f42e
  - https://git.kernel.org/stable/c/5a39382aa5411d64b25a71516c2c7480aab13bb7
  - https://git.kernel.org/stable/c/656f670613662b6cc77aad14112db2803ad18fa8
  - https://git.kernel.org/stable/c/8dddf2699da296c84205582aaead6b43dd7e8c4b
  - https://git.kernel.org/stable/c/b47bb521961f027b4dcf8683337a7a1ba9e5ea1f
  - https://git.kernel.org/stable/c/efa17e90e1711bdb084e3954fa44afb6647331c0
  - https://git.kernel.org/stable/c/f68c96821b61d2c71a35dbb8bf90c347fad624d9

------------------------------------------------------------

CVE ID: CVE-2022-49794
Description: In the Linux kernel, the following vulnerability has been resolved:

iio: adc: at91_adc: fix possible memory leak in at91_adc_allocate_trigger()

If iio_trigger_register() returns error, it should call iio_trigger_free()
to give up the reference that hold in iio_trigger_alloc(), so that it can
call iio_trig_release() to free memory when the refcount hit to 0.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1bf8c0aff8fb5c4edf3ba6728e6bedbd610d7f4b
  - https://git.kernel.org/stable/c/2b29a7f2d52fb5281b30cf61c947d88bab18a29b
  - https://git.kernel.org/stable/c/65f20301607d07ee279b0804d11a05a62a6c1a1c
  - https://git.kernel.org/stable/c/7b75515728b628a9a7540f201efdeb8ca7299385
  - https://git.kernel.org/stable/c/85d2a8b287a89853c0dcfc5a97b5e9d36376fe37
  - https://git.kernel.org/stable/c/a0d98ae5a62a7bbad8fcf9fa22e0a1274197bbc4
  - https://git.kernel.org/stable/c/c27a3b6ba23350708cf5ab9962337447b51eb76d
  - https://git.kernel.org/stable/c/c3ce73f60599a483dca7becd4112508833a40ef9

------------------------------------------------------------

CVE ID: CVE-2022-49795
Description: In the Linux kernel, the following vulnerability has been resolved:

rethook: fix a potential memleak in rethook_alloc()

In rethook_alloc(), the variable rh is not freed or passed out
if handler is NULL, which could lead to a memleak, fix it.

[Masami: Add "rethook:" tag to the title.]

Acke-by: Masami Hiramatsu (Google) <mhiramat@kernel.org>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a1ebe35cb3b7aa1f4b26b37e2a0b9ae68dc4ffb
  - https://git.kernel.org/stable/c/cbc5d1f9a8cc40ba2bc6779b36d2ea1f65bc027c

------------------------------------------------------------

CVE ID: CVE-2022-49796
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: kprobe: Fix potential null-ptr-deref on trace_array in kprobe_event_gen_test_exit()

When test_gen_kprobe_cmd() failed after kprobe_event_gen_cmd_end(), it
will goto delete, which will call kprobe_event_delete() and release the
corresponding resource. However, the trace_array in gen_kretprobe_test
will point to the invalid resource. Set gen_kretprobe_test to NULL
after called kprobe_event_delete() to prevent null-ptr-deref.

BUG: kernel NULL pointer dereference, address: 0000000000000070
PGD 0 P4D 0
Oops: 0000 [#1] SMP PTI
CPU: 0 PID: 246 Comm: modprobe Tainted: G        W
6.1.0-rc1-00174-g9522dc5c87da-dirty #248
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.15.0-0-g2dd4b9b3f840-prebuilt.qemu.org 04/01/2014
RIP: 0010:__ftrace_set_clr_event_nolock+0x53/0x1b0
Code: e8 82 26 fc ff 49 8b 1e c7 44 24 0c ea ff ff ff 49 39 de 0f 84 3c
01 00 00 c7 44 24 18 00 00 00 00 e8 61 26 fc ff 48 8b 6b 10 <44> 8b 65
70 4c 8b 6d 18 41 f7 c4 00 02 00 00 75 2f
RSP: 0018:ffffc9000159fe00 EFLAGS: 00010293
RAX: 0000000000000000 RBX: ffff88810971d268 RCX: 0000000000000000
RDX: ffff8881080be600 RSI: ffffffff811b48ff RDI: ffff88810971d058
RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000001
R10: ffffc9000159fe58 R11: 0000000000000001 R12: ffffffffa0001064
R13: ffffffffa000106c R14: ffff88810971d238 R15: 0000000000000000
FS:  00007f89eeff6540(0000) GS:ffff88813b600000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000070 CR3: 000000010599e004 CR4: 0000000000330ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 __ftrace_set_clr_event+0x3e/0x60
 trace_array_set_clr_event+0x35/0x50
 ? 0xffffffffa0000000
 kprobe_event_gen_test_exit+0xcd/0x10b [kprobe_event_gen_test]
 __x64_sys_delete_module+0x206/0x380
 ? lockdep_hardirqs_on_prepare+0xd8/0x190
 ? syscall_enter_from_user_mode+0x1c/0x50
 do_syscall_64+0x3f/0x90
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7f89eeb061b7
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/22ea4ca9631eb137e64e5ab899e9c89cb6670959
  - https://git.kernel.org/stable/c/28a54854a95923b6266a9479ad660ca2cc0e1d5f
  - https://git.kernel.org/stable/c/510c12f93674ea0a1423b24f36c67357168a262a
  - https://git.kernel.org/stable/c/e57daa750369fedbf678346aec724a43b9a51749

------------------------------------------------------------

CVE ID: CVE-2022-49797
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: kprobe: Fix potential null-ptr-deref on trace_event_file in kprobe_event_gen_test_exit()

When trace_get_event_file() failed, gen_kretprobe_test will be assigned
as the error code. If module kprobe_event_gen_test is removed now, the
null pointer dereference will happen in kprobe_event_gen_test_exit().
Check if gen_kprobe_test or gen_kretprobe_test is error code or NULL
before dereference them.

BUG: kernel NULL pointer dereference, address: 0000000000000012
PGD 0 P4D 0
Oops: 0000 [#1] SMP PTI
CPU: 3 PID: 2210 Comm: modprobe Not tainted
6.1.0-rc1-00171-g2159299a3b74-dirty #217
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.15.0-0-g2dd4b9b3f840-prebuilt.qemu.org 04/01/2014
RIP: 0010:kprobe_event_gen_test_exit+0x1c/0xb5 [kprobe_event_gen_test]
Code: Unable to access opcode bytes at 0xffffffff9ffffff2.
RSP: 0018:ffffc900015bfeb8 EFLAGS: 00010246
RAX: ffffffffffffffea RBX: ffffffffa0002080 RCX: 0000000000000000
RDX: ffffffffa0001054 RSI: ffffffffa0001064 RDI: ffffffffdfc6349c
RBP: ffffffffa0000000 R08: 0000000000000004 R09: 00000000001e95c0
R10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000800
R13: ffffffffa0002420 R14: 0000000000000000 R15: 0000000000000000
FS:  00007f56b75be540(0000) GS:ffff88813bc00000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: ffffffff9ffffff2 CR3: 000000010874a006 CR4: 0000000000330ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 __x64_sys_delete_module+0x206/0x380
 ? lockdep_hardirqs_on_prepare+0xd8/0x190
 ? syscall_enter_from_user_mode+0x1c/0x50
 do_syscall_64+0x3f/0x90
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a41c0f2a5c3bf72b4c4e9dd4b1025378201e332
  - https://git.kernel.org/stable/c/bb70fcae4115d24b7e8cee17a6da8b1943f546bb
  - https://git.kernel.org/stable/c/e0d75267f59d7084e0468bd68beeb1bf9c71d7c0
  - https://git.kernel.org/stable/c/fd0efd4f7bfe611a8339ba01bc2ac3c33e79159d

------------------------------------------------------------

CVE ID: CVE-2022-49798
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix race where eprobes can be called before the event

The flag that tells the event to call its triggers after reading the event
is set for eprobes after the eprobe is enabled. This leads to a race where
the eprobe may be triggered at the beginning of the event where the record
information is NULL. The eprobe then dereferences the NULL record causing
a NULL kernel pointer bug.

Test for a NULL record to keep this from happening.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7291dec4f2d17a2d3fd1f789fb41e58476539f21
  - https://git.kernel.org/stable/c/73f5191467ffe3af82f27fe0ea6a8c2fac724d3f
  - https://git.kernel.org/stable/c/94eedf3dded5fb472ce97bfaf3ac1c6c29c35d26

------------------------------------------------------------

CVE ID: CVE-2022-49799
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix wild-memory-access in register_synth_event()

In register_synth_event(), if set_synth_event_print_fmt() failed, then
both trace_remove_event_call() and unregister_trace_event() will be
called, which means the trace_event_call will call
__unregister_trace_event() twice. As the result, the second unregister
will causes the wild-memory-access.

register_synth_event
    set_synth_event_print_fmt failed
    trace_remove_event_call
        event_remove
            if call->event.funcs then
            __unregister_trace_event (first call)
    unregister_trace_event
        __unregister_trace_event (second call)

Fix the bug by avoiding to call the second __unregister_trace_event() by
checking if the first one is called.

general protection fault, probably for non-canonical address
	0xfbd59c0000000024: 0000 [#1] SMP KASAN PTI
KASAN: maybe wild-memory-access in range
[0xdead000000000120-0xdead000000000127]
CPU: 0 PID: 3807 Comm: modprobe Not tainted
6.1.0-rc1-00186-g76f33a7eedb4 #299
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.15.0-0-g2dd4b9b3f840-prebuilt.qemu.org 04/01/2014
RIP: 0010:unregister_trace_event+0x6e/0x280
Code: 00 fc ff df 4c 89 ea 48 c1 ea 03 80 3c 02 00 0f 85 0e 02 00 00 48
b8 00 00 00 00 00 fc ff df 4c 8b 63 08 4c 89 e2 48 c1 ea 03 <80> 3c 02
00 0f 85 e2 01 00 00 49 89 2c 24 48 85 ed 74 28 e8 7a 9b
RSP: 0018:ffff88810413f370 EFLAGS: 00010a06
RAX: dffffc0000000000 RBX: ffff888105d050b0 RCX: 0000000000000000
RDX: 1bd5a00000000024 RSI: ffff888119e276e0 RDI: ffffffff835a8b20
RBP: dead000000000100 R08: 0000000000000000 R09: fffffbfff0913481
R10: ffffffff8489a407 R11: fffffbfff0913480 R12: dead000000000122
R13: ffff888105d050b8 R14: 0000000000000000 R15: ffff888105d05028
FS:  00007f7823e8d540(0000) GS:ffff888119e00000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f7823e7ebec CR3: 000000010a058002 CR4: 0000000000330ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 __create_synth_event+0x1e37/0x1eb0
 create_or_delete_synth_event+0x110/0x250
 synth_event_run_command+0x2f/0x110
 test_gen_synth_cmd+0x170/0x2eb [synth_event_gen_test]
 synth_event_gen_test_init+0x76/0x9bc [synth_event_gen_test]
 do_one_initcall+0xdb/0x480
 do_init_module+0x1cf/0x680
 load_module+0x6a50/0x70a0
 __do_sys_finit_module+0x12f/0x1c0
 do_syscall_64+0x3f/0x90
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b5f1c34d3f5a664a57a5a7557a50e4e3cc2505c
  - https://git.kernel.org/stable/c/315b149f08229a233d47532eb5da1707b28f764c
  - https://git.kernel.org/stable/c/6517b97134f724d12f673f9fb4f456d75c7a905f
  - https://git.kernel.org/stable/c/a5bfa53e5036b3e7a80be902dd3719a930accabd

------------------------------------------------------------

CVE ID: CVE-2022-49800
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix memory leak in test_gen_synth_cmd() and test_empty_synth_event()

test_gen_synth_cmd() only free buf in fail path, hence buf will leak
when there is no failure. Add kfree(buf) to prevent the memleak. The
same reason and solution in test_empty_synth_event().

unreferenced object 0xffff8881127de000 (size 2048):
  comm "modprobe", pid 247, jiffies 4294972316 (age 78.756s)
  hex dump (first 32 bytes):
    20 67 65 6e 5f 73 79 6e 74 68 5f 74 65 73 74 20   gen_synth_test
    20 70 69 64 5f 74 20 6e 65 78 74 5f 70 69 64 5f   pid_t next_pid_
  backtrace:
    [<000000004254801a>] kmalloc_trace+0x26/0x100
    [<0000000039eb1cf5>] 0xffffffffa00083cd
    [<000000000e8c3bc8>] 0xffffffffa00086ba
    [<00000000c293d1ea>] do_one_initcall+0xdb/0x480
    [<00000000aa189e6d>] do_init_module+0x1cf/0x680
    [<00000000d513222b>] load_module+0x6a50/0x70a0
    [<000000001fd4d529>] __do_sys_finit_module+0x12f/0x1c0
    [<00000000b36c4c0f>] do_syscall_64+0x3f/0x90
    [<00000000bbf20cf3>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
unreferenced object 0xffff8881127df000 (size 2048):
  comm "modprobe", pid 247, jiffies 4294972324 (age 78.728s)
  hex dump (first 32 bytes):
    20 65 6d 70 74 79 5f 73 79 6e 74 68 5f 74 65 73   empty_synth_tes
    74 20 20 70 69 64 5f 74 20 6e 65 78 74 5f 70 69  t  pid_t next_pi
  backtrace:
    [<000000004254801a>] kmalloc_trace+0x26/0x100
    [<00000000d4db9a3d>] 0xffffffffa0008071
    [<00000000c31354a5>] 0xffffffffa00086ce
    [<00000000c293d1ea>] do_one_initcall+0xdb/0x480
    [<00000000aa189e6d>] do_init_module+0x1cf/0x680
    [<00000000d513222b>] load_module+0x6a50/0x70a0
    [<000000001fd4d529>] __do_sys_finit_module+0x12f/0x1c0
    [<00000000b36c4c0f>] do_syscall_64+0x3f/0x90
    [<00000000bbf20cf3>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/07ba4f0603aba288580866394f2916dfe55823a2
  - https://git.kernel.org/stable/c/0e5baaa181a052d968701bb9c5b1d55847f00942
  - https://git.kernel.org/stable/c/65ba7e7c241122ef0a9e61d1920f2ae9689aa796
  - https://git.kernel.org/stable/c/a4527fef9afe5c903c718d0cd24609fe9c754250

------------------------------------------------------------

CVE ID: CVE-2022-49801
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Fix memory leak in tracing_read_pipe()

kmemleak reports this issue:

unreferenced object 0xffff888105a18900 (size 128):
  comm "test_progs", pid 18933, jiffies 4336275356 (age 22801.766s)
  hex dump (first 32 bytes):
    25 73 00 90 81 88 ff ff 26 05 00 00 42 01 58 04  %s......&...B.X.
    03 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<00000000560143a1>] __kmalloc_node_track_caller+0x4a/0x140
    [<000000006af00822>] krealloc+0x8d/0xf0
    [<00000000c309be6a>] trace_iter_expand_format+0x99/0x150
    [<000000005a53bdb6>] trace_check_vprintf+0x1e0/0x11d0
    [<0000000065629d9d>] trace_event_printf+0xb6/0xf0
    [<000000009a690dc7>] trace_raw_output_bpf_trace_printk+0x89/0xc0
    [<00000000d22db172>] print_trace_line+0x73c/0x1480
    [<00000000cdba76ba>] tracing_read_pipe+0x45c/0x9f0
    [<0000000015b58459>] vfs_read+0x17b/0x7c0
    [<000000004aeee8ed>] ksys_read+0xed/0x1c0
    [<0000000063d3d898>] do_syscall_64+0x3b/0x90
    [<00000000a06dda7f>] entry_SYSCALL_64_after_hwframe+0x63/0xcd

iter->fmt alloced in
  tracing_read_pipe() -> .. ->trace_iter_expand_format(), but not
freed, to fix, add free in tracing_release_pipe()
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2c21ee020ce43d744ecd7f3e9bddfcaafef270ce
  - https://git.kernel.org/stable/c/649e72070cbbb8600eb823833e4748f5a0815116
  - https://git.kernel.org/stable/c/a7d3f8f33c113478737bc61bb32ec5f9a987da7d

------------------------------------------------------------

CVE ID: CVE-2022-49802
Description: In the Linux kernel, the following vulnerability has been resolved:

ftrace: Fix null pointer dereference in ftrace_add_mod()

The @ftrace_mod is allocated by kzalloc(), so both the members {prev,next}
of @ftrace_mode->list are NULL, it's not a valid state to call list_del().
If kstrdup() for @ftrace_mod->{func|module} fails, it goes to @out_free
tag and calls free_ftrace_mod() to destroy @ftrace_mod, then list_del()
will write prev->next and next->prev, where null pointer dereference
happens.

BUG: kernel NULL pointer dereference, address: 0000000000000008
Oops: 0002 [#1] PREEMPT SMP NOPTI
Call Trace:
 <TASK>
 ftrace_mod_callback+0x20d/0x220
 ? do_filp_open+0xd9/0x140
 ftrace_process_regex.isra.51+0xbf/0x130
 ftrace_regex_write.isra.52.part.53+0x6e/0x90
 vfs_write+0xee/0x3a0
 ? __audit_filter_op+0xb1/0x100
 ? auditd_test_task+0x38/0x50
 ksys_write+0xa5/0xe0
 do_syscall_64+0x3a/0x90
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
Kernel panic - not syncing: Fatal exception

So call INIT_LIST_HEAD() to initialize the list member to fix this issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/19ba6c8af9382c4c05dc6a0a79af3013b9a35cd0
  - https://git.kernel.org/stable/c/1bea037a1abb23a6729bef36a2265a4565f5ea77
  - https://git.kernel.org/stable/c/665b4c6648bf2b91f69b33817f4321cf4c3cafe9
  - https://git.kernel.org/stable/c/6a14828caddad0d989495a72af678adf60992704
  - https://git.kernel.org/stable/c/6e50eb4b1807017f6c2d5089064256ce2de8aef1
  - https://git.kernel.org/stable/c/b5bfc61f541d3f092b13dedcfe000d86eb8e133c
  - https://git.kernel.org/stable/c/f715f31559b82e3f75ce047fa476de63d8107584

------------------------------------------------------------

CVE ID: CVE-2022-49803
Description: In the Linux kernel, the following vulnerability has been resolved:

netdevsim: Fix memory leak of nsim_dev->fa_cookie

kmemleak reports this issue:

unreferenced object 0xffff8881bac872d0 (size 8):
  comm "sh", pid 58603, jiffies 4481524462 (age 68.065s)
  hex dump (first 8 bytes):
    04 00 00 00 de ad be ef                          ........
  backtrace:
    [<00000000c80b8577>] __kmalloc+0x49/0x150
    [<000000005292b8c6>] nsim_dev_trap_fa_cookie_write+0xc1/0x210 [netdevsim]
    [<0000000093d78e77>] full_proxy_write+0xf3/0x180
    [<000000005a662c16>] vfs_write+0x1c5/0xaf0
    [<000000007aabf84a>] ksys_write+0xed/0x1c0
    [<000000005f1d2e47>] do_syscall_64+0x3b/0x90
    [<000000006001c6ec>] entry_SYSCALL_64_after_hwframe+0x63/0xcd

The issue occurs in the following scenarios:

nsim_dev_trap_fa_cookie_write()
  kmalloc() fa_cookie
  nsim_dev->fa_cookie = fa_cookie
..
nsim_drv_remove()

The fa_cookie allocked in nsim_dev_trap_fa_cookie_write() is not freed. To
fix, add kfree(nsim_dev->fa_cookie) to nsim_drv_remove().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/064bc7312bd09a48798418663090be0c776183db
  - https://git.kernel.org/stable/c/207edad5717e0a5709ce8467f0eff41c607835c9

------------------------------------------------------------

CVE ID: CVE-2022-49804
Description: In the Linux kernel, the following vulnerability has been resolved:

s390: avoid using global register for current_stack_pointer

Commit 30de14b1884b ("s390: current_stack_pointer shouldn't be a
function") made current_stack_pointer a global register variable like
on many other architectures. Unfortunately on s390 it uncovers old
gcc bug which is fixed only since gcc-9.1 [gcc commit 3ad7fed1cc87
("S/390: Fix PR89775. Stackpointer save/restore instructions removed")]
and backported to gcc-8.4 and later. Due to this bug gcc versions prior
to 8.4 generate broken code which leads to stack corruptions.

Current minimal gcc version required to build the kernel is declared
as 5.1. It is not possible to fix all old gcc versions, so work
around this problem by avoiding using global register variable for
current_stack_pointer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/a478952a8ac44e32316dc046a063a7dc34825aa6
  - https://git.kernel.org/stable/c/e3c11025bcd2142a61abe5806b2f86a0e78118df

------------------------------------------------------------

CVE ID: CVE-2022-49805
Description: In the Linux kernel, the following vulnerability has been resolved:

net: lan966x: Fix potential null-ptr-deref in lan966x_stats_init()

lan966x_stats_init() calls create_singlethread_workqueue() and not
checked the ret value, which may return NULL. And a null-ptr-deref may
happen:

lan966x_stats_init()
    create_singlethread_workqueue() # failed, lan966x->stats_queue is NULL
    queue_delayed_work()
        queue_delayed_work_on()
            __queue_delayed_work()  # warning here, but continue
                __queue_work()      # access wq->flags, null-ptr-deref

Check the ret value and return -ENOMEM if it is NULL.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4a43c1c6040e848e1344c7b16ac696b68fbc439c
  - https://git.kernel.org/stable/c/ba86af3733aece88dbcee0dfebf7e2dcfefb2be4

------------------------------------------------------------

CVE ID: CVE-2022-49806
Description: In the Linux kernel, the following vulnerability has been resolved:

net: microchip: sparx5: Fix potential null-ptr-deref in sparx_stats_init() and sparx5_start()

sparx_stats_init() calls create_singlethread_workqueue() and not
checked the ret value, which may return NULL. And a null-ptr-deref may
happen:

sparx_stats_init()
    create_singlethread_workqueue() # failed, sparx5->stats_queue is NULL
    queue_delayed_work()
        queue_delayed_work_on()
            __queue_delayed_work()  # warning here, but continue
                __queue_work()      # access wq->flags, null-ptr-deref

Check the ret value and return -ENOMEM if it is NULL. So as
sparx5_start().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/456327e565dc49d18b2f595f39f47df8a36f1057
  - https://git.kernel.org/stable/c/639f5d006e36bb303f525d9479448c412b720c39
  - https://git.kernel.org/stable/c/80e590aeb132887102c3fa79d99b338f099dc952

------------------------------------------------------------

CVE ID: CVE-2022-49807
Description: In the Linux kernel, the following vulnerability has been resolved:

nvmet: fix a memory leak in nvmet_auth_set_key

When changing dhchap secrets we need to release the old
secrets as well.

kmemleak complaint:
--
unreferenced object 0xffff8c7f44ed8180 (size 64):
  comm "check", pid 7304, jiffies 4295686133 (age 72034.246s)
  hex dump (first 32 bytes):
    44 48 48 43 2d 31 3a 30 30 3a 4c 64 4c 4f 64 71  DHHC-1:00:LdLOdq
    79 56 69 67 77 48 55 32 6d 5a 59 4c 7a 35 59 38  yVigwHU2mZYLz5Y8
  backtrace:
    [<00000000b6fc5071>] kstrdup+0x2e/0x60
    [<00000000f0f4633f>] 0xffffffffc0e07ee6
    [<0000000053006c05>] 0xffffffffc0dff783
    [<00000000419ae922>] configfs_write_iter+0xb1/0x120
    [<000000008183c424>] vfs_write+0x2be/0x3c0
    [<000000009005a2a5>] ksys_write+0x5f/0xe0
    [<00000000cd495c89>] do_syscall_64+0x38/0x90
    [<00000000f2a84ac5>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a52566279b4ee65ecd2503d7b7342851f84755c
  - https://git.kernel.org/stable/c/65710ea51d4a185592c7b14c9e33d0c4a364f074

------------------------------------------------------------

CVE ID: CVE-2022-49808
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: don't leak tagger-owned storage on switch driver unbind

In the initial commit dc452a471dba ("net: dsa: introduce tagger-owned
storage for private and shared data"), we had a call to
tag_ops->disconnect(dst) issued from dsa_tree_free(), which is called at
tree teardown time.

There were problems with connecting to a switch tree as a whole, so this
got reworked to connecting to individual switches within the tree. In
this process, tag_ops->disconnect(ds) was made to be called only from
switch.c (cross-chip notifiers emitted as a result of dynamic tag proto
changes), but the normal driver teardown code path wasn't replaced with
anything.

Solve this problem by adding a function that does the opposite of
dsa_switch_setup_tag_protocol(), which is called from the equivalent
spot in dsa_switch_teardown(). The positioning here also ensures that we
won't have any use-after-free in tagging protocol (*rcv) ops, since the
teardown sequence is as follows:

dsa_tree_teardown
-> dsa_tree_teardown_master
   -> dsa_master_teardown
      -> unsets master->dsa_ptr, making no further packets match the
         ETH_P_XDSA packet type handler
-> dsa_tree_teardown_ports
   -> dsa_port_teardown
      -> dsa_slave_destroy
         -> unregisters DSA net devices, there is even a synchronize_net()
            in unregister_netdevice_many()
-> dsa_tree_teardown_switches
   -> dsa_switch_teardown
      -> dsa_switch_teardown_tag_protocol
         -> finally frees the tagger-owned storage
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4e0c19fcb8b5323716140fa82b79aa9f60e60407
  - https://git.kernel.org/stable/c/5809fb03942dbac25144db5bebea84fa003ecaca

------------------------------------------------------------

CVE ID: CVE-2022-49809
Description: In the Linux kernel, the following vulnerability has been resolved:

net/x25: Fix skb leak in x25_lapb_receive_frame()

x25_lapb_receive_frame() using skb_copy() to get a private copy of
skb, the new skb should be freed in the undersized/fragmented skb
error handling path. Otherwise there is a memory leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0ef17d966445358a55c5f4ccf2c73cca3e39192b
  - https://git.kernel.org/stable/c/2929cceb2fcf0ded7182562e4888afafece82cce
  - https://git.kernel.org/stable/c/2d675be16a461310d738d93f9f1a00da62055c5a
  - https://git.kernel.org/stable/c/9f00da9c866d506998bf0a3f699ec900730472da
  - https://git.kernel.org/stable/c/c8baf1fc248b2e88642f094fea9509a9bf98c5bb
  - https://git.kernel.org/stable/c/dfcfbe4f2e4b2c81cff4e79b48502d97fda73118
  - https://git.kernel.org/stable/c/e109b41870db995cae25dfaf0cc3922f9028b1a1
  - https://git.kernel.org/stable/c/fda0ba7c84b46d10947c687320804b9de149a921

------------------------------------------------------------

CVE ID: CVE-2022-49810
Description: In the Linux kernel, the following vulnerability has been resolved:

netfs: Fix missing xas_retry() calls in xarray iteration

netfslib has a number of places in which it performs iteration of an xarray
whilst being under the RCU read lock.  It *should* call xas_retry() as the
first thing inside of the loop and do "continue" if it returns true in case
the xarray walker passed out a special value indicating that the walk needs
to be redone from the root[*].

Fix this by adding the missing retry checks.

[*] I wonder if this should be done inside xas_find(), xas_next_node() and
    suchlike, but I'm told that's not an simple change to effect.

This can cause an oops like that below.  Note the faulting address - this
is an internal value (|0x2) returned from xarray.

BUG: kernel NULL pointer dereference, address: 0000000000000402
...
RIP: 0010:netfs_rreq_unlock+0xef/0x380 [netfs]
...
Call Trace:
 netfs_rreq_assess+0xa6/0x240 [netfs]
 netfs_readpage+0x173/0x3b0 [netfs]
 ? init_wait_var_entry+0x50/0x50
 filemap_read_page+0x33/0xf0
 filemap_get_pages+0x2f2/0x3f0
 filemap_read+0xaa/0x320
 ? do_filp_open+0xb2/0x150
 ? rmqueue+0x3be/0xe10
 ceph_read_iter+0x1fe/0x680 [ceph]
 ? new_sync_read+0x115/0x1a0
 new_sync_read+0x115/0x1a0
 vfs_read+0xf3/0x180
 ksys_read+0x5f/0xe0
 do_syscall_64+0x38/0x90
 entry_SYSCALL_64_after_hwframe+0x44/0xae

Changes:
========
ver #2)
 - Changed an unsigned int to a size_t to reduce the likelihood of an
   overflow as per Willy's suggestion.
 - Added an additional patch to fix the maths.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7e043a80b5dae5c2d2cf84031501de7827fd6c00
  - https://git.kernel.org/stable/c/b2cc07a76f1eb12de3b22caf5fdbf856a7bef16d

------------------------------------------------------------

CVE ID: CVE-2022-49811
Description: In the Linux kernel, the following vulnerability has been resolved:

drbd: use after free in drbd_create_device()

The drbd_destroy_connection() frees the "connection" so use the _safe()
iterator to prevent a use after free.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7d93417d596402ddd46bd76c721f205d09d0d025
  - https://git.kernel.org/stable/c/813a8dd9c45fd46f5cbbfbedf0791afa7740ccf5
  - https://git.kernel.org/stable/c/9ed51414aef6e59e832e2960f10766dce2d5b1a1
  - https://git.kernel.org/stable/c/a7a1598189228b5007369a9622ccdf587be0730f
  - https://git.kernel.org/stable/c/bf47ca1b35fc1f55091ffaff5fbe41ea0c6f59a1
  - https://git.kernel.org/stable/c/c2a00b149836d60c222930bbea6b2139caf34d4f
  - https://git.kernel.org/stable/c/fc1897f16ebcfd22364f2afcc27f53a740f3bc7a

------------------------------------------------------------

CVE ID: CVE-2022-49812
Description: In the Linux kernel, the following vulnerability has been resolved:

bridge: switchdev: Fix memory leaks when changing VLAN protocol

The bridge driver can offload VLANs to the underlying hardware either
via switchdev or the 8021q driver. When the former is used, the VLAN is
marked in the bridge driver with the 'BR_VLFLAG_ADDED_BY_SWITCHDEV'
private flag.

To avoid the memory leaks mentioned in the cited commit, the bridge
driver will try to delete a VLAN via the 8021q driver if the VLAN is not
marked with the previously mentioned flag.

When the VLAN protocol of the bridge changes, switchdev drivers are
notified via the 'SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL' attribute, but
the 8021q driver is also called to add the existing VLANs with the new
protocol and delete them with the old protocol.

In case the VLANs were offloaded via switchdev, the above behavior is
both redundant and buggy. Redundant because the VLANs are already
programmed in hardware and drivers that support VLAN protocol change
(currently only mlx5) change the protocol upon the switchdev attribute
notification. Buggy because the 8021q driver is called despite these
VLANs being marked with 'BR_VLFLAG_ADDED_BY_SWITCHDEV'. This leads to
memory leaks [1] when the VLANs are deleted.

Fix by not calling the 8021q driver for VLANs that were already
programmed via switchdev.

[1]
unreferenced object 0xffff8881f6771200 (size 256):
  comm "ip", pid 446855, jiffies 4298238841 (age 55.240s)
  hex dump (first 32 bytes):
    00 00 7f 0e 83 88 ff ff 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<00000000012819ac>] vlan_vid_add+0x437/0x750
    [<00000000f2281fad>] __br_vlan_set_proto+0x289/0x920
    [<000000000632b56f>] br_changelink+0x3d6/0x13f0
    [<0000000089d25f04>] __rtnl_newlink+0x8ae/0x14c0
    [<00000000f6276baf>] rtnl_newlink+0x5f/0x90
    [<00000000746dc902>] rtnetlink_rcv_msg+0x336/0xa00
    [<000000001c2241c0>] netlink_rcv_skb+0x11d/0x340
    [<0000000010588814>] netlink_unicast+0x438/0x710
    [<00000000e1a4cd5c>] netlink_sendmsg+0x788/0xc40
    [<00000000e8992d4e>] sock_sendmsg+0xb0/0xe0
    [<00000000621b8f91>] ____sys_sendmsg+0x4ff/0x6d0
    [<000000000ea26996>] ___sys_sendmsg+0x12e/0x1b0
    [<00000000684f7e25>] __sys_sendmsg+0xab/0x130
    [<000000004538b104>] do_syscall_64+0x3d/0x90
    [<0000000091ed9678>] entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/347f1793b573466424c550f2748ed837b6690fe7
  - https://git.kernel.org/stable/c/9d45921ee4cb364910097e7d1b7558559c2f9fd2
  - https://git.kernel.org/stable/c/f8926e2d2225eb7b7e11cd3fa266aaad9075b767
  - https://git.kernel.org/stable/c/fc16a2c81a3eb1cbba8775f5bdc67856df903a7c

------------------------------------------------------------

CVE ID: CVE-2022-49813
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ena: Fix error handling in ena_init()

The ena_init() won't destroy workqueue created by
create_singlethread_workqueue() when pci_register_driver() failed.
Call destroy_workqueue() when pci_register_driver() failed to prevent the
resource leak.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e2369223b174d198ec42a3ec0a7f06c8727b968
  - https://git.kernel.org/stable/c/3f7b2ef8fe924e299bc339811ea3f1b9935c040f
  - https://git.kernel.org/stable/c/6b23a4b252044e4fd23438930d452244818d7000
  - https://git.kernel.org/stable/c/d349e9be5a2c2d7588a2c4e4bfa0bb3dc1226769

------------------------------------------------------------

CVE ID: CVE-2022-49814
Description: In the Linux kernel, the following vulnerability has been resolved:

kcm: close race conditions on sk_receive_queue

sk->sk_receive_queue is protected by skb queue lock, but for KCM
sockets its RX path takes mux->rx_lock to protect more than just
skb queue. However, kcm_recvmsg() still only grabs the skb queue
lock, so race conditions still exist.

We can teach kcm_recvmsg() to grab mux->rx_lock too but this would
introduce a potential performance regression as struct kcm_mux can
be shared by multiple KCM sockets.

So we have to enforce skb queue lock in requeue_rx_msgs() and handle
skb peek case carefully in kcm_wait_data(). Fortunately,
skb_recv_datagram() already handles it nicely and is widely used by
other sockets, we can just switch to skb_recv_datagram() after
getting rid of the unnecessary sock lock in kcm_recvmsg() and
kcm_splice_read(). Side note: SOCK_DONE is not used by KCM sockets,
so it is safe to get rid of this check too.

I ran the original syzbot reproducer for 30 min without seeing any
issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/22f6b5d47396b4287662668ee3f5c1f766cb4259
  - https://git.kernel.org/stable/c/4154b6afa2bd639214ff259d912faad984f7413a
  - https://git.kernel.org/stable/c/5121197ecc5db58c07da95eb1ff82b98b121a221
  - https://git.kernel.org/stable/c/bf92e54597d842da127c59833b365d6faeeaf020
  - https://git.kernel.org/stable/c/ce57d6474ae999a3b2d442314087473a646a65c7
  - https://git.kernel.org/stable/c/d9ad4de92e184b19bcae4da10dac0275abf83931
  - https://git.kernel.org/stable/c/f7b0e95071bb4be4b811af3f0bfc3e200eedeaa3

------------------------------------------------------------

CVE ID: CVE-2022-49815
Description: In the Linux kernel, the following vulnerability has been resolved:

erofs: fix missing xas_retry() in fscache mode

The xarray iteration only holds the RCU read lock and thus may encounter
XA_RETRY_ENTRY if there's process modifying the xarray concurrently.
This will cause oops when referring to the invalid entry.

Fix this by adding the missing xas_retry(), which will make the
iteration wind back to the root node if XA_RETRY_ENTRY is encountered.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/37020bbb71d911431e16c2c940b97cf86ae4f2f6
  - https://git.kernel.org/stable/c/dbc98fe99e17ed18f2f272d5fe880d844b1c68c3

------------------------------------------------------------

CVE ID: CVE-2022-49817
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mhi: Fix memory leak in mhi_net_dellink()

MHI driver registers network device without setting the
needs_free_netdev flag, and does NOT call free_netdev() when
unregisters network device, which causes a memory leak.

This patch calls free_netdev() to fix it since netdev_priv
is used after unregister.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/25a270343b0f16e1f6e65f541a15975a35e238ff
  - https://git.kernel.org/stable/c/88da008e5e2f9753726ea5a51ef2eb144e9de927
  - https://git.kernel.org/stable/c/f7c125bd79f50ec6094761090be81d02726ec6f4

------------------------------------------------------------

CVE ID: CVE-2022-49818
Description: In the Linux kernel, the following vulnerability has been resolved:

mISDN: fix misuse of put_device() in mISDN_register_device()

We should not release reference by put_device() before calling device_initialize().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d25107e111a85c56f601a5470f1780ec054e6ac
  - https://git.kernel.org/stable/c/44658d65f6b3118f595a1229d7eed74845a5e2ac
  - https://git.kernel.org/stable/c/596230471da3415e92ae6b9d2a4e26f4a81cac5a
  - https://git.kernel.org/stable/c/709aa1f73d3e9e9ea16e2c4e44f2874c5d2c382c
  - https://git.kernel.org/stable/c/81db4f182744acd004f17d7cc52dde9ea53467e6
  - https://git.kernel.org/stable/c/83672c1b83d107b0d4fe0accf1bf64d8988398e6
  - https://git.kernel.org/stable/c/87b336aa158201dc30a318431e63e8c5b26c4156
  - https://git.kernel.org/stable/c/d40b35a7922f4df3767ad6fb8ef3dc86e31d7ba3

------------------------------------------------------------

CVE ID: CVE-2022-49819
Description: In the Linux kernel, the following vulnerability has been resolved:

octeon_ep: fix potential memory leak in octep_device_setup()

When occur unsupported_dev and mbox init errors, it did not free oct->conf
and iounmap() oct->mmio[i].hw_addr. That would trigger memory leak problem.
Add kfree() for oct->conf and iounmap() for oct->mmio[i].hw_addr under
unsupported_dev and mbox init errors to fix the problem.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/67b65a0db8a7fdad43159819f41335497a4bb04f
  - https://git.kernel.org/stable/c/e4041be97b15302ebfffda8bbd45f3b2d096048f

------------------------------------------------------------

CVE ID: CVE-2022-49820
Description: In the Linux kernel, the following vulnerability has been resolved:

mctp i2c: don't count unused / invalid keys for flow release

We're currently hitting the WARN_ON in mctp_i2c_flow_release:

    if (midev->release_count > midev->i2c_lock_count) {
        WARN_ONCE(1, "release count overflow");

This may be hit if we expire a flow before sending the first packet it
contains - as we will not be pairing the increment of release_count
(performed on flow release) with the i2c lock operation (only
performed on actual TX).

To fix this, only release a flow if we've encountered it previously (ie,
dev_flow_state does not indicate NEW), as we will mark the flow as
ACTIVE at the same time as accounting for the i2c lock operation. We
also need to add an INVALID flow state, to indicate when we've done the
release.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9cbd48d5fa14e4c65f8580de16686077f7cea02b
  - https://git.kernel.org/stable/c/a5915a9a3ab4067ef8996a57738d156eabeb3a12

------------------------------------------------------------

CVE ID: CVE-2022-49821
Description: In the Linux kernel, the following vulnerability has been resolved:

mISDN: fix possible memory leak in mISDN_dsp_element_register()

Afer commit 1fa5ae857bb1 ("driver core: get rid of struct device's
bus_id string array"), the name of device is allocated dynamically,
use put_device() to give up the reference, so that the name can be
freed in kobject_cleanup() when the refcount is 0.

The 'entry' is going to be freed in mISDN_dsp_dev_release(), so the
kfree() is removed. list_del() is called in mISDN_dsp_dev_release(),
so it need be initialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/083a2c9ef82e184bdf0b9f9a1e5fc38d32afbb47
  - https://git.kernel.org/stable/c/0f2c681900a01e3f23789bca26d88268c3d5b51d
  - https://git.kernel.org/stable/c/727ed7d28348c026c7ef4d852f3d0e5054d376e8
  - https://git.kernel.org/stable/c/7a05e3929668c8cfef495c69752a9e91fac4878f
  - https://git.kernel.org/stable/c/98a2ac1ca8fd6eca6867726fe238d06e75eb1acd
  - https://git.kernel.org/stable/c/b119bedbefb7dd9ed8bf8cb9f1056504250d610e
  - https://git.kernel.org/stable/c/bbd53d05c4c892080ef3b617eff4f57903acecb9
  - https://git.kernel.org/stable/c/d4b8394725079670be309f9a35ad88a8cbbaaefd

------------------------------------------------------------

CVE ID: CVE-2022-49822
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: Fix connections leak when tlink setup failed

If the tlink setup failed, lost to put the connections, then
the module refcnt leak since the cifsd kthread not exit.

Also leak the fscache info, and for next mount with fsc, it will
print the follow errors:
  CIFS: Cache volume key already in use (cifs,127.0.0.1:445,TEST)

Let's check the result of tlink setup, and do some cleanup.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a087842d10b5daa123ee5291e386cdd78413705
  - https://git.kernel.org/stable/c/1dcdf5f5b2137185cbdd5385f29949ab3da4f00c
  - https://git.kernel.org/stable/c/a9059e338fc000c0b87d8cf29e93c74fd703212e

------------------------------------------------------------

CVE ID: CVE-2022-49823
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: libata-transport: fix error handling in ata_tdev_add()

In ata_tdev_add(), the return value of transport_add_device() is
not checked. As a result, it causes null-ptr-deref while removing
the module, because transport_remove_device() is called to remove
the device that was not added.

Unable to handle kernel NULL pointer dereference at virtual address 00000000000000d0
CPU: 13 PID: 13603 Comm: rmmod Kdump: loaded Tainted: G        W          6.1.0-rc3+ #36
pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : device_del+0x48/0x3a0
lr : device_del+0x44/0x3a0
Call trace:
 device_del+0x48/0x3a0
 attribute_container_class_device_del+0x28/0x40
 transport_remove_classdev+0x60/0x7c
 attribute_container_device_trigger+0x118/0x120
 transport_remove_device+0x20/0x30
 ata_tdev_delete+0x24/0x50 [libata]
 ata_tlink_delete+0x40/0xa0 [libata]
 ata_tport_delete+0x2c/0x60 [libata]
 ata_port_detach+0x148/0x1b0 [libata]
 ata_pci_remove_one+0x50/0x80 [libata]
 ahci_remove_one+0x4c/0x8c [ahci]

Fix this by checking and handling return value of transport_add_device()
in ata_tdev_add(). In the error path, device_del() is called to delete
the device which was added earlier in this function, and ata_tdev_free()
is called to free ata_dev.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1ff36351309e3eadcff297480baf4785e726de9b
  - https://git.kernel.org/stable/c/ef2ac07ab83163b9a53f45da20e14302591ad9cc
  - https://git.kernel.org/stable/c/f23058dc2398db1d8faca9a2b1ce30b85cdd8b22
  - https://git.kernel.org/stable/c/f54331962883f4fc4bf5e487e6e7cf07c4567fef

------------------------------------------------------------

CVE ID: CVE-2022-49824
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: libata-transport: fix error handling in ata_tlink_add()

In ata_tlink_add(), the return value of transport_add_device() is
not checked. As a result, it causes null-ptr-deref while removing
the module, because transport_remove_device() is called to remove
the device that was not added.

Unable to handle kernel NULL pointer dereference at virtual address 00000000000000d0
CPU: 33 PID: 13850 Comm: rmmod Kdump: loaded Tainted: G        W          6.1.0-rc3+ #12
pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : device_del+0x48/0x39c
lr : device_del+0x44/0x39c
Call trace:
 device_del+0x48/0x39c
 attribute_container_class_device_del+0x28/0x40
 transport_remove_classdev+0x60/0x7c
 attribute_container_device_trigger+0x118/0x120
 transport_remove_device+0x20/0x30
 ata_tlink_delete+0x88/0xb0 [libata]
 ata_tport_delete+0x2c/0x60 [libata]
 ata_port_detach+0x148/0x1b0 [libata]
 ata_pci_remove_one+0x50/0x80 [libata]
 ahci_remove_one+0x4c/0x8c [ahci]

Fix this by checking and handling return value of transport_add_device()
in ata_tlink_add().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/67b219314628b90b3a314528e177335b0cd5c70b
  - https://git.kernel.org/stable/c/7377a14598f6b04446c54bc4a50cd249470d6c6f
  - https://git.kernel.org/stable/c/cf0816f6322c5c37ee52655f928e91ecf32da103
  - https://git.kernel.org/stable/c/d5234480ca822bdcf03fe4d6a590ddcb854558f7

------------------------------------------------------------

CVE ID: CVE-2022-49825
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: libata-transport: fix error handling in ata_tport_add()

In ata_tport_add(), the return value of transport_add_device() is
not checked. As a result, it causes null-ptr-deref while removing
the module, because transport_remove_device() is called to remove
the device that was not added.

Unable to handle kernel NULL pointer dereference at virtual address 00000000000000d0
CPU: 12 PID: 13605 Comm: rmmod Kdump: loaded Tainted: G        W          6.1.0-rc3+ #8
pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : device_del+0x48/0x39c
lr : device_del+0x44/0x39c
Call trace:
 device_del+0x48/0x39c
 attribute_container_class_device_del+0x28/0x40
 transport_remove_classdev+0x60/0x7c
 attribute_container_device_trigger+0x118/0x120
 transport_remove_device+0x20/0x30
 ata_tport_delete+0x34/0x60 [libata]
 ata_port_detach+0x148/0x1b0 [libata]
 ata_pci_remove_one+0x50/0x80 [libata]
 ahci_remove_one+0x4c/0x8c [ahci]

Fix this by checking and handling return value of transport_add_device()
in ata_tport_add().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3613dbe3909dcc637fe6be00e4dc43b4aa0470ee
  - https://git.kernel.org/stable/c/52d9bb0adae9359711a0c5271430afd3754069e7
  - https://git.kernel.org/stable/c/b5362dc1634d8b8d5f30920f33ac11a3276b7ed9
  - https://git.kernel.org/stable/c/e7bb1b7a7bf26f6b7372b7b683daece4a42fda02

------------------------------------------------------------

CVE ID: CVE-2022-49826
Description: In the Linux kernel, the following vulnerability has been resolved:

ata: libata-transport: fix double ata_host_put() in ata_tport_add()

In the error path in ata_tport_add(), when calling put_device(),
ata_tport_release() is called, it will put the refcount of 'ap->host'.

And then ata_host_put() is called again, the refcount is decreased
to 0, ata_host_release() is called, all ports are freed and set to
null.

When unbinding the device after failure, ata_host_stop() is called
to release the resources, it leads a null-ptr-deref(), because all
the ports all freed and null.

Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008
CPU: 7 PID: 18671 Comm: modprobe Kdump: loaded Tainted: G            E      6.1.0-rc3+ #8
pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : ata_host_stop+0x3c/0x84 [libata]
lr : release_nodes+0x64/0xd0
Call trace:
 ata_host_stop+0x3c/0x84 [libata]
 release_nodes+0x64/0xd0
 devres_release_all+0xbc/0x1b0
 device_unbind_cleanup+0x20/0x70
 really_probe+0x158/0x320
 __driver_probe_device+0x84/0x120
 driver_probe_device+0x44/0x120
 __driver_attach+0xb4/0x220
 bus_for_each_dev+0x78/0xdc
 driver_attach+0x2c/0x40
 bus_add_driver+0x184/0x240
 driver_register+0x80/0x13c
 __pci_register_driver+0x4c/0x60
 ahci_pci_driver_init+0x30/0x1000 [ahci]

Fix this by removing redundant ata_host_put() in the error path.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/30e12e2be27ac6c4be2af4163c70db381364706f
  - https://git.kernel.org/stable/c/377ff82c33c0cb74562a353361b64b33c09562cf
  - https://git.kernel.org/stable/c/865a6da40ba092c18292ae5f6194756131293745
  - https://git.kernel.org/stable/c/8c76310740807ade5ecdab5888f70ecb6d35732e
  - https://git.kernel.org/stable/c/ac471468f7c16cda2525909946ca13ddbcd14000
  - https://git.kernel.org/stable/c/bec9ded5404cb14e5f5470103d0973a2ff83d6a5

------------------------------------------------------------

CVE ID: CVE-2022-49827
Description: In the Linux kernel, the following vulnerability has been resolved:

drm: Fix potential null-ptr-deref in drm_vblank_destroy_worker()

drm_vblank_init() call drmm_add_action_or_reset() with
drm_vblank_init_release() as action. If __drmm_add_action() failed, will
directly call drm_vblank_init_release() with the vblank whose worker is
NULL. As the resule, a null-ptr-deref will happen in
kthread_destroy_worker(). Add the NULL check before calling
drm_vblank_destroy_worker().

BUG: null-ptr-deref
KASAN: null-ptr-deref in range [0x0000000000000068-0x000000000000006f]
CPU: 5 PID: 961 Comm: modprobe Not tainted 6.0.0-11331-gd465bff130bf-dirty
RIP: 0010:kthread_destroy_worker+0x25/0xb0
  Call Trace:
    <TASK>
    drm_vblank_init_release+0x124/0x220 [drm]
    ? drm_crtc_vblank_restore+0x8b0/0x8b0 [drm]
    __drmm_add_action_or_reset+0x41/0x50 [drm]
    drm_vblank_init+0x282/0x310 [drm]
    vkms_init+0x35f/0x1000 [vkms]
    ? 0xffffffffc4508000
    ? lock_is_held_type+0xd7/0x130
    ? __kmem_cache_alloc_node+0x1c2/0x2b0
    ? lock_is_held_type+0xd7/0x130
    ? 0xffffffffc4508000
    do_one_initcall+0xd0/0x4f0
    ...
    do_syscall_64+0x35/0x80
    entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d160dfb3fdf11ba9447e862c548447f91f4e74a
  - https://git.kernel.org/stable/c/3acd2016421b2e628acad65495d15493bf7a3bc3
  - https://git.kernel.org/stable/c/4979524f5a2a8210e87fde2f642b0dc060860821
  - https://git.kernel.org/stable/c/e884a6c2d49a6c12761e5bed851e9fe93bd923a1

------------------------------------------------------------

CVE ID: CVE-2022-49828
Description: In the Linux kernel, the following vulnerability has been resolved:

hugetlbfs: don't delete error page from pagecache

This change is very similar to the change that was made for shmem [1], and
it solves the same problem but for HugeTLBFS instead.

Currently, when poison is found in a HugeTLB page, the page is removed
from the page cache.  That means that attempting to map or read that
hugepage in the future will result in a new hugepage being allocated
instead of notifying the user that the page was poisoned.  As [1] states,
this is effectively memory corruption.

The fix is to leave the page in the page cache.  If the user attempts to
use a poisoned HugeTLB page with a syscall, the syscall will fail with
EIO, the same error code that shmem uses.  For attempts to map the page,
the thread will get a BUS_MCEERR_AR SIGBUS.

[1]: commit a76054266661 ("mm: shmem: don't truncate page if memory failure happens")
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/30571f28bb35c826219971c63bcf60d2517112ed
  - https://git.kernel.org/stable/c/8625147cafaa9ba74713d682f5185eb62cb2aedb
  - https://git.kernel.org/stable/c/ec667443b2dbc6cdbbac4073e51a17733158ec6a

------------------------------------------------------------

CVE ID: CVE-2022-49829
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/scheduler: fix fence ref counting

We leaked dependency fences when processes were beeing killed.

Additional to that grab a reference to the last scheduled fence.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/b3af84383e7abdc5e63435817bb73a268e7c3637
  - https://git.kernel.org/stable/c/e5f4b38362df93594cb426b04979d8834122f159

------------------------------------------------------------

CVE ID: CVE-2022-49830
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/drv: Fix potential memory leak in drm_dev_init()

drm_dev_init() will add drm_dev_init_release() as a callback. When
drmm_add_action() failed, the release function won't be added. As the
result, the ref cnt added by device_get() in drm_dev_init() won't be put
by drm_dev_init_release(), which leads to the memleak. Use
drmm_add_action_or_reset() instead of drmm_add_action() to prevent
memleak.

unreferenced object 0xffff88810bc0c800 (size 2048):
  comm "modprobe", pid 8322, jiffies 4305809845 (age 15.292s)
  hex dump (first 32 bytes):
    e8 cc c0 0b 81 88 ff ff ff ff ff ff 00 00 00 00  ................
    20 24 3c 0c 81 88 ff ff 18 c8 c0 0b 81 88 ff ff   $<.............
  backtrace:
    [<000000007251f72d>] __kmalloc+0x4b/0x1c0
    [<0000000045f21f26>] platform_device_alloc+0x2d/0xe0
    [<000000004452a479>] platform_device_register_full+0x24/0x1c0
    [<0000000089f4ea61>] 0xffffffffa0736051
    [<00000000235b2441>] do_one_initcall+0x7a/0x380
    [<0000000001a4a177>] do_init_module+0x5c/0x230
    [<000000002bf8a8e2>] load_module+0x227d/0x2420
    [<00000000637d6d0a>] __do_sys_finit_module+0xd5/0x140
    [<00000000c99fc324>] do_syscall_64+0x3f/0x90
    [<000000004d85aa77>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/07e56de8766fe5be67252596244b84ac0ec0de91
  - https://git.kernel.org/stable/c/bd8d1335e6e70a396094ef98913b513140c0b86b
  - https://git.kernel.org/stable/c/c47a823ea186263ab69cfb665327b7f72cb5e779
  - https://git.kernel.org/stable/c/ff963634f7b2e0dc011349abb3fb81a0d074f443

------------------------------------------------------------

CVE ID: CVE-2022-49831
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: zoned: initialize device's zone info for seeding

When performing seeding on a zoned filesystem it is necessary to
initialize each zoned device's btrfs_zoned_device_info structure,
otherwise mounting the filesystem will cause a NULL pointer dereference.

This was uncovered by fstests' testcase btrfs/163.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/544f38a738343d7e75f104e5e9d1ade58d8b71bd
  - https://git.kernel.org/stable/c/91c38504e589dadbcde47b1cacdfc5b684154d44
  - https://git.kernel.org/stable/c/a8d1b1647bf8244a5f270538e9e636e2657fffa3

------------------------------------------------------------

CVE ID: CVE-2022-49832
Description: In the Linux kernel, the following vulnerability has been resolved:

pinctrl: devicetree: fix null pointer dereferencing in pinctrl_dt_to_map

Here is the BUG report by KASAN about null pointer dereference:

BUG: KASAN: null-ptr-deref in strcmp+0x2e/0x50
Read of size 1 at addr 0000000000000000 by task python3/2640
Call Trace:
 strcmp
 __of_find_property
 of_find_property
 pinctrl_dt_to_map

kasprintf() would return NULL pointer when kmalloc() fail to allocate.
So directly return ENOMEM, if kasprintf() return NULL pointer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/040f726fecd88121f3b95e70369785ad452dddf9
  - https://git.kernel.org/stable/c/5834a3a98cd266ad35a229923c0adbd0addc8d68
  - https://git.kernel.org/stable/c/777430aa4ddccaa5accec6db90ffc1d47f00d471
  - https://git.kernel.org/stable/c/91d5c5060ee24fe8da88cd585bb43b843d2f0dce
  - https://git.kernel.org/stable/c/97e5b508e96176f1a73888ed89df396d7041bfcb
  - https://git.kernel.org/stable/c/a988dcd3dd9e691c5ccc3324b209688f3b5453e9
  - https://git.kernel.org/stable/c/aaf552c5d53abe4659176e099575fe870d2e4768
  - https://git.kernel.org/stable/c/b4d9f55cd38435358bc16d580612bc0d798d7b4c

------------------------------------------------------------

CVE ID: CVE-2022-49833
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: zoned: clone zoned device info when cloning a device

When cloning a btrfs_device, we're not cloning the associated
btrfs_zoned_device_info structure of the device in case of a zoned
filesystem.

Later on this leads to a NULL pointer dereference when accessing the
device's zone_info for instance when setting a zone as active.

This was uncovered by fstests' testcase btrfs/161.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/21e61ec6d0bb786818490e926aa9aeb4de95ad0d
  - https://git.kernel.org/stable/c/ad88cabcec942c033f980cd1e28d56ecdaf5f3b8

------------------------------------------------------------

CVE ID: CVE-2022-49834
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: fix use-after-free bug of ns_writer on remount

If a nilfs2 filesystem is downgraded to read-only due to metadata
corruption on disk and is remounted read/write, or if emergency read-only
remount is performed, detaching a log writer and synchronizing the
filesystem can be done at the same time.

In these cases, use-after-free of the log writer (hereinafter
nilfs->ns_writer) can happen as shown in the scenario below:

 Task1                               Task2
 --------------------------------    ------------------------------
 nilfs_construct_segment
   nilfs_segctor_sync
     init_wait
     init_waitqueue_entry
     add_wait_queue
     schedule
                                     nilfs_remount (R/W remount case)
				       nilfs_attach_log_writer
                                         nilfs_detach_log_writer
                                           nilfs_segctor_destroy
                                             kfree
     finish_wait
       _raw_spin_lock_irqsave
         __raw_spin_lock_irqsave
           do_raw_spin_lock
             debug_spin_lock_before  <-- use-after-free

While Task1 is sleeping, nilfs->ns_writer is freed by Task2.  After Task1
waked up, Task1 accesses nilfs->ns_writer which is already freed.  This
scenario diagram is based on the Shigeru Yoshida's post [1].

This patch fixes the issue by not detaching nilfs->ns_writer on remount so
that this UAF race doesn't happen.  Along with this change, this patch
also inserts a few necessary read-only checks with superblock instance
where only the ns_writer pointer was used to check if the filesystem is
read-only.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/39a3ed68270b079c6b874d4e4727a512b9b4882c
  - https://git.kernel.org/stable/c/4feedde5486c07ea79787839153a71ca71329c7d
  - https://git.kernel.org/stable/c/8cccf05fe857a18ee26e20d11a8455a73ffd4efd
  - https://git.kernel.org/stable/c/9b162e81045266a2d5b44df9dffdf05c54de9cca
  - https://git.kernel.org/stable/c/afbd1188382a75f6cfe22c0b68533f7f9664f182
  - https://git.kernel.org/stable/c/b152300d5a1ba4258dacf9916bff20e6a8c7603b
  - https://git.kernel.org/stable/c/b2fbf10040216ef5ee270773755fc2f5da65b749
  - https://git.kernel.org/stable/c/b4736ab5542112fe0a40f140a0a0b072954f34da

------------------------------------------------------------

CVE ID: CVE-2022-49835
Description: In the Linux kernel, the following vulnerability has been resolved:

ALSA: hda: fix potential memleak in 'add_widget_node'

As 'kobject_add' may allocated memory for 'kobject->name' when return error.
And in this function, if call 'kobject_add' failed didn't free kobject.
So call 'kobject_put' to recycling resources.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/02dea987ec1cac712c78e75d224ceb9bb73519ed
  - https://git.kernel.org/stable/c/3a79f9568de08657fcdbc41d6fc4c0ca145a7a2b
  - https://git.kernel.org/stable/c/455d99bd6baf19688048b6d42d9fa74eae27f93b
  - https://git.kernel.org/stable/c/7140d7aaf93da6a665b454f91bb4dc6b1de218bd
  - https://git.kernel.org/stable/c/90b7d055e2b5f39429f9a9e3815b48a48530ef28
  - https://git.kernel.org/stable/c/9a5523f72bd2b0d66eef3d58810c6eb7b5ffc143
  - https://git.kernel.org/stable/c/b688a3ec235222d9a84e43a48a6f31acb95baf2d
  - https://git.kernel.org/stable/c/bb0ac8d5e541224f599bc8e8f31a313faa4bf7b7

------------------------------------------------------------

CVE ID: CVE-2022-49836
Description: In the Linux kernel, the following vulnerability has been resolved:

siox: fix possible memory leak in siox_device_add()

If device_register() returns error in siox_device_add(),
the name allocated by dev_set_name() need be freed. As
comment of device_register() says, it should use put_device()
to give up the reference in the error path. So fix this
by calling put_device(), then the name can be freed in
kobject_cleanup(), and sdevice is freed in siox_device_release(),
set it to null in error path.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a5da069603ecc3d7aa09167450235462adaa295
  - https://git.kernel.org/stable/c/5d03c2911c529ea4d6ebfec53425f1091e8d402b
  - https://git.kernel.org/stable/c/6e63153db50059fb78b8a8447b132664887d24e3
  - https://git.kernel.org/stable/c/a4b5423f88a17a36550ae8c16c46779b1ee42f4b
  - https://git.kernel.org/stable/c/d9c31e728843259209fb530c59995e4fe262699f
  - https://git.kernel.org/stable/c/f9fe7ba4ea5b24ffdf8e125f660aca3ba4a147fb

------------------------------------------------------------

CVE ID: CVE-2022-49837
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix memory leaks in __check_func_call

kmemleak reports this issue:

unreferenced object 0xffff88817139d000 (size 2048):
  comm "test_progs", pid 33246, jiffies 4307381979 (age 45851.820s)
  hex dump (first 32 bytes):
    01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<0000000045f075f0>] kmalloc_trace+0x27/0xa0
    [<0000000098b7c90a>] __check_func_call+0x316/0x1230
    [<00000000b4c3c403>] check_helper_call+0x172e/0x4700
    [<00000000aa3875b7>] do_check+0x21d8/0x45e0
    [<000000001147357b>] do_check_common+0x767/0xaf0
    [<00000000b5a595b4>] bpf_check+0x43e3/0x5bc0
    [<0000000011e391b1>] bpf_prog_load+0xf26/0x1940
    [<0000000007f765c0>] __sys_bpf+0xd2c/0x3650
    [<00000000839815d6>] __x64_sys_bpf+0x75/0xc0
    [<00000000946ee250>] do_syscall_64+0x3b/0x90
    [<0000000000506b7f>] entry_SYSCALL_64_after_hwframe+0x63/0xcd

The root case here is: In function prepare_func_exit(), the callee is
not released in the abnormal scenario after "state->curframe--;". To
fix, move "state->curframe--;" to the very bottom of the function,
right when we free callee and reset frame[] pointer to NULL, as Andrii
suggested.

In addition, function __check_func_call() has a similar problem. In
the abnormal scenario before "state->curframe++;", the callee also
should be released by free_func_state().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.15.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.10
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/83946d772e756734a900ef99dbe0aeda506adf37
  - https://git.kernel.org/stable/c/d4944497827a3d14bc5a26dbcfb7433eb5a956c0
  - https://git.kernel.org/stable/c/eb86559a691cea5fa63e57a03ec3dc9c31e97955

------------------------------------------------------------

CVE ID: CVE-2022-49838
Description: In the Linux kernel, the following vulnerability has been resolved:

sctp: clear out_curr if all frag chunks of current msg are pruned

A crash was reported by Zhen Chen:

  list_del corruption, ffffa035ddf01c18->next is NULL
  WARNING: CPU: 1 PID: 250682 at lib/list_debug.c:49 __list_del_entry_valid+0x59/0xe0
  RIP: 0010:__list_del_entry_valid+0x59/0xe0
  Call Trace:
   sctp_sched_dequeue_common+0x17/0x70 [sctp]
   sctp_sched_fcfs_dequeue+0x37/0x50 [sctp]
   sctp_outq_flush_data+0x85/0x360 [sctp]
   sctp_outq_uncork+0x77/0xa0 [sctp]
   sctp_cmd_interpreter.constprop.0+0x164/0x1450 [sctp]
   sctp_side_effects+0x37/0xe0 [sctp]
   sctp_do_sm+0xd0/0x230 [sctp]
   sctp_primitive_SEND+0x2f/0x40 [sctp]
   sctp_sendmsg_to_asoc+0x3fa/0x5c0 [sctp]
   sctp_sendmsg+0x3d5/0x440 [sctp]
   sock_sendmsg+0x5b/0x70

and in sctp_sched_fcfs_dequeue() it dequeued a chunk from stream
out_curr outq while this outq was empty.

Normally stream->out_curr must be set to NULL once all frag chunks of
current msg are dequeued, as we can see in sctp_sched_dequeue_done().
However, in sctp_prsctp_prune_unsent() as it is not a proper dequeue,
sctp_sched_dequeue_done() is not called to do this.

This patch is to fix it by simply setting out_curr to NULL when the
last frag chunk of current msg is dequeued from out_curr stream in
sctp_prsctp_prune_unsent().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2ea600b598dd3e061854dd4dd5b4c815397dfcea
  - https://git.kernel.org/stable/c/2f201ae14ae0f91dbf1cffea7bb1e29e81d4d108
  - https://git.kernel.org/stable/c/3eff34e01062ec08fbb45ce2baaaa644550be821
  - https://git.kernel.org/stable/c/e27458b18b35caee4b27b37a4a9c503b93cae5cc

------------------------------------------------------------

CVE ID: CVE-2022-49839
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: scsi_transport_sas: Fix error handling in sas_phy_add()

If transport_add_device() fails in sas_phy_add(), the kernel will crash
trying to delete the device in transport_remove_device() called from
sas_remove_host().

Unable to handle kernel NULL pointer dereference at virtual address 0000000000000108
CPU: 61 PID: 42829 Comm: rmmod Kdump: loaded Tainted: G        W          6.1.0-rc1+ #173
pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : device_del+0x54/0x3d0
lr : device_del+0x37c/0x3d0
Call trace:
 device_del+0x54/0x3d0
 attribute_container_class_device_del+0x28/0x38
 transport_remove_classdev+0x6c/0x80
 attribute_container_device_trigger+0x108/0x110
 transport_remove_device+0x28/0x38
 sas_phy_delete+0x30/0x60 [scsi_transport_sas]
 do_sas_phy_delete+0x6c/0x80 [scsi_transport_sas]
 device_for_each_child+0x68/0xb0
 sas_remove_children+0x40/0x50 [scsi_transport_sas]
 sas_remove_host+0x20/0x38 [scsi_transport_sas]
 hisi_sas_remove+0x40/0x68 [hisi_sas_main]
 hisi_sas_v2_remove+0x20/0x30 [hisi_sas_v2_hw]
 platform_remove+0x2c/0x60

Fix this by checking and handling return value of transport_add_device()
in sas_phy_add().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.14, Last Version (Excluding): 5.10.157
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.10
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/03aabcb88aeeb7221ddb6196ae84ad5fb17b743f
  - https://git.kernel.org/stable/c/2f21d653c648735657e23948b1d7ac7273de0f87
  - https://git.kernel.org/stable/c/5d7bebf2dfb0dc97aac1fbace0910e557ecdb16f
  - https://git.kernel.org/stable/c/c736876ee294bb4f271d76a25cc7d70c8537bc5d

------------------------------------------------------------

CVE ID: CVE-2022-49840
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, test_run: Fix alignment problem in bpf_prog_test_run_skb()

We got a syzkaller problem because of aarch64 alignment fault
if KFENCE enabled. When the size from user bpf program is an odd
number, like 399, 407, etc, it will cause the struct skb_shared_info's
unaligned access. As seen below:

  BUG: KFENCE: use-after-free read in __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032

  Use-after-free read at 0xffff6254fffac077 (in kfence-#213):
   __lse_atomic_add arch/arm64/include/asm/atomic_lse.h:26 [inline]
   arch_atomic_add arch/arm64/include/asm/atomic.h:28 [inline]
   arch_atomic_inc include/linux/atomic-arch-fallback.h:270 [inline]
   atomic_inc include/asm-generic/atomic-instrumented.h:241 [inline]
   __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032
   skb_clone+0xf4/0x214 net/core/skbuff.c:1481
   ____bpf_clone_redirect net/core/filter.c:2433 [inline]
   bpf_clone_redirect+0x78/0x1c0 net/core/filter.c:2420
   bpf_prog_d3839dd9068ceb51+0x80/0x330
   bpf_dispatcher_nop_func include/linux/bpf.h:728 [inline]
   bpf_test_run+0x3c0/0x6c0 net/bpf/test_run.c:53
   bpf_prog_test_run_skb+0x638/0xa7c net/bpf/test_run.c:594
   bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline]
   __do_sys_bpf kernel/bpf/syscall.c:4441 [inline]
   __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381

  kfence-#213: 0xffff6254fffac000-0xffff6254fffac196, size=407, cache=kmalloc-512

  allocated by task 15074 on cpu 0 at 1342.585390s:
   kmalloc include/linux/slab.h:568 [inline]
   kzalloc include/linux/slab.h:675 [inline]
   bpf_test_init.isra.0+0xac/0x290 net/bpf/test_run.c:191
   bpf_prog_test_run_skb+0x11c/0xa7c net/bpf/test_run.c:512
   bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline]
   __do_sys_bpf kernel/bpf/syscall.c:4441 [inline]
   __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381
   __arm64_sys_bpf+0x50/0x60 kernel/bpf/syscall.c:4381

To fix the problem, we adjust @size so that (@size + @hearoom) is a
multiple of SMP_CACHE_BYTES. So we make sure the struct skb_shared_info
is aligned to a cache line.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.156
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.10
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/047824a730699c6c66df43306b80f700c9dfc2fd
  - https://git.kernel.org/stable/c/1b597f2d6a55e9f549989913860ad5170da04964
  - https://git.kernel.org/stable/c/730fb1ef974a13915bc7651364d8b3318891cd70
  - https://git.kernel.org/stable/c/7a704dbfd3735304e261f2787c52fbc7c3884736
  - https://git.kernel.org/stable/c/d3fd203f36d46aa29600a72d57a1b61af80e4a25
  - https://git.kernel.org/stable/c/e60f37a1d379c821c17b08f366412dce9ef3d99f
  - https://git.kernel.org/stable/c/eaa8edd86514afac9deb9bf9a5053e74f37edf40

------------------------------------------------------------

CVE ID: CVE-2022-49841
Description: In the Linux kernel, the following vulnerability has been resolved:

serial: imx: Add missing .thaw_noirq hook

The following warning is seen with non-console UART instance when
system hibernates.

[   37.371969] ------------[ cut here ]------------
[   37.376599] uart3_root_clk already disabled
[   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0
...
[   37.506986] Call trace:
[   37.509432]  clk_core_disable+0xa4/0xb0
[   37.513270]  clk_disable+0x34/0x50
[   37.516672]  imx_uart_thaw+0x38/0x5c
[   37.520250]  platform_pm_thaw+0x30/0x6c
[   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4
[   37.528972]  device_resume+0x7c/0x160
[   37.532633]  dpm_resume+0xe8/0x230
[   37.536036]  hibernation_snapshot+0x288/0x430
[   37.540397]  hibernate+0x10c/0x2e0
[   37.543798]  state_store+0xc4/0xd0
[   37.547203]  kobj_attr_store+0x1c/0x30
[   37.550953]  sysfs_kf_write+0x48/0x60
[   37.554619]  kernfs_fop_write_iter+0x118/0x1ac
[   37.559063]  new_sync_write+0xe8/0x184
[   37.562812]  vfs_write+0x230/0x290
[   37.566214]  ksys_write+0x68/0xf4
[   37.569529]  __arm64_sys_write+0x20/0x2c
[   37.573452]  invoke_syscall.constprop.0+0x50/0xf0
[   37.578156]  do_el0_svc+0x11c/0x150
[   37.581648]  el0_svc+0x30/0x140
[   37.584792]  el0t_64_sync_handler+0xe8/0xf0
[   37.588976]  el0t_64_sync+0x1a0/0x1a4
[   37.592639] ---[ end trace 56e22eec54676d75 ]---

On hibernating, pm core calls into related hooks in sequence like:

    .freeze
    .freeze_noirq
    .thaw_noirq
    .thaw

With .thaw_noirq hook being absent, the clock will be disabled in a
unbalanced call which results the warning above.

    imx_uart_freeze()
        clk_prepare_enable()
    imx_uart_suspend_noirq()
        clk_disable()
    imx_uart_thaw
        clk_disable_unprepare()

Adding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have
the call sequence corrected as below and thus fix the warning.

    imx_uart_freeze()
        clk_prepare_enable()
    imx_uart_suspend_noirq()
        clk_disable()
    imx_uart_resume_noirq()
        clk_enable()
    imx_uart_thaw
        clk_disable_unprepare()
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a3160f4ffc70ee4bfa1521f698dace06e6091fd
  - https://git.kernel.org/stable/c/4561d8008a467cb05ac632a215391d6b787f40aa
  - https://git.kernel.org/stable/c/476b09e07bd519ec7ba5941a6a6f9a02256dbb21
  - https://git.kernel.org/stable/c/ae22294e213a402a70fa1731538367d1b758ffe7
  - https://git.kernel.org/stable/c/e3f9d87d6f0732827c443bd1474df21c2fad704b
  - https://git.kernel.org/stable/c/e401312ca6e180ee1bd65f6a766e99dd40aa95e7

------------------------------------------------------------

CVE ID: CVE-2022-49842
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: core: Fix use-after-free in snd_soc_exit()

KASAN reports a use-after-free:

BUG: KASAN: use-after-free in device_del+0xb5b/0xc60
Read of size 8 at addr ffff888008655050 by task rmmod/387
CPU: 2 PID: 387 Comm: rmmod
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
Call Trace:
<TASK>
dump_stack_lvl+0x79/0x9a
print_report+0x17f/0x47b
kasan_report+0xbb/0xf0
device_del+0xb5b/0xc60
platform_device_del.part.0+0x24/0x200
platform_device_unregister+0x2e/0x40
snd_soc_exit+0xa/0x22 [snd_soc_core]
__do_sys_delete_module.constprop.0+0x34f/0x5b0
do_syscall_64+0x3a/0x90
entry_SYSCALL_64_after_hwframe+0x63/0xcd
...
</TASK>

It's bacause in snd_soc_init(), snd_soc_util_init() is possble to fail,
but its ret is ignored, which makes soc_dummy_dev unregistered twice.

snd_soc_init()
    snd_soc_util_init()
        platform_device_register_simple(soc_dummy_dev)
        platform_driver_register() # fail
    	platform_device_unregister(soc_dummy_dev)
    platform_driver_register() # success
...
snd_soc_exit()
    snd_soc_util_exit()
    # soc_dummy_dev will be unregistered for second time

To fix it, handle error and stop snd_soc_init() when util_init() fail.
Also clean debugfs when util_init() or driver_register() fail.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.0, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.156
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.80
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.10
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2ec3f558db343b045a7c7419cdbaec266b8ac1a7
  - https://git.kernel.org/stable/c/34eee4189bcebbd5f6a2ff25ef0cb893ad33d51e
  - https://git.kernel.org/stable/c/41fad4f712e081acdfde8b59847f9f66eaf407a0
  - https://git.kernel.org/stable/c/6ec27c53886c8963729885bcf2dd996eba2767a7
  - https://git.kernel.org/stable/c/8d21554ec7680e9585fb852d933203c3db60dad1
  - https://git.kernel.org/stable/c/90bbdf30a51e42378cb23a312005a022794b8e1e
  - https://git.kernel.org/stable/c/a3365e62239dc064019a244bde5686ac18527c22
  - https://git.kernel.org/stable/c/c5674bd073c0fd9f620ca550c5ff08d0d429bdd9

------------------------------------------------------------

CVE ID: CVE-2022-49844
Description: In the Linux kernel, the following vulnerability has been resolved:

can: dev: fix skb drop check

In commit a6d190f8c767 ("can: skb: drop tx skb if in listen only
mode") the priv->ctrlmode element is read even on virtual CAN
interfaces that do not create the struct can_priv at startup. This
out-of-bounds read may lead to CAN frame drops for virtual CAN
interfaces like vcan and vxcan.

This patch mainly reverts the original commit and adds a new helper
for CAN interface drivers that provide the required information in
struct can_priv.

[mkl: patch pch_can, too]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/386c49fe31ee748e053860b3bac7794a933ac9ac
  - https://git.kernel.org/stable/c/ae64438be1923e3c1102d90fd41db7afcfaf54cc

------------------------------------------------------------

CVE ID: CVE-2022-49845
Description: In the Linux kernel, the following vulnerability has been resolved:

can: j1939: j1939_send_one(): fix missing CAN header initialization

The read access to struct canxl_frame::len inside of a j1939 created
skbuff revealed a missing initialization of reserved and later filled
elements in struct can_frame.

This patch initializes the 8 byte CAN header with zero.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2719f82ad5d8199cf5f346ea8bb3998ad5323b72
  - https://git.kernel.org/stable/c/3eb3d283e8579a22b81dd2ac3987b77465b2a22f
  - https://git.kernel.org/stable/c/69e86c6268d59ceddd0abe9ae8f1f5296f316c3c
  - https://git.kernel.org/stable/c/d0513b095e1ef1469718564dec3fb3348556d0a8
  - https://git.kernel.org/stable/c/f8e0edeaa0f2b860bdbbf0aafb4492533043d650

------------------------------------------------------------

CVE ID: CVE-2022-49846
Description: In the Linux kernel, the following vulnerability has been resolved:

udf: Fix a slab-out-of-bounds write bug in udf_find_entry()

Syzbot reported a slab-out-of-bounds Write bug:

loop0: detected capacity change from 0 to 2048
==================================================================
BUG: KASAN: slab-out-of-bounds in udf_find_entry+0x8a5/0x14f0
fs/udf/namei.c:253
Write of size 105 at addr ffff8880123ff896 by task syz-executor323/3610

CPU: 0 PID: 3610 Comm: syz-executor323 Not tainted
6.1.0-rc2-syzkaller-00105-gb229b6ca5abb #0
Hardware name: Google Compute Engine/Google Compute Engine, BIOS
Google 10/11/2022
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106
 print_address_description+0x74/0x340 mm/kasan/report.c:284
 print_report+0x107/0x1f0 mm/kasan/report.c:395
 kasan_report+0xcd/0x100 mm/kasan/report.c:495
 kasan_check_range+0x2a7/0x2e0 mm/kasan/generic.c:189
 memcpy+0x3c/0x60 mm/kasan/shadow.c:66
 udf_find_entry+0x8a5/0x14f0 fs/udf/namei.c:253
 udf_lookup+0xef/0x340 fs/udf/namei.c:309
 lookup_open fs/namei.c:3391 [inline]
 open_last_lookups fs/namei.c:3481 [inline]
 path_openat+0x10e6/0x2df0 fs/namei.c:3710
 do_filp_open+0x264/0x4f0 fs/namei.c:3740
 do_sys_openat2+0x124/0x4e0 fs/open.c:1310
 do_sys_open fs/open.c:1326 [inline]
 __do_sys_creat fs/open.c:1402 [inline]
 __se_sys_creat fs/open.c:1396 [inline]
 __x64_sys_creat+0x11f/0x160 fs/open.c:1396
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7ffab0d164d9
Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89
f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01
f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007ffe1a7e6bb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000055
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffab0d164d9
RDX: 00007ffab0d164d9 RSI: 0000000000000000 RDI: 0000000020000180
RBP: 00007ffab0cd5a10 R08: 0000000000000000 R09: 0000000000000000
R10: 00005555573552c0 R11: 0000000000000246 R12: 00007ffab0cd5aa0
R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
 </TASK>

Allocated by task 3610:
 kasan_save_stack mm/kasan/common.c:45 [inline]
 kasan_set_track+0x3d/0x60 mm/kasan/common.c:52
 ____kasan_kmalloc mm/kasan/common.c:371 [inline]
 __kasan_kmalloc+0x97/0xb0 mm/kasan/common.c:380
 kmalloc include/linux/slab.h:576 [inline]
 udf_find_entry+0x7b6/0x14f0 fs/udf/namei.c:243
 udf_lookup+0xef/0x340 fs/udf/namei.c:309
 lookup_open fs/namei.c:3391 [inline]
 open_last_lookups fs/namei.c:3481 [inline]
 path_openat+0x10e6/0x2df0 fs/namei.c:3710
 do_filp_open+0x264/0x4f0 fs/namei.c:3740
 do_sys_openat2+0x124/0x4e0 fs/open.c:1310
 do_sys_open fs/open.c:1326 [inline]
 __do_sys_creat fs/open.c:1402 [inline]
 __se_sys_creat fs/open.c:1396 [inline]
 __x64_sys_creat+0x11f/0x160 fs/open.c:1396
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd

The buggy address belongs to the object at ffff8880123ff800
 which belongs to the cache kmalloc-256 of size 256
The buggy address is located 150 bytes inside of
 256-byte region [ffff8880123ff800, ffff8880123ff900)

The buggy address belongs to the physical page:
page:ffffea000048ff80 refcount:1 mapcount:0 mapping:0000000000000000
index:0x0 pfn:0x123fe
head:ffffea000048ff80 order:1 compound_mapcount:0 compound_pincount:0
flags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)
raw: 00fff00000010200 ffffea00004b8500 dead000000000003 ffff888012041b40
raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
page_owner tracks the page as allocated
page last allocated via order 0, migratetype Unmovable, gfp_mask 0x0(),
pid 1, tgid 1 (swapper/0), ts 1841222404, free_ts 0
 create_dummy_stack mm/page_owner.c:
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.6, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/03f9582a6a2ebd25a440896475c968428c4b63e7
  - https://git.kernel.org/stable/c/583fdd98d94acba1e7225e5cc29063aef0741030
  - https://git.kernel.org/stable/c/7a6051d734f1ed0031e2216f9a538621235c11a4
  - https://git.kernel.org/stable/c/ac79001b8e603226fab17240a79cb9ef679d3cd9
  - https://git.kernel.org/stable/c/c736ed8541605e3a25075bb1cbf8f38cb3083238
  - https://git.kernel.org/stable/c/c8af247de385ce49afabc3bf1cf4fd455c94bfe8
  - https://git.kernel.org/stable/c/d8971f410739a864c537e0ac29344a7b6c450232
  - https://git.kernel.org/stable/c/f1517721c408631f09d54c743aa70cb07fd3eebd

------------------------------------------------------------

CVE ID: CVE-2022-49847
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ethernet: ti: am65-cpsw: Fix segmentation fault at module unload

Move am65_cpsw_nuss_phylink_cleanup() call to after
am65_cpsw_nuss_cleanup_ndev() so phylink is still valid
to prevent the below Segmentation fault on module remove when
first slave link is up.

[   31.652944] Unable to handle kernel paging request at virtual address 00040008000005f4
[   31.684627] Mem abort info:
[   31.687446]   ESR = 0x0000000096000004
[   31.704614]   EC = 0x25: DABT (current EL), IL = 32 bits
[   31.720663]   SET = 0, FnV = 0
[   31.723729]   EA = 0, S1PTW = 0
[   31.740617]   FSC = 0x04: level 0 translation fault
[   31.756624] Data abort info:
[   31.759508]   ISV = 0, ISS = 0x00000004
[   31.776705]   CM = 0, WnR = 0
[   31.779695] [00040008000005f4] address between user and kernel address ranges
[   31.808644] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
[   31.814928] Modules linked in: wlcore_sdio wl18xx wlcore mac80211 libarc4 cfg80211 rfkill crct10dif_ce phy_gmii_sel ti_am65_cpsw_nuss(-) sch_fq_codel ipv6
[   31.828776] CPU: 0 PID: 1026 Comm: modprobe Not tainted 6.1.0-rc2-00012-gfabfcf7dafdb-dirty #160
[   31.837547] Hardware name: Texas Instruments AM625 (DT)
[   31.842760] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   31.849709] pc : phy_stop+0x18/0xf8
[   31.853202] lr : phylink_stop+0x38/0xf8
[   31.857031] sp : ffff80000a0839f0
[   31.860335] x29: ffff80000a0839f0 x28: ffff000000de1c80 x27: 0000000000000000
[   31.867462] x26: 0000000000000000 x25: 0000000000000000 x24: ffff80000a083b98
[   31.874589] x23: 0000000000000800 x22: 0000000000000001 x21: ffff000001bfba90
[   31.881715] x20: ffff0000015ee000 x19: 0004000800000200 x18: 0000000000000000
[   31.888842] x17: ffff800076c45000 x16: ffff800008004000 x15: 000058e39660b106
[   31.895969] x14: 0000000000000144 x13: 0000000000000144 x12: 0000000000000000
[   31.903095] x11: 000000000000275f x10: 00000000000009e0 x9 : ffff80000a0837d0
[   31.910222] x8 : ffff000000de26c0 x7 : ffff00007fbd6540 x6 : ffff00007fbd64c0
[   31.917349] x5 : ffff00007fbd0b10 x4 : ffff00007fbd0b10 x3 : ffff00007fbd3920
[   31.924476] x2 : d0a07fcff8b8d500 x1 : 0000000000000000 x0 : 0004000800000200
[   31.931603] Call trace:
[   31.934042]  phy_stop+0x18/0xf8
[   31.937177]  phylink_stop+0x38/0xf8
[   31.940657]  am65_cpsw_nuss_ndo_slave_stop+0x28/0x1e0 [ti_am65_cpsw_nuss]
[   31.947452]  __dev_close_many+0xa4/0x140
[   31.951371]  dev_close_many+0x84/0x128
[   31.955115]  unregister_netdevice_many+0x130/0x6d0
[   31.959897]  unregister_netdevice_queue+0x94/0xd8
[   31.964591]  unregister_netdev+0x24/0x38
[   31.968504]  am65_cpsw_nuss_cleanup_ndev.isra.0+0x48/0x70 [ti_am65_cpsw_nuss]
[   31.975637]  am65_cpsw_nuss_remove+0x58/0xf8 [ti_am65_cpsw_nuss]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1a0c016a4831ea29be09bbc8162d4a2a0690b4b8
  - https://git.kernel.org/stable/c/442fd1bfe599bc54d118775e9e1a4fe913e4b369

------------------------------------------------------------

CVE ID: CVE-2022-49848
Description: In the Linux kernel, the following vulnerability has been resolved:

phy: qcom-qmp-combo: fix NULL-deref on runtime resume

Commit fc64623637da ("phy: qcom-qmp-combo,usb: add support for separate
PCS_USB region") started treating the PCS_USB registers as potentially
separate from the PCS registers but used the wrong base when no PCS_USB
offset has been provided.

Fix the PCS_USB base used at runtime resume to prevent dereferencing a
NULL pointer on platforms that do not provide a PCS_USB offset (e.g.
SC7180).
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/04948e757148f870a31f4887ea2239403f516c3c
  - https://git.kernel.org/stable/c/c559a8b5cfa3db196ced0257b288f17027621348

------------------------------------------------------------

CVE ID: CVE-2022-49849
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix match incorrectly in dev_args_match_device

syzkaller found a failed assertion:

  assertion failed: (args->devid != (u64)-1) || args->missing, in fs/btrfs/volumes.c:6921

This can be triggered when we set devid to (u64)-1 by ioctl. In this
case, the match of devid will be skipped and the match of device may
succeed incorrectly.

Patch 562d7b1512f7 introduced this function which is used to match device.
This function contains two matching scenarios, we can distinguish them by
checking the value of args->missing rather than check whether args->devid
and args->uuid is default value.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0fca385d6ebc3cabb20f67bcf8a71f1448bdc001
  - https://git.kernel.org/stable/c/bc6c127c377010f136360552ebf91c2723081c1b
  - https://git.kernel.org/stable/c/c9fe4719c662e0af17eea723cf345e37719fd3c9

------------------------------------------------------------

CVE ID: CVE-2022-49850
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: fix deadlock in nilfs_count_free_blocks()

A semaphore deadlock can occur if nilfs_get_block() detects metadata
corruption while locating data blocks and a superblock writeback occurs at
the same time:

task 1                               task 2
------                               ------
* A file operation *
nilfs_truncate()
  nilfs_get_block()
    down_read(rwsem A) <--
    nilfs_bmap_lookup_contig()
      ...                            generic_shutdown_super()
                                       nilfs_put_super()
                                         * Prepare to write superblock *
                                         down_write(rwsem B) <--
                                         nilfs_cleanup_super()
      * Detect b-tree corruption *         nilfs_set_log_cursor()
      nilfs_bmap_convert_error()             nilfs_count_free_blocks()
        __nilfs_error()                        down_read(rwsem A) <--
          nilfs_set_error()
            down_write(rwsem B) <--

                           *** DEADLOCK ***

Here, nilfs_get_block() readlocks rwsem A (= NILFS_MDT(dat_inode)->mi_sem)
and then calls nilfs_bmap_lookup_contig(), but if it fails due to metadata
corruption, __nilfs_error() is called from nilfs_bmap_convert_error()
inside the lock section.

Since __nilfs_error() calls nilfs_set_error() unless the filesystem is
read-only and nilfs_set_error() attempts to writelock rwsem B (=
nilfs->ns_sem) to write back superblock exclusively, hierarchical lock
acquisition occurs in the order rwsem A -> rwsem B.

Now, if another task starts updating the superblock, it may writelock
rwsem B during the lock sequence above, and can deadlock trying to
readlock rwsem A in nilfs_count_free_blocks().

However, there is actually no need to take rwsem A in
nilfs_count_free_blocks() because it, within the lock section, only reads
a single integer data on a shared struct with
nilfs_sufile_get_ncleansegs().  This has been the case after commit
aa474a220180 ("nilfs2: add local variable to cache the number of clean
segments"), that is, even before this bug was introduced.

So, this resolves the deadlock problem by just not taking the semaphore in
nilfs_count_free_blocks().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.38, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1d4ff73062096c21b47954d2996b4df259777bda
  - https://git.kernel.org/stable/c/36ff974b0310771417c0be64b64aa221bd70d63d
  - https://git.kernel.org/stable/c/3c89ca6d3dfa6c09c515807a7a97a521f5d5147e
  - https://git.kernel.org/stable/c/8ac932a4921a96ca52f61935dbba64ea87bbd5dc
  - https://git.kernel.org/stable/c/8b4506cff6630bb474bb46a2a75c31e533a756ba
  - https://git.kernel.org/stable/c/abc082aac0d9b6b926038fc3adb7008306581be2
  - https://git.kernel.org/stable/c/cb029b54953420f7a2d65100f1c5107f14411bdc
  - https://git.kernel.org/stable/c/f0cc93080d4c09510b74ecba87fd778cca390bb1

------------------------------------------------------------

CVE ID: CVE-2022-49851
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv: fix reserved memory setup

Currently, RISC-V sets up reserved memory using the "early" copy of the
device tree. As a result, when trying to get a reserved memory region
using of_reserved_mem_lookup(), the pointer to reserved memory regions
is using the early, pre-virtual-memory address which causes a kernel
panic when trying to use the buffer's name:

 Unable to handle kernel paging request at virtual address 00000000401c31ac
 Oops [#1]
 Modules linked in:
 CPU: 0 PID: 0 Comm: swapper Not tainted 6.0.0-rc1-00001-g0d9d6953d834 #1
 Hardware name: Microchip PolarFire-SoC Icicle Kit (DT)
 epc : string+0x4a/0xea
  ra : vsnprintf+0x1e4/0x336
 epc : ffffffff80335ea0 ra : ffffffff80338936 sp : ffffffff81203be0
  gp : ffffffff812e0a98 tp : ffffffff8120de40 t0 : 0000000000000000
  t1 : ffffffff81203e28 t2 : 7265736572203a46 s0 : ffffffff81203c20
  s1 : ffffffff81203e28 a0 : ffffffff81203d22 a1 : 0000000000000000
  a2 : ffffffff81203d08 a3 : 0000000081203d21 a4 : ffffffffffffffff
  a5 : 00000000401c31ac a6 : ffff0a00ffffff04 a7 : ffffffffffffffff
  s2 : ffffffff81203d08 s3 : ffffffff81203d00 s4 : 0000000000000008
  s5 : ffffffff000000ff s6 : 0000000000ffffff s7 : 00000000ffffff00
  s8 : ffffffff80d9821a s9 : ffffffff81203d22 s10: 0000000000000002
  s11: ffffffff80d9821c t3 : ffffffff812f3617 t4 : ffffffff812f3617
  t5 : ffffffff812f3618 t6 : ffffffff81203d08
 status: 0000000200000100 badaddr: 00000000401c31ac cause: 000000000000000d
 [<ffffffff80338936>] vsnprintf+0x1e4/0x336
 [<ffffffff80055ae2>] vprintk_store+0xf6/0x344
 [<ffffffff80055d86>] vprintk_emit+0x56/0x192
 [<ffffffff80055ed8>] vprintk_default+0x16/0x1e
 [<ffffffff800563d2>] vprintk+0x72/0x80
 [<ffffffff806813b2>] _printk+0x36/0x50
 [<ffffffff8068af48>] print_reserved_mem+0x1c/0x24
 [<ffffffff808057ec>] paging_init+0x528/0x5bc
 [<ffffffff808031ae>] setup_arch+0xd0/0x592
 [<ffffffff8080070e>] start_kernel+0x82/0x73c

early_init_fdt_scan_reserved_mem() takes no arguments as it operates on
initial_boot_params, which is populated by early_init_dt_verify(). On
RISC-V, early_init_dt_verify() is called twice. Once, directly, in
setup_arch() if CONFIG_BUILTIN_DTB is not enabled and once indirectly,
very early in the boot process, by parse_dtb() when it calls
early_init_dt_scan_nodes().

This first call uses dtb_early_va to set initial_boot_params, which is
not usable later in the boot process when
early_init_fdt_scan_reserved_mem() is called. On arm64 for example, the
corresponding call to early_init_dt_scan_nodes() uses fixmap addresses
and doesn't suffer the same fate.

Move early_init_fdt_scan_reserved_mem() further along the boot sequence,
after the direct call to early_init_dt_verify() in setup_arch() so that
the names use the correct virtual memory addresses. The above supposed
that CONFIG_BUILTIN_DTB was not set, but should work equally in the case
where it is - unflatted_and_copy_device_tree() also updates
initial_boot_params.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/50e63dd8ed92045eb70a72d7ec725488320fb68b
  - https://git.kernel.org/stable/c/518e49f0590de66555503aabe199ba8d3f2e24ac
  - https://git.kernel.org/stable/c/93598deb101540c4f9e7de15099ea8255b965fc2
  - https://git.kernel.org/stable/c/94ab8f88feb75e3b1486102c0c9c550f37d9d137

------------------------------------------------------------

CVE ID: CVE-2022-49852
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv: process: fix kernel info leakage

thread_struct's s[12] may contain random kernel memory content, which
may be finally leaked to userspace. This is a security hole. Fix it
by clearing the s[12] array in thread_struct when fork.

As for kthread case, it's better to clear the s[12] array as well.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/358a68f98304b40b201ba5afe94c20355aa3dc68
  - https://git.kernel.org/stable/c/6510c78490c490a6636e48b61eeaa6fb65981f4b
  - https://git.kernel.org/stable/c/c4601d30f7d989b4f354df899ab85b5f7a750d30
  - https://git.kernel.org/stable/c/c5c0b3167537793a7cf936fb240366eefd2fc7fb
  - https://git.kernel.org/stable/c/cc36c7fa5d9384602529ba3eea8c5daee7be4dbc
  - https://git.kernel.org/stable/c/e56d18a976dda653194218df6d40d8122c775712

------------------------------------------------------------

CVE ID: CVE-2022-49853
Description: In the Linux kernel, the following vulnerability has been resolved:

net: macvlan: fix memory leaks of macvlan_common_newlink

kmemleak reports memory leaks in macvlan_common_newlink, as follows:

 ip link add link eth0 name .. type macvlan mode source macaddr add
 <MAC-ADDR>

kmemleak reports:

unreferenced object 0xffff8880109bb140 (size 64):
  comm "ip", pid 284, jiffies 4294986150 (age 430.108s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 b8 aa 5a 12 80 88 ff ff  ..........Z.....
    80 1b fa 0d 80 88 ff ff 1e ff ac af c7 c1 6b 6b  ..............kk
  backtrace:
    [<ffffffff813e06a7>] kmem_cache_alloc_trace+0x1c7/0x300
    [<ffffffff81b66025>] macvlan_hash_add_source+0x45/0xc0
    [<ffffffff81b66a67>] macvlan_changelink_sources+0xd7/0x170
    [<ffffffff81b6775c>] macvlan_common_newlink+0x38c/0x5a0
    [<ffffffff81b6797e>] macvlan_newlink+0xe/0x20
    [<ffffffff81d97f8f>] __rtnl_newlink+0x7af/0xa50
    [<ffffffff81d98278>] rtnl_newlink+0x48/0x70
    ...

In the scenario where the macvlan mode is configured as 'source',
macvlan_changelink_sources() will be execured to reconfigure list of
remote source mac addresses, at the same time, if register_netdevice()
return an error, the resource generated by macvlan_changelink_sources()
is not cleaned up.

Using this patch, in the case of an error, it will execute
macvlan_flush_sources() to ensure that the resource is cleaned up.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/21d3a8b6a1e39e7529ce9de07316ee13a63f305b
  - https://git.kernel.org/stable/c/23569b5652ee8e8e55a12f7835f59af6f3cefc30
  - https://git.kernel.org/stable/c/685e73e3f7a9fb75cbf049a9d0b7c45cc6b57b2e
  - https://git.kernel.org/stable/c/956e0216a19994443c90ba2ea6b0b284c9c4f9cb
  - https://git.kernel.org/stable/c/9ea003c4671b2fc455320ecf6d4a43b0a3c1878a
  - https://git.kernel.org/stable/c/9f288e338be206713d79b29144c27fca4503c39b
  - https://git.kernel.org/stable/c/a81b44d1df1f07f00c0dcc0a0b3d2fa24a46289e
  - https://git.kernel.org/stable/c/a8d67367ab33604326cc37ab44fd1801bf5691ba

------------------------------------------------------------

CVE ID: CVE-2022-49854
Description: In the Linux kernel, the following vulnerability has been resolved:

mctp: Fix an error handling path in mctp_init()

If mctp_neigh_init() return error, the routes resources should
be released in the error handling path. Otherwise some resources
leak.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/216c83222d2eb24b0e63df56e8740b02c33286e8
  - https://git.kernel.org/stable/c/49d8a6e24a3496d86e8d8ae748375df984fb6d6f
  - https://git.kernel.org/stable/c/d4072058af4fd8fb4658e7452289042a406a9398

------------------------------------------------------------

CVE ID: CVE-2022-49855
Description: In the Linux kernel, the following vulnerability has been resolved:

net: wwan: iosm: fix memory leak in ipc_pcie_read_bios_cfg

ipc_pcie_read_bios_cfg() is using the acpi_evaluate_dsm() to
obtain the wwan power state configuration from BIOS but is
not freeing the acpi_object. The acpi_evaluate_dsm() returned
acpi_object to be freed.

Free the acpi_object after use.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/13b1ea861e8aeb701bcfbfe436b943efa2d44029
  - https://git.kernel.org/stable/c/7560ceef4d2832a67e8781d924e129c7f542376f
  - https://git.kernel.org/stable/c/d38a648d2d6cc7bee11c6f533ff9426a00c2a74c

------------------------------------------------------------

CVE ID: CVE-2022-49857
Description: In the Linux kernel, the following vulnerability has been resolved:

net: marvell: prestera: fix memory leak in prestera_rxtx_switch_init()

When prestera_sdma_switch_init() failed, the memory pointed to by
sw->rxtx isn't released. Fix it. Only be compiled, not be tested.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/31e5084ac6876e52dbb0a1cc4fc18b6c79979f31
  - https://git.kernel.org/stable/c/409731df6310a33f4d0a3ef594d2410cdcd637f2
  - https://git.kernel.org/stable/c/519b58bbfa825f042fcf80261cc18e1e35f85ffd
  - https://git.kernel.org/stable/c/5333cf1b7f6861912aff6263978d4781f9858e47

------------------------------------------------------------

CVE ID: CVE-2022-49858
Description: In the Linux kernel, the following vulnerability has been resolved:

octeontx2-pf: Fix SQE threshold checking

Current way of checking available SQE count which is based on
HW updated SQB count could result in driver submitting an SQE
even before CQE for the previously transmitted SQE at the same
index is processed in NAPI resulting losing SKB pointers,
hence a leak. Fix this by checking a consumer index which
is updated once CQE is processed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/015e3c0a3b16193aab23beefe4719484b9984c2d
  - https://git.kernel.org/stable/c/f0dfc4c88ef39be0ba736aa0ce6119263fc19aeb

------------------------------------------------------------

CVE ID: CVE-2022-49859
Description: In the Linux kernel, the following vulnerability has been resolved:

net: lapbether: fix issue of invalid opcode in lapbeth_open()

If lapb_register() failed when lapb device goes to up for the first time,
the NAPI is not disabled. As a result, the invalid opcode issue is
reported when the lapb device goes to up for the second time.

The stack info is as follows:
[ 1958.311422][T11356] kernel BUG at net/core/dev.c:6442!
[ 1958.312206][T11356] invalid opcode: 0000 [#1] PREEMPT SMP KASAN
[ 1958.315979][T11356] RIP: 0010:napi_enable+0x16a/0x1f0
[ 1958.332310][T11356] Call Trace:
[ 1958.332817][T11356]  <TASK>
[ 1958.336135][T11356]  lapbeth_open+0x18/0x90
[ 1958.337446][T11356]  __dev_open+0x258/0x490
[ 1958.341672][T11356]  __dev_change_flags+0x4d4/0x6a0
[ 1958.345325][T11356]  dev_change_flags+0x93/0x160
[ 1958.346027][T11356]  devinet_ioctl+0x1276/0x1bf0
[ 1958.346738][T11356]  inet_ioctl+0x1c8/0x2d0
[ 1958.349638][T11356]  sock_ioctl+0x5d1/0x750
[ 1958.356059][T11356]  __x64_sys_ioctl+0x3ec/0x1790
[ 1958.365594][T11356]  do_syscall_64+0x35/0x80
[ 1958.366239][T11356]  entry_SYSCALL_64_after_hwframe+0x46/0xb0
[ 1958.377381][T11356]  </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3faf7e14ec0c3462c2d747fa6793b8645d1391df
  - https://git.kernel.org/stable/c/4689bd3a1b23a1bd917899e63b81bca2ccdfab45
  - https://git.kernel.org/stable/c/ed4940050a7ce7fc2ccd51db580ef1ade64290b1

------------------------------------------------------------

CVE ID: CVE-2022-49860
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: ti: k3-udma-glue: fix memory leak when register device fail

If device_register() fails, it should call put_device() to give
up reference, the name allocated in dev_set_name() can be freed
in callback function kobject_cleanup().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/025eab5189fc7ee223ae9b4bc49d7df196543e53
  - https://git.kernel.org/stable/c/1dd27541aa2b95bde71bddd43d73f9c16d73272c
  - https://git.kernel.org/stable/c/ac2b9f34f02052709aea7b34bb2a165e1853eb41

------------------------------------------------------------

CVE ID: CVE-2022-49861
Description: In the Linux kernel, the following vulnerability has been resolved:

dmaengine: mv_xor_v2: Fix a resource leak in mv_xor_v2_remove()

A clk_prepare_enable() call in the probe is not balanced by a corresponding
clk_disable_unprepare() in the remove function.

Add the missing call.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.104, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.45, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.16, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/04f2cc56d80a1ac058045a7835c5bfd910f17863
  - https://git.kernel.org/stable/c/081195d17a0c4c636da2b869bd5809d42e8cbb13
  - https://git.kernel.org/stable/c/0b7ee3d50f32d277bf024b4ddb4de54da43a3025
  - https://git.kernel.org/stable/c/1d84887327659c58a6637060ac8c50c3a952a163
  - https://git.kernel.org/stable/c/20479886b40c0ed4864a5fc8490a1f6b70cccf1b
  - https://git.kernel.org/stable/c/4b6641c3a2ba95ddcfecec263b4a5e572a4b0641
  - https://git.kernel.org/stable/c/992e966caf57e00855edbd79f19d911809732a69
  - https://git.kernel.org/stable/c/a1cb72e20a64a3c83f9b4ee993fbf97e4c1d7714

------------------------------------------------------------

CVE ID: CVE-2022-49862
Description: In the Linux kernel, the following vulnerability has been resolved:

tipc: fix the msg->req tlv len check in tipc_nl_compat_name_table_dump_header

This is a follow-up for commit 974cb0e3e7c9 ("tipc: fix uninit-value
in tipc_nl_compat_name_table_dump") where it should have type casted
sizeof(..) to int to work when TLV_GET_DATA_LEN() returns a negative
value.

syzbot reported a call trace because of it:

  BUG: KMSAN: uninit-value in ...
   tipc_nl_compat_name_table_dump+0x841/0xea0 net/tipc/netlink_compat.c:934
   __tipc_nl_compat_dumpit+0xab2/0x1320 net/tipc/netlink_compat.c:238
   tipc_nl_compat_dumpit+0x991/0xb50 net/tipc/netlink_compat.c:321
   tipc_nl_compat_recv+0xb6e/0x1640 net/tipc/netlink_compat.c:1324
   genl_family_rcv_msg_doit net/netlink/genetlink.c:731 [inline]
   genl_family_rcv_msg net/netlink/genetlink.c:775 [inline]
   genl_rcv_msg+0x103f/0x1260 net/netlink/genetlink.c:792
   netlink_rcv_skb+0x3a5/0x6c0 net/netlink/af_netlink.c:2501
   genl_rcv+0x3c/0x50 net/netlink/genetlink.c:803
   netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
   netlink_unicast+0xf3b/0x1270 net/netlink/af_netlink.c:1345
   netlink_sendmsg+0x1288/0x1440 net/netlink/af_netlink.c:1921
   sock_sendmsg_nosec net/socket.c:714 [inline]
   sock_sendmsg net/socket.c:734 [inline]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.172, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.152, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.95, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.17, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20.4, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/082707d3df191bf5bb8801d43e4ce3dea39ca173
  - https://git.kernel.org/stable/c/1c075b192fe41030457cd4a5f7dea730412bca40
  - https://git.kernel.org/stable/c/301caa06091af4d5cf056ac8249cbda4e6029c6a
  - https://git.kernel.org/stable/c/36769b9477491a7af6635863bd950309c1e1b96c
  - https://git.kernel.org/stable/c/55a253a6753a603e80b95932ca971ba514aa6ce7
  - https://git.kernel.org/stable/c/6cee2c60bd168279852ac7dbe54c2b70d1028644
  - https://git.kernel.org/stable/c/a0ead1d648df9c456baec832b494513ef405949a
  - https://git.kernel.org/stable/c/f31dd158580940938f77514b87337a777520185a

------------------------------------------------------------

CVE ID: CVE-2022-49863
Description: In the Linux kernel, the following vulnerability has been resolved:

can: af_can: fix NULL pointer dereference in can_rx_register()

It causes NULL pointer dereference when testing as following:
(a) use syscall(__NR_socket, 0x10ul, 3ul, 0) to create netlink socket.
(b) use syscall(__NR_sendmsg, ...) to create bond link device and vxcan
    link device, and bind vxcan device to bond device (can also use
    ifenslave command to bind vxcan device to bond device).
(c) use syscall(__NR_socket, 0x1dul, 3ul, 1) to create CAN socket.
(d) use syscall(__NR_bind, ...) to bind the bond device to CAN socket.

The bond device invokes the can-raw protocol registration interface to
receive CAN packets. However, ml_priv is not allocated to the dev,
dev_rcv_lists is assigned to NULL in can_rx_register(). In this case,
it will occur the NULL pointer dereference issue.

The following is the stack information:
BUG: kernel NULL pointer dereference, address: 0000000000000008
PGD 122a4067 P4D 122a4067 PUD 1223c067 PMD 0
Oops: 0000 [#1] PREEMPT SMP
RIP: 0010:can_rx_register+0x12d/0x1e0
Call Trace:
<TASK>
raw_enable_filters+0x8d/0x120
raw_enable_allfilters+0x3b/0x130
raw_bind+0x118/0x4f0
__sys_bind+0x163/0x1a0
__x64_sys_bind+0x1e/0x30
do_syscall_64+0x35/0x80
entry_SYSCALL_64_after_hwframe+0x63/0xcd
</TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.110, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.28, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11.12, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.9, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.9, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.9, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.9, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/261178a1c2623077d62e374a75c195e6c99a6f05
  - https://git.kernel.org/stable/c/8aa59e355949442c408408c2d836e561794c40a1
  - https://git.kernel.org/stable/c/a8055677b054bc2bb78beb1080fdc2dc5158c2fe
  - https://git.kernel.org/stable/c/afab4655750fcb3fca359bc7d7214e3d634cdf9c
  - https://git.kernel.org/stable/c/d68fa77ee3d03bad6fe84e89759ddf7005f9e9c6

------------------------------------------------------------

CVE ID: CVE-2022-49864
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Fix NULL pointer dereference in svm_migrate_to_ram()

./drivers/gpu/drm/amd/amdkfd/kfd_migrate.c:985:58-62: ERROR: p is NULL but dereferenced.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3c1bb6187e566143f15dbf0367ae671584aead5b
  - https://git.kernel.org/stable/c/5b994354af3cab770bf13386469c5725713679af
  - https://git.kernel.org/stable/c/613d5a9a440828970f1543b962779401ac2c9c62

------------------------------------------------------------

CVE ID: CVE-2022-49865
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: addrlabel: fix infoleak when sending struct ifaddrlblmsg to network

When copying a `struct ifaddrlblmsg` to the network, __ifal_reserved
remained uninitialized, resulting in a 1-byte infoleak:

  BUG: KMSAN: kernel-network-infoleak in __netdev_start_xmit ./include/linux/netdevice.h:4841
   __netdev_start_xmit ./include/linux/netdevice.h:4841
   netdev_start_xmit ./include/linux/netdevice.h:4857
   xmit_one net/core/dev.c:3590
   dev_hard_start_xmit+0x1dc/0x800 net/core/dev.c:3606
   __dev_queue_xmit+0x17e8/0x4350 net/core/dev.c:4256
   dev_queue_xmit ./include/linux/netdevice.h:3009
   __netlink_deliver_tap_skb net/netlink/af_netlink.c:307
   __netlink_deliver_tap+0x728/0xad0 net/netlink/af_netlink.c:325
   netlink_deliver_tap net/netlink/af_netlink.c:338
   __netlink_sendskb net/netlink/af_netlink.c:1263
   netlink_sendskb+0x1d9/0x200 net/netlink/af_netlink.c:1272
   netlink_unicast+0x56d/0xf50 net/netlink/af_netlink.c:1360
   nlmsg_unicast ./include/net/netlink.h:1061
   rtnl_unicast+0x5a/0x80 net/core/rtnetlink.c:758
   ip6addrlbl_get+0xfad/0x10f0 net/ipv6/addrlabel.c:628
   rtnetlink_rcv_msg+0xb33/0x1570 net/core/rtnetlink.c:6082
  ...
  Uninit was created at:
   slab_post_alloc_hook+0x118/0xb00 mm/slab.h:742
   slab_alloc_node mm/slub.c:3398
   __kmem_cache_alloc_node+0x4f2/0x930 mm/slub.c:3437
   __do_kmalloc_node mm/slab_common.c:954
   __kmalloc_node_track_caller+0x117/0x3d0 mm/slab_common.c:975
   kmalloc_reserve net/core/skbuff.c:437
   __alloc_skb+0x27a/0xab0 net/core/skbuff.c:509
   alloc_skb ./include/linux/skbuff.h:1267
   nlmsg_new ./include/net/netlink.h:964
   ip6addrlbl_get+0x490/0x10f0 net/ipv6/addrlabel.c:608
   rtnetlink_rcv_msg+0xb33/0x1570 net/core/rtnetlink.c:6082
   netlink_rcv_skb+0x299/0x550 net/netlink/af_netlink.c:2540
   rtnetlink_rcv+0x26/0x30 net/core/rtnetlink.c:6109
   netlink_unicast_kernel net/netlink/af_netlink.c:1319
   netlink_unicast+0x9ab/0xf50 net/netlink/af_netlink.c:1345
   netlink_sendmsg+0xebc/0x10f0 net/netlink/af_netlink.c:1921
  ...

This patch ensures that the reserved field is always initialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0f85b7ae7c4b5d7b4bbf7ac653a733c181a8a2bf
  - https://git.kernel.org/stable/c/2acb2779b147decd300c117683d5a32ce61c75d6
  - https://git.kernel.org/stable/c/49e92ba5ecd7d72ba369dde2ccff738edd028a47
  - https://git.kernel.org/stable/c/568a47ff756f913e8b374c2af9d22cd2c772c744
  - https://git.kernel.org/stable/c/58cd7fdc8c1e6c7873acc08f190069fed88d1c12
  - https://git.kernel.org/stable/c/6d26d0587abccb9835382a0b53faa7b9b1cd83e3
  - https://git.kernel.org/stable/c/a033b86c7f7621fde31f0364af8986f43b44914f
  - https://git.kernel.org/stable/c/c23fb2c82267638f9d206cb96bb93e1f93ad7828

------------------------------------------------------------

CVE ID: CVE-2022-49866
Description: In the Linux kernel, the following vulnerability has been resolved:

net: wwan: mhi: fix memory leak in mhi_mbim_dellink

MHI driver registers network device without setting the
needs_free_netdev flag, and does NOT call free_netdev() when
unregisters network device, which causes a memory leak.

This patch sets needs_free_netdev to true when registers
network device, which makes netdev subsystem call free_netdev()
automatically after unregister_netdevice().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2845bc9070cef0c651987487d84d4813d64675dd
  - https://git.kernel.org/stable/c/3cd3ffe952f78ec5dadf300cb58d4b38a0c0106d
  - https://git.kernel.org/stable/c/668205b9c9f94d5ed6ab00cce9a46a654c2b5d16

------------------------------------------------------------

CVE ID: CVE-2022-49867
Description: In the Linux kernel, the following vulnerability has been resolved:

net: wwan: iosm: fix memory leak in ipc_wwan_dellink

IOSM driver registers network device without setting the
needs_free_netdev flag, and does NOT call free_netdev() when
unregisters network device, which causes a memory leak.

This patch sets needs_free_netdev to true when registers
network device, which makes netdev subsystem call free_netdev()
automatically after unregister_netdevice().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/128514b51a5ba2c82f9e4a106f1c10423907618a
  - https://git.kernel.org/stable/c/2ce2348c2858d723f7fe389dead9b43b08e0944e
  - https://git.kernel.org/stable/c/f25caaca424703d5a0607310f0452f978f1f78d9

------------------------------------------------------------

CVE ID: CVE-2022-49868
Description: In the Linux kernel, the following vulnerability has been resolved:

phy: ralink: mt7621-pci: add sentinel to quirks table

With mt7621 soc_dev_attr fixed to register the soc as a device,
kernel will experience an oops in soc_device_match_attr

This quirk test was introduced in the staging driver in
commit 9445ccb3714c ("staging: mt7621-pci-phy: add quirks for 'E2'
revision using 'soc_device_attribute'"). The staging driver was removed,
and later re-added in commit d87da32372a0 ("phy: ralink: Add PHY driver
for MT7621 PCIe PHY") for kernel 5.11
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/500bcd3a99eae84412067c3b9e7ffba1c66e6383
  - https://git.kernel.org/stable/c/819b885cd886c193782891c4f51bbcab3de119a4
  - https://git.kernel.org/stable/c/d539cfd1202d66c2dcea383f1d96835ae72d5809

------------------------------------------------------------

CVE ID: CVE-2022-49869
Description: In the Linux kernel, the following vulnerability has been resolved:

bnxt_en: Fix possible crash in bnxt_hwrm_set_coal()

During the error recovery sequence, the rtnl_lock is not held for the
entire duration and some datastructures may be freed during the sequence.
Check for the BNXT_STATE_OPEN flag instead of netif_running() to ensure
that the device is fully operational before proceeding to reconfigure
the coalescing settings.

This will fix a possible crash like this:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000000
PGD 0 P4D 0
Oops: 0000 [#1] SMP NOPTI
CPU: 10 PID: 181276 Comm: ethtool Kdump: loaded Tainted: G          IOE    --------- -  - 4.18.0-348.el8.x86_64 #1
Hardware name: Dell Inc. PowerEdge R740/0F9N89, BIOS 2.3.10 08/15/2019
RIP: 0010:bnxt_hwrm_set_coal+0x1fb/0x2a0 [bnxt_en]
Code: c2 66 83 4e 22 08 66 89 46 1c e8 10 cb 00 00 41 83 c6 01 44 39 b3 68 01 00 00 0f 8e a3 00 00 00 48 8b 93 c8 00 00 00 49 63 c6 <48> 8b 2c c2 48 8b 85 b8 02 00 00 48 85 c0 74 2e 48 8b 74 24 08 f6
RSP: 0018:ffffb11c8dcaba50 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff8d168a8b0ac0 RCX: 00000000000000c5
RDX: 0000000000000000 RSI: ffff8d162f72c000 RDI: ffff8d168a8b0b28
RBP: 0000000000000000 R08: b6e1f68a12e9a7eb R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000037 R12: ffff8d168a8b109c
R13: ffff8d168a8b10aa R14: 0000000000000000 R15: ffffffffc01ac4e0
FS:  00007f3852e4c740(0000) GS:ffff8d24c0080000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000000 CR3: 000000041b3ee003 CR4: 00000000007706e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
PKRU: 55555554
Call Trace:
 ethnl_set_coalesce+0x3ce/0x4c0
 genl_family_rcv_msg_doit.isra.15+0x10f/0x150
 genl_family_rcv_msg+0xb3/0x160
 ? coalesce_fill_reply+0x480/0x480
 genl_rcv_msg+0x47/0x90
 ? genl_family_rcv_msg+0x160/0x160
 netlink_rcv_skb+0x4c/0x120
 genl_rcv+0x24/0x40
 netlink_unicast+0x196/0x230
 netlink_sendmsg+0x204/0x3d0
 sock_sendmsg+0x4c/0x50
 __sys_sendto+0xee/0x160
 ? syscall_trace_enter+0x1d3/0x2c0
 ? __audit_syscall_exit+0x249/0x2a0
 __x64_sys_sendto+0x24/0x30
 do_syscall_64+0x5b/0x1a0
 entry_SYSCALL_64_after_hwframe+0x65/0xca
RIP: 0033:0x7f38524163bb
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/38147073c96dce8c7e142ce0e5f305a420a729ba
  - https://git.kernel.org/stable/c/6d81ea3765dfa6c8a20822613c81edad1c4a16a0
  - https://git.kernel.org/stable/c/7781e32984cde65549bedc3201537e253297c98d
  - https://git.kernel.org/stable/c/a5a05fbef4a0dfe45fe03b2f1d02ba23aebf5384
  - https://git.kernel.org/stable/c/ac257c43fa615d22180916074feed803b8bb8cb0

------------------------------------------------------------

CVE ID: CVE-2022-49870
Description: In the Linux kernel, the following vulnerability has been resolved:

capabilities: fix undefined behavior in bit shift for CAP_TO_MASK

Shifting signed 32-bit value by 31 bits is undefined, so changing
significant bit to unsigned. The UBSAN warning calltrace like below:

UBSAN: shift-out-of-bounds in security/commoncap.c:1252:2
left shift of 1 by 31 places cannot be represented in type 'int'
Call Trace:
 <TASK>
 dump_stack_lvl+0x7d/0xa5
 dump_stack+0x15/0x1b
 ubsan_epilogue+0xe/0x4e
 __ubsan_handle_shift_out_of_bounds+0x1e7/0x20c
 cap_task_prctl+0x561/0x6f0
 security_task_prctl+0x5a/0xb0
 __x64_sys_prctl+0x61/0x8f0
 do_syscall_64+0x58/0x80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/151dc8087b5609e53b069c068e3f3ee100efa586
  - https://git.kernel.org/stable/c/27bdb134c043ff32c459d98f16550d0ffa0b3c34
  - https://git.kernel.org/stable/c/46653972e3ea64f79e7f8ae3aa41a4d3fdb70a13
  - https://git.kernel.org/stable/c/5661f111a1616ac105ec8cec81bff99b60f847ac
  - https://git.kernel.org/stable/c/5b79fa628e2ab789e629a83cd211ef9b4c1a593e
  - https://git.kernel.org/stable/c/65b0bc7a0690861812ade523d19f82688ab819dc
  - https://git.kernel.org/stable/c/dbaab08c8677d598244d21afb7818e44e1c5d826
  - https://git.kernel.org/stable/c/fcbd2b336834bd24e1d9454ad5737856470c10d7

------------------------------------------------------------

CVE ID: CVE-2022-49871
Description: In the Linux kernel, the following vulnerability has been resolved:

net: tun: Fix memory leaks of napi_get_frags

kmemleak reports after running test_progs:

unreferenced object 0xffff8881b1672dc0 (size 232):
  comm "test_progs", pid 394388, jiffies 4354712116 (age 841.975s)
  hex dump (first 32 bytes):
    e0 84 d7 a8 81 88 ff ff 80 2c 67 b1 81 88 ff ff  .........,g.....
    00 40 c5 9b 81 88 ff ff 00 00 00 00 00 00 00 00  .@..............
  backtrace:
    [<00000000c8f01748>] napi_skb_cache_get+0xd4/0x150
    [<0000000041c7fc09>] __napi_build_skb+0x15/0x50
    [<00000000431c7079>] __napi_alloc_skb+0x26e/0x540
    [<000000003ecfa30e>] napi_get_frags+0x59/0x140
    [<0000000099b2199e>] tun_get_user+0x183d/0x3bb0 [tun]
    [<000000008a5adef0>] tun_chr_write_iter+0xc0/0x1b1 [tun]
    [<0000000049993ff4>] do_iter_readv_writev+0x19f/0x320
    [<000000008f338ea2>] do_iter_write+0x135/0x630
    [<000000008a3377a4>] vfs_writev+0x12e/0x440
    [<00000000a6b5639a>] do_writev+0x104/0x280
    [<00000000ccf065d8>] do_syscall_64+0x3b/0x90
    [<00000000d776e329>] entry_SYSCALL_64_after_hwframe+0x63/0xcd

The issue occurs in the following scenarios:
tun_get_user()
  napi_gro_frags()
    napi_frags_finish()
      case GRO_NORMAL:
        gro_normal_one()
          list_add_tail(&skb->list, &napi->rx_list);
          <-- While napi->rx_count < READ_ONCE(gro_normal_batch),
          <-- gro_normal_list() is not called, napi->rx_list is not empty
  <-- not ask to complete the gro work, will cause memory leaks in
  <-- following tun_napi_del()
...
tun_napi_del()
  netif_napi_del()
    __netif_napi_del()
    <-- &napi->rx_list is not empty, which caused memory leaks

To fix, add napi_complete() after napi_gro_frags().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1118b2049d77ca0b505775fc1a8d1909cf19a7ec
  - https://git.kernel.org/stable/c/223ef6a94e52331a6a7ef31e59921e0e82d2d40a
  - https://git.kernel.org/stable/c/3401f964028ac941425b9b2c8ff8a022539ef44a
  - https://git.kernel.org/stable/c/8b12a020b20a78f62bedc50f26db3bf4fadf8cb9
  - https://git.kernel.org/stable/c/a4f73f6adc53fd7a3f9771cbc89a03ef39b0b755
  - https://git.kernel.org/stable/c/d7569302a7a52a9305d2fb054df908ff985553bb

------------------------------------------------------------

CVE ID: CVE-2022-49872
Description: In the Linux kernel, the following vulnerability has been resolved:

net: gso: fix panic on frag_list with mixed head alloc types

Since commit 3dcbdb134f32 ("net: gso: Fix skb_segment splat when
splitting gso_size mangled skb having linear-headed frag_list"), it is
allowed to change gso_size of a GRO packet. However, that commit assumes
that "checking the first list_skb member suffices; i.e if either of the
list_skb members have non head_frag head, then the first one has too".

It turns out this assumption does not hold. We've seen BUG_ON being hit
in skb_segment when skbs on the frag_list had differing head_frag with
the vmxnet3 driver. This happens because __netdev_alloc_skb and
__napi_alloc_skb can return a skb that is page backed or kmalloced
depending on the requested size. As the result, the last small skb in
the GRO packet can be kmalloced.

There are three different locations where this can be fixed:

(1) We could check head_frag in GRO and not allow GROing skbs with
    different head_frag. However, that would lead to performance
    regression on normal forward paths with unmodified gso_size, where
    !head_frag in the last packet is not a problem.

(2) Set a flag in bpf_skb_net_grow and bpf_skb_net_shrink indicating
    that NETIF_F_SG is undesirable. That would need to eat a bit in
    sk_buff. Furthermore, that flag can be unset when all skbs on the
    frag_list are page backed. To retain good performance,
    bpf_skb_net_grow/shrink would have to walk the frag_list.

(3) Walk the frag_list in skb_segment when determining whether
    NETIF_F_SG should be cleared. This of course slows things down.

This patch implements (3). To limit the performance impact in
skb_segment, the list is walked only for skbs with SKB_GSO_DODGY set
that have gso_size changed. Normal paths thus will not hit it.

We could check only the last skb but since we need to walk the whole
list anyway, let's stay on the safe side.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a9f56e525ea871d3950b90076912f5c7494f00f
  - https://git.kernel.org/stable/c/50868de7dc4e7f0fcadd6029f32bf4387c102ee6
  - https://git.kernel.org/stable/c/5876b7f249a1ecbbcc8e35072c3828d6526d1c3a
  - https://git.kernel.org/stable/c/598d9e30927b15731e83797fbd700ecf399f42dd
  - https://git.kernel.org/stable/c/65ad047fd83502447269fda8fd26c99077a9af47
  - https://git.kernel.org/stable/c/9e4b7a99a03aefd37ba7bb1f022c8efab5019165
  - https://git.kernel.org/stable/c/ad25a115f50800c6847e0d841c5c7992a9f7c1b3
  - https://git.kernel.org/stable/c/bd5362e58721e4d0d1a37796593bd6e51536ce7a

------------------------------------------------------------

CVE ID: CVE-2022-49873
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix wrong reg type conversion in release_reference()

Some helper functions will allocate memory. To avoid memory leaks, the
verifier requires the eBPF program to release these memories by calling
the corresponding helper functions.

When a resource is released, all pointer registers corresponding to the
resource should be invalidated. The verifier use release_references() to
do this job, by apply  __mark_reg_unknown() to each relevant register.

It will give these registers the type of SCALAR_VALUE. A register that
will contain a pointer value at runtime, but of type SCALAR_VALUE, which
may allow the unprivileged user to get a kernel pointer by storing this
register into a map.

Using __mark_reg_not_init() while NOT allow_ptr_leaks can mitigate this
problem.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/466ce46f251dfb259a8cbaa895ab9edd6fb56240
  - https://git.kernel.org/stable/c/ae5ccad6c711db0f2ca1231be051935dd128b8f5
  - https://git.kernel.org/stable/c/cedd4f01f67be94735f15123158f485028571037
  - https://git.kernel.org/stable/c/f1db20814af532f85e091231223e5e4818e8464b

------------------------------------------------------------

CVE ID: CVE-2022-49874
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: hyperv: fix possible memory leak in mousevsc_probe()

If hid_add_device() returns error, it should call hid_destroy_device()
to free hid_dev which is allocated in hid_allocate_device().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.3, Last Version (Excluding): 4.9.334
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.300
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/249b743801c00542e9324f87b380032e957a43e8
  - https://git.kernel.org/stable/c/5ad95d71344b7ffec360d62591633b3c465dc049
  - https://git.kernel.org/stable/c/5f3aba6566b866f5b0a4916f0b2e8a6ae66a6451
  - https://git.kernel.org/stable/c/8597b59e3d22b27849bd3e4f92a3d466774bfb04
  - https://git.kernel.org/stable/c/a6d2fb1874c52ace1f5cf1966ee558829c5c19b6
  - https://git.kernel.org/stable/c/b5bcb94b0954a026bbd671741fdb00e7141f9c91
  - https://git.kernel.org/stable/c/e29289d0d8193fca6d2c1f0a1de75cfc80edec00
  - https://git.kernel.org/stable/c/ed75d1a1c31a0cae8ecc8bcea710b25c0be68da0

------------------------------------------------------------

CVE ID: CVE-2022-49875
Description: In the Linux kernel, the following vulnerability has been resolved:

bpftool: Fix NULL pointer dereference when pin {PROG, MAP, LINK} without FILE

When using bpftool to pin {PROG, MAP, LINK} without FILE,
segmentation fault will occur. The reson is that the lack
of FILE will cause strlen to trigger NULL pointer dereference.
The corresponding stacktrace is shown below:

do_pin
  do_pin_any
    do_pin_fd
      mount_bpffs_for_pin
        strlen(name) <- NULL pointer dereference

Fix it by adding validation to the common process.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.7, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/34de8e6e0e1f66e431abf4123934a2581cb5f133
  - https://git.kernel.org/stable/c/6dcdd1b68b7f9333d48d48fc77b75e7f235f6a4a
  - https://git.kernel.org/stable/c/8c80b2fca4112d724dde477aed13f7b0510a2792
  - https://git.kernel.org/stable/c/da5161ba94c5e9182c301dd4f09c94f715c068bd

------------------------------------------------------------

CVE ID: CVE-2022-49876
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mac80211: fix general-protection-fault in ieee80211_subif_start_xmit()

When device is running and the interface status is changed, the gpf issue
is triggered. The problem triggering process is as follows:
Thread A:                           Thread B
ieee80211_runtime_change_iftype()   process_one_work()
    ...                                 ...
    ieee80211_do_stop()                 ...
    ...                                 ...
        sdata->bss = NULL               ...
        ...                             ieee80211_subif_start_xmit()
                                            ieee80211_multicast_to_unicast
                                    //!sdata->bss->multicast_to_unicast
                                      cause gpf issue

When the interface status is changed, the sending queue continues to send
packets. After the bss is set to NULL, the bss is accessed. As a result,
this causes a general-protection-fault issue.

The following is the stack information:
general protection fault, probably for non-canonical address
0xdffffc000000002f: 0000 [#1] PREEMPT SMP KASAN
KASAN: null-ptr-deref in range [0x0000000000000178-0x000000000000017f]
Workqueue: mld mld_ifc_work
RIP: 0010:ieee80211_subif_start_xmit+0x25b/0x1310
Call Trace:
<TASK>
dev_hard_start_xmit+0x1be/0x990
__dev_queue_xmit+0x2c9a/0x3b60
ip6_finish_output2+0xf92/0x1520
ip6_finish_output+0x6af/0x11e0
ip6_output+0x1ed/0x540
mld_sendpack+0xa09/0xe70
mld_ifc_work+0x71c/0xdb0
process_one_work+0x9bf/0x1710
worker_thread+0x665/0x1080
kthread+0x2e4/0x3a0
ret_from_fork+0x1f/0x30
</TASK>
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/03eb68c72cee249aeb7af7d04a83c033aca3d6d9
  - https://git.kernel.org/stable/c/780854186946e0de2be192ee7fa5125666533b3a

------------------------------------------------------------

CVE ID: CVE-2022-49877
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, sockmap: Fix the sk->sk_forward_alloc warning of sk_stream_kill_queues

When running `test_sockmap` selftests, the following warning appears:

  WARNING: CPU: 2 PID: 197 at net/core/stream.c:205 sk_stream_kill_queues+0xd3/0xf0
  Call Trace:
  <TASK>
  inet_csk_destroy_sock+0x55/0x110
  tcp_rcv_state_process+0xd28/0x1380
  ? tcp_v4_do_rcv+0x77/0x2c0
  tcp_v4_do_rcv+0x77/0x2c0
  __release_sock+0x106/0x130
  __tcp_close+0x1a7/0x4e0
  tcp_close+0x20/0x70
  inet_release+0x3c/0x80
  __sock_release+0x3a/0xb0
  sock_close+0x14/0x20
  __fput+0xa3/0x260
  task_work_run+0x59/0xb0
  exit_to_user_mode_prepare+0x1b3/0x1c0
  syscall_exit_to_user_mode+0x19/0x50
  do_syscall_64+0x48/0x90
  entry_SYSCALL_64_after_hwframe+0x44/0xae

The root case is in commit 84472b436e76 ("bpf, sockmap: Fix more uncharged
while msg has more_data"), where I used msg->sg.size to replace the tosend,
causing breakage:

  if (msg->apply_bytes && msg->apply_bytes < tosend)
    tosend = psock->apply_bytes;
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/14e8bc3bf7bd6af64d7538a0684c8238d96cdfd7
  - https://git.kernel.org/stable/c/8ec95b94716a1e4d126edc3fb2bc426a717e2dba
  - https://git.kernel.org/stable/c/95adbd2ac8de82e43fd6b347e7e1b47f74dc1abb
  - https://git.kernel.org/stable/c/cc21dc48a78cc9e5af9a4d039cd456446a6e73ff
  - https://git.kernel.org/stable/c/d975bec1eaeb52341acc9273db79ddb078220399

------------------------------------------------------------

CVE ID: CVE-2022-49878
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, verifier: Fix memory leak in array reallocation for stack state

If an error (NULL) is returned by krealloc(), callers of realloc_array()
were setting their allocation pointers to NULL, but on error krealloc()
does not touch the original allocation. This would result in a memory
resource leak. Instead, free the old allocation on the error handling
path.

The memory leak information is as follows as also reported by Zhengchao:

  unreferenced object 0xffff888019801800 (size 256):
  comm "bpf_repo", pid 6490, jiffies 4294959200 (age 17.170s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<00000000b211474b>] __kmalloc_node_track_caller+0x45/0xc0
    [<0000000086712a0b>] krealloc+0x83/0xd0
    [<00000000139aab02>] realloc_array+0x82/0xe2
    [<00000000b1ca41d1>] grow_stack_state+0xfb/0x186
    [<00000000cd6f36d2>] check_mem_access.cold+0x141/0x1341
    [<0000000081780455>] do_check_common+0x5358/0xb350
    [<0000000015f6b091>] bpf_check.cold+0xc3/0x29d
    [<000000002973c690>] bpf_prog_load+0x13db/0x2240
    [<00000000028d1644>] __sys_bpf+0x1605/0x4ce0
    [<00000000053f29bd>] __x64_sys_bpf+0x75/0xb0
    [<0000000056fedaf5>] do_syscall_64+0x35/0x80
    [<000000002bd58261>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/06615967d4889b08b19ff3dda96e8b131282f73d
  - https://git.kernel.org/stable/c/3e210891c4a4c2d858cd6f9f61d5809af251d4df
  - https://git.kernel.org/stable/c/42378a9ca55347102bbf86708776061d8fe3ece2

------------------------------------------------------------

CVE ID: CVE-2022-49879
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix BUG_ON() when directory entry has invalid rec_len

The rec_len field in the directory entry has to be a multiple of 4.  A
corrupted filesystem image can be used to hit a BUG() in
ext4_rec_len_to_disk(), called from make_indexed_dir().

 ------------[ cut here ]------------
 kernel BUG at fs/ext4/ext4.h:2413!
 ...
 RIP: 0010:make_indexed_dir+0x53f/0x5f0
 ...
 Call Trace:
  <TASK>
  ? add_dirent_to_buf+0x1b2/0x200
  ext4_add_entry+0x36e/0x480
  ext4_add_nondir+0x2b/0xc0
  ext4_create+0x163/0x200
  path_openat+0x635/0xe90
  do_filp_open+0xb4/0x160
  ? __create_object.isra.0+0x1de/0x3b0
  ? _raw_spin_unlock+0x12/0x30
  do_sys_openat2+0x91/0x150
  __x64_sys_open+0x6c/0xa0
  do_syscall_64+0x3c/0x80
  entry_SYSCALL_64_after_hwframe+0x46/0xb0

The fix simply adds a call to ext4_check_dir_entry() to validate the
directory entry, returning -EFSCORRUPTED if the entry is invalid.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/156451a67b93986fb07c274ef6995ff40766c5ad
  - https://git.kernel.org/stable/c/17a0bc9bd697f75cfdf9b378d5eb2d7409c91340
  - https://git.kernel.org/stable/c/2fa24d0274fbf913b56ee31f15bc01168669d909
  - https://git.kernel.org/stable/c/999cff2b6ce3b45c08abf793bf55534777421327
  - https://git.kernel.org/stable/c/ce1ee2c8827fb6493e91acbd50f664cf2a972c3d

------------------------------------------------------------

CVE ID: CVE-2022-49880
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix warning in 'ext4_da_release_space'

Syzkaller report issue as follows:
EXT4-fs (loop0): Free/Dirty block details
EXT4-fs (loop0): free_blocks=0
EXT4-fs (loop0): dirty_blocks=0
EXT4-fs (loop0): Block reservation details
EXT4-fs (loop0): i_reserved_data_blocks=0
EXT4-fs warning (device loop0): ext4_da_release_space:1527: ext4_da_release_space: ino 18, to_free 1 with only 0 reserved data blocks
------------[ cut here ]------------
WARNING: CPU: 0 PID: 92 at fs/ext4/inode.c:1528 ext4_da_release_space+0x25e/0x370 fs/ext4/inode.c:1524
Modules linked in:
CPU: 0 PID: 92 Comm: kworker/u4:4 Not tainted 6.0.0-syzkaller-09423-g493ffd6605b2 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022
Workqueue: writeback wb_workfn (flush-7:0)
RIP: 0010:ext4_da_release_space+0x25e/0x370 fs/ext4/inode.c:1528
RSP: 0018:ffffc900015f6c90 EFLAGS: 00010296
RAX: 42215896cd52ea00 RBX: 0000000000000000 RCX: 42215896cd52ea00
RDX: 0000000000000000 RSI: 0000000080000001 RDI: 0000000000000000
RBP: 1ffff1100e907d96 R08: ffffffff816aa79d R09: fffff520002bece5
R10: fffff520002bece5 R11: 1ffff920002bece4 R12: ffff888021fd2000
R13: ffff88807483ecb0 R14: 0000000000000001 R15: ffff88807483e740
FS:  0000000000000000(0000) GS:ffff8880b9a00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00005555569ba628 CR3: 000000000c88e000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 ext4_es_remove_extent+0x1ab/0x260 fs/ext4/extents_status.c:1461
 mpage_release_unused_pages+0x24d/0xef0 fs/ext4/inode.c:1589
 ext4_writepages+0x12eb/0x3be0 fs/ext4/inode.c:2852
 do_writepages+0x3c3/0x680 mm/page-writeback.c:2469
 __writeback_single_inode+0xd1/0x670 fs/fs-writeback.c:1587
 writeback_sb_inodes+0xb3b/0x18f0 fs/fs-writeback.c:1870
 wb_writeback+0x41f/0x7b0 fs/fs-writeback.c:2044
 wb_do_writeback fs/fs-writeback.c:2187 [inline]
 wb_workfn+0x3cb/0xef0 fs/fs-writeback.c:2227
 process_one_work+0x877/0xdb0 kernel/workqueue.c:2289
 worker_thread+0xb14/0x1330 kernel/workqueue.c:2436
 kthread+0x266/0x300 kernel/kthread.c:376
 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306
 </TASK>

Above issue may happens as follows:
ext4_da_write_begin
  ext4_create_inline_data
    ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
    ext4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);
__ext4_ioctl
  ext4_ext_migrate -> will lead to eh->eh_entries not zero, and set extent flag
ext4_da_write_begin
  ext4_da_convert_inline_data_to_extent
    ext4_da_write_inline_data_begin
      ext4_da_map_blocks
        ext4_insert_delayed_block
	  if (!ext4_es_scan_clu(inode, &ext4_es_is_delonly, lblk))
	    if (!ext4_es_scan_clu(inode, &ext4_es_is_mapped, lblk))
	      ext4_clu_mapped(inode, EXT4_B2C(sbi, lblk)); -> will return 1
	       allocated = true;
          ext4_es_insert_delayed_block(inode, lblk, allocated);
ext4_writepages
  mpage_map_and_submit_extent(handle, &mpd, &give_up_on_write); -> return -ENOSPC
  mpage_release_unused_pages(&mpd, give_up_on_write); -> give_up_on_write == 1
    ext4_es_remove_extent
      ext4_da_release_space(inode, reserved);
        if (unlikely(to_free > ei->i_reserved_data_blocks))
	  -> to_free == 1  but ei->i_reserved_data_blocks == 0
	  -> then trigger warning as above

To solve above issue, forbid inode do migrate which has inline data.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0a43c015e98121c91a76154edf42280ce1a8a883
  - https://git.kernel.org/stable/c/0de5ee103747fd3a24f1c010c79caabe35e8f0bb
  - https://git.kernel.org/stable/c/1b8f787ef547230a3249bcf897221ef0cc78481b
  - https://git.kernel.org/stable/c/5370b965b7a945bb8f48b9ee23d83a76a947902e
  - https://git.kernel.org/stable/c/72743d5598b9096950bbfd6a9b7f173d156eea97
  - https://git.kernel.org/stable/c/890d738f569fa9412b70ba09f15407f17a52da20
  - https://git.kernel.org/stable/c/89bee03d2fb8c54119b38ac6c24e7d60fae036b6
  - https://git.kernel.org/stable/c/c3bf1e95cfa7d950dc3c064d0c2e3d06b427bc63

------------------------------------------------------------

CVE ID: CVE-2022-49881
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: cfg80211: fix memory leak in query_regdb_file()

In the function query_regdb_file() the alpha2 parameter is duplicated
using kmemdup() and subsequently freed in regdb_fw_cb(). However,
request_firmware_nowait() can fail without calling regdb_fw_cb() and
thus leak memory.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.267
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.225
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.155
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.79
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.9
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0ede1a988299e95d54bd89551fd635980572e920
  - https://git.kernel.org/stable/c/219446396786330937bcd382a7bc4ccd767383bc
  - https://git.kernel.org/stable/c/38c9fa2cc6bf4b6e1a74057aef8b5cffd23d3264
  - https://git.kernel.org/stable/c/57b962e627ec0ae53d4d16d7bd1033e27e67677a
  - https://git.kernel.org/stable/c/e1e12180321f416d83444f2cdc9259e0f5093d35
  - https://git.kernel.org/stable/c/e9b5a4566d5bc71cc901be50d1fa24da00613120

------------------------------------------------------------

CVE ID: CVE-2022-49882
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: Reject attempts to consume or refresh inactive gfn_to_pfn_cache

Reject kvm_gpc_check() and kvm_gpc_refresh() if the cache is inactive.
Not checking the active flag during refresh is particularly egregious, as
KVM can end up with a valid, inactive cache, which can lead to a variety
of use-after-free bugs, e.g. consuming a NULL kernel pointer or missing
an mmu_notifier invalidation due to the cache not being on the list of
gfns to invalidate.

Note, "active" needs to be set if and only if the cache is on the list
of caches, i.e. is reachable via mmu_notifier events.  If a relevant
mmu_notifier event occurs while the cache is "active" but not on the
list, KVM will not acquire the cache's lock and so will not serailize
the mmu_notifier event with active users and/or kvm_gpc_refresh().

A race between KVM_XEN_ATTR_TYPE_SHARED_INFO and KVM_XEN_HVM_EVTCHN_SEND
can be exploited to trigger the bug.

1. Deactivate shinfo cache:

kvm_xen_hvm_set_attr
case KVM_XEN_ATTR_TYPE_SHARED_INFO
 kvm_gpc_deactivate
  kvm_gpc_unmap
   gpc->valid = false
   gpc->khva = NULL
  gpc->active = false

Result: active = false, valid = false

2. Cause cache refresh:

kvm_arch_vm_ioctl
case KVM_XEN_HVM_EVTCHN_SEND
 kvm_xen_hvm_evtchn_send
  kvm_xen_set_evtchn
   kvm_xen_set_evtchn_fast
    kvm_gpc_check
    return -EWOULDBLOCK because !gpc->valid
   kvm_xen_set_evtchn_fast
    return -EWOULDBLOCK
   kvm_gpc_refresh
    hva_to_pfn_retry
     gpc->valid = true
     gpc->khva = not NULL

Result: active = false, valid = true

3. Race ioctl KVM_XEN_HVM_EVTCHN_SEND against ioctl
KVM_XEN_ATTR_TYPE_SHARED_INFO:

kvm_arch_vm_ioctl
case KVM_XEN_HVM_EVTCHN_SEND
 kvm_xen_hvm_evtchn_send
  kvm_xen_set_evtchn
   kvm_xen_set_evtchn_fast
    read_lock gpc->lock
                                          kvm_xen_hvm_set_attr case
                                          KVM_XEN_ATTR_TYPE_SHARED_INFO
                                           mutex_lock kvm->lock
                                           kvm_xen_shared_info_init
                                            kvm_gpc_activate
                                             gpc->khva = NULL
    kvm_gpc_check
     [ Check passes because gpc->valid is
       still true, even though gpc->khva
       is already NULL. ]
    shinfo = gpc->khva
    pending_bits = shinfo->evtchn_pending
    CRASH: test_and_set_bit(..., pending_bits)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/bfa9672f8fc9eb118124bab61899d2dd497f95ba
  - https://git.kernel.org/stable/c/ecbcf030b45666ad11bc98565e71dfbcb7be4393

------------------------------------------------------------

CVE ID: CVE-2022-49883
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: smm: number of GPRs in the SMRAM image depends on the image format

On 64 bit host, if the guest doesn't have X86_FEATURE_LM, KVM will
access 16 gprs to 32-bit smram image, causing out-ouf-bound ram
access.

On 32 bit host, the rsm_load_state_64/enter_smm_save_state_64
is compiled out, thus access overflow can't happen.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/696db303e54f7352623d9f640e6c51d8fa9d5588
  - https://git.kernel.org/stable/c/a7ebfbea0f52550d7cdf12c38f3f5eaa7b2b6494

------------------------------------------------------------

CVE ID: CVE-2022-49884
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: Initialize gfn_to_pfn_cache locks in dedicated helper

Move the gfn_to_pfn_cache lock initialization to another helper and
call the new helper during VM/vCPU creation.  There are race
conditions possible due to kvm_gfn_to_pfn_cache_init()'s
ability to re-initialize the cache's locks.

For example: a race between ioctl(KVM_XEN_HVM_EVTCHN_SEND) and
kvm_gfn_to_pfn_cache_init() leads to a corrupted shinfo gpc lock.

                (thread 1)                |           (thread 2)
                                          |
 kvm_xen_set_evtchn_fast                  |
  read_lock_irqsave(&gpc->lock, ...)      |
                                          | kvm_gfn_to_pfn_cache_init
                                          |  rwlock_init(&gpc->lock)
  read_unlock_irqrestore(&gpc->lock, ...) |

Rename "cache_init" and "cache_destroy" to activate+deactivate to
avoid implying that the cache really is destroyed/freed.

Note, there more races in the newly named kvm_gpc_activate() that will
be addressed separately.

[sean: call out that this is a bug fix]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/52491a38b2c2411f3f0229dc6ad610349c704a41
  - https://git.kernel.org/stable/c/61242001d6c9c253df7645dab090842d8da08764

------------------------------------------------------------

CVE ID: CVE-2022-49885
Description: In the Linux kernel, the following vulnerability has been resolved:

ACPI: APEI: Fix integer overflow in ghes_estatus_pool_init()

Change num_ghes from int to unsigned int, preventing an overflow
and causing subsequent vmalloc() to fail.

The overflow happens in ghes_estatus_pool_init() when calculating
len during execution of the statement below as both multiplication
operands here are signed int:

len += (num_ghes * GHES_ESOURCE_PREALLOC_MAX_SIZE);

The following call trace is observed because of this bug:

[    9.317108] swapper/0: vmalloc error: size 18446744071562596352, exceeds total pages, mode:0xcc0(GFP_KERNEL), nodemask=(null),cpuset=/,mems_allowed=0-1
[    9.317131] Call Trace:
[    9.317134]  <TASK>
[    9.317137]  dump_stack_lvl+0x49/0x5f
[    9.317145]  dump_stack+0x10/0x12
[    9.317146]  warn_alloc.cold+0x7b/0xdf
[    9.317150]  ? __device_attach+0x16a/0x1b0
[    9.317155]  __vmalloc_node_range+0x702/0x740
[    9.317160]  ? device_add+0x17f/0x920
[    9.317164]  ? dev_set_name+0x53/0x70
[    9.317166]  ? platform_device_add+0xf9/0x240
[    9.317168]  __vmalloc_node+0x49/0x50
[    9.317170]  ? ghes_estatus_pool_init+0x43/0xa0
[    9.317176]  vmalloc+0x21/0x30
[    9.317177]  ghes_estatus_pool_init+0x43/0xa0
[    9.317179]  acpi_hest_init+0x129/0x19c
[    9.317185]  acpi_init+0x434/0x4a4
[    9.317188]  ? acpi_sleep_proc_init+0x2a/0x2a
[    9.317190]  do_one_initcall+0x48/0x200
[    9.317195]  kernel_init_freeable+0x221/0x284
[    9.317200]  ? rest_init+0xe0/0xe0
[    9.317204]  kernel_init+0x1a/0x130
[    9.317205]  ret_from_fork+0x22/0x30
[    9.317208]  </TASK>

[ rjw: Subject and changelog edits ]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/43d2748394c3feb86c0c771466f5847e274fc043
  - https://git.kernel.org/stable/c/4c10c854113720cbfe75d4f51db79b700a629e73
  - https://git.kernel.org/stable/c/9edf20e5a1d805855e78f241cf221d741b50d482
  - https://git.kernel.org/stable/c/c50ec15725e005e9fb20bce69b6c23b135a4a9b7

------------------------------------------------------------

CVE ID: CVE-2022-49886
Description: In the Linux kernel, the following vulnerability has been resolved:

x86/tdx: Panic on bad configs that #VE on "private" memory access

All normal kernel memory is "TDX private memory".  This includes
everything from kernel stacks to kernel text.  Handling
exceptions on arbitrary accesses to kernel memory is essentially
impossible because they can happen in horribly nasty places like
kernel entry/exit.  But, TDX hardware can theoretically _deliver_
a virtualization exception (#VE) on any access to private memory.

But, it's not as bad as it sounds.  TDX can be configured to never
deliver these exceptions on private memory with a "TD attribute"
called ATTR_SEPT_VE_DISABLE.  The guest has no way to *set* this
attribute, but it can check it.

Ensure ATTR_SEPT_VE_DISABLE is set in early boot.  panic() if it
is unset.  There is no sane way for Linux to run with this
attribute clear so a panic() is appropriate.

There's small window during boot before the check where kernel
has an early #VE handler. But the handler is only for port I/O
and will also panic() as soon as it sees any other #VE, such as
a one generated by a private memory access.

[ dhansen: Rewrite changelog and rebase on new tdx_parse_tdinfo().
	   Add Kirill's tested-by because I made changes since
	   he wrote this. ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/373e715e31bf4e0f129befe87613a278fac228d3
  - https://git.kernel.org/stable/c/895c168c8f78079f21ad50fead7593ffa352f795

------------------------------------------------------------

CVE ID: CVE-2022-49887
Description: In the Linux kernel, the following vulnerability has been resolved:

media: meson: vdec: fix possible refcount leak in vdec_probe()

v4l2_device_unregister need to be called to put the refcount got by
v4l2_device_register when vdec_probe fails or vdec_remove is called.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): None, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0457e7b12ece1a7e41fa0ae8b7e47c0a72a83bef
  - https://git.kernel.org/stable/c/70119756311a0be3b95bec2e1ba714673e90feba
  - https://git.kernel.org/stable/c/7718999356234d9cc6a11b4641bb773928f1390f
  - https://git.kernel.org/stable/c/be6e22f54623d8a856a4f167b25be73c2ff1ff80
  - https://git.kernel.org/stable/c/f96ad391d054bd5c36994f98afd6a12cbb5600bf

------------------------------------------------------------

CVE ID: CVE-2022-49888
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: entry: avoid kprobe recursion

The cortex_a76_erratum_1463225_debug_handler() function is called when
handling debug exceptions (and synchronous exceptions from BRK
instructions), and so is called when a probed function executes. If the
compiler does not inline cortex_a76_erratum_1463225_debug_handler(), it
can be probed.

If cortex_a76_erratum_1463225_debug_handler() is probed, any debug
exception or software breakpoint exception will result in recursive
exceptions leading to a stack overflow. This can be triggered with the
ftrace multiple_probes selftest, and as per the example splat below.

This is a regression caused by commit:

  6459b8469753e9fe ("arm64: entry: consolidate Cortex-A76 erratum 1463225 workaround")

... which removed the NOKPROBE_SYMBOL() annotation associated with the
function.

My intent was that cortex_a76_erratum_1463225_debug_handler() would be
inlined into its caller, el1_dbg(), which is marked noinstr and cannot
be probed. Mark cortex_a76_erratum_1463225_debug_handler() as
__always_inline to ensure this.

Example splat prior to this patch (with recursive entries elided):

| # echo p cortex_a76_erratum_1463225_debug_handler > /sys/kernel/debug/tracing/kprobe_events
| # echo p do_el0_svc >> /sys/kernel/debug/tracing/kprobe_events
| # echo 1 > /sys/kernel/debug/tracing/events/kprobes/enable
| Insufficient stack space to handle exception!
| ESR: 0x0000000096000047 -- DABT (current EL)
| FAR: 0xffff800009cefff0
| Task stack:     [0xffff800009cf0000..0xffff800009cf4000]
| IRQ stack:      [0xffff800008000000..0xffff800008004000]
| Overflow stack: [0xffff00007fbc00f0..0xffff00007fbc10f0]
| CPU: 0 PID: 145 Comm: sh Not tainted 6.0.0 #2
| Hardware name: linux,dummy-virt (DT)
| pstate: 604003c5 (nZCv DAIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
| pc : arm64_enter_el1_dbg+0x4/0x20
| lr : el1_dbg+0x24/0x5c
| sp : ffff800009cf0000
| x29: ffff800009cf0000 x28: ffff000002c74740 x27: 0000000000000000
| x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000
| x23: 00000000604003c5 x22: ffff80000801745c x21: 0000aaaac95ac068
| x20: 00000000f2000004 x19: ffff800009cf0040 x18: 0000000000000000
| x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
| x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000
| x11: 0000000000000010 x10: ffff800008c87190 x9 : ffff800008ca00d0
| x8 : 000000000000003c x7 : 0000000000000000 x6 : 0000000000000000
| x5 : 0000000000000000 x4 : 0000000000000000 x3 : 00000000000043a4
| x2 : 00000000f2000004 x1 : 00000000f2000004 x0 : ffff800009cf0040
| Kernel panic - not syncing: kernel stack overflow
| CPU: 0 PID: 145 Comm: sh Not tainted 6.0.0 #2
| Hardware name: linux,dummy-virt (DT)
| Call trace:
|  dump_backtrace+0xe4/0x104
|  show_stack+0x18/0x4c
|  dump_stack_lvl+0x64/0x7c
|  dump_stack+0x18/0x38
|  panic+0x14c/0x338
|  test_taint+0x0/0x2c
|  panic_bad_stack+0x104/0x118
|  handle_bad_stack+0x34/0x48
|  __bad_stack+0x78/0x7c
|  arm64_enter_el1_dbg+0x4/0x20
|  el1h_64_sync_handler+0x40/0x98
|  el1h_64_sync+0x64/0x68
|  cortex_a76_erratum_1463225_debug_handler+0x0/0x34
...
|  el1h_64_sync_handler+0x40/0x98
|  el1h_64_sync+0x64/0x68
|  cortex_a76_erratum_1463225_debug_handler+0x0/0x34
...
|  el1h_64_sync_handler+0x40/0x98
|  el1h_64_sync+0x64/0x68
|  cortex_a76_erratum_1463225_debug_handler+0x0/0x34
|  el1h_64_sync_handler+0x40/0x98
|  el1h_64_sync+0x64/0x68
|  do_el0_svc+0x0/0x28
|  el0t_64_sync_handler+0x84/0xf0
|  el0t_64_sync+0x18c/0x190
| Kernel Offset: disabled
| CPU features: 0x0080,00005021,19001080
| Memory Limit: none
| ---[ end Kernel panic - not syncing: kernel stack overflow ]---

With this patch, cortex_a76_erratum_1463225_debug_handler() is inlined
into el1_dbg(), and el1_dbg() cannot be probed:

| # echo p cortex_a76_erratum_1463225_debug_handler > /sys/kernel/debug/tracing/kprobe_events
| sh: write error: No such file or directory
| # grep -w cortex_a76_errat
---truncated---
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/024f4b2e1f874934943eb2d3d288ebc52c79f55c
  - https://git.kernel.org/stable/c/71d6c33fe223255f4416a01514da2c0bc3e283e7
  - https://git.kernel.org/stable/c/db66629d43b2d12cb43b004a4ca6be1d03228e97

------------------------------------------------------------

CVE ID: CVE-2022-49889
Description: In the Linux kernel, the following vulnerability has been resolved:

ring-buffer: Check for NULL cpu_buffer in ring_buffer_wake_waiters()

On some machines the number of listed CPUs may be bigger than the actual
CPUs that exist. The tracing subsystem allocates a per_cpu directory with
access to the per CPU ring buffer via a cpuX file. But to save space, the
ring buffer will only allocate buffers for online CPUs, even though the
CPU array will be as big as the nr_cpu_ids.

With the addition of waking waiters on the ring buffer when closing the
file, the ring_buffer_wake_waiters() now needs to make sure that the
buffer is allocated (with the irq_work allocated with it) before trying to
wake waiters, as it will cause a NULL pointer dereference.

While debugging this, I added a NULL check for the buffer itself (which is
OK to do), and also NULL pointer checks against buffer->buffers (which is
not fine, and will WARN) as well as making sure the CPU number passed in
is within the nr_cpu_ids (which is also not fine if it isn't).


Bugzilla: https://bugzilla.opensuse.org/show_bug.cgi?id=1204705
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.75, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19.17, Last Version (Excluding): 6.0
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0.3, Last Version (Excluding): 6.0.8
References:
  - https://git.kernel.org/stable/c/49ca992f6e50d0f46ec9608f44e011cf3121f389
  - https://git.kernel.org/stable/c/7433632c9ff68a991bd0bc38cabf354e9d2de410
  - https://git.kernel.org/stable/c/b5074df412bf3df9d6ce096b6fa03eb1082d05c9

------------------------------------------------------------

CVE ID: CVE-2022-49890
Description: In the Linux kernel, the following vulnerability has been resolved:

capabilities: fix potential memleak on error path from vfs_getxattr_alloc()

In cap_inode_getsecurity(), we will use vfs_getxattr_alloc() to
complete the memory allocation of tmpbuf, if we have completed
the memory allocation of tmpbuf, but failed to call handler->get(...),
there will be a memleak in below logic:

  |-- ret = (int)vfs_getxattr_alloc(mnt_userns, ...)
    |           /* ^^^ alloc for tmpbuf */
    |-- value = krealloc(*xattr_value, error + 1, flags)
    |           /* ^^^ alloc memory */
    |-- error = handler->get(handler, ...)
    |           /* error! */
    |-- *xattr_value = value
    |           /* xattr_value is &tmpbuf (memory leak!) */

So we will try to free(tmpbuf) after vfs_getxattr_alloc() fails to fix it.

[PM: subject line and backtrace tweaks]
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0c3e6288da650d1ec911a259c77bc2d88e498603
  - https://git.kernel.org/stable/c/2de8eec8afb75792440b8900a01d52b8f6742fd1
  - https://git.kernel.org/stable/c/6bb00eb21c0fbf18e5d3538c9ff0cf63fd0ace85
  - https://git.kernel.org/stable/c/7480aeff0093d8c54377553ec6b31110bea37b4d
  - https://git.kernel.org/stable/c/8cf0a1bc12870d148ae830a4ba88cfdf0e879cee
  - https://git.kernel.org/stable/c/90577bcc01c4188416a47269f8433f70502abe98
  - https://git.kernel.org/stable/c/cdf01c807e974048c43c7fd3ca574f6086a57906

------------------------------------------------------------

CVE ID: CVE-2022-49891
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: kprobe: Fix memory leak in test_gen_kprobe/kretprobe_cmd()

test_gen_kprobe_cmd() only free buf in fail path, hence buf will leak
when there is no failure. Move kfree(buf) from fail path to common path
to prevent the memleak. The same reason and solution in
test_gen_kretprobe_cmd().

unreferenced object 0xffff888143b14000 (size 2048):
  comm "insmod", pid 52490, jiffies 4301890980 (age 40.553s)
  hex dump (first 32 bytes):
    70 3a 6b 70 72 6f 62 65 73 2f 67 65 6e 5f 6b 70  p:kprobes/gen_kp
    72 6f 62 65 5f 74 65 73 74 20 64 6f 5f 73 79 73  robe_test do_sys
  backtrace:
    [<000000006d7b836b>] kmalloc_trace+0x27/0xa0
    [<0000000009528b5b>] 0xffffffffa059006f
    [<000000008408b580>] do_one_initcall+0x87/0x2a0
    [<00000000c4980a7e>] do_init_module+0xdf/0x320
    [<00000000d775aad0>] load_module+0x3006/0x3390
    [<00000000e9a74b80>] __do_sys_finit_module+0x113/0x1b0
    [<000000003726480d>] do_syscall_64+0x35/0x80
    [<000000003441e93b>] entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.6, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/66f0919c953ef7b55e5ab94389a013da2ce80a2c
  - https://git.kernel.org/stable/c/71aeb8d01a8c7ab5cf7da3f81b35206f56ce6bca
  - https://git.kernel.org/stable/c/bef08acbe560a926b4cee9cc46404cc98ae5703b
  - https://git.kernel.org/stable/c/d1b6a8e3414aeaa0985139180c145d2d0fbd2a49

------------------------------------------------------------

CVE ID: CVE-2022-49892
Description: In the Linux kernel, the following vulnerability has been resolved:

ftrace: Fix use-after-free for dynamic ftrace_ops

KASAN reported a use-after-free with ftrace ops [1]. It was found from
vmcore that perf had registered two ops with the same content
successively, both dynamic. After unregistering the second ops, a
use-after-free occurred.

In ftrace_shutdown(), when the second ops is unregistered, the
FTRACE_UPDATE_CALLS command is not set because there is another enabled
ops with the same content.  Also, both ops are dynamic and the ftrace
callback function is ftrace_ops_list_func, so the
FTRACE_UPDATE_TRACE_FUNC command will not be set. Eventually the value
of 'command' will be 0 and ftrace_shutdown() will skip the rcu
synchronization.

However, ftrace may be activated. When the ops is released, another CPU
may be accessing the ops.  Add the missing synchronization to fix this
problem.

[1]
BUG: KASAN: use-after-free in __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline]
BUG: KASAN: use-after-free in ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049
Read of size 8 at addr ffff56551965bbc8 by task syz-executor.2/14468

CPU: 1 PID: 14468 Comm: syz-executor.2 Not tainted 5.10.0 #7
Hardware name: linux,dummy-virt (DT)
Call trace:
 dump_backtrace+0x0/0x40c arch/arm64/kernel/stacktrace.c:132
 show_stack+0x30/0x40 arch/arm64/kernel/stacktrace.c:196
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x1b4/0x248 lib/dump_stack.c:118
 print_address_description.constprop.0+0x28/0x48c mm/kasan/report.c:387
 __kasan_report mm/kasan/report.c:547 [inline]
 kasan_report+0x118/0x210 mm/kasan/report.c:564
 check_memory_region_inline mm/kasan/generic.c:187 [inline]
 __asan_load8+0x98/0xc0 mm/kasan/generic.c:253
 __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline]
 ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049
 ftrace_graph_call+0x0/0x4
 __might_sleep+0x8/0x100 include/linux/perf_event.h:1170
 __might_fault mm/memory.c:5183 [inline]
 __might_fault+0x58/0x70 mm/memory.c:5171
 do_strncpy_from_user lib/strncpy_from_user.c:41 [inline]
 strncpy_from_user+0x1f4/0x4b0 lib/strncpy_from_user.c:139
 getname_flags+0xb0/0x31c fs/namei.c:149
 getname+0x2c/0x40 fs/namei.c:209
 [...]

Allocated by task 14445:
 kasan_save_stack+0x24/0x50 mm/kasan/common.c:48
 kasan_set_track mm/kasan/common.c:56 [inline]
 __kasan_kmalloc mm/kasan/common.c:479 [inline]
 __kasan_kmalloc.constprop.0+0x110/0x13c mm/kasan/common.c:449
 kasan_kmalloc+0xc/0x14 mm/kasan/common.c:493
 kmem_cache_alloc_trace+0x440/0x924 mm/slub.c:2950
 kmalloc include/linux/slab.h:563 [inline]
 kzalloc include/linux/slab.h:675 [inline]
 perf_event_alloc.part.0+0xb4/0x1350 kernel/events/core.c:11230
 perf_event_alloc kernel/events/core.c:11733 [inline]
 __do_sys_perf_event_open kernel/events/core.c:11831 [inline]
 __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723
 __arm64_sys_perf_event_open+0x6c/0x80 kernel/events/core.c:11723
 [...]

Freed by task 14445:
 kasan_save_stack+0x24/0x50 mm/kasan/common.c:48
 kasan_set_track+0x24/0x34 mm/kasan/common.c:56
 kasan_set_free_info+0x20/0x40 mm/kasan/generic.c:358
 __kasan_slab_free.part.0+0x11c/0x1b0 mm/kasan/common.c:437
 __kasan_slab_free mm/kasan/common.c:445 [inline]
 kasan_slab_free+0x2c/0x40 mm/kasan/common.c:446
 slab_free_hook mm/slub.c:1569 [inline]
 slab_free_freelist_hook mm/slub.c:1608 [inline]
 slab_free mm/slub.c:3179 [inline]
 kfree+0x12c/0xc10 mm/slub.c:4176
 perf_event_alloc.part.0+0xa0c/0x1350 kernel/events/core.c:11434
 perf_event_alloc kernel/events/core.c:11733 [inline]
 __do_sys_perf_event_open kernel/events/core.c:11831 [inline]
 __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723
 [...]
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.1.45, Last Version (Excluding): 4.2
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.89, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.52, Last Version (Excluding): 4.10
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.13.4, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0e792b89e6800cd9cb4757a76a96f7ef3e8b6294
  - https://git.kernel.org/stable/c/88561a66777e7a2fe06638c6dcb22a9fae0b6733
  - https://git.kernel.org/stable/c/cc1b9961a0ceb70f6ca4e2f4b8bb71c87c7a495c
  - https://git.kernel.org/stable/c/ea5f2fd4640ecbb9df969bf8bb27733ae2183169

------------------------------------------------------------

CVE ID: CVE-2022-49893
Description: In the Linux kernel, the following vulnerability has been resolved:

cxl/region: Fix cxl_region leak, cleanup targets at region delete

When a region is deleted any targets that have been previously assigned
to that region hold references to it. Trigger those references to
drop by detaching all targets at unregister_region() time.

Otherwise that region object will leak as userspace has lost the ability
to detach targets once region sysfs is torn down.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d9e734018d70cecf79e2e4c6082167160a0f13f
  - https://git.kernel.org/stable/c/45d9fb4b758b9d602ee7776eb6754b0349946aad

------------------------------------------------------------

CVE ID: CVE-2022-49894
Description: In the Linux kernel, the following vulnerability has been resolved:

cxl/region: Fix region HPA ordering validation

Some regions may not have any address space allocated. Skip them when
validating HPA order otherwise a crash like the following may result:

 devm_cxl_add_region: cxl_acpi cxl_acpi.0: decoder3.4: created region9
 BUG: kernel NULL pointer dereference, address: 0000000000000000
 [..]
 RIP: 0010:store_targetN+0x655/0x1740 [cxl_core]
 [..]
 Call Trace:
  <TASK>
  kernfs_fop_write_iter+0x144/0x200
  vfs_write+0x24a/0x4d0
  ksys_write+0x69/0xf0
  do_syscall_64+0x3a/0x90

store_targetN+0x655/0x1740:
alloc_region_ref at drivers/cxl/core/region.c:676
(inlined by) cxl_port_attach_region at drivers/cxl/core/region.c:850
(inlined by) cxl_region_attach at drivers/cxl/core/region.c:1290
(inlined by) attach_target at drivers/cxl/core/region.c:1410
(inlined by) store_targetN at drivers/cxl/core/region.c:1453
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/12316b9f7c18138ae656050cfd716728e27b7e2f
  - https://git.kernel.org/stable/c/a90accb358ae33ea982a35595573f7a045993f8b

------------------------------------------------------------

CVE ID: CVE-2022-49895
Description: In the Linux kernel, the following vulnerability has been resolved:

cxl/region: Fix decoder allocation crash

When an intermediate port's decoders have been exhausted by existing
regions, and creating a new region with the port in question in it's
hierarchical path is attempted, cxl_port_attach_region() fails to find a
port decoder (as would be expected), and drops into the failure / cleanup
path.

However, during cleanup of the region reference, a sanity check attempts
to dereference the decoder, which in the above case didn't exist. This
causes a NULL pointer dereference BUG.

To fix this, refactor the decoder allocation and de-allocation into
helper routines, and in this 'free' routine, check that the decoder,
@cxld, is valid before attempting any operations on it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/71ee71d7adcba648077997a29a91158d20c40b09
  - https://git.kernel.org/stable/c/c6813b5610ac53af73edd87a660d23a0511faa47

------------------------------------------------------------

CVE ID: CVE-2022-49896
Description: In the Linux kernel, the following vulnerability has been resolved:

cxl/pmem: Fix cxl_pmem_region and cxl_memdev leak

When a cxl_nvdimm object goes through a ->remove() event (device
physically removed, nvdimm-bridge disabled, or nvdimm device disabled),
then any associated regions must also be disabled. As highlighted by the
cxl-create-region.sh test [1], a single device may host multiple
regions, but the driver was only tracking one region at a time. This
leads to a situation where only the last enabled region per nvdimm
device is cleaned up properly. Other regions are leaked, and this also
causes cxl_memdev reference leaks.

Fix the tracking by allowing cxl_nvdimm objects to track multiple region
associations.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 6.0, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4d07ae22e79ebc2d7528bbc69daa53b86981cb3a
  - https://git.kernel.org/stable/c/f43b6bfdbab78606735ba81185cf0602b81e40b6

------------------------------------------------------------

CVE ID: CVE-2022-49898
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix tree mod log mishandling of reallocated nodes

We have been seeing the following panic in production

  kernel BUG at fs/btrfs/tree-mod-log.c:677!
  invalid opcode: 0000 [#1] SMP
  RIP: 0010:tree_mod_log_rewind+0x1b4/0x200
  RSP: 0000:ffffc9002c02f890 EFLAGS: 00010293
  RAX: 0000000000000003 RBX: ffff8882b448c700 RCX: 0000000000000000
  RDX: 0000000000008000 RSI: 00000000000000a7 RDI: ffff88877d831c00
  RBP: 0000000000000002 R08: 000000000000009f R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000100c40 R12: 0000000000000001
  R13: ffff8886c26d6a00 R14: ffff88829f5424f8 R15: ffff88877d831a00
  FS:  00007fee1d80c780(0000) GS:ffff8890400c0000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007fee1963a020 CR3: 0000000434f33002 CR4: 00000000007706e0
  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
  PKRU: 55555554
  Call Trace:
   btrfs_get_old_root+0x12b/0x420
   btrfs_search_old_slot+0x64/0x2f0
   ? tree_mod_log_oldest_root+0x3d/0xf0
   resolve_indirect_ref+0xfd/0x660
   ? ulist_alloc+0x31/0x60
   ? kmem_cache_alloc_trace+0x114/0x2c0
   find_parent_nodes+0x97a/0x17e0
   ? ulist_alloc+0x30/0x60
   btrfs_find_all_roots_safe+0x97/0x150
   iterate_extent_inodes+0x154/0x370
   ? btrfs_search_path_in_tree+0x240/0x240
   iterate_inodes_from_logical+0x98/0xd0
   ? btrfs_search_path_in_tree+0x240/0x240
   btrfs_ioctl_logical_to_ino+0xd9/0x180
   btrfs_ioctl+0xe2/0x2ec0
   ? __mod_memcg_lruvec_state+0x3d/0x280
   ? do_sys_openat2+0x6d/0x140
   ? kretprobe_dispatcher+0x47/0x70
   ? kretprobe_rethook_handler+0x38/0x50
   ? rethook_trampoline_handler+0x82/0x140
   ? arch_rethook_trampoline_callback+0x3b/0x50
   ? kmem_cache_free+0xfb/0x270
   ? do_sys_openat2+0xd5/0x140
   __x64_sys_ioctl+0x71/0xb0
   do_syscall_64+0x2d/0x40

Which is this code in tree_mod_log_rewind()

	switch (tm->op) {
        case BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING:
		BUG_ON(tm->slot < n);

This occurs because we replay the nodes in order that they happened, and
when we do a REPLACE we will log a REMOVE_WHILE_FREEING for every slot,
starting at 0.  'n' here is the number of items in this block, which in
this case was 1, but we had 2 REMOVE_WHILE_FREEING operations.

The actual root cause of this was that we were replaying operations for
a block that shouldn't have been replayed.  Consider the following
sequence of events

1. We have an already modified root, and we do a btrfs_get_tree_mod_seq().
2. We begin removing items from this root, triggering KEY_REPLACE for
   it's child slots.
3. We remove one of the 2 children this root node points to, thus triggering
   the root node promotion of the remaining child, and freeing this node.
4. We modify a new root, and re-allocate the above node to the root node of
   this other root.

The tree mod log looks something like this

	logical 0	op KEY_REPLACE (slot 1)			seq 2
	logical 0	op KEY_REMOVE (slot 1)			seq 3
	logical 0	op KEY_REMOVE_WHILE_FREEING (slot 0)	seq 4
	logical 4096	op LOG_ROOT_REPLACE (old logical 0)	seq 5
	logical 8192	op KEY_REMOVE_WHILE_FREEING (slot 1)	seq 6
	logical 8192	op KEY_REMOVE_WHILE_FREEING (slot 0)	seq 7
	logical 0	op LOG_ROOT_REPLACE (old logical 8192)	seq 8

>From here the bug is triggered by the following steps

1.  Call btrfs_get_old_root() on the new_root.
2.  We call tree_mod_log_oldest_root(btrfs_root_node(new_root)), which is
    currently logical 0.
3.  tree_mod_log_oldest_root() calls tree_mod_log_search_oldest(), which
    gives us the KEY_REPLACE seq 2, and since that's not a
    LOG_ROOT_REPLACE we incorrectly believe that we don't have an old
    root, because we expect that the most recent change should be a
    LOG_ROOT_REPLACE.
4.  Back in tree_mod_log_oldest_root() we don't have a LOG_ROOT_REPLACE,
    so we don't set old_root, we simply use our e
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/007058eb8292efc4c88f921752194b83269da085
  - https://git.kernel.org/stable/c/52b2b65c9eb56fd829dda323786db828627ff7e6
  - https://git.kernel.org/stable/c/968b71583130b6104c9f33ba60446d598e327a8b

------------------------------------------------------------

CVE ID: CVE-2022-49899
Description: In the Linux kernel, the following vulnerability has been resolved:

fscrypt: stop using keyrings subsystem for fscrypt_master_key

The approach of fs/crypto/ internally managing the fscrypt_master_key
structs as the payloads of "struct key" objects contained in a
"struct key" keyring has outlived its usefulness.  The original idea was
to simplify the code by reusing code from the keyrings subsystem.
However, several issues have arisen that can't easily be resolved:

- When a master key struct is destroyed, blk_crypto_evict_key() must be
  called on any per-mode keys embedded in it.  (This started being the
  case when inline encryption support was added.)  Yet, the keyrings
  subsystem can arbitrarily delay the destruction of keys, even past the
  time the filesystem was unmounted.  Therefore, currently there is no
  easy way to call blk_crypto_evict_key() when a master key is
  destroyed.  Currently, this is worked around by holding an extra
  reference to the filesystem's request_queue(s).  But it was overlooked
  that the request_queue reference is *not* guaranteed to pin the
  corresponding blk_crypto_profile too; for device-mapper devices that
  support inline crypto, it doesn't.  This can cause a use-after-free.

- When the last inode that was using an incompletely-removed master key
  is evicted, the master key removal is completed by removing the key
  struct from the keyring.  Currently this is done via key_invalidate().
  Yet, key_invalidate() takes the key semaphore.  This can deadlock when
  called from the shrinker, since in fscrypt_ioctl_add_key(), memory is
  allocated with GFP_KERNEL under the same semaphore.

- More generally, the fact that the keyrings subsystem can arbitrarily
  delay the destruction of keys (via garbage collection delay, or via
  random processes getting temporary key references) is undesirable, as
  it means we can't strictly guarantee that all secrets are ever wiped.

- Doing the master key lookups via the keyrings subsystem results in the
  key_permission LSM hook being called.  fscrypt doesn't want this, as
  all access control for encrypted files is designed to happen via the
  files themselves, like any other files.  The workaround which SELinux
  users are using is to change their SELinux policy to grant key search
  access to all domains.  This works, but it is an odd extra step that
  shouldn't really have to be done.

The fix for all these issues is to change the implementation to what I
should have done originally: don't use the keyrings subsystem to keep
track of the filesystem's fscrypt_master_key structs.  Instead, just
store them in a regular kernel data structure, and rework the reference
counting, locking, and lifetime accordingly.  Retain support for
RCU-mode key lookups by using a hash table.  Replace fscrypt_sb_free()
with fscrypt_sb_delete(), which releases the keys synchronously and runs
a bit earlier during unmount, so that block devices are still available.

A side effect of this patch is that neither the master keys themselves
nor the filesystem keyrings will be listed in /proc/keys anymore.
("Master key users" and the master key users keyrings will still be
listed.)  However, this was mostly an implementation detail, and it was
intended just for debugging purposes.  I don't know of anyone using it.

This patch does *not* change how "master key users" (->mk_users) works;
that still uses the keyrings subsystem.  That is still needed for key
quotas, and changing that isn't necessary to solve the issues listed
above.  If we decide to change that too, it would be a separate patch.

I've marked this as fixing the original commit that added the fscrypt
keyring, but as noted above the most important issue that this patch
fixes wasn't introduced until the addition of inline encryption support.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
References:
  - https://git.kernel.org/stable/c/391cceee6d435e616f68631e68f5b32d480b1e67
  - https://git.kernel.org/stable/c/68d15d6558a386f46d815a6ac39edecad713a1bf
  - https://git.kernel.org/stable/c/d7e7b9af104c7b389a0c21eb26532511bce4b510
  - https://git.kernel.org/stable/c/e6f4fd85ef1ee6ab356bfbd64df28c1cb73aee7e

------------------------------------------------------------

CVE ID: CVE-2022-49900
Description: In the Linux kernel, the following vulnerability has been resolved:

i2c: piix4: Fix adapter not be removed in piix4_remove()

In piix4_probe(), the piix4 adapter will be registered in:

   piix4_probe()
     piix4_add_adapters_sb800() / piix4_add_adapter()
       i2c_add_adapter()

Based on the probed device type, piix4_add_adapters_sb800() or single
piix4_add_adapter() will be called.
For the former case, piix4_adapter_count is set as the number of adapters,
while for antoher case it is not set and kept default *zero*.

When piix4 is removed, piix4_remove() removes the adapters added in
piix4_probe(), basing on the piix4_adapter_count value.
Because the count is zero for the single adapter case, the adapter won't
be removed and makes the sources allocated for adapter leaked, such as
the i2c client and device.

These sources can still be accessed by i2c or bus and cause problems.
An easily reproduced case is that if a new adapter is registered, i2c
will get the leaked adapter and try to call smbus_algorithm, which was
already freed:

Triggered by: rmmod i2c_piix4 && modprobe max31730

 BUG: unable to handle page fault for address: ffffffffc053d860
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 Oops: 0000 [#1] PREEMPT SMP KASAN
 CPU: 0 PID: 3752 Comm: modprobe Tainted: G
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
 RIP: 0010:i2c_default_probe (drivers/i2c/i2c-core-base.c:2259) i2c_core
 RSP: 0018:ffff888107477710 EFLAGS: 00000246
 ...
 <TASK>
  i2c_detect (drivers/i2c/i2c-core-base.c:2302) i2c_core
  __process_new_driver (drivers/i2c/i2c-core-base.c:1336) i2c_core
  bus_for_each_dev (drivers/base/bus.c:301)
  i2c_for_each_dev (drivers/i2c/i2c-core-base.c:1823) i2c_core
  i2c_register_driver (drivers/i2c/i2c-core-base.c:1861) i2c_core
  do_one_initcall (init/main.c:1296)
  do_init_module (kernel/module/main.c:2455)
  ...
 </TASK>
 ---[ end trace 0000000000000000 ]---

Fix this problem by correctly set piix4_adapter_count as 1 for the
single adapter so it can be normally removed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/569bea74c94d37785682b11bab76f557520477cd
  - https://git.kernel.org/stable/c/bfd5e62f9a7ee214661cb6f143a3b40ccc63317f
  - https://git.kernel.org/stable/c/d78ccdce662e88f41e87e90cf2bee63c1715d2a5
  - https://git.kernel.org/stable/c/fe51636fffc8108c7c4da6aa393010e786530ad9

------------------------------------------------------------

CVE ID: CVE-2022-49901
Description: In the Linux kernel, the following vulnerability has been resolved:

blk-mq: Fix kmemleak in blk_mq_init_allocated_queue

There is a kmemleak caused by modprobe null_blk.ko

unreferenced object 0xffff8881acb1f000 (size 1024):
  comm "modprobe", pid 836, jiffies 4294971190 (age 27.068s)
  hex dump (first 32 bytes):
    00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N..........
    ff ff ff ff ff ff ff ff 00 53 99 9e ff ff ff ff  .........S......
  backtrace:
    [<000000004a10c249>] kmalloc_node_trace+0x22/0x60
    [<00000000648f7950>] blk_mq_alloc_and_init_hctx+0x289/0x350
    [<00000000af06de0e>] blk_mq_realloc_hw_ctxs+0x2fe/0x3d0
    [<00000000e00c1872>] blk_mq_init_allocated_queue+0x48c/0x1440
    [<00000000d16b4e68>] __blk_mq_alloc_disk+0xc8/0x1c0
    [<00000000d10c98c3>] 0xffffffffc450d69d
    [<00000000b9299f48>] 0xffffffffc4538392
    [<0000000061c39ed6>] do_one_initcall+0xd0/0x4f0
    [<00000000b389383b>] do_init_module+0x1a4/0x680
    [<0000000087cf3542>] load_module+0x6249/0x7110
    [<00000000beba61b8>] __do_sys_finit_module+0x140/0x200
    [<00000000fdcfff51>] do_syscall_64+0x35/0x80
    [<000000003c0f1f71>] entry_SYSCALL_64_after_hwframe+0x46/0xb0

That is because q->ma_ops is set to NULL before blk_release_queue is
called.

blk_mq_init_queue_data
  blk_mq_init_allocated_queue
    blk_mq_realloc_hw_ctxs
      for (i = 0; i < set->nr_hw_queues; i++) {
        old_hctx = xa_load(&q->hctx_table, i);
        if (!blk_mq_alloc_and_init_hctx(.., i, ..))		[1]
          if (!old_hctx)
	    break;

      xa_for_each_start(&q->hctx_table, j, hctx, j)
        blk_mq_exit_hctx(q, set, hctx, j); 			[2]

    if (!q->nr_hw_queues)					[3]
      goto err_hctxs;

  err_exit:
      q->mq_ops = NULL;			  			[4]

  blk_put_queue
    blk_release_queue
      if (queue_is_mq(q))					[5]
        blk_mq_release(q);

[1]: blk_mq_alloc_and_init_hctx failed at i != 0.
[2]: The hctxs allocated by [1] are moved to q->unused_hctx_list and
will be cleaned up in blk_mq_release.
[3]: q->nr_hw_queues is 0.
[4]: Set q->mq_ops to NULL.
[5]: queue_is_mq returns false due to [4]. And blk_mq_release
will not be called. The hctxs in q->unused_hctx_list are leaked.

To fix it, call blk_release_queue in exception path.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.2, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/2dc97e15a54b7bdf457848aa8c663c98a24e58a6
  - https://git.kernel.org/stable/c/943f45b9399ed8b2b5190cbc797995edaa97f58f

------------------------------------------------------------

CVE ID: CVE-2022-49902
Description: In the Linux kernel, the following vulnerability has been resolved:

block: Fix possible memory leak for rq_wb on add_disk failure

kmemleak reported memory leaks in device_add_disk():

kmemleak: 3 new suspected memory leaks

unreferenced object 0xffff88800f420800 (size 512):
  comm "modprobe", pid 4275, jiffies 4295639067 (age 223.512s)
  hex dump (first 32 bytes):
    04 00 00 00 08 00 00 00 01 00 00 00 00 00 00 00  ................
    00 e1 f5 05 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<00000000d3662699>] kmalloc_trace+0x26/0x60
    [<00000000edc7aadc>] wbt_init+0x50/0x6f0
    [<0000000069601d16>] wbt_enable_default+0x157/0x1c0
    [<0000000028fc393f>] blk_register_queue+0x2a4/0x420
    [<000000007345a042>] device_add_disk+0x6fd/0xe40
    [<0000000060e6aab0>] nbd_dev_add+0x828/0xbf0 [nbd]
    ...

It is because the memory allocated in wbt_enable_default() is not
released in device_add_disk() error path.
Normally, these memory are freed in:

del_gendisk()
  rq_qos_exit()
    rqos->ops->exit(rqos);
      wbt_exit()

So rq_qos_exit() is called to free the rq_wb memory for wbt_init().
However in the error path of device_add_disk(), only
blk_unregister_queue() is called and make rq_wb memory leaked.

Add rq_qos_exit() to the error path to fix it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/4e68c5da60cd79950bd56287ae80b39d6261f995
  - https://git.kernel.org/stable/c/528677d3b4af985445bd4ac667485ded1ed11220
  - https://git.kernel.org/stable/c/fa81cbafbf5764ad5053512152345fab37a1fe18

------------------------------------------------------------

CVE ID: CVE-2022-49903
Description: In the Linux kernel, the following vulnerability has been resolved:

ipv6: fix WARNING in ip6_route_net_exit_late()

During the initialization of ip6_route_net_init_late(), if file
ipv6_route or rt6_stats fails to be created, the initialization is
successful by default. Therefore, the ipv6_route or rt6_stats file
doesn't be found during the remove in ip6_route_net_exit_late(). It
will cause WRNING.

The following is the stack information:
name 'rt6_stats'
WARNING: CPU: 0 PID: 9 at fs/proc/generic.c:712 remove_proc_entry+0x389/0x460
Modules linked in:
Workqueue: netns cleanup_net
RIP: 0010:remove_proc_entry+0x389/0x460
PKRU: 55555554
Call Trace:
<TASK>
ops_exit_list+0xb0/0x170
cleanup_net+0x4ea/0xb00
process_one_work+0x9bf/0x1710
worker_thread+0x665/0x1080
kthread+0x2e4/0x3a0
ret_from_fork+0x1f/0x30
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/080589287127838046077904f34d5054ea0f895c
  - https://git.kernel.org/stable/c/0ed71af4d017d2bd2cbb8f7254f613a4914def26
  - https://git.kernel.org/stable/c/381453770f731f0f43616a1cd4c759b7807a1517
  - https://git.kernel.org/stable/c/5dbb47ee89762da433cd8458788d7640c85f1a07
  - https://git.kernel.org/stable/c/768b3c745fe5789f2430bdab02f35a9ad1148d97
  - https://git.kernel.org/stable/c/83fbf246ced54dadd7b9adc2a16efeff30ba944d

------------------------------------------------------------

CVE ID: CVE-2022-49904
Description: In the Linux kernel, the following vulnerability has been resolved:

net, neigh: Fix null-ptr-deref in neigh_table_clear()

When IPv6 module gets initialized but hits an error in the middle,
kenel panic with:

KASAN: null-ptr-deref in range [0x0000000000000598-0x000000000000059f]
CPU: 1 PID: 361 Comm: insmod
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
RIP: 0010:__neigh_ifdown.isra.0+0x24b/0x370
RSP: 0018:ffff888012677908 EFLAGS: 00000202
...
Call Trace:
 <TASK>
 neigh_table_clear+0x94/0x2d0
 ndisc_cleanup+0x27/0x40 [ipv6]
 inet6_init+0x21c/0x2cb [ipv6]
 do_one_initcall+0xd3/0x4d0
 do_init_module+0x1ae/0x670
...
Kernel panic - not syncing: Fatal exception

When ipv6 initialization fails, it will try to cleanup and calls:

neigh_table_clear()
  neigh_ifdown(tbl, NULL)
    pneigh_queue_purge(&tbl->proxy_queue, dev_net(dev == NULL))
    # dev_net(NULL) triggers null-ptr-deref.

Fix it by passing NULL to pneigh_queue_purge() in neigh_ifdown() if dev
is NULL, to make kernel not panic immediately.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.292, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.257, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.212, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.141, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.65, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19.7, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0d38b4ca6679e72860ff8730e79bb99d0e9fa3b0
  - https://git.kernel.org/stable/c/1c89642e7f2b7ecc9635610653f5c2f0276c0051
  - https://git.kernel.org/stable/c/2b45d6d0c41cb9593868e476681efb1aae5078a1
  - https://git.kernel.org/stable/c/a99a8ec4c62180c889482a2ff6465033e0743458
  - https://git.kernel.org/stable/c/b49f6b2f21f543d4dc88fb7b1ec2adccb822f27c
  - https://git.kernel.org/stable/c/b736592de2aa53aee2d48d6b129bc0c892007bbe
  - https://git.kernel.org/stable/c/f8017317cb0b279b8ab98b0f3901a2e0ac880dad

------------------------------------------------------------

CVE ID: CVE-2022-49905
Description: In the Linux kernel, the following vulnerability has been resolved:

net/smc: Fix possible leaked pernet namespace in smc_init()

In smc_init(), register_pernet_subsys(&smc_net_stat_ops) is called
without any error handling.
If it fails, registering of &smc_net_ops won't be reverted.
And if smc_nl_init() fails, &smc_net_stat_ops itself won't be reverted.

This leaves wild ops in subsystem linkedlist and when another module
tries to call register_pernet_operations() it triggers page fault:

BUG: unable to handle page fault for address: fffffbfff81b964c
RIP: 0010:register_pernet_operations+0x1b9/0x5f0
Call Trace:
  <TASK>
  register_pernet_subsys+0x29/0x40
  ebtables_init+0x58/0x1000 [ebtables]
  ...
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/61defd6450a9ef4a1487090449999b0fd83518ef
  - https://git.kernel.org/stable/c/62ff373da2534534c55debe6c724c7fe14adb97f
  - https://git.kernel.org/stable/c/c97daf836f7caf81d3144b8cd2b2a51f9bc3bd09

------------------------------------------------------------

CVE ID: CVE-2022-49906
Description: In the Linux kernel, the following vulnerability has been resolved:

ibmvnic: Free rwi on reset success

Free the rwi structure in the event that the last rwi in the list
processed successfully. The logic in commit 4f408e1fa6e1 ("ibmvnic:
retry reset if there are no other resets") introduces an issue that
results in a 32 byte memory leak whenever the last rwi in the list
gets processed.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/535b78739ae75f257c894a05b1afa86ad9a3669e
  - https://git.kernel.org/stable/c/c3543a287cfba9105dcc4bb41eb817f51266caaf
  - https://git.kernel.org/stable/c/d6dd2fe71153f0ff748bf188bd4af076fe09a0a6

------------------------------------------------------------

CVE ID: CVE-2022-49907
Description: In the Linux kernel, the following vulnerability has been resolved:

net: mdio: fix undefined behavior in bit shift for __mdiobus_register

Shifting signed 32-bit value by 31 bits is undefined, so changing
significant bit to unsigned. The UBSAN warning calltrace like below:

UBSAN: shift-out-of-bounds in drivers/net/phy/mdio_bus.c:586:27
left shift of 1 by 31 places cannot be represented in type 'int'
Call Trace:
 <TASK>
 dump_stack_lvl+0x7d/0xa5
 dump_stack+0x15/0x1b
 ubsan_epilogue+0xe/0x4e
 __ubsan_handle_shift_out_of_bounds+0x1e7/0x20c
 __mdiobus_register+0x49d/0x4e0
 fixed_mdio_bus_init+0xd8/0x12d
 do_one_initcall+0x76/0x430
 kernel_init_freeable+0x3b3/0x422
 kernel_init+0x24/0x1e0
 ret_from_fork+0x1f/0x30
 </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/20ed01a7b9af6e6a3c33761eebbb710ea6dd49b7
  - https://git.kernel.org/stable/c/40e4eb324c59e11fcb927aa46742d28aba6ecb8a
  - https://git.kernel.org/stable/c/4954b5359eb141499492fadfab891e28905509e2
  - https://git.kernel.org/stable/c/634f066d02bdb22a26da7deb0c7617ab1a65fc9d
  - https://git.kernel.org/stable/c/6ce6f8f8f6316da6f92afe7490bc2f0b654d68e0
  - https://git.kernel.org/stable/c/7006176a3c863e3e353ce1b8a349ef5bb1b9320e
  - https://git.kernel.org/stable/c/985a88bf0b27193522bba7856b1763f428cef19d
  - https://git.kernel.org/stable/c/a3fafc974be37319679f36dc4e7cca7db1e02973

------------------------------------------------------------

CVE ID: CVE-2022-49908
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: Fix memory leak in vhci_write

Syzkaller reports a memory leak as follows:
====================================
BUG: memory leak
unreferenced object 0xffff88810d81ac00 (size 240):
  [...]
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<ffffffff838733d9>] __alloc_skb+0x1f9/0x270 net/core/skbuff.c:418
    [<ffffffff833f742f>] alloc_skb include/linux/skbuff.h:1257 [inline]
    [<ffffffff833f742f>] bt_skb_alloc include/net/bluetooth/bluetooth.h:469 [inline]
    [<ffffffff833f742f>] vhci_get_user drivers/bluetooth/hci_vhci.c:391 [inline]
    [<ffffffff833f742f>] vhci_write+0x5f/0x230 drivers/bluetooth/hci_vhci.c:511
    [<ffffffff815e398d>] call_write_iter include/linux/fs.h:2192 [inline]
    [<ffffffff815e398d>] new_sync_write fs/read_write.c:491 [inline]
    [<ffffffff815e398d>] vfs_write+0x42d/0x540 fs/read_write.c:578
    [<ffffffff815e3cdd>] ksys_write+0x9d/0x160 fs/read_write.c:631
    [<ffffffff845e0645>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]
    [<ffffffff845e0645>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
    [<ffffffff84600087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
====================================

HCI core will uses hci_rx_work() to process frame, which is queued to
the hdev->rx_q tail in hci_recv_frame() by HCI driver.

Yet the problem is that, HCI core may not free the skb after handling
ACL data packets. To be more specific, when start fragment does not
contain the L2CAP length, HCI core just copies skb into conn->rx_skb and
finishes frame process in l2cap_recv_acldata(), without freeing the skb,
which triggers the above memory leak.

This patch solves it by releasing the relative skb, after processing
the above case in l2cap_recv_acldata().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/5b4f039a2f487c5edae681d763fe1af505f84c13
  - https://git.kernel.org/stable/c/7c9524d929648935bac2bbb4c20437df8f9c3f42
  - https://git.kernel.org/stable/c/aa16cac06b752e5f609c106735bd7838f444784c

------------------------------------------------------------

CVE ID: CVE-2022-49909
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: fix use-after-free in l2cap_conn_del()

When l2cap_recv_frame() is invoked to receive data, and the cid is
L2CAP_CID_A2MP, if the channel does not exist, it will create a channel.
However, after a channel is created, the hold operation of the channel
is not performed. In this case, the value of channel reference counting
is 1. As a result, after hci_error_reset() is triggered, l2cap_conn_del()
invokes the close hook function of A2MP to release the channel. Then
 l2cap_chan_unlock(chan) will trigger UAF issue.

The process is as follows:
Receive data:
l2cap_data_channel()
    a2mp_channel_create()  --->channel ref is 2
    l2cap_chan_put()       --->channel ref is 1

Triger event:
    hci_error_reset()
        hci_dev_do_close()
        ...
        l2cap_disconn_cfm()
            l2cap_conn_del()
                l2cap_chan_hold()    --->channel ref is 2
                l2cap_chan_del()     --->channel ref is 1
                a2mp_chan_close_cb() --->channel ref is 0, release channel
                l2cap_chan_unlock()  --->UAF of channel

The detailed Call Trace is as follows:
BUG: KASAN: use-after-free in __mutex_unlock_slowpath+0xa6/0x5e0
Read of size 8 at addr ffff8880160664b8 by task kworker/u11:1/7593
Workqueue: hci0 hci_error_reset
Call Trace:
 <TASK>
 dump_stack_lvl+0xcd/0x134
 print_report.cold+0x2ba/0x719
 kasan_report+0xb1/0x1e0
 kasan_check_range+0x140/0x190
 __mutex_unlock_slowpath+0xa6/0x5e0
 l2cap_conn_del+0x404/0x7b0
 l2cap_disconn_cfm+0x8c/0xc0
 hci_conn_hash_flush+0x11f/0x260
 hci_dev_close_sync+0x5f5/0x11f0
 hci_dev_do_close+0x2d/0x70
 hci_error_reset+0x9e/0x140
 process_one_work+0x98a/0x1620
 worker_thread+0x665/0x1080
 kthread+0x2e4/0x3a0
 ret_from_fork+0x1f/0x30
 </TASK>

Allocated by task 7593:
 kasan_save_stack+0x1e/0x40
 __kasan_kmalloc+0xa9/0xd0
 l2cap_chan_create+0x40/0x930
 amp_mgr_create+0x96/0x990
 a2mp_channel_create+0x7d/0x150
 l2cap_recv_frame+0x51b8/0x9a70
 l2cap_recv_acldata+0xaa3/0xc00
 hci_rx_work+0x702/0x1220
 process_one_work+0x98a/0x1620
 worker_thread+0x665/0x1080
 kthread+0x2e4/0x3a0
 ret_from_fork+0x1f/0x30

Freed by task 7593:
 kasan_save_stack+0x1e/0x40
 kasan_set_track+0x21/0x30
 kasan_set_free_info+0x20/0x30
 ____kasan_slab_free+0x167/0x1c0
 slab_free_freelist_hook+0x89/0x1c0
 kfree+0xe2/0x580
 l2cap_chan_put+0x22a/0x2d0
 l2cap_conn_del+0x3fc/0x7b0
 l2cap_disconn_cfm+0x8c/0xc0
 hci_conn_hash_flush+0x11f/0x260
 hci_dev_close_sync+0x5f5/0x11f0
 hci_dev_do_close+0x2d/0x70
 hci_error_reset+0x9e/0x140
 process_one_work+0x98a/0x1620
 worker_thread+0x665/0x1080
 kthread+0x2e4/0x3a0
 ret_from_fork+0x1f/0x30

Last potentially related work creation:
 kasan_save_stack+0x1e/0x40
 __kasan_record_aux_stack+0xbe/0xd0
 call_rcu+0x99/0x740
 netlink_release+0xe6a/0x1cf0
 __sock_release+0xcd/0x280
 sock_close+0x18/0x20
 __fput+0x27c/0xa90
 task_work_run+0xdd/0x1a0
 exit_to_user_mode_prepare+0x23c/0x250
 syscall_exit_to_user_mode+0x19/0x50
 do_syscall_64+0x42/0x80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd

Second to last potentially related work creation:
 kasan_save_stack+0x1e/0x40
 __kasan_record_aux_stack+0xbe/0xd0
 call_rcu+0x99/0x740
 netlink_release+0xe6a/0x1cf0
 __sock_release+0xcd/0x280
 sock_close+0x18/0x20
 __fput+0x27c/0xa90
 task_work_run+0xdd/0x1a0
 exit_to_user_mode_prepare+0x23c/0x250
 syscall_exit_to_user_mode+0x19/0x50
 do_syscall_64+0x42/0x80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.326, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.291, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.255, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.209, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.135, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.59, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0d0e2d032811280b927650ff3c15fe5020e82533
  - https://git.kernel.org/stable/c/17c6164854f8bb80bf76f32b2c2f199c16b53703
  - https://git.kernel.org/stable/c/7f7bfdd9a9af3b12c33d9da9a012e7f4d5c91f4b
  - https://git.kernel.org/stable/c/8f7e4cf0694149a5d999d676ebd9ecf1b4cb2cc9
  - https://git.kernel.org/stable/c/a3a7b2ac64de232edb67279e804932cb42f0b52a
  - https://git.kernel.org/stable/c/c1f594dddd9ffd747c39f49cc5b67a9b7677d2ab
  - https://git.kernel.org/stable/c/d9ec6e2fbd4a565b2345d4852f586b7ae3ab41fd
  - https://git.kernel.org/stable/c/db4a0783ed78beb2ebaa32f5f785bfd79c580689

------------------------------------------------------------

CVE ID: CVE-2022-49910
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: Fix use-after-free caused by l2cap_reassemble_sdu

Fix the race condition between the following two flows that run in
parallel:

1. l2cap_reassemble_sdu -> chan->ops->recv (l2cap_sock_recv_cb) ->
   __sock_queue_rcv_skb.

2. bt_sock_recvmsg -> skb_recv_datagram, skb_free_datagram.

An SKB can be queued by the first flow and immediately dequeued and
freed by the second flow, therefore the callers of l2cap_reassemble_sdu
can't use the SKB after that function returns. However, some places
continue accessing struct l2cap_ctrl that resides in the SKB's CB for a
short time after l2cap_reassemble_sdu returns, leading to a
use-after-free condition (the stack trace is below, line numbers for
kernel 5.19.8).

Fix it by keeping a local copy of struct l2cap_ctrl.

BUG: KASAN: use-after-free in l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth
Read of size 1 at addr ffff88812025f2f0 by task kworker/u17:3/43169

Workqueue: hci0 hci_rx_work [bluetooth]
Call Trace:
 <TASK>
 dump_stack_lvl (lib/dump_stack.c:107 (discriminator 4))
 print_report.cold (mm/kasan/report.c:314 mm/kasan/report.c:429)
 ? l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth
 kasan_report (mm/kasan/report.c:162 mm/kasan/report.c:493)
 ? l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth
 l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth
 l2cap_rx (net/bluetooth/l2cap_core.c:7236 net/bluetooth/l2cap_core.c:7271) bluetooth
 ret_from_fork (arch/x86/entry/entry_64.S:306)
 </TASK>

Allocated by task 43169:
 kasan_save_stack (mm/kasan/common.c:39)
 __kasan_slab_alloc (mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:469)
 kmem_cache_alloc_node (mm/slab.h:750 mm/slub.c:3243 mm/slub.c:3293)
 __alloc_skb (net/core/skbuff.c:414)
 l2cap_recv_frag (./include/net/bluetooth/bluetooth.h:425 net/bluetooth/l2cap_core.c:8329) bluetooth
 l2cap_recv_acldata (net/bluetooth/l2cap_core.c:8442) bluetooth
 hci_rx_work (net/bluetooth/hci_core.c:3642 net/bluetooth/hci_core.c:3832) bluetooth
 process_one_work (kernel/workqueue.c:2289)
 worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2437)
 kthread (kernel/kthread.c:376)
 ret_from_fork (arch/x86/entry/entry_64.S:306)

Freed by task 27920:
 kasan_save_stack (mm/kasan/common.c:39)
 kasan_set_track (mm/kasan/common.c:45)
 kasan_set_free_info (mm/kasan/generic.c:372)
 ____kasan_slab_free (mm/kasan/common.c:368 mm/kasan/common.c:328)
 slab_free_freelist_hook (mm/slub.c:1780)
 kmem_cache_free (mm/slub.c:3536 mm/slub.c:3553)
 skb_free_datagram (./include/net/sock.h:1578 ./include/net/sock.h:1639 net/core/datagram.c:323)
 bt_sock_recvmsg (net/bluetooth/af_bluetooth.c:295) bluetooth
 l2cap_sock_recvmsg (net/bluetooth/l2cap_sock.c:1212) bluetooth
 sock_read_iter (net/socket.c:1087)
 new_sync_read (./include/linux/fs.h:2052 fs/read_write.c:401)
 vfs_read (fs/read_write.c:482)
 ksys_read (fs/read_write.c:620)
 do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)
 entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/03af22e23b96fb7ef75fb7885407ef457e8b403d
  - https://git.kernel.org/stable/c/3aff8aaca4e36dc8b17eaa011684881a80238966
  - https://git.kernel.org/stable/c/4cd094fd5d872862ca278e15b9b51b07e915ef3f
  - https://git.kernel.org/stable/c/6c7407bfbeafc80a04e6eaedcf34d378532a04f2
  - https://git.kernel.org/stable/c/8278a87bb1eeea94350d675ef961ee5a03341fde
  - https://git.kernel.org/stable/c/9a04161244603f502c6e453913e51edd59cb70c1
  - https://git.kernel.org/stable/c/cb1c012099ef5904cd468bdb8d6fcdfdd9bcb569
  - https://git.kernel.org/stable/c/dc30e05bb18852303084430c03ca76e69257d9ea

------------------------------------------------------------

CVE ID: CVE-2022-49911
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: ipset: enforce documented limit to prevent allocating huge memory

Daniel Xu reported that the hash:net,iface type of the ipset subsystem does
not limit adding the same network with different interfaces to a set, which
can lead to huge memory usage or allocation failure.

The quick reproducer is

$ ipset create ACL.IN.ALL_PERMIT hash:net,iface hashsize 1048576 timeout 0
$ for i in $(seq 0 100); do /sbin/ipset add ACL.IN.ALL_PERMIT 0.0.0.0/0,kaf_$i timeout 0 -exist; done

The backtrace when vmalloc fails:

        [Tue Oct 25 00:13:08 2022] ipset: vmalloc error: size 1073741848, exceeds total pages
        <...>
        [Tue Oct 25 00:13:08 2022] Call Trace:
        [Tue Oct 25 00:13:08 2022]  <TASK>
        [Tue Oct 25 00:13:08 2022]  dump_stack_lvl+0x48/0x60
        [Tue Oct 25 00:13:08 2022]  warn_alloc+0x155/0x180
        [Tue Oct 25 00:13:08 2022]  __vmalloc_node_range+0x72a/0x760
        [Tue Oct 25 00:13:08 2022]  ? hash_netiface4_add+0x7c0/0xb20
        [Tue Oct 25 00:13:08 2022]  ? __kmalloc_large_node+0x4a/0x90
        [Tue Oct 25 00:13:08 2022]  kvmalloc_node+0xa6/0xd0
        [Tue Oct 25 00:13:08 2022]  ? hash_netiface4_resize+0x99/0x710
        <...>

The fix is to enforce the limit documented in the ipset(8) manpage:

>  The internal restriction of the hash:net,iface set type is that the same
>  network prefix cannot be stored with more than 64 different interfaces
>  in a single set.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/42d20d5e24575c9afa2d66d9a51e7386db9514f5
  - https://git.kernel.org/stable/c/510841da1fcc16f702440ab58ef0b4d82a9056b7
  - https://git.kernel.org/stable/c/a37ef32fe5956fe9248df68f6a61997845ba047e

------------------------------------------------------------

CVE ID: CVE-2022-49912
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix ulist leaks in error paths of qgroup self tests

In the test_no_shared_qgroup() and test_multiple_refs() qgroup self tests,
if we fail to add the tree ref, remove the extent item or remove the
extent ref, we are returning from the test function without freeing the
"old_roots" ulist that was allocated by the previous calls to
btrfs_find_all_roots(). Fix that by calling ulist_free() before returning.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a0dead4ad1a2e2a9bdf133ef45111d7c8daef84
  - https://git.kernel.org/stable/c/203204798831c35d855ecc6417d98267d2d2184b
  - https://git.kernel.org/stable/c/3f58283d83a588ff5da62fc150de19e798ed2ec2
  - https://git.kernel.org/stable/c/5d1a47ebf84540e40b5b43fc21aef0d6c0f627d9
  - https://git.kernel.org/stable/c/d37de92b38932d40e4a251e876cc388f9aee5f42
  - https://git.kernel.org/stable/c/d81370396025cf63a7a1b5f8bb25a3479203b2ca
  - https://git.kernel.org/stable/c/da7003434bcab0ae9aba3f2c003e734cae093326
  - https://git.kernel.org/stable/c/f46ea5fa3320dca4fe0c0926b49a5f14cb85de62

------------------------------------------------------------

CVE ID: CVE-2022-49913
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix inode list leak during backref walking at find_parent_nodes()

During backref walking, at find_parent_nodes(), if we are dealing with a
data extent and we get an error while resolving the indirect backrefs, at
resolve_indirect_refs(), or in the while loop that iterates over the refs
in the direct refs rbtree, we end up leaking the inode lists attached to
the direct refs we have in the direct refs rbtree that were not yet added
to the refs ulist passed as argument to find_parent_nodes(). Since they
were not yet added to the refs ulist and prelim_release() does not free
the lists, on error the caller can only free the lists attached to the
refs that were added to the refs ulist, all the remaining refs get their
inode lists never freed, therefore leaking their memory.

Fix this by having prelim_release() always free any attached inode list
to each ref found in the rbtree, and have find_parent_nodes() set the
ref's inode list to NULL once it transfers ownership of the inode list
to a ref added to the refs ulist passed to find_parent_nodes().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/222a3d533027b9492d5b7f5ecdc01a90f57bb5a9
  - https://git.kernel.org/stable/c/61e06128113711df0534c404fb6bb528eb7d2332
  - https://git.kernel.org/stable/c/6a6731a0df8c47ecc703bd7bb73459df767051e0
  - https://git.kernel.org/stable/c/83ea8c5b54d452a5769e605e3c5c687e8ca06d89
  - https://git.kernel.org/stable/c/92876eec382a0f19f33d09d2c939e9ca49038ae5

------------------------------------------------------------

CVE ID: CVE-2022-49914
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix inode list leak during backref walking at resolve_indirect_refs()

During backref walking, at resolve_indirect_refs(), if we get an error
we jump to the 'out' label and call ulist_free() on the 'parents' ulist,
which frees all the elements in the ulist - however that does not free
any inode lists that may be attached to elements, through the 'aux' field
of a ulist node, so we end up leaking lists if we have any attached to
the unodes.

Fix this by calling free_leaf_list() instead of ulist_free() when we exit
from resolve_indirect_refs(). The static function free_leaf_list() is
moved up for this to be possible and it's slightly simplified by removing
unnecessary code.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2c0329406bb28109c07c6e23e5e3e0fa618a95d7
  - https://git.kernel.org/stable/c/396515db923ad5cbeb179d6b88927870b4cbebb7
  - https://git.kernel.org/stable/c/5614dc3a47e3310fbc77ea3b67eaadd1c6417bf1
  - https://git.kernel.org/stable/c/6ba3479f9e96b9ad460c7e77abc26dd16e5dec4f
  - https://git.kernel.org/stable/c/a52e24c7fcc3c5ce3588a14e3663c00868d36623
  - https://git.kernel.org/stable/c/b1dc9019bb5f89abae85645de1a2dd4830c1f8e9
  - https://git.kernel.org/stable/c/cded2c89774b99b67c98147ae103ea878c92a206

------------------------------------------------------------

CVE ID: CVE-2022-49915
Description: In the Linux kernel, the following vulnerability has been resolved:

mISDN: fix possible memory leak in mISDN_register_device()

Afer commit 1fa5ae857bb1 ("driver core: get rid of struct device's
bus_id string array"), the name of device is allocated dynamically,
add put_device() to give up the reference, so that the name can be
freed in kobject_cleanup() when the refcount is 0.

Set device class before put_device() to avoid null release() function
WARN message in device_release().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 2.6.30, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/029d5b7688a2f3a86f2a3be5a6ba9cc968c80e41
  - https://git.kernel.org/stable/c/080aabfb29b2ee9cbb8894a1d039651943d3773e
  - https://git.kernel.org/stable/c/0d4e91efcaee081e919b3c50e875ecbb84290e41
  - https://git.kernel.org/stable/c/2ff6b669523d3b3d253a044fa9636a67d0694995
  - https://git.kernel.org/stable/c/a636fc5a7cabd05699b5692ad838c2c7a3abec7b
  - https://git.kernel.org/stable/c/d1d1aede313eb2b9a84afd60ff6cfb7c33631e0e
  - https://git.kernel.org/stable/c/e77d213843e67b4373285712699b692f9c743f61
  - https://git.kernel.org/stable/c/e7d1d4d9ac0dfa40be4c2c8abd0731659869b297

------------------------------------------------------------

CVE ID: CVE-2022-49916
Description: In the Linux kernel, the following vulnerability has been resolved:

rose: Fix NULL pointer dereference in rose_send_frame()

The syzkaller reported an issue:

KASAN: null-ptr-deref in range [0x0000000000000380-0x0000000000000387]
CPU: 0 PID: 4069 Comm: kworker/0:15 Not tainted 6.0.0-syzkaller-02734-g0326074ff465 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022
Workqueue: rcu_gp srcu_invoke_callbacks
RIP: 0010:rose_send_frame+0x1dd/0x2f0 net/rose/rose_link.c:101
Call Trace:
 <IRQ>
 rose_transmit_clear_request+0x1d5/0x290 net/rose/rose_link.c:255
 rose_rx_call_request+0x4c0/0x1bc0 net/rose/af_rose.c:1009
 rose_loopback_timer+0x19e/0x590 net/rose/rose_loopback.c:111
 call_timer_fn+0x1a0/0x6b0 kernel/time/timer.c:1474
 expire_timers kernel/time/timer.c:1519 [inline]
 __run_timers.part.0+0x674/0xa80 kernel/time/timer.c:1790
 __run_timers kernel/time/timer.c:1768 [inline]
 run_timer_softirq+0xb3/0x1d0 kernel/time/timer.c:1803
 __do_softirq+0x1d0/0x9c8 kernel/softirq.c:571
 [...]
 </IRQ>

It triggers NULL pointer dereference when 'neigh->dev->dev_addr' is
called in the rose_send_frame(). It's the first occurrence of the
`neigh` is in rose_loopback_timer() as `rose_loopback_neigh', and
the 'dev' in 'rose_loopback_neigh' is initialized sa nullptr.

It had been fixed by commit 3b3fd068c56e3fbea30090859216a368398e39bf
("rose: Fix Null pointer dereference in rose_send_frame()") ever.
But it's introduced by commit 3c53cd65dece47dd1f9d3a809f32e59d1d87b2b8
("rose: check NULL rose_loopback_neigh->loopback") again.

We fix it by add NULL check in rose_transmit_clear_request(). When
the 'dev' in 'neigh' is NULL, we don't reply the request and just
clear it.

syzkaller don't provide repro, and I provide a syz repro like:
r0 = syz_init_net_socket$bt_sco(0x1f, 0x5, 0x2)
ioctl$sock_inet_SIOCSIFFLAGS(r0, 0x8914, &(0x7f0000000180)={'rose0\x00', 0x201})
r1 = syz_init_net_socket$rose(0xb, 0x5, 0x0)
bind$rose(r1, &(0x7f00000000c0)=@full={0xb, @dev, @null, 0x0, [@null, @null, @netrom, @netrom, @default, @null]}, 0x40)
connect$rose(r1, &(0x7f0000000240)=@short={0xb, @dev={0xbb, 0xbb, 0xbb, 0x1, 0x0}, @remote={0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x1}, 0x1, @netrom={0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x0, 0x0}}, 0x1c)
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.9.327, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.14.292, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.19.257, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.212, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.140, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.64, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.19.6, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/01b9c68c121847d05a4ccef68244dadf82bfa331
  - https://git.kernel.org/stable/c/3e2129c67daca21043a26575108f6286c85e71f6
  - https://git.kernel.org/stable/c/5b46adfbee1e429f33b10a88d6c00fa88f3d6c77
  - https://git.kernel.org/stable/c/a601e5eded33bb88b8a42743db8fef3ad41dd97e
  - https://git.kernel.org/stable/c/b13be5e852b03f376058027e462fad4230240891
  - https://git.kernel.org/stable/c/bbc03d74e641e824754443b908454ca9e203773e
  - https://git.kernel.org/stable/c/e97c089d7a49f67027395ddf70bf327eeac2611e
  - https://git.kernel.org/stable/c/f06186e5271b980bac03f5c97276ed0146ddc9b0

------------------------------------------------------------

CVE ID: CVE-2022-49917
Description: In the Linux kernel, the following vulnerability has been resolved:

ipvs: fix WARNING in ip_vs_app_net_cleanup()

During the initialization of ip_vs_app_net_init(), if file ip_vs_app
fails to be created, the initialization is successful by default.
Therefore, the ip_vs_app file doesn't be found during the remove in
ip_vs_app_net_cleanup(). It will cause WRNING.

The following is the stack information:
name 'ip_vs_app'
WARNING: CPU: 1 PID: 9 at fs/proc/generic.c:712 remove_proc_entry+0x389/0x460
Modules linked in:
Workqueue: netns cleanup_net
RIP: 0010:remove_proc_entry+0x389/0x460
Call Trace:
<TASK>
ops_exit_list+0x125/0x170
cleanup_net+0x4ea/0xb00
process_one_work+0x9bf/0x1710
worker_thread+0x665/0x1080
kthread+0x2e4/0x3a0
ret_from_fork+0x1f/0x30
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/06d7596d18725f1a93cf817662d36050e5afb989
  - https://git.kernel.org/stable/c/2c8d81bdb2684d53d6cedad7410ba4cf9090e343
  - https://git.kernel.org/stable/c/5663ed63adb9619c98ab7479aa4606fa9b7a548c
  - https://git.kernel.org/stable/c/8457a00c981fe1a799ce34123908856b0f5973b8
  - https://git.kernel.org/stable/c/97f872b00937f2689bff2dab4ad9ed259482840f
  - https://git.kernel.org/stable/c/adc76740ccd52e4a1d910767cd1223e134a7078b

------------------------------------------------------------

CVE ID: CVE-2022-49918
Description: In the Linux kernel, the following vulnerability has been resolved:

ipvs: fix WARNING in __ip_vs_cleanup_batch()

During the initialization of ip_vs_conn_net_init(), if file ip_vs_conn
or ip_vs_conn_sync fails to be created, the initialization is successful
by default. Therefore, the ip_vs_conn or ip_vs_conn_sync file doesn't
be found during the remove.

The following is the stack information:
name 'ip_vs_conn_sync'
WARNING: CPU: 3 PID: 9 at fs/proc/generic.c:712
remove_proc_entry+0x389/0x460
Modules linked in:
Workqueue: netns cleanup_net
RIP: 0010:remove_proc_entry+0x389/0x460
Call Trace:
<TASK>
__ip_vs_cleanup_batch+0x7d/0x120
ops_exit_list+0x125/0x170
cleanup_net+0x4ea/0xb00
process_one_work+0x9bf/0x1710
worker_thread+0x665/0x1080
kthread+0x2e4/0x3a0
ret_from_fork+0x1f/0x30
</TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3d00c6a0da8ddcf75213e004765e4a42acc71d5d
  - https://git.kernel.org/stable/c/5ee2d6b726b0ce339e36569e5849692f4cf4595e
  - https://git.kernel.org/stable/c/7effc4ce3d1434ce6ff286866585a6e905fdbfc1
  - https://git.kernel.org/stable/c/931f56d59c854263b32075bfac56fdb3b1598d1b
  - https://git.kernel.org/stable/c/e724220b826e008764309d2a1f55a9434a4e1530
  - https://git.kernel.org/stable/c/f08ee2aa24c076f81d84e26e213d8c6f4efd9f50

------------------------------------------------------------

CVE ID: CVE-2022-49919
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: release flow rule object from commit path

No need to postpone this to the commit release path, since no packets
are walking over this object, this is accessed from control plane only.
This helped uncovered UAF triggered by races with the netlink notifier.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.0
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.198, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.122, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.15.47, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.17.15, Last Version (Excluding): 5.18
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18.4, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/26b5934ff4194e13196bedcba373cd4915071d0e
  - https://git.kernel.org/stable/c/4ab6f96444e936f5e4a936d5c0bc948144bcded3
  - https://git.kernel.org/stable/c/6044791b7be707fd0e709f26e961a446424e5051
  - https://git.kernel.org/stable/c/74fd5839467054cd9c4d050614d3ee8788386171
  - https://git.kernel.org/stable/c/b2d7a92aff0fbd93c29d2aa6451fb99f050e2c4e

------------------------------------------------------------

CVE ID: CVE-2022-49920
Description: In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: netlink notifier might race to release objects

commit release path is invoked via call_rcu and it runs lockless to
release the objects after rcu grace period. The netlink notifier handler
might win race to remove objects that the transaction context is still
referencing from the commit release path.

Call rcu_barrier() to ensure pending rcu callbacks run to completion
if the list of transactions to be destroyed is not empty.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.7
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.12, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1ffe7100411a8b9015115ce124cd6c9c9da6f8e3
  - https://git.kernel.org/stable/c/d4bc8271db21ea9f1c86a1ca4d64999f184d4aae
  - https://git.kernel.org/stable/c/e40b7c44d19e327ad8b49a491ef1fa8dcc4566e0

------------------------------------------------------------

CVE ID: CVE-2022-49921
Description: In the Linux kernel, the following vulnerability has been resolved:

net: sched: Fix use after free in red_enqueue()

We can't use "skb" again after passing it to qdisc_enqueue().  This is
basically identical to commit 2f09707d0c97 ("sch_sfb: Also store skb
len before calling child enqueue").
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4.163, Last Version (Excluding): 4.5
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.7, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/170e5317042c302777ed6d59fdb84af9b0219d4e
  - https://git.kernel.org/stable/c/52e0429471976785c155bfbf51d80990c6cd46e2
  - https://git.kernel.org/stable/c/5960b9081baca85cc7dcb14aec1de85999ea9d36
  - https://git.kernel.org/stable/c/795afe0b9bb6c915f0299a8e309936519be01619
  - https://git.kernel.org/stable/c/8bdc2acd420c6f3dd1f1c78750ec989f02a1e2b9
  - https://git.kernel.org/stable/c/a238cdcf2bdc72207c74375fc8be13ee549ca9db
  - https://git.kernel.org/stable/c/e877f8fa49fbccc63cb2df2e9179bddc695b825a
  - https://git.kernel.org/stable/c/fc4b50adb400ee5ec527a04073174e8e73a139fa

------------------------------------------------------------

CVE ID: CVE-2022-49922
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: nfcmrvl: Fix potential memory leak in nfcmrvl_i2c_nci_send()

nfcmrvl_i2c_nci_send() will be called by nfcmrvl_nci_send(), and skb
should be freed in nfcmrvl_i2c_nci_send(). However, nfcmrvl_nci_send()
will only free skb when i2c_master_send() return >=0, which means skb
will memleak when i2c_master_send() failed. Free skb no matter whether
i2c_master_send() succeeds.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/52438e734c1566f5e2bcd9a065d2d65e306c0555
  - https://git.kernel.org/stable/c/5dfdac5e3f8db5f4445228c44f64091045644a3b
  - https://git.kernel.org/stable/c/825656ae61e73ddc05f585e6258d284c87064b10
  - https://git.kernel.org/stable/c/92a1df9c6da20c02cf9872f8b025a66ddb307aeb
  - https://git.kernel.org/stable/c/93d904a734a74c54d945a9884b4962977f1176cd
  - https://git.kernel.org/stable/c/c8e7d4a1166f063703955f1b2e765a6db5bf1771
  - https://git.kernel.org/stable/c/dd0ee55ead91fbb16889dbe7ff0b0f7c9e4e849d
  - https://git.kernel.org/stable/c/f30060efcf18883748a0541aa41acef183cd9c0e

------------------------------------------------------------

CVE ID: CVE-2022-49923
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: nxp-nci: Fix potential memory leak in nxp_nci_send()

nxp_nci_send() will call nxp_nci_i2c_write(), and only free skb when
nxp_nci_i2c_write() failed. However, even if the nxp_nci_i2c_write()
run succeeds, the skb will not be freed in nxp_nci_i2c_write(). As the
result, the skb will memleak. nxp_nci_send() should also free the skb
when nxp_nci_i2c_write() succeeds.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.1, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/3cba1f061bfe23fece2841129ca2862cdec29d5c
  - https://git.kernel.org/stable/c/3ecf0f4227029b2c42e036b10ff6e5d09e20821e
  - https://git.kernel.org/stable/c/7bf1ed6aff0f70434bd0cdd45495e83f1dffb551
  - https://git.kernel.org/stable/c/9ae2c9a91ff068f4c3e392f47e8e26a1c9f85ebb

------------------------------------------------------------

CVE ID: CVE-2022-49924
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: fdp: Fix potential memory leak in fdp_nci_send()

fdp_nci_send() will call fdp_nci_i2c_write that will not free skb in
the function. As a result, when fdp_nci_i2c_write() finished, the skb
will memleak. fdp_nci_send() should free skb after fdp_nci_i2c_write()
finished.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.4, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1a7a898f8f7b56c0eaa2baf67a0c96235a30bc29
  - https://git.kernel.org/stable/c/44bc1868a4f542502ea2221fe5ad88ca66d1c6b6
  - https://git.kernel.org/stable/c/8e4aae6b8ca76afb1fb64dcb24be44ba814e7f8a
  - https://git.kernel.org/stable/c/e8c11ee2d07f7c4dfa2ac0ea8efc4f627e58ea57

------------------------------------------------------------

CVE ID: CVE-2022-49925
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/core: Fix null-ptr-deref in ib_core_cleanup()

KASAN reported a null-ptr-deref error:

  KASAN: null-ptr-deref in range [0x0000000000000118-0x000000000000011f]
  CPU: 1 PID: 379
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)
  RIP: 0010:destroy_workqueue+0x2f/0x740
  RSP: 0018:ffff888016137df8 EFLAGS: 00000202
  ...
  Call Trace:
   ib_core_cleanup+0xa/0xa1 [ib_core]
   __do_sys_delete_module.constprop.0+0x34f/0x5b0
   do_syscall_64+0x3a/0x90
   entry_SYSCALL_64_after_hwframe+0x63/0xcd
  RIP: 0033:0x7fa1a0d221b7
  ...

It is because the fail of roce_gid_mgmt_init() is ignored:

 ib_core_init()
   roce_gid_mgmt_init()
     gid_cache_wq = alloc_ordered_workqueue # fail
 ...
 ib_core_cleanup()
   roce_gid_mgmt_cleanup()
     destroy_workqueue(gid_cache_wq)
     # destroy an unallocated wq

Fix this by catching the fail of roce_gid_mgmt_init() in ib_core_init().
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.3, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/07c0d131cc0fe1f3981a42958fc52d573d303d89
  - https://git.kernel.org/stable/c/6b3d5dcb12347f3518308c2c9d2cf72453a3e1e5
  - https://git.kernel.org/stable/c/ab817f75e5e0fa58d9be0825da6a7b7d8a1fa1d9
  - https://git.kernel.org/stable/c/af8fb5a0600e9ae29950e9422a032c3c22649ee5
  - https://git.kernel.org/stable/c/d360e875c011a005628525bf290322058927e7dc

------------------------------------------------------------

CVE ID: CVE-2022-49926
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: Fix possible memory leaks in dsa_loop_init()

kmemleak reported memory leaks in dsa_loop_init():

kmemleak: 12 new suspected memory leaks

unreferenced object 0xffff8880138ce000 (size 2048):
  comm "modprobe", pid 390, jiffies 4295040478 (age 238.976s)
  backtrace:
    [<000000006a94f1d5>] kmalloc_trace+0x26/0x60
    [<00000000a9c44622>] phy_device_create+0x5d/0x970
    [<00000000d0ee2afc>] get_phy_device+0xf3/0x2b0
    [<00000000dca0c71f>] __fixed_phy_register.part.0+0x92/0x4e0
    [<000000008a834798>] fixed_phy_register+0x84/0xb0
    [<0000000055223fcb>] dsa_loop_init+0xa9/0x116 [dsa_loop]
    ...

There are two reasons for memleak in dsa_loop_init().

First, fixed_phy_register() create and register phy_device:

fixed_phy_register()
  get_phy_device()
    phy_device_create() # freed by phy_device_free()
  phy_device_register() # freed by phy_device_remove()

But fixed_phy_unregister() only calls phy_device_remove().
So the memory allocated in phy_device_create() is leaked.

Second, when mdio_driver_register() fail in dsa_loop_init(),
it just returns and there is no cleanup for phydevs.

Fix the problems by catching the error of mdio_driver_register()
in dsa_loop_init(), then calling both fixed_phy_unregister() and
phy_device_free() to release phydevs.
Also add a function for phydevs cleanup to avoid duplacate.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.12, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/37a098fc9b42bd7fce66764866aa514639667b6e
  - https://git.kernel.org/stable/c/4d2024b138d9f7b02ae13ee997fd3a71e9e46254
  - https://git.kernel.org/stable/c/633efc8b3dc96f56f5a57f2a49764853a2fa3f50
  - https://git.kernel.org/stable/c/935b4beb724946a37cebf97191592d4879d3a3a3
  - https://git.kernel.org/stable/c/9f555b1584fc2d5d16ee3c4d9438e93ac7c502c7
  - https://git.kernel.org/stable/c/bbc5d7b46a729bfcbb5544f6612b7a67dd4f4d6f
  - https://git.kernel.org/stable/c/d593e1ede655b74c42e4e4fe285ea64aee96fb5c

------------------------------------------------------------

CVE ID: CVE-2022-49927
Description: In the Linux kernel, the following vulnerability has been resolved:

nfs4: Fix kmemleak when allocate slot failed

If one of the slot allocate failed, should cleanup all the other
allocated slots, otherwise, the allocated slots will leak:

  unreferenced object 0xffff8881115aa100 (size 64):
    comm ""mount.nfs"", pid 679, jiffies 4294744957 (age 115.037s)
    hex dump (first 32 bytes):
      00 cc 19 73 81 88 ff ff 00 a0 5a 11 81 88 ff ff  ...s......Z.....
      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    backtrace:
      [<000000007a4c434a>] nfs4_find_or_create_slot+0x8e/0x130
      [<000000005472a39c>] nfs4_realloc_slot_table+0x23f/0x270
      [<00000000cd8ca0eb>] nfs40_init_client+0x4a/0x90
      [<00000000128486db>] nfs4_init_client+0xce/0x270
      [<000000008d2cacad>] nfs4_set_client+0x1a2/0x2b0
      [<000000000e593b52>] nfs4_create_server+0x300/0x5f0
      [<00000000e4425dd2>] nfs4_try_get_tree+0x65/0x110
      [<00000000d3a6176f>] vfs_get_tree+0x41/0xf0
      [<0000000016b5ad4c>] path_mount+0x9b3/0xdd0
      [<00000000494cae71>] __x64_sys_mount+0x190/0x1d0
      [<000000005d56bdec>] do_syscall_64+0x35/0x80
      [<00000000687c9ae4>] entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 3.12, Last Version (Excluding): 4.9.333
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.10, Last Version (Excluding): 4.14.299
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.15, Last Version (Excluding): 4.19.265
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 4.20, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.5, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.11, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/24641993a7dce6b1628645f4e1d97ca06c9f765d
  - https://git.kernel.org/stable/c/45aea4fbf61e205649c29200726b9f45c1718a67
  - https://git.kernel.org/stable/c/7e8436728e22181c3f12a5dbabd35ed3a8b8c593
  - https://git.kernel.org/stable/c/84b5cb476903003ae9ca88f32b57ff0eaefa6d4c
  - https://git.kernel.org/stable/c/86ce0e93cf6fb4d0c447323ac66577c642628b9d
  - https://git.kernel.org/stable/c/925cb538bd5851154602818dc80bf4b4d924c127
  - https://git.kernel.org/stable/c/aae35a0c8a775fa4afa6a4e7dab3f936f1f89bbb
  - https://git.kernel.org/stable/c/db333ae981fb8843c383aa7dbf62cc682597d401

------------------------------------------------------------

CVE ID: CVE-2022-49928
Description: In the Linux kernel, the following vulnerability has been resolved:

SUNRPC: Fix null-ptr-deref when xps sysfs alloc failed

There is a null-ptr-deref when xps sysfs alloc failed:
  BUG: KASAN: null-ptr-deref in sysfs_do_create_link_sd+0x40/0xd0
  Read of size 8 at addr 0000000000000030 by task gssproxy/457

  CPU: 5 PID: 457 Comm: gssproxy Not tainted 6.0.0-09040-g02357b27ee03 #9
  Call Trace:
   <TASK>
   dump_stack_lvl+0x34/0x44
   kasan_report+0xa3/0x120
   sysfs_do_create_link_sd+0x40/0xd0
   rpc_sysfs_client_setup+0x161/0x1b0
   rpc_new_client+0x3fc/0x6e0
   rpc_create_xprt+0x71/0x220
   rpc_create+0x1d4/0x350
   gssp_rpc_create+0xc3/0x160
   set_gssp_clnt+0xbc/0x140
   write_gssp+0x116/0x1a0
   proc_reg_write+0xd6/0x130
   vfs_write+0x177/0x690
   ksys_write+0xb9/0x150
   do_syscall_64+0x35/0x80
   entry_SYSCALL_64_after_hwframe+0x46/0xb0

When the xprt_switch sysfs alloc failed, should not add xprt and
switch sysfs to it, otherwise, maybe null-ptr-deref; also initialize
the 'xps_sysfs' to NULL to avoid oops when destroy it.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/7b189b0aa8dab14b49c31c65af8a982e96e25b62
  - https://git.kernel.org/stable/c/cbdeaee94a415800c65a8c3fa04d9664a8b8fb3a
  - https://git.kernel.org/stable/c/d59722d088a9d86ce6d9d39979e5d1d669d249f7

------------------------------------------------------------

CVE ID: CVE-2022-49929
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/rxe: Fix mr leak in RESPST_ERR_RNR

rxe_recheck_mr() will increase mr's ref_cnt, so we should call rxe_put(mr)
to drop mr's ref_cnt in RESPST_ERR_RNR to avoid below warning:

  WARNING: CPU: 0 PID: 4156 at drivers/infiniband/sw/rxe/rxe_pool.c:259 __rxe_cleanup+0x1df/0x240 [rdma_rxe]
...
  Call Trace:
   rxe_dereg_mr+0x4c/0x60 [rdma_rxe]
   ib_dereg_mr_user+0xa8/0x200 [ib_core]
   ib_mr_pool_destroy+0x77/0xb0 [ib_core]
   nvme_rdma_destroy_queue_ib+0x89/0x240 [nvme_rdma]
   nvme_rdma_free_queue+0x40/0x50 [nvme_rdma]
   nvme_rdma_teardown_io_queues.part.0+0xc3/0x120 [nvme_rdma]
   nvme_rdma_error_recovery_work+0x4d/0xf0 [nvme_rdma]
   process_one_work+0x582/0xa40
   ? pwq_dec_nr_in_flight+0x100/0x100
   ? rwlock_bug.part.0+0x60/0x60
   worker_thread+0x2a9/0x700
   ? process_one_work+0xa40/0xa40
   kthread+0x168/0x1a0
   ? kthread_complete_and_exit+0x20/0x20
   ret_from_fork+0x22/0x30
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/50b35ad2864a9d66f802f9ce193d99bbef64e219
  - https://git.kernel.org/stable/c/b5f9a01fae42684648c2ee3cd9985f80c67ab9f7

------------------------------------------------------------

CVE ID: CVE-2022-49930
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/hns: Fix NULL pointer problem in free_mr_init()

Lock grab occurs in a concurrent scenario, resulting in stepping on a NULL
pointer.  It should be init mutex_init() first before use the lock.

  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
  Call trace:
   __mutex_lock.constprop.0+0xd0/0x5c0
   __mutex_lock_slowpath+0x1c/0x2c
   mutex_lock+0x44/0x50
   free_mr_send_cmd_to_hw+0x7c/0x1c0 [hns_roce_hw_v2]
   hns_roce_v2_dereg_mr+0x30/0x40 [hns_roce_hw_v2]
   hns_roce_dereg_mr+0x4c/0x130 [hns_roce_hw_v2]
   ib_dereg_mr_user+0x54/0x124
   uverbs_free_mr+0x24/0x30
   destroy_hw_idr_uobject+0x38/0x74
   uverbs_destroy_uobject+0x48/0x1c4
   uobj_destroy+0x74/0xcc
   ib_uverbs_cmd_verbs+0x368/0xbb0
   ib_uverbs_ioctl+0xec/0x1a4
   __arm64_sys_ioctl+0xb4/0x100
   invoke_syscall+0x50/0x120
   el0_svc_common.constprop.0+0x58/0x190
   do_el0_svc+0x30/0x90
   el0_svc+0x2c/0xb4
   el0t_64_sync_handler+0x1a4/0x1b0
   el0t_64_sync+0x19c/0x1a0
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.18, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/0e23e85d86b78e734dd6654f1b69fbaeb5534c81
  - https://git.kernel.org/stable/c/12bcaf87d8b66d8cd812479c8a6349dcb245375c

------------------------------------------------------------

CVE ID: CVE-2022-49931
Description: In the Linux kernel, the following vulnerability has been resolved:

IB/hfi1: Correctly move list in sc_disable()

Commit 13bac861952a ("IB/hfi1: Fix abba locking issue with sc_disable()")
incorrectly tries to move a list from one list head to another.  The
result is a kernel crash.

The crash is triggered when a link goes down and there are waiters for a
send to complete.  The following signature is seen:

  BUG: kernel NULL pointer dereference, address: 0000000000000030
  [...]
  Call Trace:
   sc_disable+0x1ba/0x240 [hfi1]
   pio_freeze+0x3d/0x60 [hfi1]
   handle_freeze+0x27/0x1b0 [hfi1]
   process_one_work+0x1b0/0x380
   ? process_one_work+0x380/0x380
   worker_thread+0x30/0x360
   ? process_one_work+0x380/0x380
   kthread+0xd7/0x100
   ? kthread_complete_and_exit+0x20/0x20
   ret_from_fork+0x1f/0x30

The fix is to use the correct call to move the list.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.4.157, Last Version (Excluding): 5.4.224
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.10.77, Last Version (Excluding): 5.10.154
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.14.16, Last Version (Excluding): 5.15.78
  - Vendor: linux, Product: linux_kernel, Version: *, First Version (Including): 5.16, Last Version (Excluding): 6.0.8
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
  - Vendor: linux, Product: linux_kernel, Version: 6.1, First Version (Including): None, Last Version (Excluding): None
References:
  - https://git.kernel.org/stable/c/1afac08b39d85437187bb2a92d89a741b1078f55
  - https://git.kernel.org/stable/c/25760a41e3802f54aadcc31385543665ab349b8e
  - https://git.kernel.org/stable/c/7c4260f8f188df32414a5ecad63e8b934c2aa3f0
  - https://git.kernel.org/stable/c/b8bcff99b07cc175a6ee12a52db51cdd2229586c
  - https://git.kernel.org/stable/c/ba95409d6b580501ff6d78efd00064f7df669926

------------------------------------------------------------

CVE ID: CVE-2025-23246
Description: NVIDIA vGPU software for Windows and Linux contains a vulnerability in the Virtual GPU Manager (vGPU plugin), where it allows a guest to consume uncontrolled resources. A successful exploit of this vulnerability might lead to denial of service.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://nvidia.custhelp.com/app/answers/detail/a_id/5630

------------------------------------------------------------

CVE ID: CVE-2024-52903
Description: IBM Db2 for Linux, UNIX and Windows 12.1.0 and 12.1.1 is vulnerable to a denial of service as the server may crash under certain conditions with a specially crafted query.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://www.ibm.com/support/pages/node/7232336

------------------------------------------------------------

CVE ID: CVE-2025-37797
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: hfsc: Fix a UAF vulnerability in class handling

This patch fixes a Use-After-Free vulnerability in the HFSC qdisc class
handling. The issue occurs due to a time-of-check/time-of-use condition
in hfsc_change_class() when working with certain child qdiscs like netem
or codel.

The vulnerability works as follows:
1. hfsc_change_class() checks if a class has packets (q.qlen != 0)
2. It then calls qdisc_peek_len(), which for certain qdiscs (e.g.,
   codel, netem) might drop packets and empty the queue
3. The code continues assuming the queue is still non-empty, adding
   the class to vttree
4. This breaks HFSC scheduler assumptions that only non-empty classes
   are in vttree
5. Later, when the class is destroyed, this can lead to a Use-After-Free

The fix adds a second queue length check after qdisc_peek_len() to verify
the queue wasn't emptied.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/20d584a33e480ae80d105f43e0e7b56784da41b9
  - https://git.kernel.org/stable/c/28b09a067831f7317c3841812276022d6c940677
  - https://git.kernel.org/stable/c/39b9095dd3b55d9b2743df038c32138efa34a9de
  - https://git.kernel.org/stable/c/3aa852e3605000d5c47035c3fc3a986d14ccfa9f
  - https://git.kernel.org/stable/c/3df275ef0a6ae181e8428a6589ef5d5231e58b5c
  - https://git.kernel.org/stable/c/86cd4641c713455a4f1c8e54c370c598c2b1cee0
  - https://git.kernel.org/stable/c/bb583c88d23b72d8d16453d24856c99bd93dadf5
  - https://git.kernel.org/stable/c/fcc8ede663569c704fb00a702973bd6c00373283

------------------------------------------------------------

CVE ID: CVE-2025-37798
Description: In the Linux kernel, the following vulnerability has been resolved:

codel: remove sch->q.qlen check before qdisc_tree_reduce_backlog()

After making all ->qlen_notify() callbacks idempotent, now it is safe to
remove the check of qlen!=0 from both fq_codel_dequeue() and
codel_qdisc_dequeue().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2f9761a94bae33d26e6a81b31b36e7d776d93dc1
  - https://git.kernel.org/stable/c/342debc12183b51773b3345ba267e9263bdfaaef
  - https://git.kernel.org/stable/c/4d55144b12e742404bb3f8fee6038bafbf45619d
  - https://git.kernel.org/stable/c/829c49b6b2ff45b043739168fd1245e4e1a91a30
  - https://git.kernel.org/stable/c/a57fe60ef4cf96bfbb6b58397ec28bdb5a5c6b31
  - https://git.kernel.org/stable/c/e73c838c80dccb9e4f19becc11d9f3cb4a27d483

------------------------------------------------------------

CVE ID: CVE-2022-49932
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: VMX: Do _all_ initialization before exposing /dev/kvm to userspace

Call kvm_init() only after _all_ setup is complete, as kvm_init() exposes
/dev/kvm to userspace and thus allows userspace to create VMs (and call
other ioctls).  E.g. KVM will encounter a NULL pointer when attempting to
add a vCPU to the per-CPU loaded_vmcss_on_cpu list if userspace is able to
create a VM before vmx_init() configures said list.

 BUG: kernel NULL pointer dereference, address: 0000000000000008
 #PF: supervisor write access in kernel mode
 #PF: error_code(0x0002) - not-present page
 PGD 0 P4D 0
 Oops: 0002 [#1] SMP
 CPU: 6 PID: 1143 Comm: stable Not tainted 6.0.0-rc7+ #988
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015
 RIP: 0010:vmx_vcpu_load_vmcs+0x68/0x230 [kvm_intel]
  <TASK>
  vmx_vcpu_load+0x16/0x60 [kvm_intel]
  kvm_arch_vcpu_load+0x32/0x1f0 [kvm]
  vcpu_load+0x2f/0x40 [kvm]
  kvm_arch_vcpu_create+0x231/0x310 [kvm]
  kvm_vm_ioctl+0x79f/0xe10 [kvm]
  ? handle_mm_fault+0xb1/0x220
  __x64_sys_ioctl+0x80/0xb0
  do_syscall_64+0x2b/0x50
  entry_SYSCALL_64_after_hwframe+0x46/0xb0
 RIP: 0033:0x7f5a6b05743b
  </TASK>
 Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel(+) kvm irqbypass
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/e136e969d268b9b89329c816c002e53f60e82985
  - https://git.kernel.org/stable/c/e28533c08023c4b319b7f2cd77f3f7c9204eb517
  - https://git.kernel.org/stable/c/e32b120071ea114efc0b4ddd439547750b85f618

------------------------------------------------------------

CVE ID: CVE-2022-49933
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: VMX: Reset eVMCS controls in VP assist page during hardware disabling

Reset the eVMCS controls in the per-CPU VP assist page during hardware
disabling instead of waiting until kvm-intel's module exit.  The controls
are activated if and only if KVM creates a VM, i.e. don't need to be
reset if hardware is never enabled.

Doing the reset during hardware disabling will naturally fix a potential
NULL pointer deref bug once KVM disables CPU hotplug while enabling and
disabling hardware (which is necessary to fix a variety of bugs).  If the
kernel is running as the root partition, the VP assist page is unmapped
during CPU hot unplug, and so KVM's clearing of the eVMCS controls needs
to occur with CPU hot(un)plug disabled, otherwise KVM could attempt to
write to a CPU's VP assist page after it's unmapped.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01aa8e5704bac9fcd7401eb1a74a375fba594203
  - https://git.kernel.org/stable/c/2916b70fc342719f570640de07251b7f91feebdb
  - https://git.kernel.org/stable/c/afb26bfc01db6ef4728e96314f08431934ffe833

------------------------------------------------------------

CVE ID: CVE-2023-53035
Description: In the Linux kernel, the following vulnerability has been resolved:

nilfs2: fix kernel-infoleak in nilfs_ioctl_wrap_copy()

The ioctl helper function nilfs_ioctl_wrap_copy(), which exchanges a
metadata array to/from user space, may copy uninitialized buffer regions
to user space memory for read-only ioctl commands NILFS_IOCTL_GET_SUINFO
and NILFS_IOCTL_GET_CPINFO.

This can occur when the element size of the user space metadata given by
the v_size member of the argument nilfs_argv structure is larger than the
size of the metadata element (nilfs_suinfo structure or nilfs_cpinfo
structure) on the file system side.

KMSAN-enabled kernels detect this issue as follows:

 BUG: KMSAN: kernel-infoleak in instrument_copy_to_user
 include/linux/instrumented.h:121 [inline]
 BUG: KMSAN: kernel-infoleak in _copy_to_user+0xc0/0x100 lib/usercopy.c:33
  instrument_copy_to_user include/linux/instrumented.h:121 [inline]
  _copy_to_user+0xc0/0x100 lib/usercopy.c:33
  copy_to_user include/linux/uaccess.h:169 [inline]
  nilfs_ioctl_wrap_copy+0x6fa/0xc10 fs/nilfs2/ioctl.c:99
  nilfs_ioctl_get_info fs/nilfs2/ioctl.c:1173 [inline]
  nilfs_ioctl+0x2402/0x4450 fs/nilfs2/ioctl.c:1290
  nilfs_compat_ioctl+0x1b8/0x200 fs/nilfs2/ioctl.c:1343
  __do_compat_sys_ioctl fs/ioctl.c:968 [inline]
  __se_compat_sys_ioctl+0x7dd/0x1000 fs/ioctl.c:910
  __ia32_compat_sys_ioctl+0x93/0xd0 fs/ioctl.c:910
  do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline]
  __do_fast_syscall_32+0xa2/0x100 arch/x86/entry/common.c:178
  do_fast_syscall_32+0x37/0x80 arch/x86/entry/common.c:203
  do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:246
  entry_SYSENTER_compat_after_hwframe+0x70/0x82

 Uninit was created at:
  __alloc_pages+0x9f6/0xe90 mm/page_alloc.c:5572
  alloc_pages+0xab0/0xd80 mm/mempolicy.c:2287
  __get_free_pages+0x34/0xc0 mm/page_alloc.c:5599
  nilfs_ioctl_wrap_copy+0x223/0xc10 fs/nilfs2/ioctl.c:74
  nilfs_ioctl_get_info fs/nilfs2/ioctl.c:1173 [inline]
  nilfs_ioctl+0x2402/0x4450 fs/nilfs2/ioctl.c:1290
  nilfs_compat_ioctl+0x1b8/0x200 fs/nilfs2/ioctl.c:1343
  __do_compat_sys_ioctl fs/ioctl.c:968 [inline]
  __se_compat_sys_ioctl+0x7dd/0x1000 fs/ioctl.c:910
  __ia32_compat_sys_ioctl+0x93/0xd0 fs/ioctl.c:910
  do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline]
  __do_fast_syscall_32+0xa2/0x100 arch/x86/entry/common.c:178
  do_fast_syscall_32+0x37/0x80 arch/x86/entry/common.c:203
  do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:246
  entry_SYSENTER_compat_after_hwframe+0x70/0x82

 Bytes 16-127 of 3968 are uninitialized
 ...

This eliminates the leak issue by initializing the page allocated as
buffer using get_zeroed_page().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/003587000276f81d0114b5ce773d80c119d8cb30
  - https://git.kernel.org/stable/c/5bb105cc72beb9d51bf12f5c657336d2d35bdc5d
  - https://git.kernel.org/stable/c/5f33b042f74fc9662eba17f4cd19b07d84bbc6c5
  - https://git.kernel.org/stable/c/8a6550b365c0ce2e65905de57dcbfe1f7d629726
  - https://git.kernel.org/stable/c/8f5cbf6a8c0e19b062b829c5b7aca01468bb57f6
  - https://git.kernel.org/stable/c/9c5034e9a0e03db8d5e9eabb176340259b5b97e4
  - https://git.kernel.org/stable/c/a94932381e8dae4117e9129b3c1282e18aa97b05
  - https://git.kernel.org/stable/c/d18db946cc6a394291539e030df32324285648f7

------------------------------------------------------------

CVE ID: CVE-2023-53036
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix call trace warning and hang when removing amdgpu device

On GPUs with RAS enabled, below call trace and hang are observed when
shutting down device.

v2: use DRM device unplugged flag instead of shutdown flag as the check to
prevent memory wipe in shutdown stage.

[ +0.000000] RIP: 0010:amdgpu_vram_mgr_fini+0x18d/0x1c0 [amdgpu]
[ +0.000001] PKRU: 55555554
[ +0.000001] Call Trace:
[ +0.000001] <TASK>
[ +0.000002] amdgpu_ttm_fini+0x140/0x1c0 [amdgpu]
[ +0.000183] amdgpu_bo_fini+0x27/0xa0 [amdgpu]
[ +0.000184] gmc_v11_0_sw_fini+0x2b/0x40 [amdgpu]
[ +0.000163] amdgpu_device_fini_sw+0xb6/0x510 [amdgpu]
[ +0.000152] amdgpu_driver_release_kms+0x16/0x30 [amdgpu]
[ +0.000090] drm_dev_release+0x28/0x50 [drm]
[ +0.000016] devm_drm_dev_init_release+0x38/0x60 [drm]
[ +0.000011] devm_action_release+0x15/0x20
[ +0.000003] release_nodes+0x40/0xc0
[ +0.000001] devres_release_all+0x9e/0xe0
[ +0.000001] device_unbind_cleanup+0x12/0x80
[ +0.000003] device_release_driver_internal+0xff/0x160
[ +0.000001] driver_detach+0x4a/0x90
[ +0.000001] bus_remove_driver+0x6c/0xf0
[ +0.000001] driver_unregister+0x31/0x50
[ +0.000001] pci_unregister_driver+0x40/0x90
[ +0.000003] amdgpu_exit+0x15/0x120 [amdgpu]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/93bb18d2a873d2fa9625c8ea927723660a868b95
  - https://git.kernel.org/stable/c/9a02dae3bbfe2df8e1c81e61a08695709e9588f9
  - https://git.kernel.org/stable/c/f06b902511ea05526f405ee64da54a8313d91831

------------------------------------------------------------

CVE ID: CVE-2023-53037
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Bad drive in topology results kernel crash

When the SAS Transport Layer support is enabled and a device exposed to
the OS by the driver fails INQUIRY commands, the driver frees up the memory
allocated for an internal HBA port data structure. However, in some places,
the reference to the freed memory is not cleared. When the firmware sends
the Device Info change event for the same device again, the freed memory is
accessed and that leads to memory corruption and OS crash.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1f822ae8fb2a20fffa71e9bfa9b203c03d72d3ba
  - https://git.kernel.org/stable/c/8e45183978d64699df639e795235433a60f35047
  - https://git.kernel.org/stable/c/aa11e4b6cdb403b9fdef6939550f6b36dd61624d

------------------------------------------------------------

CVE ID: CVE-2023-53038
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Check kzalloc() in lpfc_sli4_cgn_params_read()

If kzalloc() fails in lpfc_sli4_cgn_params_read(), then we rely on
lpfc_read_object()'s routine to NULL check pdata.

Currently, an early return error is thrown from lpfc_read_object() to
protect us from NULL ptr dereference, but the errno code is -ENODEV.

Change the errno code to a more appropriate -ENOMEM.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/312320b0e0ec21249a17645683fe5304d796aec1
  - https://git.kernel.org/stable/c/4829a1e1171536978b240a1438789c2e4d5c9715
  - https://git.kernel.org/stable/c/67b8343998b84418bc5b5206aa01fe9b461a80ef
  - https://git.kernel.org/stable/c/908dd9a0853a88155a5a36018c7e2b32ccf20379

------------------------------------------------------------

CVE ID: CVE-2023-53039
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: intel-ish-hid: ipc: Fix potential use-after-free in work function

When a reset notify IPC message is received, the ISR schedules a work
function and passes the ISHTP device to it via a global pointer
ishtp_dev. If ish_probe() fails, the devm-managed device resources
including ishtp_dev are freed, but the work is not cancelled, causing a
use-after-free when the work function tries to access ishtp_dev. Use
devm_work_autocancel() instead, so that the work is automatically
cancelled if probe fails.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a594cb490ca6232671fc09e2dc1a0fc7ccbb0b5
  - https://git.kernel.org/stable/c/8ae2f2b0a28416ed2f6d8478ac8b9f7862f36785
  - https://git.kernel.org/stable/c/8c1d378b8c224fd50247625255f09fc01dcc5836
  - https://git.kernel.org/stable/c/d3ce3afd9f791dd1b7daedfcf8c396b60af5dec0

------------------------------------------------------------

CVE ID: CVE-2023-53040
Description: In the Linux kernel, the following vulnerability has been resolved:

ca8210: fix mac_len negative array access

This patch fixes a buffer overflow access of skb->data if
ieee802154_hdr_peek_addrs() fails.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/55d836f75778d2e2cafe37e023f9c106400bad4b
  - https://git.kernel.org/stable/c/5da4469a7aa011de614c3e2ae383c35a353a382e
  - https://git.kernel.org/stable/c/6c993779ea1d0cccdb3a5d7d45446dd229e610a3
  - https://git.kernel.org/stable/c/7df72bedbdd1d02bb216e1f6eca0a16900238c4e
  - https://git.kernel.org/stable/c/918944526a386f186dd818ea6b0bcbed75d8c16b
  - https://git.kernel.org/stable/c/d143e327c97241599c958d1ba9fbaa88c37db721
  - https://git.kernel.org/stable/c/d2b3bd0d4cadfdb7f3454d2aef9d5d9e8b48aae4
  - https://git.kernel.org/stable/c/fd176a18db96d574d8c4763708abcec4444a08b6

------------------------------------------------------------

CVE ID: CVE-2023-53041
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Perform lockless command completion in abort path

While adding and removing the controller, the following call trace was
observed:

WARNING: CPU: 3 PID: 623596 at kernel/dma/mapping.c:532 dma_free_attrs+0x33/0x50
CPU: 3 PID: 623596 Comm: sh Kdump: loaded Not tainted 5.14.0-96.el9.x86_64 #1
RIP: 0010:dma_free_attrs+0x33/0x50

Call Trace:
   qla2x00_async_sns_sp_done+0x107/0x1b0 [qla2xxx]
   qla2x00_abort_srb+0x8e/0x250 [qla2xxx]
   ? ql_dbg+0x70/0x100 [qla2xxx]
   __qla2x00_abort_all_cmds+0x108/0x190 [qla2xxx]
   qla2x00_abort_all_cmds+0x24/0x70 [qla2xxx]
   qla2x00_abort_isp_cleanup+0x305/0x3e0 [qla2xxx]
   qla2x00_remove_one+0x364/0x400 [qla2xxx]
   pci_device_remove+0x36/0xa0
   __device_release_driver+0x17a/0x230
   device_release_driver+0x24/0x30
   pci_stop_bus_device+0x68/0x90
   pci_stop_and_remove_bus_device_locked+0x16/0x30
   remove_store+0x75/0x90
   kernfs_fop_write_iter+0x11c/0x1b0
   new_sync_write+0x11f/0x1b0
   vfs_write+0x1eb/0x280
   ksys_write+0x5f/0xe0
   do_syscall_64+0x5c/0x80
   ? do_user_addr_fault+0x1d8/0x680
   ? do_syscall_64+0x69/0x80
   ? exc_page_fault+0x62/0x140
   ? asm_exc_page_fault+0x8/0x30
   entry_SYSCALL_64_after_hwframe+0x44/0xae

The command was completed in the abort path during driver unload with a
lock held, causing the warning in abort path. Hence complete the command
without any lock held.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0367076b0817d5c75dfb83001ce7ce5c64d803a9
  - https://git.kernel.org/stable/c/231cfa78ec5badd84a1a2b09465bfad1a926aba1
  - https://git.kernel.org/stable/c/415d614344a4f1bbddf55d724fc7eb9ef4b39aad
  - https://git.kernel.org/stable/c/9189f20b4c5307c0998682bb522e481b4567a8b8
  - https://git.kernel.org/stable/c/cd0a1804ac5bab2545ac700c8d0fe9ae9284c567
  - https://git.kernel.org/stable/c/d6f7377528d2abf338e504126e44439541be8f7d

------------------------------------------------------------

CVE ID: CVE-2023-53042
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Do not set DRR on pipe Commit

[WHY]
Writing to DRR registers such as OTG_V_TOTAL_MIN on the same frame as a
pipe commit can cause underflow.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3c20a098b507020936e02a98f4fbb924deeef44b
  - https://git.kernel.org/stable/c/56574f89dbd84004c3fd6485bcaafb5aa9b8be14
  - https://git.kernel.org/stable/c/f8080f1e300e7abcc03025ec8b5bab69ae98daaa

------------------------------------------------------------

CVE ID: CVE-2023-53043
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: dts: qcom: sc7280: Mark PCIe controller as cache coherent

If the controller is not marked as cache coherent, then kernel will
try to ensure coherency during dma-ops and that may cause data corruption.
So, mark the PCIe node as dma-coherent as the devices on PCIe bus are
cache coherent.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/267b899375bf38944d915c9654d6eb434edad0ce
  - https://git.kernel.org/stable/c/8a63441e83724fee1ef3fd37b237d40d90780766
  - https://git.kernel.org/stable/c/e43bba938e2c9104bb4f8bc417ac4d7bb29755e1

------------------------------------------------------------

CVE ID: CVE-2023-53044
Description: In the Linux kernel, the following vulnerability has been resolved:

dm stats: check for and propagate alloc_percpu failure

Check alloc_precpu()'s return value and return an error from
dm_stats_init() if it fails. Update alloc_dev() to fail if
dm_stats_init() does.

Otherwise, a NULL pointer dereference will occur in dm_stats_cleanup()
even if dm-stats isn't being actively used.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d96bd507ed7e7d565b6d53ebd3874686f123b2e
  - https://git.kernel.org/stable/c/2287d7b721471a3d58bcd829250336e3cdf1635e
  - https://git.kernel.org/stable/c/443c9d522397511a4328dc2ec3c9c63c73049756
  - https://git.kernel.org/stable/c/4a32a9a818a895671bd43e0c40351e60e4e9140b
  - https://git.kernel.org/stable/c/5b66e36a3efd24041b7374432bfa4dec2ff01e95
  - https://git.kernel.org/stable/c/a42180dd361584816bfe15c137b665699b994d90
  - https://git.kernel.org/stable/c/c68f08cc745675a17894e1b4a5b5b9700ace6da4
  - https://git.kernel.org/stable/c/d3aa3e060c4a80827eb801fc448debc9daa7c46b

------------------------------------------------------------

CVE ID: CVE-2023-53045
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: u_audio: don't let userspace block driver unbind

In the unbind callback for f_uac1 and f_uac2, a call to snd_card_free()
via g_audio_cleanup() will disconnect the card and then wait for all
resources to be released, which happens when the refcount falls to zero.
Since userspace can keep the refcount incremented by not closing the
relevant file descriptor, the call to unbind may block indefinitely.
This can cause a deadlock during reboot, as evidenced by the following
blocked task observed on my machine:

  task:reboot  state:D stack:0   pid:2827  ppid:569    flags:0x0000000c
  Call trace:
   __switch_to+0xc8/0x140
   __schedule+0x2f0/0x7c0
   schedule+0x60/0xd0
   schedule_timeout+0x180/0x1d4
   wait_for_completion+0x78/0x180
   snd_card_free+0x90/0xa0
   g_audio_cleanup+0x2c/0x64
   afunc_unbind+0x28/0x60
   ...
   kernel_restart+0x4c/0xac
   __do_sys_reboot+0xcc/0x1ec
   __arm64_sys_reboot+0x28/0x30
   invoke_syscall+0x4c/0x110
   ...

The issue can also be observed by opening the card with arecord and
then stopping the process through the shell before unbinding:

  # arecord -D hw:UAC2Gadget -f S32_LE -c 2 -r 48000 /dev/null
  Recording WAVE '/dev/null' : Signed 32 bit Little Endian, Rate 48000 Hz, Stereo
  ^Z[1]+  Stopped                    arecord -D hw:UAC2Gadget -f S32_LE -c 2 -r 48000 /dev/null
  # echo gadget.0 > /sys/bus/gadget/drivers/configfs-gadget/unbind
  (observe that the unbind command never finishes)

Fix the problem by using snd_card_free_when_closed() instead, which will
still disconnect the card as desired, but defer the task of freeing the
resources to the core once userspace closes its file descriptor.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0eda2004f38d95ef5715d62be884cd344260535b
  - https://git.kernel.org/stable/c/3256e152b645fc1e788ba44c2d8ced690113e3e6
  - https://git.kernel.org/stable/c/33f341c1fc60e172a3515c51bdabee11e83d1ee9
  - https://git.kernel.org/stable/c/3bc7324e4911351e39c54a62e6ca46321cb10faf
  - https://git.kernel.org/stable/c/3e016ef2e72da93a2ea7afbb45de1b481b44d761
  - https://git.kernel.org/stable/c/43ca70753dfffd517d2af126da28690f8f615605
  - https://git.kernel.org/stable/c/6c67ed9ad9b83e453e808f9b31a931a20a25629b
  - https://git.kernel.org/stable/c/b131989797f7287d7fdadb2bababc05a15d44750

------------------------------------------------------------

CVE ID: CVE-2023-53046
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: Fix race condition in hci_cmd_sync_clear

There is a potential race condition in hci_cmd_sync_work and
hci_cmd_sync_clear, and could lead to use-after-free. For instance,
hci_cmd_sync_work is added to the 'req_workqueue' after cancel_work_sync
The entry of 'cmd_sync_work_list' may be freed in hci_cmd_sync_clear, and
causing kernel panic when it is used in 'hci_cmd_sync_work'.

Here's the call trace:

dump_stack_lvl+0x49/0x63
print_report.cold+0x5e/0x5d3
? hci_cmd_sync_work+0x282/0x320
kasan_report+0xaa/0x120
? hci_cmd_sync_work+0x282/0x320
__asan_report_load8_noabort+0x14/0x20
hci_cmd_sync_work+0x282/0x320
process_one_work+0x77b/0x11c0
? _raw_spin_lock_irq+0x8e/0xf0
worker_thread+0x544/0x1180
? poll_idle+0x1e0/0x1e0
kthread+0x285/0x320
? process_one_work+0x11c0/0x11c0
? kthread_complete_and_exit+0x30/0x30
ret_from_fork+0x22/0x30
</TASK>

Allocated by task 266:
kasan_save_stack+0x26/0x50
__kasan_kmalloc+0xae/0xe0
kmem_cache_alloc_trace+0x191/0x350
hci_cmd_sync_queue+0x97/0x2b0
hci_update_passive_scan+0x176/0x1d0
le_conn_complete_evt+0x1b5/0x1a00
hci_le_conn_complete_evt+0x234/0x340
hci_le_meta_evt+0x231/0x4e0
hci_event_packet+0x4c5/0xf00
hci_rx_work+0x37d/0x880
process_one_work+0x77b/0x11c0
worker_thread+0x544/0x1180
kthread+0x285/0x320
ret_from_fork+0x22/0x30

Freed by task 269:
kasan_save_stack+0x26/0x50
kasan_set_track+0x25/0x40
kasan_set_free_info+0x24/0x40
____kasan_slab_free+0x176/0x1c0
__kasan_slab_free+0x12/0x20
slab_free_freelist_hook+0x95/0x1a0
kfree+0xba/0x2f0
hci_cmd_sync_clear+0x14c/0x210
hci_unregister_dev+0xff/0x440
vhci_release+0x7b/0xf0
__fput+0x1f3/0x970
____fput+0xe/0x20
task_work_run+0xd4/0x160
do_exit+0x8b0/0x22a0
do_group_exit+0xba/0x2a0
get_signal+0x1e4a/0x25b0
arch_do_signal_or_restart+0x93/0x1f80
exit_to_user_mode_prepare+0xf5/0x1a0
syscall_exit_to_user_mode+0x26/0x50
ret_from_fork+0x15/0x30
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c66bee492a5fe00ae3fe890bb693bfc99f994c6
  - https://git.kernel.org/stable/c/608901a77c945ac15dea23f6098c9882ef19d9f0
  - https://git.kernel.org/stable/c/be586211a3ab40a4f4ca60450e0d31606afc55ec

------------------------------------------------------------

CVE ID: CVE-2023-53047
Description: In the Linux kernel, the following vulnerability has been resolved:

tee: amdtee: fix race condition in amdtee_open_session

There is a potential race condition in amdtee_open_session that may
lead to use-after-free. For instance, in amdtee_open_session() after
sess->sess_mask is set, and before setting:

    sess->session_info[i] = session_info;

if amdtee_close_session() closes this same session, then 'sess' data
structure will be released, causing kernel panic when 'sess' is
accessed within amdtee_open_session().

The solution is to set the bit sess->sess_mask as the last step in
amdtee_open_session().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/02b296978a2137d7128151c542e84dc96400bc00
  - https://git.kernel.org/stable/c/a63cce9393e4e7dbc5af82dc87e68cb321cb1a78
  - https://git.kernel.org/stable/c/b3ef9e6fe09f1a132af28c623edcf4d4f39d9f35
  - https://git.kernel.org/stable/c/f632a90f8e39db39b322107b9a8d438b826a7f4f
  - https://git.kernel.org/stable/c/f8502fba45bd30e1a6a354d9d898bc99d1a11e6d

------------------------------------------------------------

CVE ID: CVE-2023-53048
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: typec: tcpm: fix warning when handle discover_identity message

Since both source and sink device can send discover_identity message in
PD3, kernel may dump below warning:

------------[ cut here ]------------
WARNING: CPU: 0 PID: 169 at drivers/usb/typec/tcpm/tcpm.c:1446 tcpm_queue_vdm+0xe0/0xf0
Modules linked in:
CPU: 0 PID: 169 Comm: 1-0050 Not tainted 6.1.1-00038-g6a3c36cf1da2-dirty #567
Hardware name: NXP i.MX8MPlus EVK board (DT)
pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : tcpm_queue_vdm+0xe0/0xf0
lr : tcpm_queue_vdm+0x2c/0xf0
sp : ffff80000c19bcd0
x29: ffff80000c19bcd0 x28: 0000000000000001 x27: ffff0000d11c8ab8
x26: ffff0000d11cc000 x25: 0000000000000000 x24: 00000000ff008081
x23: 0000000000000001 x22: 00000000ff00a081 x21: ffff80000c19bdbc
x20: 0000000000000000 x19: ffff0000d11c8080 x18: ffffffffffffffff
x17: 0000000000000000 x16: 0000000000000000 x15: ffff0000d716f580
x14: 0000000000000001 x13: ffff0000d716f507 x12: 0000000000000001
x11: 0000000000000000 x10: 0000000000000020 x9 : 00000000000ee098
x8 : 00000000ffffffff x7 : 000000000000001c x6 : ffff0000d716f580
x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000
x2 : ffff80000c19bdbc x1 : 00000000ff00a081 x0 : 0000000000000004
Call trace:
tcpm_queue_vdm+0xe0/0xf0
tcpm_pd_rx_handler+0x340/0x1ab0
kthread_worker_fn+0xcc/0x18c
kthread+0x10c/0x110
ret_from_fork+0x10/0x20
---[ end trace 0000000000000000 ]---

Below sequences may trigger this warning:

tcpm_send_discover_work(work)
  tcpm_send_vdm(port, USB_SID_PD, CMD_DISCOVER_IDENT, NULL, 0);
   tcpm_queue_vdm(port, header, data, count);
    port->vdm_state = VDM_STATE_READY;

vdm_state_machine_work(work);
			<-- received discover_identity from partner
 vdm_run_state_machine(port);
  port->vdm_state = VDM_STATE_SEND_MESSAGE;
   mod_vdm_delayed_work(port, x);

tcpm_pd_rx_handler(work);
 tcpm_pd_data_request(port, msg);
  tcpm_handle_vdm_request(port, msg->payload, cnt);
   tcpm_queue_vdm(port, response[0], &response[1], rlen - 1);
--> WARN_ON(port->vdm_state > VDM_STATE_DONE);

For this case, the state machine could still send out discover
identity message later if we skip current discover_identity message.
So we should handle the received message firstly and override the pending
discover_identity message without warning in this case. Then, a delayed
send_discover work will send discover_identity message again.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/abfc4fa28f0160df61c7149567da4f6494dfb488
  - https://git.kernel.org/stable/c/bb579b3f75c60bf488a7c36e092e8be583407d53
  - https://git.kernel.org/stable/c/d55ca2d2ea1a7ec553213986993fba8c0257381c
  - https://git.kernel.org/stable/c/e37d2c489d71e94ed4a39529bc9520a7fd983d42

------------------------------------------------------------

CVE ID: CVE-2023-53049
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: ucsi: Fix NULL pointer deref in ucsi_connector_change()

When ucsi_init() fails, ucsi->connector is NULL, yet in case of
ucsi_acpi we may still get events which cause the ucs_acpi code to call
ucsi_connector_change(), which then derefs the NULL ucsi->connector
pointer.

Fix this by not setting ucsi->ntfy inside ucsi_init() until ucsi_init()
has succeeded, so that ucsi_connector_change() ignores the events
because UCSI_ENABLE_NTFY_CONNECTOR_CHANGE is not set in the ntfy mask.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1c5abcb13491da8c049f20462189c12c753ba978
  - https://git.kernel.org/stable/c/7dd27aed9c456670b3882877ef17a48195f21693
  - https://git.kernel.org/stable/c/7ef0423e43f877a328454059d46763043ce3da44
  - https://git.kernel.org/stable/c/a6adfe9bbd6ac11e398b54ccd99a0f8eea09f3c0
  - https://git.kernel.org/stable/c/f87fb985452ab2083967103ac00bfd68fb182764

------------------------------------------------------------

CVE ID: CVE-2023-53050
Description: In the Linux kernel, the following vulnerability has been resolved:

thunderbolt: Fix memory leak in margining

Memory for the usb4->margining needs to be relased for the upstream port
of the router as well, even though the debugfs directory gets released
with the router device removal. Fix this.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b357b360e671688f9bf38ff94300515b68bc247
  - https://git.kernel.org/stable/c/acec726473822bc6b585961f4ca2a11fa7f28341
  - https://git.kernel.org/stable/c/f390095bbd131ec2dfb29792d9f6fd0f0656bfc0

------------------------------------------------------------

CVE ID: CVE-2023-53051
Description: In the Linux kernel, the following vulnerability has been resolved:

dm crypt: add cond_resched() to dmcrypt_write()

The loop in dmcrypt_write may be running for unbounded amount of time,
thus we need cond_resched() in it.

This commit fixes the following warning:

[ 3391.153255][   C12] watchdog: BUG: soft lockup - CPU#12 stuck for 23s! [dmcrypt_write/2:2897]
...
[ 3391.387210][   C12] Call trace:
[ 3391.390338][   C12]  blk_attempt_bio_merge.part.6+0x38/0x158
[ 3391.395970][   C12]  blk_attempt_plug_merge+0xc0/0x1b0
[ 3391.401085][   C12]  blk_mq_submit_bio+0x398/0x550
[ 3391.405856][   C12]  submit_bio_noacct+0x308/0x380
[ 3391.410630][   C12]  dmcrypt_write+0x1e4/0x208 [dm_crypt]
[ 3391.416005][   C12]  kthread+0x130/0x138
[ 3391.419911][   C12]  ret_from_fork+0x10/0x18
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2c743db1193bf0e76c73d71ede08bd9b96e6c31d
  - https://git.kernel.org/stable/c/66ff37993dd7e9954b6446237fe2453b380ce40d
  - https://git.kernel.org/stable/c/7b9f8efb5fc888dd938d2964e705b8e00f1dc0f6
  - https://git.kernel.org/stable/c/885c28ceae7dab2b18c2cc0eb95f1f82b1f629d1
  - https://git.kernel.org/stable/c/e87cd83f70504f1cd2e428966f353c007d6d2d7f
  - https://git.kernel.org/stable/c/eb485b7404a281d974bd445ddc5b0b8d5958f371
  - https://git.kernel.org/stable/c/f0eb61b493dbbc32529fbd0d2e945b71b0e47306
  - https://git.kernel.org/stable/c/fb294b1c0ba982144ca467a75e7d01ff26304e2b

------------------------------------------------------------

CVE ID: CVE-2023-53052
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: fix use-after-free bug in refresh_cache_worker()

The UAF bug occurred because we were putting DFS root sessions in
cifs_umount() while DFS cache refresher was being executed.

Make DFS root sessions have same lifetime as DFS tcons so we can avoid
the use-after-free bug is DFS cache refresher and other places that
require IPCs to get new DFS referrals on.  Also, get rid of mount
group handling in DFS cache as we no longer need it.

This fixes below use-after-free bug catched by KASAN

[ 379.946955] BUG: KASAN: use-after-free in __refresh_tcon.isra.0+0x10b/0xc10 [cifs]
[ 379.947642] Read of size 8 at addr ffff888018f57030 by task kworker/u4:3/56
[ 379.948096]
[ 379.948208] CPU: 0 PID: 56 Comm: kworker/u4:3 Not tainted 6.2.0-rc7-lku #23
[ 379.948661] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS
rel-1.16.0-0-gd239552-rebuilt.opensuse.org 04/01/2014
[ 379.949368] Workqueue: cifs-dfscache refresh_cache_worker [cifs]
[ 379.949942] Call Trace:
[ 379.950113] <TASK>
[ 379.950260] dump_stack_lvl+0x50/0x67
[ 379.950510] print_report+0x16a/0x48e
[ 379.950759] ? __virt_addr_valid+0xd8/0x160
[ 379.951040] ? __phys_addr+0x41/0x80
[ 379.951285] kasan_report+0xdb/0x110
[ 379.951533] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs]
[ 379.952056] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs]
[ 379.952585] __refresh_tcon.isra.0+0x10b/0xc10 [cifs]
[ 379.953096] ? __pfx___refresh_tcon.isra.0+0x10/0x10 [cifs]
[ 379.953637] ? __pfx___mutex_lock+0x10/0x10
[ 379.953915] ? lock_release+0xb6/0x720
[ 379.954167] ? __pfx_lock_acquire+0x10/0x10
[ 379.954443] ? refresh_cache_worker+0x34e/0x6d0 [cifs]
[ 379.954960] ? __pfx_wb_workfn+0x10/0x10
[ 379.955239] refresh_cache_worker+0x4ad/0x6d0 [cifs]
[ 379.955755] ? __pfx_refresh_cache_worker+0x10/0x10 [cifs]
[ 379.956323] ? __pfx_lock_acquired+0x10/0x10
[ 379.956615] ? read_word_at_a_time+0xe/0x20
[ 379.956898] ? lockdep_hardirqs_on_prepare+0x12/0x220
[ 379.957235] process_one_work+0x535/0x990
[ 379.957509] ? __pfx_process_one_work+0x10/0x10
[ 379.957812] ? lock_acquired+0xb7/0x5f0
[ 379.958069] ? __list_add_valid+0x37/0xd0
[ 379.958341] ? __list_add_valid+0x37/0xd0
[ 379.958611] worker_thread+0x8e/0x630
[ 379.958861] ? __pfx_worker_thread+0x10/0x10
[ 379.959148] kthread+0x17d/0x1b0
[ 379.959369] ? __pfx_kthread+0x10/0x10
[ 379.959630] ret_from_fork+0x2c/0x50
[ 379.959879] </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/396935de145589c8bfe552fa03a5e38604071829
  - https://git.kernel.org/stable/c/5a89d81c1a3c152837ea204fd29572228e54ce0b

------------------------------------------------------------

CVE ID: CVE-2023-53053
Description: In the Linux kernel, the following vulnerability has been resolved:

erspan: do not use skb_mac_header() in ndo_start_xmit()

Drivers should not assume skb_mac_header(skb) == skb->data in their
ndo_start_xmit().

Use skb_network_offset() and skb_transport_offset() which
better describe what is needed in erspan_fb_xmit() and
ip6erspan_tunnel_xmit()

syzbot reported:
WARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 skb_mac_header include/linux/skbuff.h:2873 [inline]
WARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962
Modules linked in:
CPU: 0 PID: 5083 Comm: syz-executor406 Not tainted 6.3.0-rc2-syzkaller-00866-gd4671cb96fa3 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/02/2023
RIP: 0010:skb_mac_header include/linux/skbuff.h:2873 [inline]
RIP: 0010:ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962
Code: 04 02 41 01 de 84 c0 74 08 3c 03 0f 8e 1c 0a 00 00 45 89 b4 24 c8 00 00 00 c6 85 77 fe ff ff 01 e9 33 e7 ff ff e8 b4 27 a1 f8 <0f> 0b e9 b6 e7 ff ff e8 a8 27 a1 f8 49 8d bf f0 0c 00 00 48 b8 00
RSP: 0018:ffffc90003b2f830 EFLAGS: 00010293
RAX: 0000000000000000 RBX: 000000000000ffff RCX: 0000000000000000
RDX: ffff888021273a80 RSI: ffffffff88e1bd4c RDI: 0000000000000003
RBP: ffffc90003b2f9d8 R08: 0000000000000003 R09: 000000000000ffff
R10: 000000000000ffff R11: 0000000000000000 R12: ffff88802b28da00
R13: 00000000000000d0 R14: ffff88807e25b6d0 R15: ffff888023408000
FS: 0000555556a61300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000055e5b11eb6e8 CR3: 0000000027c1b000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
__netdev_start_xmit include/linux/netdevice.h:4900 [inline]
netdev_start_xmit include/linux/netdevice.h:4914 [inline]
__dev_direct_xmit+0x504/0x730 net/core/dev.c:4300
dev_direct_xmit include/linux/netdevice.h:3088 [inline]
packet_xmit+0x20a/0x390 net/packet/af_packet.c:285
packet_snd net/packet/af_packet.c:3075 [inline]
packet_sendmsg+0x31a0/0x5150 net/packet/af_packet.c:3107
sock_sendmsg_nosec net/socket.c:724 [inline]
sock_sendmsg+0xde/0x190 net/socket.c:747
__sys_sendto+0x23a/0x340 net/socket.c:2142
__do_sys_sendto net/socket.c:2154 [inline]
__se_sys_sendto net/socket.c:2150 [inline]
__x64_sys_sendto+0xe1/0x1b0 net/socket.c:2150
do_syscall_x64 arch/x86/entry/common.c:50 [inline]
do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7f123aaa1039
Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007ffc15d12058 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f123aaa1039
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003
RBP: 0000000000000000 R08: 0000000020000040 R09: 0000000000000014
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f123aa648c0
R13: 431bde82d7b634db R14: 0000000000000000 R15: 0000000000000000
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5d4172732f0ee1639a361a6cc5c3114bbb397386
  - https://git.kernel.org/stable/c/8e50ed774554f93d55426039b27b1e38d7fa64d8
  - https://git.kernel.org/stable/c/9c7d6803689c99d55bbb862260d0ba486ff23c0b
  - https://git.kernel.org/stable/c/b41f37dbd9cdb60000e3b0dfad6df787591c2265
  - https://git.kernel.org/stable/c/b72f453e886af532bde1fd049a2d2421999630d3
  - https://git.kernel.org/stable/c/da149daf821a3c05cd04f7c60776c86c5ee9685c
  - https://git.kernel.org/stable/c/f8cec30541f5c5cc218e9a32138d45d227727f2f

------------------------------------------------------------

CVE ID: CVE-2023-53054
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: dwc2: fix a devres leak in hw_enable upon suspend resume

Each time the platform goes to low power, PM suspend / resume routines
call: __dwc2_lowlevel_hw_enable -> devm_add_action_or_reset().
This adds a new devres each time.
This may also happen at runtime, as dwc2_lowlevel_hw_enable() can be
called from udc_start().

This can be seen with tracing:
- echo 1 > /sys/kernel/debug/tracing/events/dev/devres_log/enable
- go to low power
- cat /sys/kernel/debug/tracing/trace

A new "ADD" entry is found upon each low power cycle:
... devres_log: 49000000.usb-otg ADD 82a13bba devm_action_release (8 bytes)
... devres_log: 49000000.usb-otg ADD 49889daf devm_action_release (8 bytes)
...

A second issue is addressed here:
- regulator_bulk_enable() is called upon each PM cycle (suspend/resume).
- regulator_bulk_disable() never gets called.

So the reference count for these regulators constantly increase, by one
upon each low power cycle, due to missing regulator_bulk_disable() call
in __dwc2_lowlevel_hw_disable().

The original fix that introduced the devm_add_action_or_reset() call,
fixed an issue during probe, that happens due to other errors in
dwc2_driver_probe() -> dwc2_core_reset(). Then the probe fails without
disabling regulators, when dr_mode == USB_DR_MODE_PERIPHERAL.

Rather fix the error path: disable all the low level hardware in the
error path, by using the "hsotg->ll_hw_enabled" flag. Checking dr_mode
has been introduced to avoid a dual call to dwc2_lowlevel_hw_disable().
"ll_hw_enabled" should achieve the same (and is used currently in the
remove() routine).
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1f01027c51eb16145e8e07fafea3ca07ef102d06
  - https://git.kernel.org/stable/c/6485fc381b6528b6f547ee1ff10bdbcbe31a6e4c
  - https://git.kernel.org/stable/c/cba76e1fb896b573f09f51aa299223276a77bc90
  - https://git.kernel.org/stable/c/f747313249b74f323ddf841a9c8db14d989f296a
  - https://git.kernel.org/stable/c/ffb8ab6f87bd28d700ab5c20d9d3a7e75067630d

------------------------------------------------------------

CVE ID: CVE-2023-53055
Description: In the Linux kernel, the following vulnerability has been resolved:

fscrypt: destroy keyring after security_sb_delete()

fscrypt_destroy_keyring() must be called after all potentially-encrypted
inodes were evicted; otherwise it cannot safely destroy the keyring.
Since inodes that are in-use by the Landlock LSM don't get evicted until
security_sb_delete(), this means that fscrypt_destroy_keyring() must be
called *after* security_sb_delete().

This fixes a WARN_ON followed by a NULL dereference, only possible if
Landlock was being used on encrypted files.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/497ab5d9c7852dfedab2c9de75e41b60e54b7c5d
  - https://git.kernel.org/stable/c/992a3f3e8a0c92151dfdf65fc85567c865fd558a
  - https://git.kernel.org/stable/c/ccb820dc7d2236b1af0d54ae038a27b5b6d5ae5a
  - https://git.kernel.org/stable/c/d77531fac6a1fd9f1db0195438ba5419d72b96c4

------------------------------------------------------------

CVE ID: CVE-2023-53056
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Synchronize the IOCB count to be in order

A system hang was observed with the following call trace:

BUG: kernel NULL pointer dereference, address: 0000000000000000
PGD 0 P4D 0
Oops: 0000 [#1] PREEMPT SMP NOPTI
CPU: 15 PID: 86747 Comm: nvme Kdump: loaded Not tainted 6.2.0+ #1
Hardware name: Dell Inc. PowerEdge R6515/04F3CJ, BIOS 2.7.3 03/31/2022
RIP: 0010:__wake_up_common+0x55/0x190
Code: 41 f6 01 04 0f 85 b2 00 00 00 48 8b 43 08 4c 8d
      40 e8 48 8d 43 08 48 89 04 24 48 89 c6\
      49 8d 40 18 48 39 c6 0f 84 e9 00 00 00 <49> 8b 40 18 89 6c 24 14 31
      ed 4c 8d 60 e8 41 8b 18 f6 c3 04 75 5d
RSP: 0018:ffffb05a82afbba0 EFLAGS: 00010082
RAX: 0000000000000000 RBX: ffff8f9b83a00018 RCX: 0000000000000000
RDX: 0000000000000001 RSI: ffff8f9b83a00020 RDI: ffff8f9b83a00018
RBP: 0000000000000001 R08: ffffffffffffffe8 R09: ffffb05a82afbbf8
R10: 70735f7472617473 R11: 5f30307832616c71 R12: 0000000000000001
R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000
FS:  00007f815cf4c740(0000) GS:ffff8f9eeed80000(0000)
	knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000000 CR3: 000000010633a000 CR4: 0000000000350ee0
Call Trace:
    <TASK>
    __wake_up_common_lock+0x83/0xd0
    qla_nvme_ls_req+0x21b/0x2b0 [qla2xxx]
    __nvme_fc_send_ls_req+0x1b5/0x350 [nvme_fc]
    nvme_fc_xmt_disconnect_assoc+0xca/0x110 [nvme_fc]
    nvme_fc_delete_association+0x1bf/0x220 [nvme_fc]
    ? nvme_remove_namespaces+0x9f/0x140 [nvme_core]
    nvme_do_delete_ctrl+0x5b/0xa0 [nvme_core]
    nvme_sysfs_delete+0x5f/0x70 [nvme_core]
    kernfs_fop_write_iter+0x12b/0x1c0
    vfs_write+0x2a3/0x3b0
    ksys_write+0x5f/0xe0
    do_syscall_64+0x5c/0x90
    ? syscall_exit_work+0x103/0x130
    ? syscall_exit_to_user_mode+0x12/0x30
    ? do_syscall_64+0x69/0x90
    ? exit_to_user_mode_loop+0xd0/0x130
    ? exit_to_user_mode_prepare+0xec/0x100
    ? syscall_exit_to_user_mode+0x12/0x30
    ? do_syscall_64+0x69/0x90
    ? syscall_exit_to_user_mode+0x12/0x30
    ? do_syscall_64+0x69/0x90
    entry_SYSCALL_64_after_hwframe+0x72/0xdc
    RIP: 0033:0x7f815cd3eb97

The IOCB counts are out of order and that would block any commands from
going out and subsequently hang the system. Synchronize the IOCB count to
be in correct order.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6295b3ec64a3623fa96869ffb7cf17d0b3c92035
  - https://git.kernel.org/stable/c/6d57b77d7369ed73836c82b25f785b34923eef84
  - https://git.kernel.org/stable/c/d3affdeb400f3adc925bd996f3839481f5291839
  - https://git.kernel.org/stable/c/ffd7831841d3c56c655531fc8c5acafaaf20e1bb

------------------------------------------------------------

CVE ID: CVE-2023-53057
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: HCI: Fix global-out-of-bounds

To loop a variable-length array, hci_init_stage_sync(stage) considers
that stage[i] is valid as long as stage[i-1].func is valid.
Thus, the last element of stage[].func should be intentionally invalid
as hci_init0[], le_init2[], and others did.
However, amp_init1[] and amp_init2[] have no invalid element, letting
hci_init_stage_sync() keep accessing amp_init1[] over its valid range.
This patch fixes this by adding {} in the last of amp_init1[] and
amp_init2[].

==================================================================
BUG: KASAN: global-out-of-bounds in hci_dev_open_sync (
/v6.2-bzimage/net/bluetooth/hci_sync.c:3154
/v6.2-bzimage/net/bluetooth/hci_sync.c:3343
/v6.2-bzimage/net/bluetooth/hci_sync.c:4418
/v6.2-bzimage/net/bluetooth/hci_sync.c:4609
/v6.2-bzimage/net/bluetooth/hci_sync.c:4689)
Read of size 8 at addr ffffffffaed1ab70 by task kworker/u5:0/1032
CPU: 0 PID: 1032 Comm: kworker/u5:0 Not tainted 6.2.0 #3
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04
Workqueue: hci1 hci_power_on
Call Trace:
 <TASK>
dump_stack_lvl (/v6.2-bzimage/lib/dump_stack.c:107 (discriminator 1))
print_report (/v6.2-bzimage/mm/kasan/report.c:307
  /v6.2-bzimage/mm/kasan/report.c:417)
? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154
  /v6.2-bzimage/net/bluetooth/hci_sync.c:3343
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4418
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4609
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4689)
kasan_report (/v6.2-bzimage/mm/kasan/report.c:184
  /v6.2-bzimage/mm/kasan/report.c:519)
? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154
  /v6.2-bzimage/net/bluetooth/hci_sync.c:3343
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4418
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4609
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4689)
hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154
  /v6.2-bzimage/net/bluetooth/hci_sync.c:3343
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4418
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4609
  /v6.2-bzimage/net/bluetooth/hci_sync.c:4689)
? __pfx_hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:4635)
? mutex_lock (/v6.2-bzimage/./arch/x86/include/asm/atomic64_64.h:190
  /v6.2-bzimage/./include/linux/atomic/atomic-long.h:443
  /v6.2-bzimage/./include/linux/atomic/atomic-instrumented.h:1781
  /v6.2-bzimage/kernel/locking/mutex.c:171
  /v6.2-bzimage/kernel/locking/mutex.c:285)
? __pfx_mutex_lock (/v6.2-bzimage/kernel/locking/mutex.c:282)
hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:485
  /v6.2-bzimage/net/bluetooth/hci_core.c:984)
? __pfx_hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:969)
? read_word_at_a_time (/v6.2-bzimage/./include/asm-generic/rwonce.h:85)
? strscpy (/v6.2-bzimage/./arch/x86/include/asm/word-at-a-time.h:62
  /v6.2-bzimage/lib/string.c:161)
process_one_work (/v6.2-bzimage/kernel/workqueue.c:2294)
worker_thread (/v6.2-bzimage/./include/linux/list.h:292
  /v6.2-bzimage/kernel/workqueue.c:2437)
? __pfx_worker_thread (/v6.2-bzimage/kernel/workqueue.c:2379)
kthread (/v6.2-bzimage/kernel/kthread.c:376)
? __pfx_kthread (/v6.2-bzimage/kernel/kthread.c:331)
ret_from_fork (/v6.2-bzimage/arch/x86/entry/entry_64.S:314)
 </TASK>
The buggy address belongs to the variable:
amp_init1+0x30/0x60
The buggy address belongs to the physical page:
page:000000003a157ec6 refcount:1 mapcount:0 mapping:0000000000000000 ia
flags: 0x200000000001000(reserved|node=0|zone=2)
raw: 0200000000001000 ffffea0005054688 ffffea0005054688 000000000000000
raw: 0000000000000000 0000000000000000 00000001ffffffff 000000000000000
page dumped because: kasan: bad access detected
Memory state around the buggy address:
 ffffffffaed1aa00: f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9 00 00 00 00
 ffffffffaed1aa80: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 00 00 00 00
>ffffffffaed1ab00: 00 f9 f9 f9 f9 f9 f9 f9 00 00 00 00 00 00 f9 f9
                  
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/8497222b22b591c6b2d106e0e3c1672ffe4e10e0
  - https://git.kernel.org/stable/c/b3168abd24245aa0775c5a387dcf94d36ca7e738
  - https://git.kernel.org/stable/c/bce56405201111807cc8e4f47c6de3e10b17c1ac

------------------------------------------------------------

CVE ID: CVE-2023-53058
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: E-Switch, Fix an Oops in error handling code

The error handling dereferences "vport".  There is nothing we can do if
it is an error pointer except returning the error code.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1a9853a7437a22fd849347008fb3c85087906b56
  - https://git.kernel.org/stable/c/388188fb58bef9e7f3ca4f8970f03d493b66909f
  - https://git.kernel.org/stable/c/5eadc80328298ef7beaaf0cd96791667d3b485ca
  - https://git.kernel.org/stable/c/640fcdbcf27fc62de9223f958ceb4e897a00e791
  - https://git.kernel.org/stable/c/c4c977935b2fc60084b3735737d17a06e7ba1bd0

------------------------------------------------------------

CVE ID: CVE-2023-53059
Description: In the Linux kernel, the following vulnerability has been resolved:

platform/chrome: cros_ec_chardev: fix kernel data leak from ioctl

It is possible to peep kernel page's data by providing larger `insize`
in struct cros_ec_command[1] when invoking EC host commands.

Fix it by using zeroed memory.

[1]: https://elixir.bootlin.com/linux/v6.2/source/include/linux/platform_data/cros_ec_proto.h#L74
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/13493ad6a220cb3f6f3552a16b4f2753a118b633
  - https://git.kernel.org/stable/c/a0d8644784f73fa39f57f72f374eefaba2bf48a0
  - https://git.kernel.org/stable/c/b20cf3f89c56b5f6a38b7f76a8128bf9f291bbd3
  - https://git.kernel.org/stable/c/eab28bfafcd1245a3510df9aa9eb940589956ea6
  - https://git.kernel.org/stable/c/ebea2e16504f40d2c2bac42ad5c5a3de5ce034b4
  - https://git.kernel.org/stable/c/f86ff88a1548ccf5a13960c0e7625ca787ea0993

------------------------------------------------------------

CVE ID: CVE-2023-53060
Description: In the Linux kernel, the following vulnerability has been resolved:

igb: revert rtnl_lock() that causes deadlock

The commit 6faee3d4ee8b ("igb: Add lock to avoid data race") adds
rtnl_lock to eliminate a false data race shown below

 (FREE from device detaching)      |   (USE from netdev core)
igb_remove                         |  igb_ndo_get_vf_config
 igb_disable_sriov                 |  vf >= adapter->vfs_allocated_count?
  kfree(adapter->vf_data)          |
  adapter->vfs_allocated_count = 0 |
                                   |    memcpy(... adapter->vf_data[vf]

The above race will never happen and the extra rtnl_lock causes deadlock
below

[  141.420169]  <TASK>
[  141.420672]  __schedule+0x2dd/0x840
[  141.421427]  schedule+0x50/0xc0
[  141.422041]  schedule_preempt_disabled+0x11/0x20
[  141.422678]  __mutex_lock.isra.13+0x431/0x6b0
[  141.423324]  unregister_netdev+0xe/0x20
[  141.423578]  igbvf_remove+0x45/0xe0 [igbvf]
[  141.423791]  pci_device_remove+0x36/0xb0
[  141.423990]  device_release_driver_internal+0xc1/0x160
[  141.424270]  pci_stop_bus_device+0x6d/0x90
[  141.424507]  pci_stop_and_remove_bus_device+0xe/0x20
[  141.424789]  pci_iov_remove_virtfn+0xba/0x120
[  141.425452]  sriov_disable+0x2f/0xf0
[  141.425679]  igb_disable_sriov+0x4e/0x100 [igb]
[  141.426353]  igb_remove+0xa0/0x130 [igb]
[  141.426599]  pci_device_remove+0x36/0xb0
[  141.426796]  device_release_driver_internal+0xc1/0x160
[  141.427060]  driver_detach+0x44/0x90
[  141.427253]  bus_remove_driver+0x55/0xe0
[  141.427477]  pci_unregister_driver+0x2a/0xa0
[  141.428296]  __x64_sys_delete_module+0x141/0x2b0
[  141.429126]  ? mntput_no_expire+0x4a/0x240
[  141.429363]  ? syscall_trace_enter.isra.19+0x126/0x1a0
[  141.429653]  do_syscall_64+0x5b/0x80
[  141.429847]  ? exit_to_user_mode_prepare+0x14d/0x1c0
[  141.430109]  ? syscall_exit_to_user_mode+0x12/0x30
[  141.430849]  ? do_syscall_64+0x67/0x80
[  141.431083]  ? syscall_exit_to_user_mode_prepare+0x183/0x1b0
[  141.431770]  ? syscall_exit_to_user_mode+0x12/0x30
[  141.432482]  ? do_syscall_64+0x67/0x80
[  141.432714]  ? exc_page_fault+0x64/0x140
[  141.432911]  entry_SYSCALL_64_after_hwframe+0x72/0xdc

Since the igb_disable_sriov() will call pci_disable_sriov() before
releasing any resources, the netdev core will synchronize the cleanup to
avoid any races. This patch removes the useless rtnl_(un)lock to guarantee
correctness.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0dabb72b923e17cb3b4ac99ea1adc9ef35116930
  - https://git.kernel.org/stable/c/4d2626e10709ff8474ffd1a9db3cf4647569e89c
  - https://git.kernel.org/stable/c/62a64645749926f9d75af82a96440941f22b046f
  - https://git.kernel.org/stable/c/65f69851e44d71248b952a687e44759a7abb5016
  - https://git.kernel.org/stable/c/66e5577cabc3d463eea540332727929d0ace41c6
  - https://git.kernel.org/stable/c/7d845e9a485f287181ff81567c3900a8e7ad1e28
  - https://git.kernel.org/stable/c/cd1e320ac0958298c2774605ad050483f33a21f2
  - https://git.kernel.org/stable/c/de91528d8ba274c614a2265077d695c61e31fd43

------------------------------------------------------------

CVE ID: CVE-2023-53061
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix possible refcount leak in smb2_open()

Reference count of acls will leak when memory allocation fails. Fix this
by adding the missing posix_acl_release().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2624b445544ffc1472ccabfb6ec867c199d4c95c
  - https://git.kernel.org/stable/c/303f8e58cc3ace744801dcdcabfc06ffc72ed62d
  - https://git.kernel.org/stable/c/a22c49a05e5e7aa2c414fbc42c49c4c01a5c9a78
  - https://git.kernel.org/stable/c/c33344b7972225b232966f95d31f6312dcc6273d

------------------------------------------------------------

CVE ID: CVE-2023-53062
Description: In the Linux kernel, the following vulnerability has been resolved:

net: usb: smsc95xx: Limit packet length to skb->len

Packet length retrieved from descriptor may be larger than
the actual socket buffer length. In such case the cloned
skb passed up the network stack will leak kernel memory contents.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/33d1603a38e05886c538129ddfe00bd52d347e7b
  - https://git.kernel.org/stable/c/70eb25c6a6cde149affe8a587371a3a8ad295ba0
  - https://git.kernel.org/stable/c/733580e268a53db1cd01f2251419da91866378f6
  - https://git.kernel.org/stable/c/ba6c40227108f8ee428e42eb0337b48ed3001e65
  - https://git.kernel.org/stable/c/d3c145a4d24b752c9a1314d5a595014d51471418
  - https://git.kernel.org/stable/c/e041bef1adee02999cf24f9a2e15ed452bc363fe
  - https://git.kernel.org/stable/c/f2111c791d885211714db85f9a06188571c57dd0
  - https://git.kernel.org/stable/c/ff821092cf02a70c2bccd2d19269f01e29aa52cf

------------------------------------------------------------

CVE ID: CVE-2023-53064
Description: In the Linux kernel, the following vulnerability has been resolved:

iavf: fix hang on reboot with ice

When a system with E810 with existing VFs gets rebooted the following
hang may be observed.

 Pid 1 is hung in iavf_remove(), part of a network driver:
 PID: 1        TASK: ffff965400e5a340  CPU: 24   COMMAND: "systemd-shutdow"
  #0 [ffffaad04005fa50] __schedule at ffffffff8b3239cb
  #1 [ffffaad04005fae8] schedule at ffffffff8b323e2d
  #2 [ffffaad04005fb00] schedule_hrtimeout_range_clock at ffffffff8b32cebc
  #3 [ffffaad04005fb80] usleep_range_state at ffffffff8b32c930
  #4 [ffffaad04005fbb0] iavf_remove at ffffffffc12b9b4c [iavf]
  #5 [ffffaad04005fbf0] pci_device_remove at ffffffff8add7513
  #6 [ffffaad04005fc10] device_release_driver_internal at ffffffff8af08baa
  #7 [ffffaad04005fc40] pci_stop_bus_device at ffffffff8adcc5fc
  #8 [ffffaad04005fc60] pci_stop_and_remove_bus_device at ffffffff8adcc81e
  #9 [ffffaad04005fc70] pci_iov_remove_virtfn at ffffffff8adf9429
 #10 [ffffaad04005fca8] sriov_disable at ffffffff8adf98e4
 #11 [ffffaad04005fcc8] ice_free_vfs at ffffffffc04bb2c8 [ice]
 #12 [ffffaad04005fd10] ice_remove at ffffffffc04778fe [ice]
 #13 [ffffaad04005fd38] ice_shutdown at ffffffffc0477946 [ice]
 #14 [ffffaad04005fd50] pci_device_shutdown at ffffffff8add58f1
 #15 [ffffaad04005fd70] device_shutdown at ffffffff8af05386
 #16 [ffffaad04005fd98] kernel_restart at ffffffff8a92a870
 #17 [ffffaad04005fda8] __do_sys_reboot at ffffffff8a92abd6
 #18 [ffffaad04005fee0] do_syscall_64 at ffffffff8b317159
 #19 [ffffaad04005ff08] __context_tracking_enter at ffffffff8b31b6fc
 #20 [ffffaad04005ff18] syscall_exit_to_user_mode at ffffffff8b31b50d
 #21 [ffffaad04005ff28] do_syscall_64 at ffffffff8b317169
 #22 [ffffaad04005ff50] entry_SYSCALL_64_after_hwframe at ffffffff8b40009b
     RIP: 00007f1baa5c13d7  RSP: 00007fffbcc55a98  RFLAGS: 00000202
     RAX: ffffffffffffffda  RBX: 0000000000000000  RCX: 00007f1baa5c13d7
     RDX: 0000000001234567  RSI: 0000000028121969  RDI: 00000000fee1dead
     RBP: 00007fffbcc55ca0   R8: 0000000000000000   R9: 00007fffbcc54e90
     R10: 00007fffbcc55050  R11: 0000000000000202  R12: 0000000000000005
     R13: 0000000000000000  R14: 00007fffbcc55af0  R15: 0000000000000000
     ORIG_RAX: 00000000000000a9  CS: 0033  SS: 002b

During reboot all drivers PM shutdown callbacks are invoked.
In iavf_shutdown() the adapter state is changed to __IAVF_REMOVE.
In ice_shutdown() the call chain above is executed, which at some point
calls iavf_remove(). However iavf_remove() expects the VF to be in one
of the states __IAVF_RUNNING, __IAVF_DOWN or __IAVF_INIT_FAILED. If
that's not the case it sleeps forever.
So if iavf_shutdown() gets invoked before iavf_remove() the system will
hang indefinitely because the adapter is already in state __IAVF_REMOVE.

Fix this by returning from iavf_remove() if the state is __IAVF_REMOVE,
as we already went through iavf_shutdown().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4e264be98b88a6d6f476c11087fe865696e8bef5
  - https://git.kernel.org/stable/c/502b898235f06130750c91512c86dd0e9efe28e6
  - https://git.kernel.org/stable/c/7a29799fc141ba9e6cf921fc8e958e3398ad1a4f
  - https://git.kernel.org/stable/c/f752ace58867de3c063512b21e0f1694fc27f043

------------------------------------------------------------

CVE ID: CVE-2023-53065
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/core: Fix perf_output_begin parameter is incorrectly invoked in perf_event_bpf_output

syzkaller reportes a KASAN issue with stack-out-of-bounds.
The call trace is as follows:
  dump_stack+0x9c/0xd3
  print_address_description.constprop.0+0x19/0x170
  __kasan_report.cold+0x6c/0x84
  kasan_report+0x3a/0x50
  __perf_event_header__init_id+0x34/0x290
  perf_event_header__init_id+0x48/0x60
  perf_output_begin+0x4a4/0x560
  perf_event_bpf_output+0x161/0x1e0
  perf_iterate_sb_cpu+0x29e/0x340
  perf_iterate_sb+0x4c/0xc0
  perf_event_bpf_event+0x194/0x2c0
  __bpf_prog_put.constprop.0+0x55/0xf0
  __cls_bpf_delete_prog+0xea/0x120 [cls_bpf]
  cls_bpf_delete_prog_work+0x1c/0x30 [cls_bpf]
  process_one_work+0x3c2/0x730
  worker_thread+0x93/0x650
  kthread+0x1b8/0x210
  ret_from_fork+0x1f/0x30

commit 267fb27352b6 ("perf: Reduce stack usage of perf_output_begin()")
use on-stack struct perf_sample_data of the caller function.

However, perf_event_bpf_output uses incorrect parameter to convert
small-sized data (struct perf_bpf_event) into large-sized data
(struct perf_sample_data), which causes memory overwriting occurs in
__perf_event_header__init_id.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3a776fddb4e5598c8bfcd4ad094fba34f9856fc9
  - https://git.kernel.org/stable/c/ac5f88642cb211152041f84a985309e9af4baf59
  - https://git.kernel.org/stable/c/ddcf8320003638a06eb1e46412e045d0c5701575
  - https://git.kernel.org/stable/c/eb81a2ed4f52be831c9fb879752d89645a312c13
  - https://git.kernel.org/stable/c/ff8137727a2af4ad5f6e6c8b9f7ec5e8db9da86c

------------------------------------------------------------

CVE ID: CVE-2023-53066
Description: In the Linux kernel, the following vulnerability has been resolved:

qed/qed_sriov: guard against NULL derefs from qed_iov_get_vf_info

We have to make sure that the info returned by the helper is valid
before using it.

Found by Linux Verification Center (linuxtesting.org) with the SVACE
static analysis tool.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/25143b6a01d0cc5319edd3de22ffa2578b045550
  - https://git.kernel.org/stable/c/39c3b9dd481c3afce9439b29bafe00444cb4406b
  - https://git.kernel.org/stable/c/42d72c6d1edc9dc09a5d6f6695d257fa9e9cc270
  - https://git.kernel.org/stable/c/7742c08e012eb65405e8304d100641638c5ff882
  - https://git.kernel.org/stable/c/7bd0037822fd04da13721f77a42ee5a077d4c5fb
  - https://git.kernel.org/stable/c/97ea704f39b5ded96f071e98701aa543f6f89683
  - https://git.kernel.org/stable/c/b224b0cab3a66e93d414825065a2e667a1d28c32
  - https://git.kernel.org/stable/c/e42d3bde4ec03c863259878dddaef5c351cca7ad

------------------------------------------------------------

CVE ID: CVE-2023-53067
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Only call get_timer_irq() once in constant_clockevent_init()

Under CONFIG_DEBUG_ATOMIC_SLEEP=y and CONFIG_DEBUG_PREEMPT=y, we can see
the following messages on LoongArch, this is because using might_sleep()
in preemption disable context.

[    0.001127] smp: Bringing up secondary CPUs ...
[    0.001222] Booting CPU#1...
[    0.001244] 64-bit Loongson Processor probed (LA464 Core)
[    0.001247] CPU1 revision is: 0014c012 (Loongson-64bit)
[    0.001250] FPU1 revision is: 00000000
[    0.001252] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283
[    0.001255] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1
[    0.001257] preempt_count: 1, expected: 0
[    0.001258] RCU nest depth: 0, expected: 0
[    0.001259] Preemption disabled at:
[    0.001261] [<9000000000223800>] arch_dup_task_struct+0x20/0x110
[    0.001272] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc7+ #43
[    0.001275] Hardware name: Loongson Loongson-3A5000-7A1000-1w-A2101/Loongson-LS3A5000-7A1000-1w-A2101, BIOS vUDK2018-LoongArch-V4.0.05132-beta10 12/13/202
[    0.001277] Stack : 0072617764726148 0000000000000000 9000000000222f1c 90000001001e0000
[    0.001286]         90000001001e3be0 90000001001e3be8 0000000000000000 0000000000000000
[    0.001292]         90000001001e3be8 0000000000000040 90000001001e3cb8 90000001001e3a50
[    0.001297]         9000000001642000 90000001001e3be8 be694d10ce4139dd 9000000100174500
[    0.001303]         0000000000000001 0000000000000001 00000000ffffe0a2 0000000000000020
[    0.001309]         000000000000002f 9000000001354116 00000000056b0000 ffffffffffffffff
[    0.001314]         0000000000000000 0000000000000000 90000000014f6e90 9000000001642000
[    0.001320]         900000000022b69c 0000000000000001 0000000000000000 9000000001736a90
[    0.001325]         9000000100038000 0000000000000000 9000000000222f34 0000000000000000
[    0.001331]         00000000000000b0 0000000000000004 0000000000000000 0000000000070000
[    0.001337]         ...
[    0.001339] Call Trace:
[    0.001342] [<9000000000222f34>] show_stack+0x5c/0x180
[    0.001346] [<90000000010bdd80>] dump_stack_lvl+0x60/0x88
[    0.001352] [<9000000000266418>] __might_resched+0x180/0x1cc
[    0.001356] [<90000000010c742c>] mutex_lock+0x20/0x64
[    0.001359] [<90000000002a8ccc>] irq_find_matching_fwspec+0x48/0x124
[    0.001364] [<90000000002259c4>] constant_clockevent_init+0x68/0x204
[    0.001368] [<900000000022acf4>] start_secondary+0x40/0xa8
[    0.001371] [<90000000010c0124>] smpboot_entry+0x60/0x64

Here are the complete call chains:

smpboot_entry()
  start_secondary()
    constant_clockevent_init()
      get_timer_irq()
        irq_find_matching_fwnode()
          irq_find_matching_fwspec()
            mutex_lock()
              might_sleep()
                __might_sleep()
                  __might_resched()

In order to avoid the above issue, we should break the call chains,
using timer_irq_installed variable as check condition to only call
get_timer_irq() once in constant_clockevent_init() is a simple and
proper way.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/acadbd058fa12b510fbecca11eae22bd6f654250
  - https://git.kernel.org/stable/c/b9c379e1d7e141b102f41858c9b8f6f36e7c89a4
  - https://git.kernel.org/stable/c/bb7a78e343468873bf00b2b181fcfd3c02d8cb56

------------------------------------------------------------

CVE ID: CVE-2023-53068
Description: In the Linux kernel, the following vulnerability has been resolved:

net: usb: lan78xx: Limit packet length to skb->len

Packet length retrieved from descriptor may be larger than
the actual socket buffer length. In such case the cloned
skb passed up the network stack will leak kernel memory contents.

Additionally prevent integer underflow when size is less than
ETH_FCS_LEN.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/44b9ed73369fc5ec85dd2ee487e986301792a82d
  - https://git.kernel.org/stable/c/7f247f5a2c18b3f21206cdd51193df4f38e1b9f5
  - https://git.kernel.org/stable/c/83de34967473ed31d276381373713cc2869a42e5

------------------------------------------------------------

CVE ID: CVE-2023-53069
Description: In the Linux kernel, the following vulnerability has been resolved:

octeontx2-vf: Add missing free for alloc_percpu

Add the free_percpu for the allocated "vf->hw.lmt_info" in order to avoid
memory leak, same as the "pf->hw.lmt_info" in
`drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c`.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/813b590840771890c738ce6dbfd0c5938a1bafb9
  - https://git.kernel.org/stable/c/840631bcf21f58c0a3f01378a54d79e9ce86b226
  - https://git.kernel.org/stable/c/90874b76e5f82eaa3309714d72ff2cd8bb8d1b02
  - https://git.kernel.org/stable/c/f038f3917baf04835ba2b7bcf2a04ac93fbf8a9c

------------------------------------------------------------

CVE ID: CVE-2023-53070
Description: In the Linux kernel, the following vulnerability has been resolved:

ACPI: PPTT: Fix to avoid sleep in the atomic context when PPTT is absent

Commit 0c80f9e165f8 ("ACPI: PPTT: Leave the table mapped for the runtime usage")
enabled to map PPTT once on the first invocation of acpi_get_pptt() and
never unmapped the same allowing it to be used at runtime with out the
hassle of mapping and unmapping the table. This was needed to fetch LLC
information from the PPTT in the cpuhotplug path which is executed in
the atomic context as the acpi_get_table() might sleep waiting for a
mutex.

However it missed to handle the case when there is no PPTT on the system
which results in acpi_get_pptt() being called from all the secondary
CPUs attempting to fetch the LLC information in the atomic context
without knowing the absence of PPTT resulting in the splat like below:

 | BUG: sleeping function called from invalid context at kernel/locking/semaphore.c:164
 | in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1
 | preempt_count: 1, expected: 0
 | RCU nest depth: 0, expected: 0
 | no locks held by swapper/1/0.
 | irq event stamp: 0
 | hardirqs last  enabled at (0): 0x0
 | hardirqs last disabled at (0): copy_process+0x61c/0x1b40
 | softirqs last  enabled at (0): copy_process+0x61c/0x1b40
 | softirqs last disabled at (0): 0x0
 | CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.3.0-rc1 #1
 | Call trace:
 |  dump_backtrace+0xac/0x138
 |  show_stack+0x30/0x48
 |  dump_stack_lvl+0x60/0xb0
 |  dump_stack+0x18/0x28
 |  __might_resched+0x160/0x270
 |  __might_sleep+0x58/0xb0
 |  down_timeout+0x34/0x98
 |  acpi_os_wait_semaphore+0x7c/0xc0
 |  acpi_ut_acquire_mutex+0x58/0x108
 |  acpi_get_table+0x40/0xe8
 |  acpi_get_pptt+0x48/0xa0
 |  acpi_get_cache_info+0x38/0x140
 |  init_cache_level+0xf4/0x118
 |  detect_cache_attributes+0x2e4/0x640
 |  update_siblings_masks+0x3c/0x330
 |  store_cpu_topology+0x88/0xf0
 |  secondary_start_kernel+0xd0/0x168
 |  __secondary_switched+0xb8/0xc0

Update acpi_get_pptt() to consider the fact that PPTT is once checked and
is not available on the system and return NULL avoiding any attempts to
fetch PPTT and thereby avoiding any possible sleep waiting for a mutex
in the atomic context.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1318a07706bb2f8c65f88f39a16c2b5260bcdcd4
  - https://git.kernel.org/stable/c/91d7b60a65d9f71230ea09b86d2058a884a3c2af
  - https://git.kernel.org/stable/c/e0c1106d51b9abc8eae03c5522b20649b6a55f6e

------------------------------------------------------------

CVE ID: CVE-2023-53071
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: do not run mt76_unregister_device() on unregistered hw

Trying to probe a mt7921e pci card without firmware results in a
successful probe where ieee80211_register_hw hasn't been called. When
removing the driver, ieee802111_unregister_hw is called unconditionally
leading to a kernel NULL pointer dereference.
Fix the issue running mt76_unregister_device routine just for registered
hw.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2d34f27714c97a9786a30b3bb54944d6d8ed612f
  - https://git.kernel.org/stable/c/41130c32f3a18fcc930316da17f3a5f3bc326aa1
  - https://git.kernel.org/stable/c/dffe86df26aee01a5fc56a175b7a7f157961e370

------------------------------------------------------------

CVE ID: CVE-2023-53072
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: use the workqueue to destroy unaccepted sockets

Christoph reported a UaF at token lookup time after having
refactored the passive socket initialization part:

  BUG: KASAN: use-after-free in __token_bucket_busy+0x253/0x260
  Read of size 4 at addr ffff88810698d5b0 by task syz-executor653/3198

  CPU: 1 PID: 3198 Comm: syz-executor653 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
  Call Trace:
   <TASK>
   dump_stack_lvl+0x6e/0x91
   print_report+0x16a/0x46f
   kasan_report+0xad/0x130
   __token_bucket_busy+0x253/0x260
   mptcp_token_new_connect+0x13d/0x490
   mptcp_connect+0x4ed/0x860
   __inet_stream_connect+0x80e/0xd90
   tcp_sendmsg_fastopen+0x3ce/0x710
   mptcp_sendmsg+0xff1/0x1a20
   inet_sendmsg+0x11d/0x140
   __sys_sendto+0x405/0x490
   __x64_sys_sendto+0xdc/0x1b0
   do_syscall_64+0x3b/0x90
   entry_SYSCALL_64_after_hwframe+0x72/0xdc

We need to properly clean-up all the paired MPTCP-level
resources and be sure to release the msk last, even when
the unaccepted subflow is destroyed by the TCP internals
via inet_child_forget().

We can re-use the existing MPTCP_WORK_CLOSE_SUBFLOW infra,
explicitly checking that for the critical scenario: the
closed subflow is the MPC one, the msk is not accepted and
eventually going through full cleanup.

With such change, __mptcp_destroy_sock() is always called
on msk sockets, even on accepted ones. We don't need anymore
to transiently drop one sk reference at msk clone time.

Please note this commit depends on the parent one:

  mptcp: refactor passive socket initialization
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2827f099b3fb9a59263c997400e9182f5d423e84
  - https://git.kernel.org/stable/c/804cf487fb0031f3c74755b78d8663333f0ba636
  - https://git.kernel.org/stable/c/b6985b9b82954caa53f862d6059d06c0526254f0

------------------------------------------------------------

CVE ID: CVE-2023-53073
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/x86/amd/core: Always clear status for idx

The variable 'status' (which contains the unhandled overflow bits) is
not being properly masked in some cases, displaying the following
warning:

  WARNING: CPU: 156 PID: 475601 at arch/x86/events/amd/core.c:972 amd_pmu_v2_handle_irq+0x216/0x270

This seems to be happening because the loop is being continued before
the status bit being unset, in case x86_perf_event_set_period()
returns 0. This is also causing an inconsistency because the "handled"
counter is incremented, but the status bit is not cleaned.

Move the bit cleaning together above, together when the "handled"
counter is incremented.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/263f5ecaf7080513efc248ec739b6d9e00f4129f
  - https://git.kernel.org/stable/c/9d4c7b1f12e101d6d6253092588b127416ddfb6c
  - https://git.kernel.org/stable/c/ab33a8f7649b0324639a336e1081aaea51a4523e

------------------------------------------------------------

CVE ID: CVE-2023-53074
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: fix ttm_bo calltrace warning in psp_hw_fini

The call trace occurs when the amdgpu is removed after
the mode1 reset. During mode1 reset, from suspend to resume,
there is no need to reinitialize the ta firmware buffer
which caused the bo pin_count increase redundantly.

[  489.885525] Call Trace:
[  489.885525]  <TASK>
[  489.885526]  amdttm_bo_put+0x34/0x50 [amdttm]
[  489.885529]  amdgpu_bo_free_kernel+0xe8/0x130 [amdgpu]
[  489.885620]  psp_free_shared_bufs+0xb7/0x150 [amdgpu]
[  489.885720]  psp_hw_fini+0xce/0x170 [amdgpu]
[  489.885815]  amdgpu_device_fini_hw+0x2ff/0x413 [amdgpu]
[  489.885960]  ? blocking_notifier_chain_unregister+0x56/0xb0
[  489.885962]  amdgpu_driver_unload_kms+0x51/0x60 [amdgpu]
[  489.886049]  amdgpu_pci_remove+0x5a/0x140 [amdgpu]
[  489.886132]  ? __pm_runtime_resume+0x60/0x90
[  489.886134]  pci_device_remove+0x3e/0xb0
[  489.886135]  __device_release_driver+0x1ab/0x2a0
[  489.886137]  driver_detach+0xf3/0x140
[  489.886138]  bus_remove_driver+0x6c/0xf0
[  489.886140]  driver_unregister+0x31/0x60
[  489.886141]  pci_unregister_driver+0x40/0x90
[  489.886142]  amdgpu_exit+0x15/0x451 [amdgpu]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/23f4a2d29ba57bf88095f817de5809d427fcbe7e
  - https://git.kernel.org/stable/c/55a7c647ebf6e376c45d8322568dd6eb71937139
  - https://git.kernel.org/stable/c/7be9a2f8c5179520a7d5570e648e0c97d09e4fae

------------------------------------------------------------

CVE ID: CVE-2023-53075
Description: In the Linux kernel, the following vulnerability has been resolved:

ftrace: Fix invalid address access in lookup_rec() when index is 0

KASAN reported follow problem:

 BUG: KASAN: use-after-free in lookup_rec
 Read of size 8 at addr ffff000199270ff0 by task modprobe
 CPU: 2 Comm: modprobe
 Call trace:
  kasan_report
  __asan_load8
  lookup_rec
  ftrace_location
  arch_check_ftrace_location
  check_kprobe_address_safe
  register_kprobe

When checking pg->records[pg->index - 1].ip in lookup_rec(), it can get a
pg which is newly added to ftrace_pages_start in ftrace_process_locs().
Before the first pg->index++, index is 0 and accessing pg->records[-1].ip
will cause this problem.

Don't check the ip when pg->index is 0.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2a0d71fabfeb349216d33f001a6421b1768bd3a9
  - https://git.kernel.org/stable/c/2de28e5ce34b22b73b833a21e2c45ae3aade3964
  - https://git.kernel.org/stable/c/4f84f31f63416b0f02fc146ffdc4ab32723eb7e8
  - https://git.kernel.org/stable/c/7569ee04b0e3b32df79f64db3a7138573edad9bc
  - https://git.kernel.org/stable/c/83c3b2f4e7c61367c7b24551f4c6eb94bbdda283
  - https://git.kernel.org/stable/c/ac58b88ccbbb8e9fb83e137cee04a856b1ea6635
  - https://git.kernel.org/stable/c/ee92fa443358f4fc0017c1d0d325c27b37802504
  - https://git.kernel.org/stable/c/f1bd8b7fd890d87d0dc4dedc6287ea34dd07c0b4

------------------------------------------------------------

CVE ID: CVE-2023-53077
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix shift-out-of-bounds in CalculateVMAndRowBytes

[WHY]
When PTEBufferSizeInRequests is zero, UBSAN reports the following
warning because dml_log2 returns an unexpected negative value:

  shift exponent 4294966273 is too large for 32-bit type 'int'

[HOW]

In the case PTEBufferSizeInRequests is zero, skip the dml_log2() and
assign the result directly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/031f196d1b1b6d5dfcb0533b431e3ab1750e6189
  - https://git.kernel.org/stable/c/7257070be70e19a9138f39009c1a26c83a8a7cfa
  - https://git.kernel.org/stable/c/a16394b5d661afec9a264fecac3abd87aea439ea
  - https://git.kernel.org/stable/c/bec1bea2fa974e63f6059c33edde669c7894d0bc
  - https://git.kernel.org/stable/c/e12b95680821b9880cd9992c0f3555389363604f

------------------------------------------------------------

CVE ID: CVE-2023-53078
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: scsi_dh_alua: Fix memleak for 'qdata' in alua_activate()

If alua_rtpg_queue() failed from alua_activate(), then 'qdata' is not
freed, which will cause following memleak:

unreferenced object 0xffff88810b2c6980 (size 32):
  comm "kworker/u16:2", pid 635322, jiffies 4355801099 (age 1216426.076s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    40 39 24 c1 ff ff ff ff 00 f8 ea 0a 81 88 ff ff  @9$.............
  backtrace:
    [<0000000098f3a26d>] alua_activate+0xb0/0x320
    [<000000003b529641>] scsi_dh_activate+0xb2/0x140
    [<000000007b296db3>] activate_path_work+0xc6/0xe0 [dm_multipath]
    [<000000007adc9ace>] process_one_work+0x3c5/0x730
    [<00000000c457a985>] worker_thread+0x93/0x650
    [<00000000cb80e628>] kthread+0x1ba/0x210
    [<00000000a1e61077>] ret_from_fork+0x22/0x30

Fix the problem by freeing 'qdata' in error path.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d89254a4320eb7de0970c478172f764125c6355
  - https://git.kernel.org/stable/c/123483df146492ca22b503ae6dacc2ce7c3a3974
  - https://git.kernel.org/stable/c/1c55982beb80c7d3c30278fc6cfda8496a31dbe6
  - https://git.kernel.org/stable/c/5c4d71424df34fc23dc5336d09394ce68c849542
  - https://git.kernel.org/stable/c/9311e7a554dffd3823499e309a8b86a5cd1540e5
  - https://git.kernel.org/stable/c/a13faca032acbf2699293587085293bdfaafc8ae
  - https://git.kernel.org/stable/c/c09cdf6eb815ee35e55d6c50ac7f63db58bd20b8
  - https://git.kernel.org/stable/c/c110051d335ef7f62ad33474b0c23997fee5bfb5

------------------------------------------------------------

CVE ID: CVE-2023-53079
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Fix steering rules cleanup

vport's mc, uc and multicast rules are not deleted in teardown path when
EEH happens. Since the vport's promisc settings(uc, mc and all) in
firmware are reset after EEH, mlx5 driver will try to delete the above
rules in the initialization path. This cause kernel crash because these
software rules are no longer valid.

Fix by nullifying these rules right after delete to avoid accessing any dangling
pointers.

Call Trace:
__list_del_entry_valid+0xcc/0x100 (unreliable)
tree_put_node+0xf4/0x1b0 [mlx5_core]
tree_remove_node+0x30/0x70 [mlx5_core]
mlx5_del_flow_rules+0x14c/0x1f0 [mlx5_core]
esw_apply_vport_rx_mode+0x10c/0x200 [mlx5_core]
esw_update_vport_rx_mode+0xb4/0x180 [mlx5_core]
esw_vport_change_handle_locked+0x1ec/0x230 [mlx5_core]
esw_enable_vport+0x130/0x260 [mlx5_core]
mlx5_eswitch_enable_sriov+0x2a0/0x2f0 [mlx5_core]
mlx5_device_enable_sriov+0x74/0x440 [mlx5_core]
mlx5_load_one+0x114c/0x1550 [mlx5_core]
mlx5_pci_resume+0x68/0xf0 [mlx5_core]
eeh_report_resume+0x1a4/0x230
eeh_pe_dev_traverse+0x98/0x170
eeh_handle_normal_event+0x3e4/0x640
eeh_handle_event+0x4c/0x370
eeh_event_handler+0x14c/0x210
kthread+0x168/0x1b0
ret_from_kernel_thread+0x5c/0x84
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/18cead61e437f4c7898acca0a5f3df12f801d97f
  - https://git.kernel.org/stable/c/4df1f2d36bdc9a368650bf14b9097c555e95f71d
  - https://git.kernel.org/stable/c/63546395a0e6ac264f78f65218086ce6014b4494
  - https://git.kernel.org/stable/c/6f5780536181d1d0d09a11a1bc92f22e143447e2
  - https://git.kernel.org/stable/c/922f56e9a795d6f3dd72d3428ebdd7ee040fa855

------------------------------------------------------------

CVE ID: CVE-2023-53080
Description: In the Linux kernel, the following vulnerability has been resolved:

xsk: Add missing overflow check in xdp_umem_reg

The number of chunks can overflow u32. Make sure to return -EINVAL on
overflow. Also remove a redundant u32 cast assigning umem->npgs.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3cfc3564411acf96bf2fb791f706a1aa4f872c1d
  - https://git.kernel.org/stable/c/580634b03a55f04a3c1968bcbd97736c079c6601
  - https://git.kernel.org/stable/c/a069909acc4435eeb41d05ccc03baa447cc01b7e
  - https://git.kernel.org/stable/c/bb2e3bfb2a79db0c2057c6f701b782954394c67f
  - https://git.kernel.org/stable/c/c7df4813b149362248d6ef7be41a311e27bf75fe

------------------------------------------------------------

CVE ID: CVE-2023-53081
Description: In the Linux kernel, the following vulnerability has been resolved:

ocfs2: fix data corruption after failed write

When buffered write fails to copy data into underlying page cache page,
ocfs2_write_end_nolock() just zeroes out and dirties the page.  This can
leave dirty page beyond EOF and if page writeback tries to write this page
before write succeeds and expands i_size, page gets into inconsistent
state where page dirty bit is clear but buffer dirty bits stay set
resulting in page data never getting written and so data copied to the
page is lost.  Fix the problem by invalidating page beyond EOF after
failed write.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1629f6f522b2d058019710466a84b240683bbee3
  - https://git.kernel.org/stable/c/205759c6c18f54659b0b5976b14a52d1b3eb9f57
  - https://git.kernel.org/stable/c/47eb055ad3588fc96d34e9e1dd87b210ce62906b
  - https://git.kernel.org/stable/c/4c24eb49ab44351424ac8fe8567f91ea48a06089
  - https://git.kernel.org/stable/c/90410bcf873cf05f54a32183afff0161f44f9715
  - https://git.kernel.org/stable/c/91d7a4bd5656552d6259e2d0f8859f9e8cc5ef68
  - https://git.kernel.org/stable/c/a9e53869cb43c96d6d851c491fd4e26430ab6ba6
  - https://git.kernel.org/stable/c/c26f3ff4c0be590c1250f945ac2e4fc5fcdc5f45

------------------------------------------------------------

CVE ID: CVE-2023-53082
Description: In the Linux kernel, the following vulnerability has been resolved:

vp_vdpa: fix the crash in hot unplug with vp_vdpa

While unplugging the vp_vdpa device, it triggers a kernel panic
The root cause is: vdpa_mgmtdev_unregister() will accesses modern
devices which will cause a use after free.
So need to change the sequence in vp_vdpa_remove

[  195.003359] BUG: unable to handle page fault for address: ff4e8beb80199014
[  195.004012] #PF: supervisor read access in kernel mode
[  195.004486] #PF: error_code(0x0000) - not-present page
[  195.004960] PGD 100000067 P4D 1001b6067 PUD 1001b7067 PMD 1001b8067 PTE 0
[  195.005578] Oops: 0000 1 PREEMPT SMP PTI
[  195.005968] CPU: 13 PID: 164 Comm: kworker/u56:10 Kdump: loaded Not tainted 5.14.0-252.el9.x86_64 #1
[  195.006792] Hardware name: Red Hat KVM/RHEL, BIOS edk2-20221207gitfff6d81270b5-2.el9 unknown
[  195.007556] Workqueue: kacpi_hotplug acpi_hotplug_work_fn
[  195.008059] RIP: 0010:ioread8+0x31/0x80
[  195.008418] Code: 77 28 48 81 ff 00 00 01 00 76 0b 89 fa ec 0f b6 c0 c3 cc cc cc cc 8b 15 ad 72 93 01 b8 ff 00 00 00 85 d2 75 0f c3 cc cc cc cc <8a> 07 0f b6 c0 c3 cc cc cc cc 83 ea 01 48 83 ec 08 48 89 fe 48 c7
[  195.010104] RSP: 0018:ff4e8beb8067bab8 EFLAGS: 00010292
[  195.010584] RAX: ffffffffc05834a0 RBX: ffffffffc05843c0 RCX: ff4e8beb8067bae0
[  195.011233] RDX: ff1bcbd580f88000 RSI: 0000000000000246 RDI: ff4e8beb80199014
[  195.011881] RBP: ff1bcbd587e39000 R08: ffffffff916fa2d0 R09: ff4e8beb8067ba68
[  195.012527] R10: 000000000000001c R11: 0000000000000000 R12: ff1bcbd5a3de9120
[  195.013179] R13: ffffffffc062d000 R14: 0000000000000080 R15: ff1bcbe402bc7805
[  195.013826] FS:  0000000000000000(0000) GS:ff1bcbe402740000(0000) knlGS:0000000000000000
[  195.014564] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  195.015093] CR2: ff4e8beb80199014 CR3: 0000000107dea002 CR4: 0000000000771ee0
[  195.015741] PKRU: 55555554
[  195.016001] Call Trace:
[  195.016233]  <TASK>
[  195.016434]  vp_modern_get_status+0x12/0x20
[  195.016823]  vp_vdpa_reset+0x1b/0x50 [vp_vdpa]
[  195.017238]  virtio_vdpa_reset+0x3c/0x48 [virtio_vdpa]
[  195.017709]  remove_vq_common+0x1f/0x3a0 [virtio_net]
[  195.018178]  virtnet_remove+0x5d/0x70 [virtio_net]
[  195.018618]  virtio_dev_remove+0x3d/0x90
[  195.018986]  device_release_driver_internal+0x1aa/0x230
[  195.019466]  bus_remove_device+0xd8/0x150
[  195.019841]  device_del+0x18b/0x3f0
[  195.020167]  ? kernfs_find_ns+0x35/0xd0
[  195.020526]  device_unregister+0x13/0x60
[  195.020894]  unregister_virtio_device+0x11/0x20
[  195.021311]  device_release_driver_internal+0x1aa/0x230
[  195.021790]  bus_remove_device+0xd8/0x150
[  195.022162]  device_del+0x18b/0x3f0
[  195.022487]  device_unregister+0x13/0x60
[  195.022852]  ? vdpa_dev_remove+0x30/0x30 [vdpa]
[  195.023270]  vp_vdpa_dev_del+0x12/0x20 [vp_vdpa]
[  195.023694]  vdpa_match_remove+0x2b/0x40 [vdpa]
[  195.024115]  bus_for_each_dev+0x78/0xc0
[  195.024471]  vdpa_mgmtdev_unregister+0x65/0x80 [vdpa]
[  195.024937]  vp_vdpa_remove+0x23/0x40 [vp_vdpa]
[  195.025353]  pci_device_remove+0x36/0xa0
[  195.025719]  device_release_driver_internal+0x1aa/0x230
[  195.026201]  pci_stop_bus_device+0x6c/0x90
[  195.026580]  pci_stop_and_remove_bus_device+0xe/0x20
[  195.027039]  disable_slot+0x49/0x90
[  195.027366]  acpiphp_disable_and_eject_slot+0x15/0x90
[  195.027832]  hotplug_event+0xea/0x210
[  195.028171]  ? hotplug_event+0x210/0x210
[  195.028535]  acpiphp_hotplug_notify+0x22/0x80
[  195.028942]  ? hotplug_event+0x210/0x210
[  195.029303]  acpi_device_hotplug+0x8a/0x1d0
[  195.029690]  acpi_hotplug_work_fn+0x1a/0x30
[  195.030077]  process_one_work+0x1e8/0x3c0
[  195.030451]  worker_thread+0x50/0x3b0
[  195.030791]  ? rescuer_thread+0x3a0/0x3a0
[  195.031165]  kthread+0xd9/0x100
[  195.031459]  ? kthread_complete_and_exit+0x20/0x20
[  195.031899]  ret_from_fork+0x22/0x30
[  195.032233]  </TASK>
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/aed8efddd39b3434c96718d39009285c52b1cafc
  - https://git.kernel.org/stable/c/baafa2960731211837d8fc04ff3873ecb7440464
  - https://git.kernel.org/stable/c/fa1f327f93c9a7310cce9d2fcda28b7af91f7437

------------------------------------------------------------

CVE ID: CVE-2023-53083
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: don't replace page in rq_pages if it's a continuation of last page

The splice read calls nfsd_splice_actor to put the pages containing file
data into the svc_rqst->rq_pages array. It's possible however to get a
splice result that only has a partial page at the end, if (e.g.) the
filesystem hands back a short read that doesn't cover the whole page.

nfsd_splice_actor will plop the partial page into its rq_pages array and
return. Then later, when nfsd_splice_actor is called again, the
remainder of the page may end up being filled out. At this point,
nfsd_splice_actor will put the page into the array _again_ corrupting
the reply. If this is done enough times, rq_next_page will overrun the
array and corrupt the trailing fields -- the rq_respages and
rq_next_page pointers themselves.

If we've already added the page to the array in the last pass, don't add
it to the array a second time when dealing with a splice continuation.
This was originally handled properly in nfsd_splice_actor, but commit
91e23b1c3982 ("NFSD: Clean up nfsd_splice_actor()") removed the check
for it.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0101067f376eb7b9afd00279270f25d5111a091d
  - https://git.kernel.org/stable/c/12eca509234acb6b666802edf77408bb70d7bfca
  - https://git.kernel.org/stable/c/27c934dd8832dd40fd34776f916dc201e18b319b
  - https://git.kernel.org/stable/c/51ddb84baff6f09ad62b5999ece3ec172e4e3568
  - https://git.kernel.org/stable/c/8235cd619db6e67f1d7d26c55f1f3e4e575c947d

------------------------------------------------------------

CVE ID: CVE-2023-53084
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/shmem-helper: Remove another errant put in error path

drm_gem_shmem_mmap() doesn't own reference in error code path, resulting
in the dma-buf shmem GEM object getting prematurely freed leading to a
later use-after-free.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5cfb617967b05f8f27e862c97db1fabd8485f4db
  - https://git.kernel.org/stable/c/684c7372bbd6447c2e86a2a84e97a1478604d21f
  - https://git.kernel.org/stable/c/77d26c824aa5a7e0681ef1d5b75fe538d746addc
  - https://git.kernel.org/stable/c/dede8c14a37a7ac458f9add56154a074ed78e7cf
  - https://git.kernel.org/stable/c/ee9adb7a45516cfa536ca92253d7ae59d56db9e4

------------------------------------------------------------

CVE ID: CVE-2023-53085
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/edid: fix info leak when failing to get panel id

Make sure to clear the transfer buffer before fetching the EDID to
avoid leaking slab data to the logs on errors that leave the buffer
unchanged.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4d8457fe0eb9c80ff7795cf8a30962128b71d853
  - https://git.kernel.org/stable/c/598c42c78919117dc0d235ae22d17ad642377483

------------------------------------------------------------

CVE ID: CVE-2023-53086
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: connac: do not check WED status for non-mmio devices

WED is supported just for mmio devices, so do not check it for usb or
sdio devices. This patch fixes the crash reported below:

[   21.946627] wlp0s3u1i3: authenticate with c4:41:1e:f5:2b:1d
[   22.525298] wlp0s3u1i3: send auth to c4:41:1e:f5:2b:1d (try 1/3)
[   22.548274] wlp0s3u1i3: authenticate with c4:41:1e:f5:2b:1d
[   22.557694] wlp0s3u1i3: send auth to c4:41:1e:f5:2b:1d (try 1/3)
[   22.565885] wlp0s3u1i3: authenticated
[   22.569502] wlp0s3u1i3: associate with c4:41:1e:f5:2b:1d (try 1/3)
[   22.578966] wlp0s3u1i3: RX AssocResp from c4:41:1e:f5:2b:1d (capab=0x11 status=30 aid=3)
[   22.579113] wlp0s3u1i3: c4:41:1e:f5:2b:1d rejected association temporarily; comeback duration 1000 TU (1024 ms)
[   23.649518] wlp0s3u1i3: associate with c4:41:1e:f5:2b:1d (try 2/3)
[   23.752528] wlp0s3u1i3: RX AssocResp from c4:41:1e:f5:2b:1d (capab=0x11 status=0 aid=3)
[   23.797450] wlp0s3u1i3: associated
[   24.959527] kernel tried to execute NX-protected page - exploit attempt? (uid: 0)
[   24.959640] BUG: unable to handle page fault for address: ffff88800c223200
[   24.959706] #PF: supervisor instruction fetch in kernel mode
[   24.959788] #PF: error_code(0x0011) - permissions violation
[   24.959846] PGD 2c01067 P4D 2c01067 PUD 2c02067 PMD c2a8063 PTE 800000000c223163
[   24.959957] Oops: 0011 [#1] PREEMPT SMP
[   24.960009] CPU: 0 PID: 391 Comm: wpa_supplicant Not tainted 6.2.0-kvm #18
[   24.960089] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014
[   24.960191] RIP: 0010:0xffff88800c223200
[   24.960446] RSP: 0018:ffffc90000ff7698 EFLAGS: 00010282
[   24.960513] RAX: ffff888028397010 RBX: ffff88800c26e630 RCX: 0000000000000058
[   24.960598] RDX: ffff88800c26f844 RSI: 0000000000000006 RDI: ffff888028397010
[   24.960682] RBP: ffff88800ea72f00 R08: 18b873fbab2b964c R09: be06b38235f3c63c
[   24.960766] R10: 18b873fbab2b964c R11: be06b38235f3c63c R12: 0000000000000001
[   24.960853] R13: ffff88800c26f84c R14: ffff8880063f0ff8 R15: ffff88800c26e644
[   24.960950] FS:  00007effcea327c0(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000
[   24.961036] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   24.961106] CR2: ffff88800c223200 CR3: 000000000eaa2000 CR4: 00000000000006b0
[   24.961190] Call Trace:
[   24.961219]  <TASK>
[   24.961245]  ? mt76_connac_mcu_add_key+0x2cf/0x310
[   24.961313]  ? mt7921_set_key+0x150/0x200
[   24.961365]  ? drv_set_key+0xa9/0x1b0
[   24.961418]  ? ieee80211_key_enable_hw_accel+0xd9/0x240
[   24.961485]  ? ieee80211_key_replace+0x3f3/0x730
[   24.961541]  ? crypto_shash_setkey+0x89/0xd0
[   24.961597]  ? ieee80211_key_link+0x2d7/0x3a0
[   24.961664]  ? crypto_aead_setauthsize+0x31/0x50
[   24.961730]  ? sta_info_hash_lookup+0xa6/0xf0
[   24.961785]  ? ieee80211_add_key+0x1fc/0x250
[   24.961842]  ? rdev_add_key+0x41/0x140
[   24.961882]  ? nl80211_parse_key+0x6c/0x2f0
[   24.961940]  ? nl80211_new_key+0x24a/0x290
[   24.961984]  ? genl_rcv_msg+0x36c/0x3a0
[   24.962036]  ? rdev_mod_link_station+0xe0/0xe0
[   24.962102]  ? nl80211_set_key+0x410/0x410
[   24.962143]  ? nl80211_pre_doit+0x200/0x200
[   24.962187]  ? genl_bind+0xc0/0xc0
[   24.962217]  ? netlink_rcv_skb+0xaa/0xd0
[   24.962259]  ? genl_rcv+0x24/0x40
[   24.962300]  ? netlink_unicast+0x224/0x2f0
[   24.962345]  ? netlink_sendmsg+0x30b/0x3d0
[   24.962388]  ? ____sys_sendmsg+0x109/0x1b0
[   24.962388]  ? ____sys_sendmsg+0x109/0x1b0
[   24.962440]  ? __import_iovec+0x2e/0x110
[   24.962482]  ? ___sys_sendmsg+0xbe/0xe0
[   24.962525]  ? mod_objcg_state+0x25c/0x330
[   24.962576]  ? __dentry_kill+0x19e/0x1d0
[   24.962618]  ? call_rcu+0x18f/0x270
[   24.962660]  ? __dentry_kill+0x19e/0x1d0
[   24.962702]  ? __x64_sys_sendmsg+0x70/0x90
[   24.962744]  ? do_syscall_64+0x3d/0x80
[   24.962796]  ? exit_to_user_mode_prepare+0x1b/0x70
[   24.962852]  ? entry_SYSCA
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/53edfda851dd1ce41ac049ce2f195dc41dd27cc1
  - https://git.kernel.org/stable/c/5683e1488aa9b0805a9403d215e48fed29d6d923

------------------------------------------------------------

CVE ID: CVE-2023-53087
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915/active: Fix misuse of non-idle barriers as fence trackers

Users reported oopses on list corruptions when using i915 perf with a
number of concurrently running graphics applications.  Root cause analysis
pointed at an issue in barrier processing code -- a race among perf open /
close replacing active barriers with perf requests on kernel context and
concurrent barrier preallocate / acquire operations performed during user
context first pin / last unpin.

When adding a request to a composite tracker, we try to reuse an existing
fence tracker, already allocated and registered with that composite.  The
tracker we obtain may already track another fence, may be an idle barrier,
or an active barrier.

If the tracker we get occurs a non-idle barrier then we try to delete that
barrier from a list of barrier tasks it belongs to.  However, while doing
that we don't respect return value from a function that performs the
barrier deletion.  Should the deletion ever fail, we would end up reusing
the tracker still registered as a barrier task.  Since the same structure
field is reused with both fence callback lists and barrier tasks list,
list corruptions would likely occur.

Barriers are now deleted from a barrier tasks list by temporarily removing
the list content, traversing that content with skip over the node to be
deleted, then populating the list back with the modified content.  Should
that intentionally racy concurrent deletion attempts be not serialized,
one or more of those may fail because of the list being temporary empty.

Related code that ignores the results of barrier deletion was initially
introduced in v5.4 by commit d8af05ff38ae ("drm/i915: Allow sharing the
idle-barrier from other kernel requests").  However, all users of the
barrier deletion routine were apparently serialized at that time, then the
issue didn't exhibit itself.  Results of git bisect with help of a newly
developed igt@gem_barrier_race@remote-request IGT test indicate that list
corruptions might start to appear after commit 311770173fac ("drm/i915/gt:
Schedule request retirement when timeline idles"), introduced in v5.5.

Respect results of barrier deletion attempts -- mark the barrier as idle
only if successfully deleted from the list.  Then, before proceeding with
setting our fence as the one currently tracked, make sure that the tracker
we've got is not a non-idle barrier.  If that check fails then don't use
that tracker but go back and try to acquire a new, usable one.

v3: use unlikely() to document what outcome we expect (Andi),
  - fix bad grammar in commit description.
v2: no code changes,
  - blame commit 311770173fac ("drm/i915/gt: Schedule request retirement
    when timeline idles"), v5.5, not commit d8af05ff38ae ("drm/i915: Allow
    sharing the idle-barrier from other kernel requests"), v5.4,
  - reword commit description.

(cherry picked from commit 506006055769b10d1b2b4e22f636f3b45e0e9fc7)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5c7591b8574c52c56b3994c2fbef1a3a311b5715
  - https://git.kernel.org/stable/c/5e784a7d07af42057c0576fb647b482f4cb0dc2c
  - https://git.kernel.org/stable/c/6ab7d33617559cced63d467928f478ea5c459021
  - https://git.kernel.org/stable/c/9159db27fb19bbf1c91b5c9d5285e66cc96cc5ff
  - https://git.kernel.org/stable/c/e0e6b416b25ee14716f3549e0cbec1011b193809

------------------------------------------------------------

CVE ID: CVE-2023-53088
Description: In the Linux kernel, the following vulnerability has been resolved:

mptcp: fix UaF in listener shutdown

As reported by Christoph after having refactored the passive
socket initialization, the mptcp listener shutdown path is prone
to an UaF issue.

  BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x73/0xe0
  Write of size 4 at addr ffff88810cb23098 by task syz-executor731/1266

  CPU: 1 PID: 1266 Comm: syz-executor731 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
  Call Trace:
   <TASK>
   dump_stack_lvl+0x6e/0x91
   print_report+0x16a/0x46f
   kasan_report+0xad/0x130
   kasan_check_range+0x14a/0x1a0
   _raw_spin_lock_bh+0x73/0xe0
   subflow_error_report+0x6d/0x110
   sk_error_report+0x3b/0x190
   tcp_disconnect+0x138c/0x1aa0
   inet_child_forget+0x6f/0x2e0
   inet_csk_listen_stop+0x209/0x1060
   __mptcp_close_ssk+0x52d/0x610
   mptcp_destroy_common+0x165/0x640
   mptcp_destroy+0x13/0x80
   __mptcp_destroy_sock+0xe7/0x270
   __mptcp_close+0x70e/0x9b0
   mptcp_close+0x2b/0x150
   inet_release+0xe9/0x1f0
   __sock_release+0xd2/0x280
   sock_close+0x15/0x20
   __fput+0x252/0xa20
   task_work_run+0x169/0x250
   exit_to_user_mode_prepare+0x113/0x120
   syscall_exit_to_user_mode+0x1d/0x40
   do_syscall_64+0x48/0x90
   entry_SYSCALL_64_after_hwframe+0x72/0xdc

The msk grace period can legitly expire in between the last
reference count dropped in mptcp_subflow_queue_clean() and
the later eventual access in inet_csk_listen_stop()

After the previous patch we don't need anymore special-casing
msk listener socket cleanup: the mptcp worker will process each
of the unaccepted msk sockets.

Just drop the now unnecessary code.

Please note this commit depends on the two parent ones:

  mptcp: refactor passive socket initialization
  mptcp: use the workqueue to destroy unaccepted sockets
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a3f4f1f9c27215e4ddcd312558342e57b93e518
  - https://git.kernel.org/stable/c/0f4f4cf5d32f10543deb946a37111e714579511e
  - https://git.kernel.org/stable/c/5564be74a22a61855f8b8c100d8c4abb003bb792

------------------------------------------------------------

CVE ID: CVE-2023-53089
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix task hung in ext4_xattr_delete_inode

Syzbot reported a hung task problem:
==================================================================
INFO: task syz-executor232:5073 blocked for more than 143 seconds.
      Not tainted 6.2.0-rc2-syzkaller-00024-g512dee0c00ad #0
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
task:syz-exec232 state:D stack:21024 pid:5073 ppid:5072 flags:0x00004004
Call Trace:
 <TASK>
 context_switch kernel/sched/core.c:5244 [inline]
 __schedule+0x995/0xe20 kernel/sched/core.c:6555
 schedule+0xcb/0x190 kernel/sched/core.c:6631
 __wait_on_freeing_inode fs/inode.c:2196 [inline]
 find_inode_fast+0x35a/0x4c0 fs/inode.c:950
 iget_locked+0xb1/0x830 fs/inode.c:1273
 __ext4_iget+0x22e/0x3ed0 fs/ext4/inode.c:4861
 ext4_xattr_inode_iget+0x68/0x4e0 fs/ext4/xattr.c:389
 ext4_xattr_inode_dec_ref_all+0x1a7/0xe50 fs/ext4/xattr.c:1148
 ext4_xattr_delete_inode+0xb04/0xcd0 fs/ext4/xattr.c:2880
 ext4_evict_inode+0xd7c/0x10b0 fs/ext4/inode.c:296
 evict+0x2a4/0x620 fs/inode.c:664
 ext4_orphan_cleanup+0xb60/0x1340 fs/ext4/orphan.c:474
 __ext4_fill_super fs/ext4/super.c:5516 [inline]
 ext4_fill_super+0x81cd/0x8700 fs/ext4/super.c:5644
 get_tree_bdev+0x400/0x620 fs/super.c:1282
 vfs_get_tree+0x88/0x270 fs/super.c:1489
 do_new_mount+0x289/0xad0 fs/namespace.c:3145
 do_mount fs/namespace.c:3488 [inline]
 __do_sys_mount fs/namespace.c:3697 [inline]
 __se_sys_mount+0x2d3/0x3c0 fs/namespace.c:3674
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7fa5406fd5ea
RSP: 002b:00007ffc7232f968 EFLAGS: 00000202 ORIG_RAX: 00000000000000a5
RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fa5406fd5ea
RDX: 0000000020000440 RSI: 0000000020000000 RDI: 00007ffc7232f970
RBP: 00007ffc7232f970 R08: 00007ffc7232f9b0 R09: 0000000000000432
R10: 0000000000804a03 R11: 0000000000000202 R12: 0000000000000004
R13: 0000555556a7a2c0 R14: 00007ffc7232f9b0 R15: 0000000000000000
 </TASK>
==================================================================

The problem is that the inode contains an xattr entry with ea_inum of 15
when cleaning up an orphan inode <15>. When evict inode <15>, the reference
counting of the corresponding EA inode is decreased. When EA inode <15> is
found by find_inode_fast() in __ext4_iget(), it is found that the EA inode
holds the I_FREEING flag and waits for the EA inode to complete deletion.
As a result, when inode <15> is being deleted, we wait for inode <15> to
complete the deletion, resulting in an infinite loop and triggering Hung
Task. To solve this problem, we only need to check whether the ino of EA
inode and parent is the same before getting EA inode.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0f7bfd6f8164be32dbbdf36aa1e5d00485c53cd7
  - https://git.kernel.org/stable/c/1aec41c98cce61d19ce89650895e51b9f3cdef13
  - https://git.kernel.org/stable/c/2c96c52aeaa6fd9163cfacdd98778b4a0398ef18
  - https://git.kernel.org/stable/c/64b72f5e7574020dea62ab733d88a54d903c42a1
  - https://git.kernel.org/stable/c/73f7987fe1b82596f1a380e85cd0097ebaae7e01
  - https://git.kernel.org/stable/c/94fd091576b12540924f6316ebc0678e84cb2800
  - https://git.kernel.org/stable/c/a98160d8f3e6242ca9b7f443f26e7ef3a61ba684
  - https://git.kernel.org/stable/c/efddc7e106fdf8d1f62d45e79de78f63b7c04fba

------------------------------------------------------------

CVE ID: CVE-2023-53090
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Fix an illegal memory access

In the kfd_wait_on_events() function, the kfd_event_waiter structure is
allocated by alloc_event_waiters(), but the event field of the waiter
structure is not initialized; When copy_from_user() fails in the
kfd_wait_on_events() function, it will enter exception handling to
release the previously allocated memory of the waiter structure;
Due to the event field of the waiters structure being accessed
in the free_waiters() function, this results in illegal memory access
and system crash, here is the crash log:

localhost kernel: RIP: 0010:native_queued_spin_lock_slowpath+0x185/0x1e0
localhost kernel: RSP: 0018:ffffaa53c362bd60 EFLAGS: 00010082
localhost kernel: RAX: ff3d3d6bff4007cb RBX: 0000000000000282 RCX: 00000000002c0000
localhost kernel: RDX: ffff9e855eeacb80 RSI: 000000000000279c RDI: ffffe7088f6a21d0
localhost kernel: RBP: ffffe7088f6a21d0 R08: 00000000002c0000 R09: ffffaa53c362be64
localhost kernel: R10: ffffaa53c362bbd8 R11: 0000000000000001 R12: 0000000000000002
localhost kernel: R13: ffff9e7ead15d600 R14: 0000000000000000 R15: ffff9e7ead15d698
localhost kernel: FS:  0000152a3d111700(0000) GS:ffff9e855ee80000(0000) knlGS:0000000000000000
localhost kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
localhost kernel: CR2: 0000152938000010 CR3: 000000044d7a4000 CR4: 00000000003506e0
localhost kernel: Call Trace:
localhost kernel: _raw_spin_lock_irqsave+0x30/0x40
localhost kernel: remove_wait_queue+0x12/0x50
localhost kernel: kfd_wait_on_events+0x1b6/0x490 [hydcu]
localhost kernel: ? ftrace_graph_caller+0xa0/0xa0
localhost kernel: kfd_ioctl+0x38c/0x4a0 [hydcu]
localhost kernel: ? kfd_ioctl_set_trap_handler+0x70/0x70 [hydcu]
localhost kernel: ? kfd_ioctl_create_queue+0x5a0/0x5a0 [hydcu]
localhost kernel: ? ftrace_graph_caller+0xa0/0xa0
localhost kernel: __x64_sys_ioctl+0x8e/0xd0
localhost kernel: ? syscall_trace_enter.isra.18+0x143/0x1b0
localhost kernel: do_syscall_64+0x33/0x80
localhost kernel: entry_SYSCALL_64_after_hwframe+0x44/0xa9
localhost kernel: RIP: 0033:0x152a4dff68d7

Allocate the structure with kcalloc, and remove redundant 0-initialization
and a redundant loop condition check.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2fece63b55c5d74cd6f5de51159e2cde37e10555
  - https://git.kernel.org/stable/c/4fc8fff378b2f2039f2a666d9f8c570f4e58352c
  - https://git.kernel.org/stable/c/5a3fb3b745af0ce46ec2e0c8e507bae45b937334
  - https://git.kernel.org/stable/c/61f306f8df0d5559659c5578cf6d95236bcdcb25
  - https://git.kernel.org/stable/c/6936525142a015e854d0a23e9ad9ea0a28b3843d
  - https://git.kernel.org/stable/c/bbf5eada4334a96e3a204b2307ff5b14dc380b0b
  - https://git.kernel.org/stable/c/d9923e7214a870b312bf61f6a89c7554d0966985

------------------------------------------------------------

CVE ID: CVE-2023-53091
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: update s_journal_inum if it changes after journal replay

When mounting a crafted ext4 image, s_journal_inum may change after journal
replay, which is obviously unreasonable because we have successfully loaded
and replayed the journal through the old s_journal_inum. And the new
s_journal_inum bypasses some of the checks in ext4_get_journal(), which
may trigger a null pointer dereference problem. So if s_journal_inum
changes after the journal replay, we ignore the change, and rewrite the
current journal_inum to the superblock.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3039d8b8692408438a618fac2776b629852663c3
  - https://git.kernel.org/stable/c/499fef2030fb754c68b1c7cb3a799a3bc1d0d925
  - https://git.kernel.org/stable/c/70e66bdeae4d0f7c8e87762f425b68aedd5e8955
  - https://git.kernel.org/stable/c/ee0c5277d4fab920bd31345c49e193ecede9ecef

------------------------------------------------------------

CVE ID: CVE-2023-53092
Description: In the Linux kernel, the following vulnerability has been resolved:

interconnect: exynos: fix node leak in probe PM QoS error path

Make sure to add the newly allocated interconnect node to the provider
before adding the PM QoS request so that the node is freed on errors.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3aab264875bf3c915ea2517fae1eec213e0b4987
  - https://git.kernel.org/stable/c/b71dd43bd49bd68186c1d19dbeedee219e003149
  - https://git.kernel.org/stable/c/c479e4ac4a3d1485a48599e66ce46547c1367828
  - https://git.kernel.org/stable/c/fd4738ae1a0c216d25360a98e835967b06d6a253

------------------------------------------------------------

CVE ID: CVE-2023-53093
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: Do not let histogram values have some modifiers

Histogram values can not be strings, stacktraces, graphs, symbols,
syscalls, or grouped in buckets or log. Give an error if a value is set to
do so.

Note, the histogram code was not prepared to handle these modifiers for
histograms and caused a bug.

Mark Rutland reported:

 # echo 'p:copy_to_user __arch_copy_to_user n=$arg2' >> /sys/kernel/tracing/kprobe_events
 # echo 'hist:keys=n:vals=hitcount.buckets=8:sort=hitcount' > /sys/kernel/tracing/events/kprobes/copy_to_user/trigger
 # cat /sys/kernel/tracing/events/kprobes/copy_to_user/hist
[  143.694628] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
[  143.695190] Mem abort info:
[  143.695362]   ESR = 0x0000000096000004
[  143.695604]   EC = 0x25: DABT (current EL), IL = 32 bits
[  143.695889]   SET = 0, FnV = 0
[  143.696077]   EA = 0, S1PTW = 0
[  143.696302]   FSC = 0x04: level 0 translation fault
[  143.702381] Data abort info:
[  143.702614]   ISV = 0, ISS = 0x00000004
[  143.702832]   CM = 0, WnR = 0
[  143.703087] user pgtable: 4k pages, 48-bit VAs, pgdp=00000000448f9000
[  143.703407] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000
[  143.704137] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
[  143.704714] Modules linked in:
[  143.705273] CPU: 0 PID: 133 Comm: cat Not tainted 6.2.0-00003-g6fc512c10a7c #3
[  143.706138] Hardware name: linux,dummy-virt (DT)
[  143.706723] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[  143.707120] pc : hist_field_name.part.0+0x14/0x140
[  143.707504] lr : hist_field_name.part.0+0x104/0x140
[  143.707774] sp : ffff800008333a30
[  143.707952] x29: ffff800008333a30 x28: 0000000000000001 x27: 0000000000400cc0
[  143.708429] x26: ffffd7a653b20260 x25: 0000000000000000 x24: ffff10d303ee5800
[  143.708776] x23: ffffd7a6539b27b0 x22: ffff10d303fb8c00 x21: 0000000000000001
[  143.709127] x20: ffff10d303ec2000 x19: 0000000000000000 x18: 0000000000000000
[  143.709478] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
[  143.709824] x14: 0000000000000000 x13: 203a6f666e692072 x12: 6567676972742023
[  143.710179] x11: 0a230a6d6172676f x10: 000000000000002c x9 : ffffd7a6521e018c
[  143.710584] x8 : 000000000000002c x7 : 7f7f7f7f7f7f7f7f x6 : 000000000000002c
[  143.710915] x5 : ffff10d303b0103e x4 : ffffd7a653b20261 x3 : 000000000000003d
[  143.711239] x2 : 0000000000020001 x1 : 0000000000000001 x0 : 0000000000000000
[  143.711746] Call trace:
[  143.712115]  hist_field_name.part.0+0x14/0x140
[  143.712642]  hist_field_name.part.0+0x104/0x140
[  143.712925]  hist_field_print+0x28/0x140
[  143.713125]  event_hist_trigger_print+0x174/0x4d0
[  143.713348]  hist_show+0xf8/0x980
[  143.713521]  seq_read_iter+0x1bc/0x4b0
[  143.713711]  seq_read+0x8c/0xc4
[  143.713876]  vfs_read+0xc8/0x2a4
[  143.714043]  ksys_read+0x70/0xfc
[  143.714218]  __arm64_sys_read+0x24/0x30
[  143.714400]  invoke_syscall+0x50/0x120
[  143.714587]  el0_svc_common.constprop.0+0x4c/0x100
[  143.714807]  do_el0_svc+0x44/0xd0
[  143.714970]  el0_svc+0x2c/0x84
[  143.715134]  el0t_64_sync_handler+0xbc/0x140
[  143.715334]  el0t_64_sync+0x190/0x194
[  143.715742] Code: a9bd7bfd 910003fd a90153f3 aa0003f3 (f9400000)
[  143.716510] ---[ end trace 0000000000000000 ]---
Segmentation fault
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2fc0ee435c9264cdb7c5e872f76cd9bb97640227
  - https://git.kernel.org/stable/c/39cd75f2f3a43c0e2f95749eb6dd6420c553f87d
  - https://git.kernel.org/stable/c/e0213434fe3e4a0d118923dc98d31e7ff1cd9e45

------------------------------------------------------------

CVE ID: CVE-2023-53094
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: serial: fsl_lpuart: fix race on RX DMA shutdown

From time to time DMA completion can come in the middle of DMA shutdown:

<process ctx>:				<IRQ>:
lpuart32_shutdown()
  lpuart_dma_shutdown()
    del_timer_sync()
					lpuart_dma_rx_complete()
					  lpuart_copy_rx_to_tty()
					    mod_timer()
    lpuart_dma_rx_free()

When the timer fires a bit later, sport->dma_rx_desc is NULL:

Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
pc : lpuart_copy_rx_to_tty+0xcc/0x5bc
lr : lpuart_timer_func+0x1c/0x2c
Call trace:
 lpuart_copy_rx_to_tty
 lpuart_timer_func
 call_timer_fn
 __run_timers.part.0
 run_timer_softirq
 __do_softirq
 __irq_exit_rcu
 irq_exit
 handle_domain_irq
 gic_handle_irq
 call_on_irq_stack
 do_interrupt_handler
 ...

To fix this fold del_timer_sync() into lpuart_dma_rx_free() after
dmaengine_terminate_sync() to make sure timer will not be re-started in
lpuart_copy_rx_to_tty() <= lpuart_dma_rx_complete().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/19a98d56dfedafb25652bdb9cd48a4e73ceba702
  - https://git.kernel.org/stable/c/1be6f2b15f902c02e055ae0b419ca789200473c9
  - https://git.kernel.org/stable/c/2a36b444cace9580380467fd1183bb5e85bcc80a
  - https://git.kernel.org/stable/c/90530e7214c8a04dcdde57502d93fa96af288c38
  - https://git.kernel.org/stable/c/954fc9931f0aabf272b5674cf468affdd88d3a36

------------------------------------------------------------

CVE ID: CVE-2023-53095
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/ttm: Fix a NULL pointer dereference

The LRU mechanism may look up a resource in the process of being removed
from an object. The locking rules here are a bit unclear but it looks
currently like res->bo assignment is protected by the LRU lock, whereas
bo->resource is protected by the object lock, while *clearing* of
bo->resource is also protected by the LRU lock. This means that if
we check that bo->resource points to the LRU resource under the LRU
lock we should be safe.
So perform that check before deciding to swap out a bo. That avoids
dereferencing a NULL bo->resource in ttm_bo_swapout().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9a9a8fe26751334b7739193a94eba741073b8a55
  - https://git.kernel.org/stable/c/9ba1720f6c4a0f13c3f3cb5c28132ee75555d04f
  - https://git.kernel.org/stable/c/9d9b1f9f7a72d83ebf173534e76b246349f32374

------------------------------------------------------------

CVE ID: CVE-2023-53096
Description: In the Linux kernel, the following vulnerability has been resolved:

interconnect: fix mem leak when freeing nodes

The node link array is allocated when adding links to a node but is not
deallocated when nodes are destroyed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2e0b13a1827229a02abef97b50ffaf89ba25370a
  - https://git.kernel.org/stable/c/3167306455d0fbbbcf08cb25651acc527a86a95e
  - https://git.kernel.org/stable/c/a5904f415e1af72fa8fe6665aa4f554dc2099a95
  - https://git.kernel.org/stable/c/c1722e4113281fb34e5b4fb5c5387b17cd39a537
  - https://git.kernel.org/stable/c/efae80ca13faa94457208852825731da44a788ad
  - https://git.kernel.org/stable/c/f1e3a20c60196c37a402c584d0c9de306ba988ce

------------------------------------------------------------

CVE ID: CVE-2023-53097
Description: In the Linux kernel, the following vulnerability has been resolved:

powerpc/iommu: fix memory leak with using debugfs_lookup()

When calling debugfs_lookup() the result must have dput() called on it,
otherwise the memory will leak over time.  To make things simpler, just
call debugfs_lookup_and_remove() instead which handles all of the logic
at once.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/24c1bd1cd0d1ff821fd7d2f01a1e648c7882dfc2
  - https://git.kernel.org/stable/c/4050498c0ae3946c223fc63e9dd7b878b76611e0
  - https://git.kernel.org/stable/c/b505063910c134778202dfad9332dfcecb76bab3
  - https://git.kernel.org/stable/c/e3a62a35f903fd8be5b44542fe3901ec45f16757

------------------------------------------------------------

CVE ID: CVE-2023-53098
Description: In the Linux kernel, the following vulnerability has been resolved:

media: rc: gpio-ir-recv: add remove function

In case runtime PM is enabled, do runtime PM clean up to remove
cpu latency qos request, otherwise driver removal may have below
kernel dump:

[   19.463299] Unable to handle kernel NULL pointer dereference at
virtual address 0000000000000048
[   19.472161] Mem abort info:
[   19.474985]   ESR = 0x0000000096000004
[   19.478754]   EC = 0x25: DABT (current EL), IL = 32 bits
[   19.484081]   SET = 0, FnV = 0
[   19.487149]   EA = 0, S1PTW = 0
[   19.490361]   FSC = 0x04: level 0 translation fault
[   19.495256] Data abort info:
[   19.498149]   ISV = 0, ISS = 0x00000004
[   19.501997]   CM = 0, WnR = 0
[   19.504977] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000049f81000
[   19.511432] [0000000000000048] pgd=0000000000000000,
p4d=0000000000000000
[   19.518245] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
[   19.524520] Modules linked in: gpio_ir_recv(+) rc_core [last
unloaded: rc_core]
[   19.531845] CPU: 0 PID: 445 Comm: insmod Not tainted
6.2.0-rc1-00028-g2c397a46d47c #72
[   19.531854] Hardware name: FSL i.MX8MM EVK board (DT)
[   19.531859] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS
BTYPE=--)
[   19.551777] pc : cpu_latency_qos_remove_request+0x20/0x110
[   19.557277] lr : gpio_ir_recv_runtime_suspend+0x18/0x30
[gpio_ir_recv]
[   19.557294] sp : ffff800008ce3740
[   19.557297] x29: ffff800008ce3740 x28: 0000000000000000 x27:
ffff800008ce3d50
[   19.574270] x26: ffffc7e3e9cea100 x25: 00000000000f4240 x24:
ffffc7e3f9ef0e30
[   19.574284] x23: 0000000000000000 x22: ffff0061803820f4 x21:
0000000000000008
[   19.574296] x20: ffffc7e3fa75df30 x19: 0000000000000020 x18:
ffffffffffffffff
[   19.588570] x17: 0000000000000000 x16: ffffc7e3f9efab70 x15:
ffffffffffffffff
[   19.595712] x14: ffff800008ce37b8 x13: ffff800008ce37aa x12:
0000000000000001
[   19.602853] x11: 0000000000000001 x10: ffffcbe3ec0dff87 x9 :
0000000000000008
[   19.609991] x8 : 0101010101010101 x7 : 0000000000000000 x6 :
000000000f0bfe9f
[   19.624261] x5 : 00ffffffffffffff x4 : 0025ab8e00000000 x3 :
ffff006180382010
[   19.631405] x2 : ffffc7e3e9ce8030 x1 : ffffc7e3fc3eb810 x0 :
0000000000000020
[   19.638548] Call trace:
[   19.640995]  cpu_latency_qos_remove_request+0x20/0x110
[   19.646142]  gpio_ir_recv_runtime_suspend+0x18/0x30 [gpio_ir_recv]
[   19.652339]  pm_generic_runtime_suspend+0x2c/0x44
[   19.657055]  __rpm_callback+0x48/0x1dc
[   19.660807]  rpm_callback+0x6c/0x80
[   19.664301]  rpm_suspend+0x10c/0x640
[   19.667880]  rpm_idle+0x250/0x2d0
[   19.671198]  update_autosuspend+0x38/0xe0
[   19.675213]  pm_runtime_set_autosuspend_delay+0x40/0x60
[   19.680442]  gpio_ir_recv_probe+0x1b4/0x21c [gpio_ir_recv]
[   19.685941]  platform_probe+0x68/0xc0
[   19.689610]  really_probe+0xc0/0x3dc
[   19.693189]  __driver_probe_device+0x7c/0x190
[   19.697550]  driver_probe_device+0x3c/0x110
[   19.701739]  __driver_attach+0xf4/0x200
[   19.705578]  bus_for_each_dev+0x70/0xd0
[   19.709417]  driver_attach+0x24/0x30
[   19.712998]  bus_add_driver+0x17c/0x240
[   19.716834]  driver_register+0x78/0x130
[   19.720676]  __platform_driver_register+0x28/0x34
[   19.725386]  gpio_ir_recv_driver_init+0x20/0x1000 [gpio_ir_recv]
[   19.731404]  do_one_initcall+0x44/0x2ac
[   19.735243]  do_init_module+0x48/0x1d0
[   19.739003]  load_module+0x19fc/0x2034
[   19.742759]  __do_sys_finit_module+0xac/0x12c
[   19.747124]  __arm64_sys_finit_module+0x20/0x30
[   19.751664]  invoke_syscall+0x48/0x114
[   19.755420]  el0_svc_common.constprop.0+0xcc/0xec
[   19.760132]  do_el0_svc+0x38/0xb0
[   19.763456]  el0_svc+0x2c/0x84
[   19.766516]  el0t_64_sync_handler+0xf4/0x120
[   19.770789]  el0t_64_sync+0x190/0x194
[   19.774460] Code: 910003fd a90153f3 aa0003f3 91204021 (f9401400)
[   19.780556] ---[ end trace 0000000000000000 ]---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/00e81f191bc00cb6faabf468960e96ebf0404a6c
  - https://git.kernel.org/stable/c/2ece4d2f7eac1cb51dc0e9859e09bfdb00faa28e
  - https://git.kernel.org/stable/c/30040818b338b8ebc956ce0ebd198f8d593586a6
  - https://git.kernel.org/stable/c/513572bb89e8075f5d2a2bb4c89f1152e44da9d8
  - https://git.kernel.org/stable/c/a5c140d88a69eb43de2a030f1d7ff7b16bff3b1a

------------------------------------------------------------

CVE ID: CVE-2023-53099
Description: In the Linux kernel, the following vulnerability has been resolved:

firmware: xilinx: don't make a sleepable memory allocation from an atomic context

The following issue was discovered using lockdep:
[    6.691371] BUG: sleeping function called from invalid context at include/linux/sched/mm.h:209
[    6.694602] in_atomic(): 1, irqs_disabled(): 128, non_block: 0, pid: 1, name: swapper/0
[    6.702431] 2 locks held by swapper/0/1:
[    6.706300]  #0: ffffff8800f6f188 (&dev->mutex){....}-{3:3}, at: __device_driver_lock+0x4c/0x90
[    6.714900]  #1: ffffffc009a2abb8 (enable_lock){....}-{2:2}, at: clk_enable_lock+0x4c/0x140
[    6.723156] irq event stamp: 304030
[    6.726596] hardirqs last  enabled at (304029): [<ffffffc008d17ee0>] _raw_spin_unlock_irqrestore+0xc0/0xd0
[    6.736142] hardirqs last disabled at (304030): [<ffffffc00876bc5c>] clk_enable_lock+0xfc/0x140
[    6.744742] softirqs last  enabled at (303958): [<ffffffc0080904f0>] _stext+0x4f0/0x894
[    6.752655] softirqs last disabled at (303951): [<ffffffc0080e53b8>] irq_exit+0x238/0x280
[    6.760744] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G     U            5.15.36 #2
[    6.768048] Hardware name: xlnx,zynqmp (DT)
[    6.772179] Call trace:
[    6.774584]  dump_backtrace+0x0/0x300
[    6.778197]  show_stack+0x18/0x30
[    6.781465]  dump_stack_lvl+0xb8/0xec
[    6.785077]  dump_stack+0x1c/0x38
[    6.788345]  ___might_sleep+0x1a8/0x2a0
[    6.792129]  __might_sleep+0x6c/0xd0
[    6.795655]  kmem_cache_alloc_trace+0x270/0x3d0
[    6.800127]  do_feature_check_call+0x100/0x220
[    6.804513]  zynqmp_pm_invoke_fn+0x8c/0xb0
[    6.808555]  zynqmp_pm_clock_getstate+0x90/0xe0
[    6.813027]  zynqmp_pll_is_enabled+0x8c/0x120
[    6.817327]  zynqmp_pll_enable+0x38/0xc0
[    6.821197]  clk_core_enable+0x144/0x400
[    6.825067]  clk_core_enable+0xd4/0x400
[    6.828851]  clk_core_enable+0xd4/0x400
[    6.832635]  clk_core_enable+0xd4/0x400
[    6.836419]  clk_core_enable+0xd4/0x400
[    6.840203]  clk_core_enable+0xd4/0x400
[    6.843987]  clk_core_enable+0xd4/0x400
[    6.847771]  clk_core_enable+0xd4/0x400
[    6.851555]  clk_core_enable_lock+0x24/0x50
[    6.855683]  clk_enable+0x24/0x40
[    6.858952]  fclk_probe+0x84/0xf0
[    6.862220]  platform_probe+0x8c/0x110
[    6.865918]  really_probe+0x110/0x5f0
[    6.869530]  __driver_probe_device+0xcc/0x210
[    6.873830]  driver_probe_device+0x64/0x140
[    6.877958]  __driver_attach+0x114/0x1f0
[    6.881828]  bus_for_each_dev+0xe8/0x160
[    6.885698]  driver_attach+0x34/0x50
[    6.889224]  bus_add_driver+0x228/0x300
[    6.893008]  driver_register+0xc0/0x1e0
[    6.896792]  __platform_driver_register+0x44/0x60
[    6.901436]  fclk_driver_init+0x1c/0x28
[    6.905220]  do_one_initcall+0x104/0x590
[    6.909091]  kernel_init_freeable+0x254/0x2bc
[    6.913390]  kernel_init+0x24/0x130
[    6.916831]  ret_from_fork+0x10/0x20

Fix it by passing the GFP_ATOMIC gfp flag for the corresponding
memory allocation.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/162049c31eb64308afa22e341a257a723526eb5c
  - https://git.kernel.org/stable/c/38ed310c22e7a0fc978b1f8292136a4a4a8b3051
  - https://git.kernel.org/stable/c/86afb633beaa02ee95b5126a14c9f22cfade4fd9
  - https://git.kernel.org/stable/c/9bbab2843f2d1337a268499a1c02b435d2985a17
  - https://git.kernel.org/stable/c/b37d3ccbd549494890672136a0e623eb010d46a7

------------------------------------------------------------

CVE ID: CVE-2023-53100
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix WARNING in ext4_update_inline_data

Syzbot found the following issue:
EXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 without journal. Quota mode: none.
fscrypt: AES-256-CTS-CBC using implementation "cts-cbc-aes-aesni"
fscrypt: AES-256-XTS using implementation "xts-aes-aesni"
------------[ cut here ]------------
WARNING: CPU: 0 PID: 5071 at mm/page_alloc.c:5525 __alloc_pages+0x30a/0x560 mm/page_alloc.c:5525
Modules linked in:
CPU: 1 PID: 5071 Comm: syz-executor263 Not tainted 6.2.0-rc1-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
RIP: 0010:__alloc_pages+0x30a/0x560 mm/page_alloc.c:5525
RSP: 0018:ffffc90003c2f1c0 EFLAGS: 00010246
RAX: ffffc90003c2f220 RBX: 0000000000000014 RCX: 0000000000000000
RDX: 0000000000000028 RSI: 0000000000000000 RDI: ffffc90003c2f248
RBP: ffffc90003c2f2d8 R08: dffffc0000000000 R09: ffffc90003c2f220
R10: fffff52000785e49 R11: 1ffff92000785e44 R12: 0000000000040d40
R13: 1ffff92000785e40 R14: dffffc0000000000 R15: 1ffff92000785e3c
FS:  0000555556c0d300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f95d5e04138 CR3: 00000000793aa000 CR4: 00000000003506f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 __alloc_pages_node include/linux/gfp.h:237 [inline]
 alloc_pages_node include/linux/gfp.h:260 [inline]
 __kmalloc_large_node+0x95/0x1e0 mm/slab_common.c:1113
 __do_kmalloc_node mm/slab_common.c:956 [inline]
 __kmalloc+0xfe/0x190 mm/slab_common.c:981
 kmalloc include/linux/slab.h:584 [inline]
 kzalloc include/linux/slab.h:720 [inline]
 ext4_update_inline_data+0x236/0x6b0 fs/ext4/inline.c:346
 ext4_update_inline_dir fs/ext4/inline.c:1115 [inline]
 ext4_try_add_inline_entry+0x328/0x990 fs/ext4/inline.c:1307
 ext4_add_entry+0x5a4/0xeb0 fs/ext4/namei.c:2385
 ext4_add_nondir+0x96/0x260 fs/ext4/namei.c:2772
 ext4_create+0x36c/0x560 fs/ext4/namei.c:2817
 lookup_open fs/namei.c:3413 [inline]
 open_last_lookups fs/namei.c:3481 [inline]
 path_openat+0x12ac/0x2dd0 fs/namei.c:3711
 do_filp_open+0x264/0x4f0 fs/namei.c:3741
 do_sys_openat2+0x124/0x4e0 fs/open.c:1310
 do_sys_open fs/open.c:1326 [inline]
 __do_sys_openat fs/open.c:1342 [inline]
 __se_sys_openat fs/open.c:1337 [inline]
 __x64_sys_openat+0x243/0x290 fs/open.c:1337
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd

Above issue happens as follows:
ext4_iget
   ext4_find_inline_data_nolock ->i_inline_off=164 i_inline_size=60
ext4_try_add_inline_entry
   __ext4_mark_inode_dirty
      ext4_expand_extra_isize_ea ->i_extra_isize=32 s_want_extra_isize=44
         ext4_xattr_shift_entries
	 ->after shift i_inline_off is incorrect, actually is change to 176
ext4_try_add_inline_entry
  ext4_update_inline_dir
    get_max_inline_xattr_value_size
      if (EXT4_I(inode)->i_inline_off)
	entry = (struct ext4_xattr_entry *)((void *)raw_inode +
			EXT4_I(inode)->i_inline_off);
        free += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));
	->As entry is incorrect, then 'free' may be negative
   ext4_update_inline_data
      value = kzalloc(len, GFP_NOFS);
      -> len is unsigned int, maybe very large, then trigger warning when
         'kzalloc()'

To resolve the above issue we need to update 'i_inline_off' after
'ext4_xattr_shift_entries()'.  We do not need to set
EXT4_STATE_MAY_INLINE_DATA flag here, since ext4_mark_inode_dirty()
already sets this flag if needed.  Setting EXT4_STATE_MAY_INLINE_DATA
when it is needed may trigger a BUG_ON in ext4_writepages().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2b96b4a5d9443ca4cad58b0040be455803c05a42
  - https://git.kernel.org/stable/c/35161cec76772f74526f5886ad4082ec48511d5c
  - https://git.kernel.org/stable/c/39c5df2ca544368b44b59d0f6d80131e90763371
  - https://git.kernel.org/stable/c/74d775083e9f3d9dadf9e3b5f3e0028d1ad0bd5c
  - https://git.kernel.org/stable/c/92eee6a82a9a6f9f83559e17a2b6b935e1a5cd25
  - https://git.kernel.org/stable/c/a9bd94f67b27739bbe8583c52256502bd4cc7e83
  - https://git.kernel.org/stable/c/c5aa102b433b1890e1ccaa40c06826c77dda1665
  - https://git.kernel.org/stable/c/ca500cf2eceb5a8e93bf71ab97b5f7a18ecabce2

------------------------------------------------------------

CVE ID: CVE-2023-53101
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: zero i_disksize when initializing the bootloader inode

If the boot loader inode has never been used before, the
EXT4_IOC_SWAP_BOOT inode will initialize it, including setting the
i_size to 0.  However, if the "never before used" boot loader has a
non-zero i_size, then i_disksize will be non-zero, and the
inconsistency between i_size and i_disksize can trigger a kernel
warning:

 WARNING: CPU: 0 PID: 2580 at fs/ext4/file.c:319
 CPU: 0 PID: 2580 Comm: bb Not tainted 6.3.0-rc1-00004-g703695902cfa
 RIP: 0010:ext4_file_write_iter+0xbc7/0xd10
 Call Trace:
  vfs_write+0x3b1/0x5c0
  ksys_write+0x77/0x160
  __x64_sys_write+0x22/0x30
  do_syscall_64+0x39/0x80

Reproducer:
 1. create corrupted image and mount it:
       mke2fs -t ext4 /tmp/foo.img 200
       debugfs -wR "sif <5> size 25700" /tmp/foo.img
       mount -t ext4 /tmp/foo.img /mnt
       cd /mnt
       echo 123 > file
 2. Run the reproducer program:
       posix_memalign(&buf, 1024, 1024)
       fd = open("file", O_RDWR | O_DIRECT);
       ioctl(fd, EXT4_IOC_SWAP_BOOT);
       write(fd, buf, 1024);

Fix this by setting i_disksize as well as i_size to zero when
initiaizing the boot loader inode.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01a821aacc64d4b05dafd239dbc9b7856686002f
  - https://git.kernel.org/stable/c/0d8a6c9a6415999fee1259ccf1796480c026b7d6
  - https://git.kernel.org/stable/c/3f00c476da8fe7c4c34ea16abb55d74127120413
  - https://git.kernel.org/stable/c/59eee0cdf8c036f554add97a4da7c06d7a9ff34a
  - https://git.kernel.org/stable/c/9cb27b1e76f0cc886ac09055bc41c0ab3f205167
  - https://git.kernel.org/stable/c/9e9a4cc5486356158554f6ad73027d8635a48b34
  - https://git.kernel.org/stable/c/d6c1447e483c05dbcfb3ff77ac04237a82070b8c
  - https://git.kernel.org/stable/c/f5361da1e60d54ec81346aee8e3d8baf1be0b762

------------------------------------------------------------

CVE ID: CVE-2023-53102
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: xsk: disable txq irq before flushing hw

ice_qp_dis() intends to stop a given queue pair that is a target of xsk
pool attach/detach. One of the steps is to disable interrupts on these
queues. It currently is broken in a way that txq irq is turned off
*after* HW flush which in turn takes no effect.

ice_qp_dis():
-> ice_qvec_dis_irq()
--> disable rxq irq
--> flush hw
-> ice_vsi_stop_tx_ring()
-->disable txq irq

Below splat can be triggered by following steps:
- start xdpsock WITHOUT loading xdp prog
- run xdp_rxq_info with XDP_TX action on this interface
- start traffic
- terminate xdpsock

[  256.312485] BUG: kernel NULL pointer dereference, address: 0000000000000018
[  256.319560] #PF: supervisor read access in kernel mode
[  256.324775] #PF: error_code(0x0000) - not-present page
[  256.329994] PGD 0 P4D 0
[  256.332574] Oops: 0000 [#1] PREEMPT SMP NOPTI
[  256.337006] CPU: 3 PID: 32 Comm: ksoftirqd/3 Tainted: G           OE      6.2.0-rc5+ #51
[  256.345218] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019
[  256.355807] RIP: 0010:ice_clean_rx_irq_zc+0x9c/0x7d0 [ice]
[  256.361423] Code: b7 8f 8a 00 00 00 66 39 ca 0f 84 f1 04 00 00 49 8b 47 40 4c 8b 24 d0 41 0f b7 45 04 66 25 ff 3f 66 89 04 24 0f 84 85 02 00 00 <49> 8b 44 24 18 0f b7 14 24 48 05 00 01 00 00 49 89 04 24 49 89 44
[  256.380463] RSP: 0018:ffffc900088bfd20 EFLAGS: 00010206
[  256.385765] RAX: 000000000000003c RBX: 0000000000000035 RCX: 000000000000067f
[  256.393012] RDX: 0000000000000775 RSI: 0000000000000000 RDI: ffff8881deb3ac80
[  256.400256] RBP: 000000000000003c R08: ffff889847982710 R09: 0000000000010000
[  256.407500] R10: ffffffff82c060c0 R11: 0000000000000004 R12: 0000000000000000
[  256.414746] R13: ffff88811165eea0 R14: ffffc9000d255000 R15: ffff888119b37600
[  256.421990] FS:  0000000000000000(0000) GS:ffff8897e0cc0000(0000) knlGS:0000000000000000
[  256.430207] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  256.436036] CR2: 0000000000000018 CR3: 0000000005c0a006 CR4: 00000000007706e0
[  256.443283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  256.450527] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[  256.457770] PKRU: 55555554
[  256.460529] Call Trace:
[  256.463015]  <TASK>
[  256.465157]  ? ice_xmit_zc+0x6e/0x150 [ice]
[  256.469437]  ice_napi_poll+0x46d/0x680 [ice]
[  256.473815]  ? _raw_spin_unlock_irqrestore+0x1b/0x40
[  256.478863]  __napi_poll+0x29/0x160
[  256.482409]  net_rx_action+0x136/0x260
[  256.486222]  __do_softirq+0xe8/0x2e5
[  256.489853]  ? smpboot_thread_fn+0x2c/0x270
[  256.494108]  run_ksoftirqd+0x2a/0x50
[  256.497747]  smpboot_thread_fn+0x1c1/0x270
[  256.501907]  ? __pfx_smpboot_thread_fn+0x10/0x10
[  256.506594]  kthread+0xea/0x120
[  256.509785]  ? __pfx_kthread+0x10/0x10
[  256.513597]  ret_from_fork+0x29/0x50
[  256.517238]  </TASK>

In fact, irqs were not disabled and napi managed to be scheduled and run
while xsk_pool pointer was still valid, but SW ring of xdp_buff pointers
was already freed.

To fix this, call ice_qvec_dis_irq() after ice_vsi_stop_tx_ring(). Also
while at it, remove redundant ice_clean_rx_ring() call - this is handled
in ice_qp_clean_rings().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/243cde8de10894d7812c8a6b62653bf04d8f9700
  - https://git.kernel.org/stable/c/2ecc6e44959382f95c9d427cd8da85121a9cecda
  - https://git.kernel.org/stable/c/b830c9642386867863ac64295185f896ff2928ac
  - https://git.kernel.org/stable/c/b89a453c6918e0f346fb0562e8c7812b94d28c73
  - https://git.kernel.org/stable/c/cccba1ff0798a27f7b8d0c06762ef977400a2afb

------------------------------------------------------------

CVE ID: CVE-2023-53103
Description: In the Linux kernel, the following vulnerability has been resolved:

bonding: restore bond's IFF_SLAVE flag if a non-eth dev enslave fails

syzbot reported a warning[1] where the bond device itself is a slave and
we try to enslave a non-ethernet device as the first slave which fails
but then in the error path when ether_setup() restores the bond device
it also clears all flags. In my previous fix[2] I restored the
IFF_MASTER flag, but I didn't consider the case that the bond device
itself might also be a slave with IFF_SLAVE set, so we need to restore
that flag as well. Use the bond_ether_setup helper which does the right
thing and restores the bond's flags properly.

Steps to reproduce using a nlmon dev:
 $ ip l add nlmon0 type nlmon
 $ ip l add bond1 type bond
 $ ip l add bond2 type bond
 $ ip l set bond1 master bond2
 $ ip l set dev nlmon0 master bond1
 $ ip -d l sh dev bond1
 22: bond1: <BROADCAST,MULTICAST,MASTER> mtu 1500 qdisc noqueue master bond2 state DOWN mode DEFAULT group default qlen 1000
 (now bond1's IFF_SLAVE flag is gone and we'll hit a warning[3] if we
  try to delete it)

[1] https://syzkaller.appspot.com/bug?id=391c7b1f6522182899efba27d891f1743e8eb3ef
[2] commit 7d5cd2ce5292 ("bonding: correctly handle bonding type change on enslave failure")
[3] example warning:
 [   27.008664] bond1: (slave nlmon0): The slave device specified does not support setting the MAC address
 [   27.008692] bond1: (slave nlmon0): Error -95 calling set_mac_address
 [   32.464639] bond1 (unregistering): Released all slaves
 [   32.464685] ------------[ cut here ]------------
 [   32.464686] WARNING: CPU: 1 PID: 2004 at net/core/dev.c:10829 unregister_netdevice_many+0x72a/0x780
 [   32.464694] Modules linked in: br_netfilter bridge bonding virtio_net
 [   32.464699] CPU: 1 PID: 2004 Comm: ip Kdump: loaded Not tainted 5.18.0-rc3+ #47
 [   32.464703] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014
 [   32.464704] RIP: 0010:unregister_netdevice_many+0x72a/0x780
 [   32.464707] Code: 99 fd ff ff ba 90 1a 00 00 48 c7 c6 f4 02 66 96 48 c7 c7 20 4d 35 96 c6 05 fa c7 2b 02 01 e8 be 6f 4a 00 0f 0b e9 73 fd ff ff <0f> 0b e9 5f fd ff ff 80 3d e3 c7 2b 02 00 0f 85 3b fd ff ff ba 59
 [   32.464710] RSP: 0018:ffffa006422d7820 EFLAGS: 00010206
 [   32.464712] RAX: ffff8f6e077140a0 RBX: ffffa006422d7888 RCX: 0000000000000000
 [   32.464714] RDX: ffff8f6e12edbe58 RSI: 0000000000000296 RDI: ffffffff96d4a520
 [   32.464716] RBP: ffff8f6e07714000 R08: ffffffff96d63600 R09: ffffa006422d7728
 [   32.464717] R10: 0000000000000ec0 R11: ffffffff9698c988 R12: ffff8f6e12edb140
 [   32.464719] R13: dead000000000122 R14: dead000000000100 R15: ffff8f6e12edb140
 [   32.464723] FS:  00007f297c2f1740(0000) GS:ffff8f6e5d900000(0000) knlGS:0000000000000000
 [   32.464725] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 [   32.464726] CR2: 00007f297bf1c800 CR3: 00000000115e8000 CR4: 0000000000350ee0
 [   32.464730] Call Trace:
 [   32.464763]  <TASK>
 [   32.464767]  rtnl_dellink+0x13e/0x380
 [   32.464776]  ? cred_has_capability.isra.0+0x68/0x100
 [   32.464780]  ? __rtnl_unlock+0x33/0x60
 [   32.464783]  ? bpf_lsm_capset+0x10/0x10
 [   32.464786]  ? security_capable+0x36/0x50
 [   32.464790]  rtnetlink_rcv_msg+0x14e/0x3b0
 [   32.464792]  ? _copy_to_iter+0xb1/0x790
 [   32.464796]  ? post_alloc_hook+0xa0/0x160
 [   32.464799]  ? rtnl_calcit.isra.0+0x110/0x110
 [   32.464802]  netlink_rcv_skb+0x50/0xf0
 [   32.464806]  netlink_unicast+0x216/0x340
 [   32.464809]  netlink_sendmsg+0x23f/0x480
 [   32.464812]  sock_sendmsg+0x5e/0x60
 [   32.464815]  ____sys_sendmsg+0x22c/0x270
 [   32.464818]  ? import_iovec+0x17/0x20
 [   32.464821]  ? sendmsg_copy_msghdr+0x59/0x90
 [   32.464823]  ? do_set_pte+0xa0/0xe0
 [   32.464828]  ___sys_sendmsg+0x81/0xc0
 [   32.464832]  ? mod_objcg_state+0xc6/0x300
 [   32.464835]  ? refill_obj_stock+0xa9/0x160
 [   32.464838]  ? memcg_slab_free_hook+0x1a5/0x1f0
 [   32.464842]  __sys_sendm
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0276813b8ab08d9bf5ca4159f301d0829ecf13fc
  - https://git.kernel.org/stable/c/93c8cbeb1b2b8ff670b3dfd01b3abd843995c80f
  - https://git.kernel.org/stable/c/e667d469098671261d558be0cd93dca4d285ce1e
  - https://git.kernel.org/stable/c/ecb1b5135bd3f232d5335b3935e2c2ac11bfa02f

------------------------------------------------------------

CVE ID: CVE-2023-53105
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: Fix cleanup null-ptr deref on encap lock

During module is unloaded while a peer tc flow is still offloaded,
first the peer uplink rep profile is changed to a nic profile, and so
neigh encap lock is destroyed. Next during unload, the VF reps netdevs
are unregistered which causes the original non-peer tc flow to be deleted,
which deletes the peer flow. The peer flow deletion detaches the encap
entry and try to take the already destroyed encap lock, causing the
below trace.

Fix this by clearing peer flows during tc eswitch cleanup
(mlx5e_tc_esw_cleanup()).

Relevant trace:
[ 4316.837128] BUG: kernel NULL pointer dereference, address: 00000000000001d8
[ 4316.842239] RIP: 0010:__mutex_lock+0xb5/0xc40
[ 4316.851897] Call Trace:
[ 4316.852481]  <TASK>
[ 4316.857214]  mlx5e_rep_neigh_entry_release+0x93/0x790 [mlx5_core]
[ 4316.858258]  mlx5e_rep_encap_entry_detach+0xa7/0xf0 [mlx5_core]
[ 4316.859134]  mlx5e_encap_dealloc+0xa3/0xf0 [mlx5_core]
[ 4316.859867]  clean_encap_dests.part.0+0x5c/0xe0 [mlx5_core]
[ 4316.860605]  mlx5e_tc_del_fdb_flow+0x32a/0x810 [mlx5_core]
[ 4316.862609]  __mlx5e_tc_del_fdb_peer_flow+0x1a2/0x250 [mlx5_core]
[ 4316.863394]  mlx5e_tc_del_flow+0x(/0x630 [mlx5_core]
[ 4316.864090]  mlx5e_flow_put+0x5f/0x100 [mlx5_core]
[ 4316.864771]  mlx5e_delete_flower+0x4de/0xa40 [mlx5_core]
[ 4316.865486]  tc_setup_cb_reoffload+0x20/0x80
[ 4316.865905]  fl_reoffload+0x47c/0x510 [cls_flower]
[ 4316.869181]  tcf_block_playback_offloads+0x91/0x1d0
[ 4316.869649]  tcf_block_unbind+0xe7/0x1b0
[ 4316.870049]  tcf_block_offload_cmd.isra.0+0x1ee/0x270
[ 4316.879266]  tcf_block_offload_unbind+0x61/0xa0
[ 4316.879711]  __tcf_block_put+0xa4/0x310
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01fdaea410787fe372daeaeda93a29ed0606d334
  - https://git.kernel.org/stable/c/b7350f8dbe0c2a1d4d3ad7c35b610abd3cb91750
  - https://git.kernel.org/stable/c/c9668f0b1d28570327dbba189f2c61f6f9e43ae7

------------------------------------------------------------

CVE ID: CVE-2023-53106
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: st-nci: Fix use after free bug in ndlc_remove due to race condition

This bug influences both st_nci_i2c_remove and st_nci_spi_remove.
Take st_nci_i2c_remove as an example.

In st_nci_i2c_probe, it called ndlc_probe and bound &ndlc->sm_work
with llt_ndlc_sm_work.

When it calls ndlc_recv or timeout handler, it will finally call
schedule_work to start the work.

When we call st_nci_i2c_remove to remove the driver, there
may be a sequence as follows:

Fix it by finishing the work before cleanup in ndlc_remove

CPU0                  CPU1

                    |llt_ndlc_sm_work
st_nci_i2c_remove   |
  ndlc_remove       |
     st_nci_remove  |
     nci_free_device|
     kfree(ndev)    |
//free ndlc->ndev   |
                    |llt_ndlc_rcv_queue
                    |nci_recv_frame
                    |//use ndlc->ndev
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2156490c4b7cacda9a18ec99929940b8376dc0e3
  - https://git.kernel.org/stable/c/3405eb641dafcc8b28d174784b203c1622c121bf
  - https://git.kernel.org/stable/c/43aa468df246175207a7d5d7d6d31b231f15b49c
  - https://git.kernel.org/stable/c/5000fe6c27827a61d8250a7e4a1d26c3298ef4f6
  - https://git.kernel.org/stable/c/5e331022b448fbc5e76f24349cd0246844dcad25
  - https://git.kernel.org/stable/c/84dd9cc34014e3a3dcce0eb6d54b8a067e97676b
  - https://git.kernel.org/stable/c/b0c202a8dc63008205a5d546559736507a9aae66
  - https://git.kernel.org/stable/c/f589e5b56c562d99ea74e05b1c3f0eab78aa17a3

------------------------------------------------------------

CVE ID: CVE-2023-53107
Description: In the Linux kernel, the following vulnerability has been resolved:

veth: Fix use after free in XDP_REDIRECT

Commit 718a18a0c8a6 ("veth: Rework veth_xdp_rcv_skb in order
to accept non-linear skb") introduced a bug where it tried to
use pskb_expand_head() if the headroom was less than
XDP_PACKET_HEADROOM.  This however uses kmalloc to expand the head,
which will later allow consume_skb() to free the skb while is it still
in use by AF_XDP.

Previously if the headroom was less than XDP_PACKET_HEADROOM we
continued on to allocate a new skb from pages so this restores that
behavior.

BUG: KASAN: use-after-free in __xsk_rcv+0x18d/0x2c0
Read of size 78 at addr ffff888976250154 by task napi/iconduit-g/148640

CPU: 5 PID: 148640 Comm: napi/iconduit-g Kdump: loaded Tainted: G           O       6.1.4-cloudflare-kasan-2023.1.2 #1
Hardware name: Quanta Computer Inc. QuantaPlex T41S-2U/S2S-MB, BIOS S2S_3B10.03 06/21/2018
Call Trace:
  <TASK>
  dump_stack_lvl+0x34/0x48
  print_report+0x170/0x473
  ? __xsk_rcv+0x18d/0x2c0
  kasan_report+0xad/0x130
  ? __xsk_rcv+0x18d/0x2c0
  kasan_check_range+0x149/0x1a0
  memcpy+0x20/0x60
  __xsk_rcv+0x18d/0x2c0
  __xsk_map_redirect+0x1f3/0x490
  ? veth_xdp_rcv_skb+0x89c/0x1ba0 [veth]
  xdp_do_redirect+0x5ca/0xd60
  veth_xdp_rcv_skb+0x935/0x1ba0 [veth]
  ? __netif_receive_skb_list_core+0x671/0x920
  ? veth_xdp+0x670/0x670 [veth]
  veth_xdp_rcv+0x304/0xa20 [veth]
  ? do_xdp_generic+0x150/0x150
  ? veth_xdp_rcv_one+0xde0/0xde0 [veth]
  ? _raw_spin_lock_bh+0xe0/0xe0
  ? newidle_balance+0x887/0xe30
  ? __perf_event_task_sched_in+0xdb/0x800
  veth_poll+0x139/0x571 [veth]
  ? veth_xdp_rcv+0xa20/0xa20 [veth]
  ? _raw_spin_unlock+0x39/0x70
  ? finish_task_switch.isra.0+0x17e/0x7d0
  ? __switch_to+0x5cf/0x1070
  ? __schedule+0x95b/0x2640
  ? io_schedule_timeout+0x160/0x160
  __napi_poll+0xa1/0x440
  napi_threaded_poll+0x3d1/0x460
  ? __napi_poll+0x440/0x440
  ? __kthread_parkme+0xc6/0x1f0
  ? __napi_poll+0x440/0x440
  kthread+0x2a2/0x340
  ? kthread_complete_and_exit+0x20/0x20
  ret_from_fork+0x22/0x30
  </TASK>

Freed by task 148640:
  kasan_save_stack+0x23/0x50
  kasan_set_track+0x21/0x30
  kasan_save_free_info+0x2a/0x40
  ____kasan_slab_free+0x169/0x1d0
  slab_free_freelist_hook+0xd2/0x190
  __kmem_cache_free+0x1a1/0x2f0
  skb_release_data+0x449/0x600
  consume_skb+0x9f/0x1c0
  veth_xdp_rcv_skb+0x89c/0x1ba0 [veth]
  veth_xdp_rcv+0x304/0xa20 [veth]
  veth_poll+0x139/0x571 [veth]
  __napi_poll+0xa1/0x440
  napi_threaded_poll+0x3d1/0x460
  kthread+0x2a2/0x340
  ret_from_fork+0x22/0x30

The buggy address belongs to the object at ffff888976250000
  which belongs to the cache kmalloc-2k of size 2048
The buggy address is located 340 bytes inside of
  2048-byte region [ffff888976250000, ffff888976250800)

The buggy address belongs to the physical page:
page:00000000ae18262a refcount:2 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x976250
head:00000000ae18262a order:3 compound_mapcount:0 compound_pincount:0
flags: 0x2ffff800010200(slab|head|node=0|zone=2|lastcpupid=0x1ffff)
raw: 002ffff800010200 0000000000000000 dead000000000122 ffff88810004cf00
raw: 0000000000000000 0000000080080008 00000002ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
  ffff888976250000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  ffff888976250080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
> ffff888976250100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                  ^
  ffff888976250180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  ffff888976250200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6e755b56896df48b0fae0db275e148f8d8aa7d6f
  - https://git.kernel.org/stable/c/717d20710596b5b26595ede454d1105fa176f4a4
  - https://git.kernel.org/stable/c/7c10131803e45269ddc6c817f19ed649110f3cae

------------------------------------------------------------

CVE ID: CVE-2023-53108
Description: In the Linux kernel, the following vulnerability has been resolved:

net/iucv: Fix size of interrupt data

iucv_irq_data needs to be 4 bytes larger.
These bytes are not used by the iucv module, but written by
the z/VM hypervisor in case a CPU is deconfigured.

Reported as:
BUG dma-kmalloc-64 (Not tainted): kmalloc Redzone overwritten
-----------------------------------------------------------------------------
0x0000000000400564-0x0000000000400567 @offset=1380. First byte 0x80 instead of 0xcc
Allocated in iucv_cpu_prepare+0x44/0xd0 age=167839 cpu=2 pid=1
__kmem_cache_alloc_node+0x166/0x450
kmalloc_node_trace+0x3a/0x70
iucv_cpu_prepare+0x44/0xd0
cpuhp_invoke_callback+0x156/0x2f0
cpuhp_issue_call+0xf0/0x298
__cpuhp_setup_state_cpuslocked+0x136/0x338
__cpuhp_setup_state+0xf4/0x288
iucv_init+0xf4/0x280
do_one_initcall+0x78/0x390
do_initcalls+0x11a/0x140
kernel_init_freeable+0x25e/0x2a0
kernel_init+0x2e/0x170
__ret_from_fork+0x3c/0x58
ret_from_fork+0xa/0x40
Freed in iucv_init+0x92/0x280 age=167839 cpu=2 pid=1
__kmem_cache_free+0x308/0x358
iucv_init+0x92/0x280
do_one_initcall+0x78/0x390
do_initcalls+0x11a/0x140
kernel_init_freeable+0x25e/0x2a0
kernel_init+0x2e/0x170
__ret_from_fork+0x3c/0x58
ret_from_fork+0xa/0x40
Slab 0x0000037200010000 objects=32 used=30 fp=0x0000000000400640 flags=0x1ffff00000010200(slab|head|node=0|zone=0|
Object 0x0000000000400540 @offset=1344 fp=0x0000000000000000
Redzone  0000000000400500: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
Redzone  0000000000400510: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
Redzone  0000000000400520: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
Redzone  0000000000400530: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
Object   0000000000400540: 00 01 00 03 00 00 00 00 00 00 00 00 00 00 00 00  ................
Object   0000000000400550: f3 86 81 f2 f4 82 f8 82 f0 f0 f0 f0 f0 f0 f0 f2  ................
Object   0000000000400560: 00 00 00 00 80 00 00 00 cc cc cc cc cc cc cc cc  ................
Object   0000000000400570: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
Redzone  0000000000400580: cc cc cc cc cc cc cc cc                          ........
Padding  00000000004005d4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
Padding  00000000004005e4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
Padding  00000000004005f4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a              ZZZZZZZZZZZZ
CPU: 6 PID: 121030 Comm: 116-pai-crypto. Not tainted 6.3.0-20230221.rc0.git4.99b8246b2d71.300.fc37.s390x+debug #1
Hardware name: IBM 3931 A01 704 (z/VM 7.3.0)
Call Trace:
[<000000032aa034ec>] dump_stack_lvl+0xac/0x100
[<0000000329f5a6cc>] check_bytes_and_report+0x104/0x140
[<0000000329f5aa78>] check_object+0x370/0x3c0
[<0000000329f5ede6>] free_debug_processing+0x15e/0x348
[<0000000329f5f06a>] free_to_partial_list+0x9a/0x2f0
[<0000000329f5f4a4>] __slab_free+0x1e4/0x3a8
[<0000000329f61768>] __kmem_cache_free+0x308/0x358
[<000000032a91465c>] iucv_cpu_dead+0x6c/0x88
[<0000000329c2fc66>] cpuhp_invoke_callback+0x156/0x2f0
[<000000032aa062da>] _cpu_down.constprop.0+0x22a/0x5e0
[<0000000329c3243e>] cpu_device_down+0x4e/0x78
[<000000032a61dee0>] device_offline+0xc8/0x118
[<000000032a61e048>] online_store+0x60/0xe0
[<000000032a08b6b0>] kernfs_fop_write_iter+0x150/0x1e8
[<0000000329fab65c>] vfs_write+0x174/0x360
[<0000000329fab9fc>] ksys_write+0x74/0x100
[<000000032aa03a5a>] __do_syscall+0x1da/0x208
[<000000032aa177b2>] system_call+0x82/0xb0
INFO: lockdep is turned off.
FIX dma-kmalloc-64: Restoring kmalloc Redzone 0x0000000000400564-0x0000000000400567=0xcc
FIX dma-kmalloc-64: Object at 0x0000000000400540 not freed
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3cfdefdaaa4b2a77e84d0db5e0a47a7aa3bb615a
  - https://git.kernel.org/stable/c/3d87debb8ed2649608ff432699e7c961c0c6f03b
  - https://git.kernel.org/stable/c/71da5991b6438ad6da13ceb25465ee2760a1c52f
  - https://git.kernel.org/stable/c/93a970494881004c348d8feb38463ee72496e99a
  - https://git.kernel.org/stable/c/a908eae0f71811afee86be7088692f1aa5855c3b
  - https://git.kernel.org/stable/c/b0d2bb5e31a693ebc8888eb407f8a257a3680efa
  - https://git.kernel.org/stable/c/bd2e78462ae18484e55ae4d285df2c86b86bdd12
  - https://git.kernel.org/stable/c/c78f1345db4e4b3b78f9b768f4074ebd60abe966

------------------------------------------------------------

CVE ID: CVE-2023-53109
Description: In the Linux kernel, the following vulnerability has been resolved:

net: tunnels: annotate lockless accesses to dev->needed_headroom

IP tunnels can apparently update dev->needed_headroom
in their xmit path.

This patch takes care of three tunnels xmit, and also the
core LL_RESERVED_SPACE() and LL_RESERVED_SPACE_EXTRA()
helpers.

More changes might be needed for completeness.

BUG: KCSAN: data-race in ip_tunnel_xmit / ip_tunnel_xmit

read to 0xffff88815b9da0ec of 2 bytes by task 888 on cpu 1:
ip_tunnel_xmit+0x1270/0x1730 net/ipv4/ip_tunnel.c:803
__gre_xmit net/ipv4/ip_gre.c:469 [inline]
ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661
__netdev_start_xmit include/linux/netdevice.h:4881 [inline]
netdev_start_xmit include/linux/netdevice.h:4895 [inline]
xmit_one net/core/dev.c:3580 [inline]
dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596
__dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246
dev_queue_xmit include/linux/netdevice.h:3051 [inline]
neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623
neigh_output include/net/neighbour.h:546 [inline]
ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228
ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316
NF_HOOK_COND include/linux/netfilter.h:291 [inline]
ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430
dst_output include/net/dst.h:444 [inline]
ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126
iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82
ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813
__gre_xmit net/ipv4/ip_gre.c:469 [inline]
ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661
__netdev_start_xmit include/linux/netdevice.h:4881 [inline]
netdev_start_xmit include/linux/netdevice.h:4895 [inline]
xmit_one net/core/dev.c:3580 [inline]
dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596
__dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246
dev_queue_xmit include/linux/netdevice.h:3051 [inline]
neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623
neigh_output include/net/neighbour.h:546 [inline]
ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228
ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316
NF_HOOK_COND include/linux/netfilter.h:291 [inline]
ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430
dst_output include/net/dst.h:444 [inline]
ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126
iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82
ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813
__gre_xmit net/ipv4/ip_gre.c:469 [inline]
ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661
__netdev_start_xmit include/linux/netdevice.h:4881 [inline]
netdev_start_xmit include/linux/netdevice.h:4895 [inline]
xmit_one net/core/dev.c:3580 [inline]
dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596
__dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246
dev_queue_xmit include/linux/netdevice.h:3051 [inline]
neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623
neigh_output include/net/neighbour.h:546 [inline]
ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228
ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316
NF_HOOK_COND include/linux/netfilter.h:291 [inline]
ip_output+0xe5/0x1b0 net/ipv4/ip_output.c:430
dst_output include/net/dst.h:444 [inline]
ip_local_out+0x64/0x80 net/ipv4/ip_output.c:126
iptunnel_xmit+0x34a/0x4b0 net/ipv4/ip_tunnel_core.c:82
ip_tunnel_xmit+0x1451/0x1730 net/ipv4/ip_tunnel.c:813
__gre_xmit net/ipv4/ip_gre.c:469 [inline]
ipgre_xmit+0x516/0x570 net/ipv4/ip_gre.c:661
__netdev_start_xmit include/linux/netdevice.h:4881 [inline]
netdev_start_xmit include/linux/netdevice.h:4895 [inline]
xmit_one net/core/dev.c:3580 [inline]
dev_hard_start_xmit+0x127/0x400 net/core/dev.c:3596
__dev_queue_xmit+0x1007/0x1eb0 net/core/dev.c:4246
dev_queue_xmit include/linux/netdevice.h:3051 [inline]
neigh_direct_output+0x17/0x20 net/core/neighbour.c:1623
neigh_output include/net/neighbour.h:546 [inline]
ip_finish_output2+0x740/0x840 net/ipv4/ip_output.c:228
ip_finish_output+0xf4/0x240 net/ipv4/ip_output.c:316
NF_HOOK_COND include/linux/netfilter.h:291 [inline]
ip_output+0xe5/0x1b0 net/i
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4b397c06cb987935b1b097336532aa6b4210e091
  - https://git.kernel.org/stable/c/51f3bd3765bc5ca4583af07a00833da00d2ace1d
  - https://git.kernel.org/stable/c/5aaab217c8f5387b9c5fff9e940d80f135e04366
  - https://git.kernel.org/stable/c/8e206f66d824b3b28a7f9ee1366dfc79a937bb46
  - https://git.kernel.org/stable/c/9b86a8702b042ee4e15d2d46375be873a6a8834f
  - https://git.kernel.org/stable/c/a69b72b57b7d269e833e520ba7500d556e8189b6
  - https://git.kernel.org/stable/c/be59b87ee4aed81db7c10e44f603866a0ac3ca5d
  - https://git.kernel.org/stable/c/e0a557fc1daf5c1086e47150a4571aebadbb62be

------------------------------------------------------------

CVE ID: CVE-2023-53110
Description: In the Linux kernel, the following vulnerability has been resolved:

net/smc: fix NULL sndbuf_desc in smc_cdc_tx_handler()

When performing a stress test on SMC-R by rmmod mlx5_ib driver
during the wrk/nginx test, we found that there is a probability
of triggering a panic while terminating all link groups.

This issue dues to the race between smc_smcr_terminate_all()
and smc_buf_create().

			smc_smcr_terminate_all

smc_buf_create
/* init */
conn->sndbuf_desc = NULL;
...

			__smc_lgr_terminate
				smc_conn_kill
					smc_close_abort
						smc_cdc_get_slot_and_msg_send

			__softirqentry_text_start
				smc_wr_tx_process_cqe
					smc_cdc_tx_handler
						READ(conn->sndbuf_desc->len);
						/* panic dues to NULL sndbuf_desc */

conn->sndbuf_desc = xxx;

This patch tries to fix the issue by always to check the sndbuf_desc
before send any cdc msg, to make sure that no null pointer is
seen during cqe processing.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/22a825c541d775c1dbe7b2402786025acad6727b
  - https://git.kernel.org/stable/c/31817c530768b0199771ec6019571b4f0ddbf230
  - https://git.kernel.org/stable/c/3c270435db8aa34929263dddae8fd050f5216ecb
  - https://git.kernel.org/stable/c/3ebac7cf0a184a8102821a7a00203f02bebda83c
  - https://git.kernel.org/stable/c/b108bd9e6be000492ebebe867daa699285978a10

------------------------------------------------------------

CVE ID: CVE-2023-53111
Description: In the Linux kernel, the following vulnerability has been resolved:

loop: Fix use-after-free issues

do_req_filebacked() calls blk_mq_complete_request() synchronously or
asynchronously when using asynchronous I/O unless memory allocation fails.
Hence, modify loop_handle_cmd() such that it does not dereference 'cmd' nor
'rq' after do_req_filebacked() finished unless we are sure that the request
has not yet been completed. This patch fixes the following kernel crash:

Unable to handle kernel NULL pointer dereference at virtual address 0000000000000054
Call trace:
 css_put.42938+0x1c/0x1ac
 loop_process_work+0xc8c/0xfd4
 loop_rootcg_workfn+0x24/0x34
 process_one_work+0x244/0x558
 worker_thread+0x400/0x8fc
 kthread+0x16c/0x1e0
 ret_from_fork+0x10/0x20
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/407badf73ec9fb0d5744bf2ca1745c1818aa222f
  - https://git.kernel.org/stable/c/6917395c4667cfb607ed8bf1826205a59414657c
  - https://git.kernel.org/stable/c/9b0cb770f5d7b1ff40bea7ca385438ee94570eec
  - https://git.kernel.org/stable/c/e3fda704903f6d1fc351412f1bc6620333959ada

------------------------------------------------------------

CVE ID: CVE-2023-53112
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/i915/sseu: fix max_subslices array-index-out-of-bounds access

It seems that commit bc3c5e0809ae ("drm/i915/sseu: Don't try to store EU
mask internally in UAPI format") exposed a potential out-of-bounds
access, reported by UBSAN as following on a laptop with a gen 11 i915
card:

  UBSAN: array-index-out-of-bounds in drivers/gpu/drm/i915/gt/intel_sseu.c:65:27
  index 6 is out of range for type 'u16 [6]'
  CPU: 2 PID: 165 Comm: systemd-udevd Not tainted 6.2.0-9-generic #9-Ubuntu
  Hardware name: Dell Inc. XPS 13 9300/077Y9N, BIOS 1.11.0 03/22/2022
  Call Trace:
   <TASK>
   show_stack+0x4e/0x61
   dump_stack_lvl+0x4a/0x6f
   dump_stack+0x10/0x18
   ubsan_epilogue+0x9/0x3a
   __ubsan_handle_out_of_bounds.cold+0x42/0x47
   gen11_compute_sseu_info+0x121/0x130 [i915]
   intel_sseu_info_init+0x15d/0x2b0 [i915]
   intel_gt_init_mmio+0x23/0x40 [i915]
   i915_driver_mmio_probe+0x129/0x400 [i915]
   ? intel_gt_probe_all+0x91/0x2e0 [i915]
   i915_driver_probe+0xe1/0x3f0 [i915]
   ? drm_privacy_screen_get+0x16d/0x190 [drm]
   ? acpi_dev_found+0x64/0x80
   i915_pci_probe+0xac/0x1b0 [i915]
   ...

According to the definition of sseu_dev_info, eu_mask->hsw is limited to
a maximum of GEN_MAX_SS_PER_HSW_SLICE (6) sub-slices, but
gen11_sseu_info_init() can potentially set 8 sub-slices, in the
!IS_JSL_EHL(gt->i915) case.

Fix this by reserving up to 8 slots for max_subslices in the eu_mask
struct.

(cherry picked from commit 3cba09a6ac86ea1d456909626eb2685596c07822)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/193c41926d152761764894f46e23b53c00186a82
  - https://git.kernel.org/stable/c/1a1682abf7399318ac074b1f2ac6a8c992b5b3da
  - https://git.kernel.org/stable/c/36b076ab6247cf0d2135b2ad6bb337617c3b5a1b

------------------------------------------------------------

CVE ID: CVE-2023-53113
Description: In the Linux kernel, the following vulnerability has been resolved:

wifi: nl80211: fix NULL-ptr deref in offchan check

If, e.g. in AP mode, the link was already created by userspace
but not activated yet, it has a chandef but the chandef isn't
valid and has no channel. Check for this and ignore this link.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/201a836c2385fdd2b9d0a8e7737bba5b26f1863a
  - https://git.kernel.org/stable/c/87e80ea4fbc9ce2f2005905fdbcd38baaa47463a
  - https://git.kernel.org/stable/c/f624bb6fad23df3270580b4fcef415c6e7bf7705

------------------------------------------------------------

CVE ID: CVE-2023-53114
Description: In the Linux kernel, the following vulnerability has been resolved:

i40e: Fix kernel crash during reboot when adapter is in recovery mode

If the driver detects during probe that firmware is in recovery
mode then i40e_init_recovery_mode() is called and the rest of
probe function is skipped including pci_set_drvdata(). Subsequent
i40e_shutdown() called during shutdown/reboot dereferences NULL
pointer as pci_get_drvdata() returns NULL.

To fix call pci_set_drvdata() also during entering to recovery mode.

Reproducer:
1) Lets have i40e NIC with firmware in recovery mode
2) Run reboot

Result:
[  139.084698] i40e: Intel(R) Ethernet Connection XL710 Network Driver
[  139.090959] i40e: Copyright (c) 2013 - 2019 Intel Corporation.
[  139.108438] i40e 0000:02:00.0: Firmware recovery mode detected. Limiting functionality.
[  139.116439] i40e 0000:02:00.0: Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode.
[  139.129499] i40e 0000:02:00.0: fw 8.3.64775 api 1.13 nvm 8.30 0x8000b78d 1.3106.0 [8086:1583] [15d9:084a]
[  139.215932] i40e 0000:02:00.0 enp2s0f0: renamed from eth0
[  139.223292] i40e 0000:02:00.1: Firmware recovery mode detected. Limiting functionality.
[  139.231292] i40e 0000:02:00.1: Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode.
[  139.244406] i40e 0000:02:00.1: fw 8.3.64775 api 1.13 nvm 8.30 0x8000b78d 1.3106.0 [8086:1583] [15d9:084a]
[  139.329209] i40e 0000:02:00.1 enp2s0f1: renamed from eth0
...
[  156.311376] BUG: kernel NULL pointer dereference, address: 00000000000006c2
[  156.318330] #PF: supervisor write access in kernel mode
[  156.323546] #PF: error_code(0x0002) - not-present page
[  156.328679] PGD 0 P4D 0
[  156.331210] Oops: 0002 [#1] PREEMPT SMP NOPTI
[  156.335567] CPU: 26 PID: 15119 Comm: reboot Tainted: G            E      6.2.0+ #1
[  156.343126] Hardware name: Abacus electric, s.r.o. - servis@abacus.cz Super Server/H12SSW-iN, BIOS 2.4 04/13/2022
[  156.353369] RIP: 0010:i40e_shutdown+0x15/0x130 [i40e]
[  156.358430] Code: c1 fc ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 55 48 89 fd 53 48 8b 9f 48 01 00 00 <f0> 80 8b c2 06 00 00 04 f0 80 8b c0 06 00 00 08 48 8d bb 08 08 00
[  156.377168] RSP: 0018:ffffb223c8447d90 EFLAGS: 00010282
[  156.382384] RAX: ffffffffc073ee70 RBX: 0000000000000000 RCX: 0000000000000001
[  156.389510] RDX: 0000000080000001 RSI: 0000000000000246 RDI: ffff95db49988000
[  156.396634] RBP: ffff95db49988000 R08: ffffffffffffffff R09: ffffffff8bd17d40
[  156.403759] R10: 0000000000000001 R11: ffffffff8a5e3d28 R12: ffff95db49988000
[  156.410882] R13: ffffffff89a6fe17 R14: ffff95db49988150 R15: 0000000000000000
[  156.418007] FS:  00007fe7c0cc3980(0000) GS:ffff95ea8ee80000(0000) knlGS:0000000000000000
[  156.426083] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  156.431819] CR2: 00000000000006c2 CR3: 00000003092fc005 CR4: 0000000000770ee0
[  156.438944] PKRU: 55555554
[  156.441647] Call Trace:
[  156.444096]  <TASK>
[  156.446199]  pci_device_shutdown+0x38/0x60
[  156.450297]  device_shutdown+0x163/0x210
[  156.454215]  kernel_restart+0x12/0x70
[  156.457872]  __do_sys_reboot+0x1ab/0x230
[  156.461789]  ? vfs_writev+0xa6/0x1a0
[  156.465362]  ? __pfx_file_free_rcu+0x10/0x10
[  156.469635]  ? __call_rcu_common.constprop.85+0x109/0x5a0
[  156.475034]  do_syscall_64+0x3e/0x90
[  156.478611]  entry_SYSCALL_64_after_hwframe+0x72/0xdc
[  156.483658] RIP: 0033:0x7fe7bff37ab7
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3cbecb1c9085a00155639404f7addbcbfc987ba3
  - https://git.kernel.org/stable/c/4ff82695266576a0b4f1077a7100b2451e476df4
  - https://git.kernel.org/stable/c/6e18f66b704bd725196508c1db93bf7338cdc8de
  - https://git.kernel.org/stable/c/7e4f8a0c495413a50413e8c9f1032ce1bc633bae
  - https://git.kernel.org/stable/c/b3826fb3ea14646b3d4e6309bfc384b349f36eb6
  - https://git.kernel.org/stable/c/c703362a66ea971905b9dc153fc54d1b6ac05423

------------------------------------------------------------

CVE ID: CVE-2023-53115
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix memory leaks in mpi3mr_init_ioc()

Don't allocate memory again when IOC is being reinitialized.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5aab9342f12f980b64617a034d121efbbf09100a
  - https://git.kernel.org/stable/c/7277b4eec2f25a0653646ba95b1f25fa16be1d6c
  - https://git.kernel.org/stable/c/c798304470cab88723d895726d17fcb96472e0e9

------------------------------------------------------------

CVE ID: CVE-2023-53116
Description: In the Linux kernel, the following vulnerability has been resolved:

nvmet: avoid potential UAF in nvmet_req_complete()

An nvme target ->queue_response() operation implementation may free the
request passed as argument. Such implementation potentially could result
in a use after free of the request pointer when percpu_ref_put() is
called in nvmet_req_complete().

Avoid such problem by using a local variable to save the sq pointer
before calling __nvmet_req_complete(), thus avoiding dereferencing the
req pointer after that function call.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/04c394208831d5e0d5cfee46722eb0f033cd4083
  - https://git.kernel.org/stable/c/6173a77b7e9d3e202bdb9897b23f2a8afe7bf286
  - https://git.kernel.org/stable/c/8ed9813871038b25a934b21ab76b5b7dbf44fc3a
  - https://git.kernel.org/stable/c/a6317235da8aa7cb97529ebc8121cc2a4c4c437a
  - https://git.kernel.org/stable/c/bcd535f07c58342302a2cd2bdd8894fe0872c8a9
  - https://git.kernel.org/stable/c/e5d99b29012bbf0e86929403209723b2806500c1
  - https://git.kernel.org/stable/c/f1d5888a5efe345b63c430b256e95acb0a475642
  - https://git.kernel.org/stable/c/fafcb4b26393870c45462f9af6a48e581dbbcf7e

------------------------------------------------------------

CVE ID: CVE-2023-53117
Description: In the Linux kernel, the following vulnerability has been resolved:

fs: prevent out-of-bounds array speculation when closing a file descriptor

Google-Bug-Id: 114199369
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3d5d9501b634fd268eb56428cda92cd317752d69
  - https://git.kernel.org/stable/c/609d54441493c99f21c1823dfd66fa7f4c512ff4
  - https://git.kernel.org/stable/c/6631c8da02cfad96c53b217cf647b511c7f34faf
  - https://git.kernel.org/stable/c/a759905de9cd6ec9ca08ceadf0920272772ed830
  - https://git.kernel.org/stable/c/cec08b7d1ebcd3138d4658b3868ce26aeb1e8e06
  - https://git.kernel.org/stable/c/eea8e4e056a5ffbeb539a13854c017d5d62c756a
  - https://git.kernel.org/stable/c/f31cd5da636682caea424fa1c22679016cbfc16b
  - https://git.kernel.org/stable/c/f8cd8754a03a3748384ee438c572423643c9c315

------------------------------------------------------------

CVE ID: CVE-2023-53118
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: core: Fix a procfs host directory removal regression

scsi_proc_hostdir_rm() decreases a reference counter and hence must only be
called once per host that is removed. This change does not require a
scsi_add_host_with_dma() change since scsi_add_host_with_dma() will return
0 (success) if scsi_proc_host_add() is called.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2a764d55e938743efa7c2cba7305633bcf227f09
  - https://git.kernel.org/stable/c/68c665bb185037e7eb66fb792c61da9d7151e99c
  - https://git.kernel.org/stable/c/73f030d4ef6d1ad17f824a0a2eb637ef7a9c7d51
  - https://git.kernel.org/stable/c/7e0ae8667fcdd99d1756922e1140cac75f5fa279
  - https://git.kernel.org/stable/c/88c3d3bb6469cea929ac68fd326bdcbefcdfdd83
  - https://git.kernel.org/stable/c/be03df3d4bfe7e8866d4aa43d62e648ffe884f5f

------------------------------------------------------------

CVE ID: CVE-2023-53119
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: pn533: initialize struct pn533_out_arg properly

struct pn533_out_arg used as a temporary context for out_urb is not
initialized properly. Its uninitialized 'phy' field can be dereferenced in
error cases inside pn533_out_complete() callback function. It causes the
following failure:

general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN
KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc3-next-20230110-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
RIP: 0010:pn533_out_complete.cold+0x15/0x44 drivers/nfc/pn533/usb.c:441
Call Trace:
 <IRQ>
 __usb_hcd_giveback_urb+0x2b6/0x5c0 drivers/usb/core/hcd.c:1671
 usb_hcd_giveback_urb+0x384/0x430 drivers/usb/core/hcd.c:1754
 dummy_timer+0x1203/0x32d0 drivers/usb/gadget/udc/dummy_hcd.c:1988
 call_timer_fn+0x1da/0x800 kernel/time/timer.c:1700
 expire_timers+0x234/0x330 kernel/time/timer.c:1751
 __run_timers kernel/time/timer.c:2022 [inline]
 __run_timers kernel/time/timer.c:1995 [inline]
 run_timer_softirq+0x326/0x910 kernel/time/timer.c:2035
 __do_softirq+0x1fb/0xaf6 kernel/softirq.c:571
 invoke_softirq kernel/softirq.c:445 [inline]
 __irq_exit_rcu+0x123/0x180 kernel/softirq.c:650
 irq_exit_rcu+0x9/0x20 kernel/softirq.c:662
 sysvec_apic_timer_interrupt+0x97/0xc0 arch/x86/kernel/apic/apic.c:1107

Initialize the field with the pn533_usb_phy currently used.

Found by Linux Verification Center (linuxtesting.org) with Syzkaller.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0f9c1f26d434c32520dfe33326b28c5954bc4299
  - https://git.kernel.org/stable/c/2703da78849c47b6b5b4471edb35fc7b7f91dead
  - https://git.kernel.org/stable/c/2bd1ed6d607d7013ed4959e86990a04f028543ef
  - https://git.kernel.org/stable/c/2bee84369b76f6c9ef71938069c65a6ebd1a12f7
  - https://git.kernel.org/stable/c/2cbd4213baf7be5d87d183e2032c54003de0790f
  - https://git.kernel.org/stable/c/484b7059796e3bc1cb527caa61dfc60da649b4f6
  - https://git.kernel.org/stable/c/4c20a07ed26a71a8ccc9c6d935fc181573f5462e
  - https://git.kernel.org/stable/c/a97ef110c491b72c138111a595a3a3af56cbc94c

------------------------------------------------------------

CVE ID: CVE-2023-53120
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix config page DMA memory leak

A fix for:

DMA-API: pci 0000:83:00.0: device driver has pending DMA allocations while released from device [count=1]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5fc4d698ed4b6507be2eb36d040a678adcb89da4
  - https://git.kernel.org/stable/c/7d2b02172b6a2ae6aecd7ef6480b9c4bf3dc59f4
  - https://git.kernel.org/stable/c/dca06ccf13de14e144d34f158f73ae0032f80e63

------------------------------------------------------------

CVE ID: CVE-2023-53121
Description: In the Linux kernel, the following vulnerability has been resolved:

tcp: tcp_make_synack() can be called from process context

tcp_rtx_synack() now could be called in process context as explained in
0a375c822497 ("tcp: tcp_rtx_synack() can be called from process
context").

tcp_rtx_synack() might call tcp_make_synack(), which will touch per-CPU
variables with preemption enabled. This causes the following BUG:

    BUG: using __this_cpu_add() in preemptible [00000000] code: ThriftIO1/5464
    caller is tcp_make_synack+0x841/0xac0
    Call Trace:
     <TASK>
     dump_stack_lvl+0x10d/0x1a0
     check_preemption_disabled+0x104/0x110
     tcp_make_synack+0x841/0xac0
     tcp_v6_send_synack+0x5c/0x450
     tcp_rtx_synack+0xeb/0x1f0
     inet_rtx_syn_ack+0x34/0x60
     tcp_check_req+0x3af/0x9e0
     tcp_rcv_state_process+0x59b/0x2030
     tcp_v6_do_rcv+0x5f5/0x700
     release_sock+0x3a/0xf0
     tcp_sendmsg+0x33/0x40
     ____sys_sendmsg+0x2f2/0x490
     __sys_sendmsg+0x184/0x230
     do_syscall_64+0x3d/0x90

Avoid calling __TCP_INC_STATS() with will touch per-cpu variables. Use
TCP_INC_STATS() which is safe to be called from context switch.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/442aa78ed70188b21ccd8669738448702c0a3281
  - https://git.kernel.org/stable/c/7613cde8c0c1f02a7ec2e1d536c01b65b135fc1c
  - https://git.kernel.org/stable/c/77ad58bca0119e8cc3e0e9d91a3f22caa66e4dfa
  - https://git.kernel.org/stable/c/9180aa4622a720b433e842b4d3aa34d73eec577a
  - https://git.kernel.org/stable/c/ad07290d63ff6689f50565b02f5b6f34ec15a5ca
  - https://git.kernel.org/stable/c/bced3f7db95ff2e6ca29dc4d1c9751ab5e736a09
  - https://git.kernel.org/stable/c/d493d4fe88195a144d6a277a90062a7534ed2192
  - https://git.kernel.org/stable/c/e23ca307745be3df7fe9762f3e2a7e311a57852e

------------------------------------------------------------

CVE ID: CVE-2023-53123
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: s390: Fix use-after-free of PCI resources with per-function hotplug

On s390 PCI functions may be hotplugged individually even when they
belong to a multi-function device. In particular on an SR-IOV device VFs
may be removed and later re-added.

In commit a50297cf8235 ("s390/pci: separate zbus creation from
scanning") it was missed however that struct pci_bus and struct
zpci_bus's resource list retained a reference to the PCI functions MMIO
resources even though those resources are released and freed on
hot-unplug. These stale resources may subsequently be claimed when the
PCI function re-appears resulting in use-after-free.

One idea of fixing this use-after-free in s390 specific code that was
investigated was to simply keep resources around from the moment a PCI
function first appeared until the whole virtual PCI bus created for
a multi-function device disappears. The problem with this however is
that due to the requirement of artificial MMIO addreesses (address
cookies) extra logic is then needed to keep the address cookies
compatible on re-plug. At the same time the MMIO resources semantically
belong to the PCI function so tying their lifecycle to the function
seems more logical.

Instead a simpler approach is to remove the resources of an individually
hot-unplugged PCI function from the PCI bus's resource list while
keeping the resources of other PCI functions on the PCI bus untouched.

This is done by introducing pci_bus_remove_resource() to remove an
individual resource. Similarly the resource also needs to be removed
from the struct zpci_bus's resource list. It turns out however, that
there is really no need to add the MMIO resources to the struct
zpci_bus's resource list at all and instead we can simply use the
zpci_bar_struct's resource pointer directly.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/437bb839e36cc9f35adc6d2a2bf113b7a0fc9985
  - https://git.kernel.org/stable/c/a2410d0c3d2d714ed968a135dfcbed6aa3ff7027
  - https://git.kernel.org/stable/c/ab909509850b27fd39b8ba99e44cda39dbc3858c
  - https://git.kernel.org/stable/c/b99ebf4b62774e690e73a551cf5fbf6f219bdd96

------------------------------------------------------------

CVE ID: CVE-2023-53124
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpt3sas: Fix NULL pointer access in mpt3sas_transport_port_add()

Port is allocated by sas_port_alloc_num() and rphy is allocated by either
sas_end_device_alloc() or sas_expander_alloc(), all of which may return
NULL. So we need to check the rphy to avoid possible NULL pointer access.

If sas_rphy_add() returned with failure, rphy is set to NULL. We would
access the rphy in the following lines which would also result NULL pointer
access.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/090305c36185c0547e4441d4c08f1cf096b32134
  - https://git.kernel.org/stable/c/6f0c2f70d9929208d8427ec72c3ed91e2251e289
  - https://git.kernel.org/stable/c/9937f784a608944107dcc2ba9a9c3333f8330b9e
  - https://git.kernel.org/stable/c/a26c775ccc4cfe46f9b718b51bd24313053c7e0b
  - https://git.kernel.org/stable/c/b5e5bbb3fa5f8412e96c5eda7f4a4af6241d6bd3
  - https://git.kernel.org/stable/c/d3c57724f1569311e4b81e98fad0931028b9bdcd

------------------------------------------------------------

CVE ID: CVE-2023-53125
Description: In the Linux kernel, the following vulnerability has been resolved:

net: usb: smsc75xx: Limit packet length to skb->len

Packet length retrieved from skb data may be larger than
the actual socket buffer length (up to 9026 bytes). In such
case the cloned skb passed up the network stack will leak
kernel memory contents.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/105db6574281e1e03fcbf87983f4fee111682306
  - https://git.kernel.org/stable/c/4a4de0a68b18485c68ab4f0cfa665b1633c6d277
  - https://git.kernel.org/stable/c/53966d572d056d6b234cfe76a5f9d60049d3c178
  - https://git.kernel.org/stable/c/8ee5df9c039e37b9d8eb5e3de08bfb7f53d31cb6
  - https://git.kernel.org/stable/c/9fabdd79051a9fe51388df099aff6e4b660fedd2
  - https://git.kernel.org/stable/c/c7bdc137ca163b90917c1eeba4f1937684bd4f8b
  - https://git.kernel.org/stable/c/d8b228318935044dafe3a5bc07ee71a1f1424b8d
  - https://git.kernel.org/stable/c/e294f0aa47e4844f3d3c8766c02accd5a76a7d4e

------------------------------------------------------------

CVE ID: CVE-2023-53126
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix sas_hba.phy memory leak in mpi3mr_remove()

Free mrioc->sas_hba.phy at .remove.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/480aae2f30637b5140e9c7a9b10298e538df2b5e
  - https://git.kernel.org/stable/c/c60a7c7508645a9f36e4a18a5f548fb79378acd1
  - https://git.kernel.org/stable/c/d4caa1a4255cc44be56bcab3db2c97c632e6cc10

------------------------------------------------------------

CVE ID: CVE-2023-53127
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix expander node leak in mpi3mr_remove()

Add a missing resource clean up in .remove.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0023972a7593720f8878aed06c03ac9e541078be
  - https://git.kernel.org/stable/c/ce756daa36e1ba271bb3334267295e447aa57a5c
  - https://git.kernel.org/stable/c/cf9777be5683c5e55680c089df02ee27d2226aa8

------------------------------------------------------------

CVE ID: CVE-2023-53128
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix throttle_groups memory leak

Add a missing kfree().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/574cc10edaa7dba833764efed8c57ee0e6bf7574
  - https://git.kernel.org/stable/c/85349a227eb4a56520adc190c666075f80d4ae70
  - https://git.kernel.org/stable/c/f305a7b6ca21a665e8d0cf70b5936991a298c93c

------------------------------------------------------------

CVE ID: CVE-2023-53131
Description: In the Linux kernel, the following vulnerability has been resolved:

SUNRPC: Fix a server shutdown leak

Fix a race where kthread_stop() may prevent the threadfn from ever getting
called.  If that happens the svc_rqst will not be cleaned up.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7a3720361068ab520aed4608bad31ea9a6cc7fe7
  - https://git.kernel.org/stable/c/9ca6705d9d609441d34f8b853e1e4a6369b3b171
  - https://git.kernel.org/stable/c/ad7e40ee157ba33950a4ccdc284334580da3638d
  - https://git.kernel.org/stable/c/ce7dd61e004002bc1c48d1ca47c887f3f3cc7370
  - https://git.kernel.org/stable/c/f74b3286859463cd63cc9d4aeaabd8b0c640182a

------------------------------------------------------------

CVE ID: CVE-2023-53132
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Fix mpi3mr_hba_port memory leak in mpi3mr_remove()

Free mpi3mr_hba_port at .remove.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6322569273071745f2dd0c541b154b9666ae7767
  - https://git.kernel.org/stable/c/d0f3c3728da8af76dfe435f7f0cfa2b9d9e43ef0
  - https://git.kernel.org/stable/c/f28bdab9e208792212c52b0c232a13bba84cf048

------------------------------------------------------------

CVE ID: CVE-2023-53133
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf, sockmap: Fix an infinite loop error when len is 0 in tcp_bpf_recvmsg_parser()

When the buffer length of the recvmsg system call is 0, we got the
flollowing soft lockup problem:

watchdog: BUG: soft lockup - CPU#3 stuck for 27s! [a.out:6149]
CPU: 3 PID: 6149 Comm: a.out Kdump: loaded Not tainted 6.2.0+ #30
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014
RIP: 0010:remove_wait_queue+0xb/0xc0
Code: 5e 41 5f c3 cc cc cc cc 0f 1f 80 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 41 57 <41> 56 41 55 41 54 55 48 89 fd 53 48 89 f3 4c 8d 6b 18 4c 8d 73 20
RSP: 0018:ffff88811b5978b8 EFLAGS: 00000246
RAX: 0000000000000000 RBX: ffff88811a7d3780 RCX: ffffffffb7a4d768
RDX: dffffc0000000000 RSI: ffff88811b597908 RDI: ffff888115408040
RBP: 1ffff110236b2f1b R08: 0000000000000000 R09: ffff88811a7d37e7
R10: ffffed10234fa6fc R11: 0000000000000001 R12: ffff88811179b800
R13: 0000000000000001 R14: ffff88811a7d38a8 R15: ffff88811a7d37e0
FS:  00007f6fb5398740(0000) GS:ffff888237180000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000020000000 CR3: 000000010b6ba002 CR4: 0000000000370ee0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 tcp_msg_wait_data+0x279/0x2f0
 tcp_bpf_recvmsg_parser+0x3c6/0x490
 inet_recvmsg+0x280/0x290
 sock_recvmsg+0xfc/0x120
 ____sys_recvmsg+0x160/0x3d0
 ___sys_recvmsg+0xf0/0x180
 __sys_recvmsg+0xea/0x1a0
 do_syscall_64+0x3f/0x90
 entry_SYSCALL_64_after_hwframe+0x72/0xdc

The logic in tcp_bpf_recvmsg_parser is as follows:

msg_bytes_ready:
	copied = sk_msg_recvmsg(sk, psock, msg, len, flags);
	if (!copied) {
		wait data;
		goto msg_bytes_ready;
	}

In this case, "copied" always is 0, the infinite loop occurs.

According to the Linux system call man page, 0 should be returned in this
case. Therefore, in tcp_bpf_recvmsg_parser(), if the length is 0, directly
return. Also modify several other functions with the same problem.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4a476285f6d2921c3c9faa494eab83b78f78fc55
  - https://git.kernel.org/stable/c/bf0579989de64d36e177c0611c685dc4a91457a7
  - https://git.kernel.org/stable/c/d900f3d20cc3169ce42ec72acc850e662a4d4db2
  - https://git.kernel.org/stable/c/f45cf3ae3068e70e2c7f3e24a7f8e8aa99511f03

------------------------------------------------------------

CVE ID: CVE-2023-53134
Description: In the Linux kernel, the following vulnerability has been resolved:

bnxt_en: Avoid order-5 memory allocation for TPA data

The driver needs to keep track of all the possible concurrent TPA (GRO/LRO)
completions on the aggregation ring.  On P5 chips, the maximum number
of concurrent TPA is 256 and the amount of memory we allocate is order-5
on systems using 4K pages.  Memory allocation failure has been reported:

NetworkManager: page allocation failure: order:5, mode:0x40dc0(GFP_KERNEL|__GFP_COMP|__GFP_ZERO), nodemask=(null),cpuset=/,mems_allowed=0-1
CPU: 15 PID: 2995 Comm: NetworkManager Kdump: loaded Not tainted 5.10.156 #1
Hardware name: Dell Inc. PowerEdge R660/0M1CC5, BIOS 0.2.25 08/12/2022
Call Trace:
 dump_stack+0x57/0x6e
 warn_alloc.cold.120+0x7b/0xdd
 ? _cond_resched+0x15/0x30
 ? __alloc_pages_direct_compact+0x15f/0x170
 __alloc_pages_slowpath.constprop.108+0xc58/0xc70
 __alloc_pages_nodemask+0x2d0/0x300
 kmalloc_order+0x24/0xe0
 kmalloc_order_trace+0x19/0x80
 bnxt_alloc_mem+0x1150/0x15c0 [bnxt_en]
 ? bnxt_get_func_stat_ctxs+0x13/0x60 [bnxt_en]
 __bnxt_open_nic+0x12e/0x780 [bnxt_en]
 bnxt_open+0x10b/0x240 [bnxt_en]
 __dev_open+0xe9/0x180
 __dev_change_flags+0x1af/0x220
 dev_change_flags+0x21/0x60
 do_setlink+0x35c/0x1100

Instead of allocating this big chunk of memory and dividing it up for the
concurrent TPA instances, allocate each small chunk separately for each
TPA instance.  This will reduce it to order-0 allocations.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/16f3aae1aa2dd89bc8d073a67f190af580386ae9
  - https://git.kernel.org/stable/c/20fd0607acbf9770db9b99e3418dd75614f80b6c
  - https://git.kernel.org/stable/c/accd7e23693aaaa9aa0d3e9eca0ae77d1be80ab3
  - https://git.kernel.org/stable/c/ad529d1fae1565d38f929479d4ea8aea90054bd2
  - https://git.kernel.org/stable/c/d16701a385b54f44bf41ff1d7485e7a11080deb3
  - https://git.kernel.org/stable/c/fcae40e65802547def39b4deaa2ae38a29864d81

------------------------------------------------------------

CVE ID: CVE-2023-53135
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv: Use READ_ONCE_NOCHECK in imprecise unwinding stack mode

When CONFIG_FRAME_POINTER is unset, the stack unwinding function
walk_stackframe randomly reads the stack and then, when KASAN is enabled,
it can lead to the following backtrace:

[    0.000000] ==================================================================
[    0.000000] BUG: KASAN: stack-out-of-bounds in walk_stackframe+0xa6/0x11a
[    0.000000] Read of size 8 at addr ffffffff81807c40 by task swapper/0
[    0.000000]
[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 6.2.0-12919-g24203e6db61f #43
[    0.000000] Hardware name: riscv-virtio,qemu (DT)
[    0.000000] Call Trace:
[    0.000000] [<ffffffff80007ba8>] walk_stackframe+0x0/0x11a
[    0.000000] [<ffffffff80099ecc>] init_param_lock+0x26/0x2a
[    0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a
[    0.000000] [<ffffffff80c49c80>] dump_stack_lvl+0x22/0x36
[    0.000000] [<ffffffff80c3783e>] print_report+0x198/0x4a8
[    0.000000] [<ffffffff80099ecc>] init_param_lock+0x26/0x2a
[    0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a
[    0.000000] [<ffffffff8015f68a>] kasan_report+0x9a/0xc8
[    0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a
[    0.000000] [<ffffffff80007c4a>] walk_stackframe+0xa2/0x11a
[    0.000000] [<ffffffff8006e99c>] desc_make_final+0x80/0x84
[    0.000000] [<ffffffff8009a04e>] stack_trace_save+0x88/0xa6
[    0.000000] [<ffffffff80099fc2>] filter_irq_stacks+0x72/0x76
[    0.000000] [<ffffffff8006b95e>] devkmsg_read+0x32a/0x32e
[    0.000000] [<ffffffff8015ec16>] kasan_save_stack+0x28/0x52
[    0.000000] [<ffffffff8006e998>] desc_make_final+0x7c/0x84
[    0.000000] [<ffffffff8009a04a>] stack_trace_save+0x84/0xa6
[    0.000000] [<ffffffff8015ec52>] kasan_set_track+0x12/0x20
[    0.000000] [<ffffffff8015f22e>] __kasan_slab_alloc+0x58/0x5e
[    0.000000] [<ffffffff8015e7ea>] __kmem_cache_create+0x21e/0x39a
[    0.000000] [<ffffffff80e133ac>] create_boot_cache+0x70/0x9c
[    0.000000] [<ffffffff80e17ab2>] kmem_cache_init+0x6c/0x11e
[    0.000000] [<ffffffff80e00fd6>] mm_init+0xd8/0xfe
[    0.000000] [<ffffffff80e011d8>] start_kernel+0x190/0x3ca
[    0.000000]
[    0.000000] The buggy address belongs to stack of task swapper/0
[    0.000000]  and is located at offset 0 in frame:
[    0.000000]  stack_trace_save+0x0/0xa6
[    0.000000]
[    0.000000] This frame has 1 object:
[    0.000000]  [32, 56) 'c'
[    0.000000]
[    0.000000] The buggy address belongs to the physical page:
[    0.000000] page:(____ptrval____) refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x81a07
[    0.000000] flags: 0x1000(reserved|zone=0)
[    0.000000] raw: 0000000000001000 ff600003f1e3d150 ff600003f1e3d150 0000000000000000
[    0.000000] raw: 0000000000000000 0000000000000000 00000001ffffffff
[    0.000000] page dumped because: kasan: bad access detected
[    0.000000]
[    0.000000] Memory state around the buggy address:
[    0.000000]  ffffffff81807b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[    0.000000]  ffffffff81807b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[    0.000000] >ffffffff81807c00: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 00 f3
[    0.000000]                                            ^
[    0.000000]  ffffffff81807c80: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
[    0.000000]  ffffffff81807d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[    0.000000] ==================================================================

Fix that by using READ_ONCE_NOCHECK when reading the stack in imprecise
mode.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/17fa90ffba20743c946920fbb0afe160d0ead8c9
  - https://git.kernel.org/stable/c/324912d6c0c4006711054d389faa2239c1655e1e
  - https://git.kernel.org/stable/c/3a9418d2c93c1c86ce4d0595112d91c7a8e70c2c
  - https://git.kernel.org/stable/c/3de277af481ab931fab9e295ad8762692920732a
  - https://git.kernel.org/stable/c/76950340cf03b149412fe0d5f0810e52ac1df8cb
  - https://git.kernel.org/stable/c/a99a61d9e1bfca2fc37d223a6a185c0eb66aba02

------------------------------------------------------------

CVE ID: CVE-2023-53136
Description: In the Linux kernel, the following vulnerability has been resolved:

af_unix: fix struct pid leaks in OOB support

syzbot reported struct pid leak [1].

Issue is that queue_oob() calls maybe_add_creds() which potentially
holds a reference on a pid.

But skb->destructor is not set (either directly or by calling
unix_scm_to_skb())

This means that subsequent kfree_skb() or consume_skb() would leak
this reference.

In this fix, I chose to fully support scm even for the OOB message.

[1]
BUG: memory leak
unreferenced object 0xffff8881053e7f80 (size 128):
comm "syz-executor242", pid 5066, jiffies 4294946079 (age 13.220s)
hex dump (first 32 bytes):
01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
backtrace:
[<ffffffff812ae26a>] alloc_pid+0x6a/0x560 kernel/pid.c:180
[<ffffffff812718df>] copy_process+0x169f/0x26c0 kernel/fork.c:2285
[<ffffffff81272b37>] kernel_clone+0xf7/0x610 kernel/fork.c:2684
[<ffffffff812730cc>] __do_sys_clone+0x7c/0xb0 kernel/fork.c:2825
[<ffffffff849ad699>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]
[<ffffffff849ad699>] do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
[<ffffffff84a0008b>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2aab4b96900272885bc157f8b236abf1cdc02e08
  - https://git.kernel.org/stable/c/a59d6306263c38e5c0592ea4451ca26a0778c947
  - https://git.kernel.org/stable/c/ac1968ac399205fda9ee3b18f7de7416cb3a5d0d
  - https://git.kernel.org/stable/c/f3969427fb06a2c3cd6efd7faab63505cfa76e76

------------------------------------------------------------

CVE ID: CVE-2023-53137
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: Fix possible corruption when moving a directory

When we are renaming a directory to a different directory, we need to
update '..' entry in the moved directory. However nothing prevents moved
directory from being modified and even converted from the inline format
to the normal format. When such race happens the rename code gets
confused and we crash. Fix the problem by locking the moved directory.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0813299c586b175d7edb25f56412c54b812d0379
  - https://git.kernel.org/stable/c/0c440f14558bfacd22c6935ae1fd4b2a09e96b5d
  - https://git.kernel.org/stable/c/291cd19d107e197306869cb3237c1bba62d13182
  - https://git.kernel.org/stable/c/8dac5a63cf79707b547ea3d425fead5f4482198f
  - https://git.kernel.org/stable/c/b0bb13612292ca90fa4c2a7e425375649bc50d3e
  - https://git.kernel.org/stable/c/c50fc503ee1b97f12c98e26afc39fdaebebcf04f

------------------------------------------------------------

CVE ID: CVE-2023-53138
Description: In the Linux kernel, the following vulnerability has been resolved:

net: caif: Fix use-after-free in cfusbl_device_notify()

syzbot reported use-after-free in cfusbl_device_notify() [1].  This
causes a stack trace like below:

BUG: KASAN: use-after-free in cfusbl_device_notify+0x7c9/0x870 net/caif/caif_usb.c:138
Read of size 8 at addr ffff88807ac4e6f0 by task kworker/u4:6/1214

CPU: 0 PID: 1214 Comm: kworker/u4:6 Not tainted 5.19.0-rc3-syzkaller-00146-g92f20ff72066 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
Workqueue: netns cleanup_net
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
 print_address_description.constprop.0.cold+0xeb/0x467 mm/kasan/report.c:313
 print_report mm/kasan/report.c:429 [inline]
 kasan_report.cold+0xf4/0x1c6 mm/kasan/report.c:491
 cfusbl_device_notify+0x7c9/0x870 net/caif/caif_usb.c:138
 notifier_call_chain+0xb5/0x200 kernel/notifier.c:87
 call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:1945
 call_netdevice_notifiers_extack net/core/dev.c:1983 [inline]
 call_netdevice_notifiers net/core/dev.c:1997 [inline]
 netdev_wait_allrefs_any net/core/dev.c:10227 [inline]
 netdev_run_todo+0xbc0/0x10f0 net/core/dev.c:10341
 default_device_exit_batch+0x44e/0x590 net/core/dev.c:11334
 ops_exit_list+0x125/0x170 net/core/net_namespace.c:167
 cleanup_net+0x4ea/0xb00 net/core/net_namespace.c:594
 process_one_work+0x996/0x1610 kernel/workqueue.c:2289
 worker_thread+0x665/0x1080 kernel/workqueue.c:2436
 kthread+0x2e9/0x3a0 kernel/kthread.c:376
 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:302
 </TASK>

When unregistering a net device, unregister_netdevice_many_notify()
sets the device's reg_state to NETREG_UNREGISTERING, calls notifiers
with NETDEV_UNREGISTER, and adds the device to the todo list.

Later on, devices in the todo list are processed by netdev_run_todo().
netdev_run_todo() waits devices' reference count become 1 while
rebdoadcasting NETDEV_UNREGISTER notification.

When cfusbl_device_notify() is called with NETDEV_UNREGISTER multiple
times, the parent device might be freed.  This could cause UAF.
Processing NETDEV_UNREGISTER multiple times also causes inbalance of
reference count for the module.

This patch fixes the issue by accepting only first NETDEV_UNREGISTER
notification.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1793da97a23e31c5bf06631f3f3e5a25f368fd64
  - https://git.kernel.org/stable/c/287027d8a567168a5d8ce5cb0cba16a34791a48c
  - https://git.kernel.org/stable/c/3f14457e1584224f4296af613bbd99deb60b5d91
  - https://git.kernel.org/stable/c/68a45c3cf0e2242a533657f4f535d9b6a7447a79
  - https://git.kernel.org/stable/c/9781e98a97110f5e76999058368b4be76a788484
  - https://git.kernel.org/stable/c/9dc16be373b382ddd4c274052a6e870a95e76c01
  - https://git.kernel.org/stable/c/c3aaec463a632cf4187dc017e421bfa69d7834a9
  - https://git.kernel.org/stable/c/d1a11bbdbb5ea9f172019c5a4a3e9d8eabd72179

------------------------------------------------------------

CVE ID: CVE-2023-53139
Description: In the Linux kernel, the following vulnerability has been resolved:

nfc: fdp: add null check of devm_kmalloc_array in fdp_nci_i2c_read_device_properties

devm_kmalloc_array may fails, *fw_vsc_cfg might be null and cause
out-of-bounds write in device_property_read_u8_array later.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0a3664a1058d4b2b1ea2112cc275ca47fba7fc08
  - https://git.kernel.org/stable/c/11f180a5d62a51b484e9648f9b310e1bd50b1a57
  - https://git.kernel.org/stable/c/27824b2f98818215adc9661e563252c48dab1a13
  - https://git.kernel.org/stable/c/4357bbb921fe9e81d0fd9f70d669d1f177d8380e
  - https://git.kernel.org/stable/c/80be62358fa5507cefbaa067c7e6648401f2c3da
  - https://git.kernel.org/stable/c/98f49e693e02c1dafd5786be3468657840dd6f06
  - https://git.kernel.org/stable/c/ad11b872bc9b5d27e56183c6b01f9218c85395d2
  - https://git.kernel.org/stable/c/ce93f1afc05941a572f5a69e2ed4012af905a693

------------------------------------------------------------

CVE ID: CVE-2023-53140
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: core: Remove the /proc/scsi/${proc_name} directory earlier

Remove the /proc/scsi/${proc_name} directory earlier to fix a race
condition between unloading and reloading kernel modules. This fixes a bug
introduced in 2009 by commit 77c019768f06 ("[SCSI] fix /proc memory leak in
the SCSI core").

Fix the following kernel warning:

proc_dir_entry 'scsi/scsi_debug' already registered
WARNING: CPU: 19 PID: 27986 at fs/proc/generic.c:376 proc_register+0x27d/0x2e0
Call Trace:
 proc_mkdir+0xb5/0xe0
 scsi_proc_hostdir_add+0xb5/0x170
 scsi_host_alloc+0x683/0x6c0
 sdebug_driver_probe+0x6b/0x2d0 [scsi_debug]
 really_probe+0x159/0x540
 __driver_probe_device+0xdc/0x230
 driver_probe_device+0x4f/0x120
 __device_attach_driver+0xef/0x180
 bus_for_each_drv+0xe5/0x130
 __device_attach+0x127/0x290
 device_initial_probe+0x17/0x20
 bus_probe_device+0x110/0x130
 device_add+0x673/0xc80
 device_register+0x1e/0x30
 sdebug_add_host_helper+0x1a7/0x3b0 [scsi_debug]
 scsi_debug_init+0x64f/0x1000 [scsi_debug]
 do_one_initcall+0xd7/0x470
 do_init_module+0xe7/0x330
 load_module+0x122a/0x12c0
 __do_sys_finit_module+0x124/0x1a0
 __x64_sys_finit_module+0x46/0x50
 do_syscall_64+0x38/0x80
 entry_SYSCALL_64_after_hwframe+0x46/0xb0
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/13daafe1e209b03e9bda16ff2bd2b2da145a139b
  - https://git.kernel.org/stable/c/17e98a5ede81b7696bec421f7afa2dfe467f5e6b
  - https://git.kernel.org/stable/c/1ec363599f8346d5a8d08c71a0d9860d6c420ec0
  - https://git.kernel.org/stable/c/6b223e32d66ca9db1f252f433514783d8b22a8e1
  - https://git.kernel.org/stable/c/891a3cba425cf483d96facca55aebd6ff1da4338
  - https://git.kernel.org/stable/c/e471e928de97b00f297ad1015cc14f9459765713
  - https://git.kernel.org/stable/c/fc663711b94468f4e1427ebe289c9f05669699c9

------------------------------------------------------------

CVE ID: CVE-2023-53141
Description: In the Linux kernel, the following vulnerability has been resolved:

ila: do not generate empty messages in ila_xlat_nl_cmd_get_mapping()

ila_xlat_nl_cmd_get_mapping() generates an empty skb,
triggerring a recent sanity check [1].

Instead, return an error code, so that user space
can get it.

[1]
skb_assert_len
WARNING: CPU: 0 PID: 5923 at include/linux/skbuff.h:2527 skb_assert_len include/linux/skbuff.h:2527 [inline]
WARNING: CPU: 0 PID: 5923 at include/linux/skbuff.h:2527 __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156
Modules linked in:
CPU: 0 PID: 5923 Comm: syz-executor269 Not tainted 6.2.0-syzkaller-18300-g2ebd1fbb946d #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023
pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : skb_assert_len include/linux/skbuff.h:2527 [inline]
pc : __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156
lr : skb_assert_len include/linux/skbuff.h:2527 [inline]
lr : __dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156
sp : ffff80001e0d6c40
x29: ffff80001e0d6e60 x28: dfff800000000000 x27: ffff0000c86328c0
x26: dfff800000000000 x25: ffff0000c8632990 x24: ffff0000c8632a00
x23: 0000000000000000 x22: 1fffe000190c6542 x21: ffff0000c8632a10
x20: ffff0000c8632a00 x19: ffff80001856e000 x18: ffff80001e0d5fc0
x17: 0000000000000000 x16: ffff80001235d16c x15: 0000000000000000
x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000001
x11: ff80800008353a30 x10: 0000000000000000 x9 : 21567eaf25bfb600
x8 : 21567eaf25bfb600 x7 : 0000000000000001 x6 : 0000000000000001
x5 : ffff80001e0d6558 x4 : ffff800015c74760 x3 : ffff800008596744
x2 : 0000000000000001 x1 : 0000000100000000 x0 : 000000000000000e
Call trace:
skb_assert_len include/linux/skbuff.h:2527 [inline]
__dev_queue_xmit+0x1bc0/0x3488 net/core/dev.c:4156
dev_queue_xmit include/linux/netdevice.h:3033 [inline]
__netlink_deliver_tap_skb net/netlink/af_netlink.c:307 [inline]
__netlink_deliver_tap+0x45c/0x6f8 net/netlink/af_netlink.c:325
netlink_deliver_tap+0xf4/0x174 net/netlink/af_netlink.c:338
__netlink_sendskb net/netlink/af_netlink.c:1283 [inline]
netlink_sendskb+0x6c/0x154 net/netlink/af_netlink.c:1292
netlink_unicast+0x334/0x8d4 net/netlink/af_netlink.c:1380
nlmsg_unicast include/net/netlink.h:1099 [inline]
genlmsg_unicast include/net/genetlink.h:433 [inline]
genlmsg_reply include/net/genetlink.h:443 [inline]
ila_xlat_nl_cmd_get_mapping+0x620/0x7d0 net/ipv6/ila/ila_xlat.c:493
genl_family_rcv_msg_doit net/netlink/genetlink.c:968 [inline]
genl_family_rcv_msg net/netlink/genetlink.c:1048 [inline]
genl_rcv_msg+0x938/0xc1c net/netlink/genetlink.c:1065
netlink_rcv_skb+0x214/0x3c4 net/netlink/af_netlink.c:2574
genl_rcv+0x38/0x50 net/netlink/genetlink.c:1076
netlink_unicast_kernel net/netlink/af_netlink.c:1339 [inline]
netlink_unicast+0x660/0x8d4 net/netlink/af_netlink.c:1365
netlink_sendmsg+0x800/0xae0 net/netlink/af_netlink.c:1942
sock_sendmsg_nosec net/socket.c:714 [inline]
sock_sendmsg net/socket.c:734 [inline]
____sys_sendmsg+0x558/0x844 net/socket.c:2479
___sys_sendmsg net/socket.c:2533 [inline]
__sys_sendmsg+0x26c/0x33c net/socket.c:2562
__do_sys_sendmsg net/socket.c:2571 [inline]
__se_sys_sendmsg net/socket.c:2569 [inline]
__arm64_sys_sendmsg+0x80/0x94 net/socket.c:2569
__invoke_syscall arch/arm64/kernel/syscall.c:38 [inline]
invoke_syscall+0x98/0x2c0 arch/arm64/kernel/syscall.c:52
el0_svc_common+0x138/0x258 arch/arm64/kernel/syscall.c:142
do_el0_svc+0x64/0x198 arch/arm64/kernel/syscall.c:193
el0_svc+0x58/0x168 arch/arm64/kernel/entry-common.c:637
el0t_64_sync_handler+0x84/0xf0 arch/arm64/kernel/entry-common.c:655
el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:591
irq event stamp: 136484
hardirqs last enabled at (136483): [<ffff800008350244>] __up_console_sem+0x60/0xb4 kernel/printk/printk.c:345
hardirqs last disabled at (136484): [<ffff800012358d60>] el1_dbg+0x24/0x80 arch/arm64/kernel/entry-common.c:405
softirqs last enabled at (136418): [<ffff800008020ea8>] softirq_ha
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/25b54f247ea060aeb85ec88a82c75060fca03521
  - https://git.kernel.org/stable/c/42d9ed4e5dc5f87fbd67c232e2e4a9b88ceeb47f
  - https://git.kernel.org/stable/c/60fe7cb483c8c5dcadaeeac867251d6e59c7badc
  - https://git.kernel.org/stable/c/693aa2c0d9b6d5b1f2745d31b6e70d09dbbaf06e
  - https://git.kernel.org/stable/c/783f218940b3c7b872e4111d0145000f26ecbdf6
  - https://git.kernel.org/stable/c/91aceb3844d4aec555c7f423f9fd843eff5835e9
  - https://git.kernel.org/stable/c/b26bc5861505f04dea933ca3e522772b20fa086f
  - https://git.kernel.org/stable/c/c631e52aea0fc8d4deea06e439f5810a8b40ad0f

------------------------------------------------------------

CVE ID: CVE-2023-53142
Description: In the Linux kernel, the following vulnerability has been resolved:

ice: copy last block omitted in ice_get_module_eeprom()

ice_get_module_eeprom() is broken since commit e9c9692c8a81 ("ice:
Reimplement module reads used by ethtool") In this refactor,
ice_get_module_eeprom() reads the eeprom in blocks of size 8.
But the condition that should protect the buffer overflow
ignores the last block. The last block always contains zeros.

Bug uncovered by ethtool upstream commit 9538f384b535
("netlink: eeprom: Defer page requests to individual parsers")
After this commit, ethtool reads a block with length = 1;
to read the SFF-8024 identifier value.

unpatched driver:
$ ethtool -m enp65s0f0np0 offset 0x90 length 8
Offset          Values
------          ------
0x0090:         00 00 00 00 00 00 00 00
$ ethtool -m enp65s0f0np0 offset 0x90 length 12
Offset          Values
------          ------
0x0090:         00 00 01 a0 4d 65 6c 6c 00 00 00 00
$

$ ethtool -m enp65s0f0np0
Offset          Values
------          ------
0x0000:         11 06 06 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0010:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0020:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0030:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0040:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0050:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0060:         00 00 00 00 00 00 00 00 00 00 00 00 00 01 08 00
0x0070:         00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00

patched driver:
$ ethtool -m enp65s0f0np0 offset 0x90 length 8
Offset          Values
------          ------
0x0090:         00 00 01 a0 4d 65 6c 6c
$ ethtool -m enp65s0f0np0 offset 0x90 length 12
Offset          Values
------          ------
0x0090:         00 00 01 a0 4d 65 6c 6c 61 6e 6f 78
$ ethtool -m enp65s0f0np0
    Identifier                                : 0x11 (QSFP28)
    Extended identifier                       : 0x00
    Extended identifier description           : 1.5W max. Power consumption
    Extended identifier description           : No CDR in TX, No CDR in RX
    Extended identifier description           : High Power Class (> 3.5 W) not enabled
    Connector                                 : 0x23 (No separable connector)
    Transceiver codes                         : 0x88 0x00 0x00 0x00 0x00 0x00 0x00 0x00
    Transceiver type                          : 40G Ethernet: 40G Base-CR4
    Transceiver type                          : 25G Ethernet: 25G Base-CR CA-N
    Encoding                                  : 0x05 (64B/66B)
    BR, Nominal                               : 25500Mbps
    Rate identifier                           : 0x00
    Length (SMF,km)                           : 0km
    Length (OM3 50um)                         : 0m
    Length (OM2 50um)                         : 0m
    Length (OM1 62.5um)                       : 0m
    Length (Copper or Active cable)           : 1m
    Transmitter technology                    : 0xa0 (Copper cable unequalized)
    Attenuation at 2.5GHz                     : 4db
    Attenuation at 5.0GHz                     : 5db
    Attenuation at 7.0GHz                     : 7db
    Attenuation at 12.9GHz                    : 10db
    ........
    ....
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/84cba1840e68430325ac133a11be06bfb2f7acd8
  - https://git.kernel.org/stable/c/8cfbdda65588e75bfbd93e5ee847efcb4796ad09
  - https://git.kernel.org/stable/c/90b40ab29298db3a4879c1d3c4e685184386bce6
  - https://git.kernel.org/stable/c/c813f7a3161481483ae2077651b21bc217c419e0

------------------------------------------------------------

CVE ID: CVE-2023-53143
Description: In the Linux kernel, the following vulnerability has been resolved:

ext4: fix another off-by-one fsmap error on 1k block filesystems

Apparently syzbot figured out that issuing this FSMAP call:

struct fsmap_head cmd = {
	.fmh_count	= ...;
	.fmh_keys	= {
		{ .fmr_device = /* ext4 dev */, .fmr_physical = 0, },
		{ .fmr_device = /* ext4 dev */, .fmr_physical = 0, },
	},
...
};
ret = ioctl(fd, FS_IOC_GETFSMAP, &cmd);

Produces this crash if the underlying filesystem is a 1k-block ext4
filesystem:

kernel BUG at fs/ext4/ext4.h:3331!
invalid opcode: 0000 [#1] PREEMPT SMP
CPU: 3 PID: 3227965 Comm: xfs_io Tainted: G        W  O       6.2.0-rc8-achx
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014
RIP: 0010:ext4_mb_load_buddy_gfp+0x47c/0x570 [ext4]
RSP: 0018:ffffc90007c03998 EFLAGS: 00010246
RAX: ffff888004978000 RBX: ffffc90007c03a20 RCX: ffff888041618000
RDX: 0000000000000000 RSI: 00000000000005a4 RDI: ffffffffa0c99b11
RBP: ffff888012330000 R08: ffffffffa0c2b7d0 R09: 0000000000000400
R10: ffffc90007c03950 R11: 0000000000000000 R12: 0000000000000001
R13: 00000000ffffffff R14: 0000000000000c40 R15: ffff88802678c398
FS:  00007fdf2020c880(0000) GS:ffff88807e100000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007ffd318a5fe8 CR3: 000000007f80f001 CR4: 00000000001706e0
Call Trace:
 <TASK>
 ext4_mballoc_query_range+0x4b/0x210 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]
 ext4_getfsmap_datadev+0x713/0x890 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]
 ext4_getfsmap+0x2b7/0x330 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]
 ext4_ioc_getfsmap+0x153/0x2b0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]
 __ext4_ioctl+0x2a7/0x17e0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]
 __x64_sys_ioctl+0x82/0xa0
 do_syscall_64+0x2b/0x80
 entry_SYSCALL_64_after_hwframe+0x46/0xb0
RIP: 0033:0x7fdf20558aff
RSP: 002b:00007ffd318a9e30 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00000000000200c0 RCX: 00007fdf20558aff
RDX: 00007fdf1feb2010 RSI: 00000000c0c0583b RDI: 0000000000000003
RBP: 00005625c0634be0 R08: 00005625c0634c40 R09: 0000000000000001
R10: 0000000000000000 R11: 0000000000000246 R12: 00007fdf1feb2010
R13: 00005625be70d994 R14: 0000000000000800 R15: 0000000000000000

For GETFSMAP calls, the caller selects a physical block device by
writing its block number into fsmap_head.fmh_keys[01].fmr_device.
To query mappings for a subrange of the device, the starting byte of the
range is written to fsmap_head.fmh_keys[0].fmr_physical and the last
byte of the range goes in fsmap_head.fmh_keys[1].fmr_physical.

IOWs, to query what mappings overlap with bytes 3-14 of /dev/sda, you'd
set the inputs as follows:

	fmh_keys[0] = { .fmr_device = major(8, 0), .fmr_physical = 3},
	fmh_keys[1] = { .fmr_device = major(8, 0), .fmr_physical = 14},

Which would return you whatever is mapped in the 12 bytes starting at
physical offset 3.

The crash is due to insufficient range validation of keys[1] in
ext4_getfsmap_datadev.  On 1k-block filesystems, block 0 is not part of
the filesystem, which means that s_first_data_block is nonzero.
ext4_get_group_no_and_offset subtracts this quantity from the blocknr
argument before cracking it into a group number and a block number
within a group.  IOWs, block group 0 spans blocks 1-8192 (1-based)
instead of 0-8191 (0-based) like what happens with larger blocksizes.

The net result of this encoding is that blocknr < s_first_data_block is
not a valid input to this function.  The end_fsb variable is set from
the keys that are copied from userspace, which means that in the above
example, its value is zero.  That leads to an underflow here:

	blocknr = blocknr - le32_to_cpu(es->s_first_data_block);

The division then operates on -1:

	offset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>
		EXT4_SB(sb)->s_cluster_bits;

Leaving an impossibly large group number (2^32-1) in blocknr.
ext4_getfsmap_check_keys checked that keys[0
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/15ebade3266b300da9cd1edce4004fe8fd6a2b88
  - https://git.kernel.org/stable/c/1d2366624b4c19a2ba6baf67fe57f4a1b0f67c05
  - https://git.kernel.org/stable/c/a70b49dc7eee5dbe3775a650ce598e3557ff5475
  - https://git.kernel.org/stable/c/c24f838493792b5e78a3596b4ca96375aa0af4c2
  - https://git.kernel.org/stable/c/c5d7c31e17224d847a330180ec1b03bf390632b2
  - https://git.kernel.org/stable/c/c993799baf9c5861f8df91beb80e1611b12efcbd
  - https://git.kernel.org/stable/c/eb3a695aa71a514f2e7f5778e05faba3733b70a0
  - https://git.kernel.org/stable/c/f16054ac1774915160ca4e1c73ff7a269465a1b9

------------------------------------------------------------

CVE ID: CVE-2023-53144
Description: In the Linux kernel, the following vulnerability has been resolved:

erofs: fix wrong kunmap when using LZMA on HIGHMEM platforms

As the call trace shown, the root cause is kunmap incorrect pages:

 BUG: kernel NULL pointer dereference, address: 00000000
 CPU: 1 PID: 40 Comm: kworker/u5:0 Not tainted 6.2.0-rc5 #4
 Workqueue: erofs_worker z_erofs_decompressqueue_work
 EIP: z_erofs_lzma_decompress+0x34b/0x8ac
  z_erofs_decompress+0x12/0x14
  z_erofs_decompress_queue+0x7e7/0xb1c
  z_erofs_decompressqueue_work+0x32/0x60
  process_one_work+0x24b/0x4d8
  ? process_one_work+0x1a4/0x4d8
  worker_thread+0x14c/0x3fc
  kthread+0xe6/0x10c
  ? rescuer_thread+0x358/0x358
  ? kthread_complete_and_exit+0x18/0x18
  ret_from_fork+0x1c/0x28
 ---[ end trace 0000000000000000 ]---

The bug is trivial and should be fixed now.  It has no impact on
!HIGHMEM platforms.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28aea8ae6cf212a5bf3ed962b27921e2029ad754
  - https://git.kernel.org/stable/c/8f121dfb15f7b4ab345992ce96003eb63fd608f4
  - https://git.kernel.org/stable/c/fa4056781ac067b5946c6811459e1a36842047fd

------------------------------------------------------------

CVE ID: CVE-2022-21546
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: target: Fix WRITE_SAME No Data Buffer crash

In newer version of the SBC specs, we have a NDOB bit that indicates there
is no data buffer that gets written out. If this bit is set using commands
like "sg_write_same --ndob" we will crash in target_core_iblock/file's
execute_write_same handlers when we go to access the se_cmd->t_data_sg
because its NULL.

This patch adds a check for the NDOB bit in the common WRITE SAME code
because we don't support it. And, it adds a check for zero SG elements in
each handler in case the initiator tries to send a normal WRITE SAME with
no data buffer.
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.7
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4226622647e3e5ac06d3ebc1605b917446157510
  - https://git.kernel.org/stable/c/ccd3f449052449a917a3e577d8ba0368f43b8f29
  - https://git.kernel.org/linus/ccd3f449052449a917a3e577d8ba0368f43b8f29
  - https://linux.oracle.com/cve/CVE-2022-21546.html
  - https://lore.kernel.org/all/20220628022325.14627-2-michael.christie@oracle.com/

------------------------------------------------------------

CVE ID: CVE-2025-37799
Description: In the Linux kernel, the following vulnerability has been resolved:

vmxnet3: Fix malformed packet sizing in vmxnet3_process_xdp

vmxnet3 driver's XDP handling is buggy for packet sizes using ring0 (that
is, packet sizes between 128 - 3k bytes).

We noticed MTU-related connectivity issues with Cilium's service load-
balancing in case of vmxnet3 as NIC underneath. A simple curl to a HTTP
backend service where the XDP LB was doing IPIP encap led to overly large
packet sizes but only for *some* of the packets (e.g. HTTP GET request)
while others (e.g. the prior TCP 3WHS) looked completely fine on the wire.

In fact, the pcap recording on the backend node actually revealed that the
node with the XDP LB was leaking uninitialized kernel data onto the wire
for the affected packets, for example, while the packets should have been
152 bytes their actual size was 1482 bytes, so the remainder after 152 bytes
was padded with whatever other data was in that page at the time (e.g. we
saw user/payload data from prior processed packets).

We only noticed this through an MTU issue, e.g. when the XDP LB node and
the backend node both had the same MTU (e.g. 1500) then the curl request
got dropped on the backend node's NIC given the packet was too large even
though the IPIP-encapped packet normally would never even come close to
the MTU limit. Lowering the MTU on the XDP LB (e.g. 1480) allowed to let
the curl request succeed (which also indicates that the kernel ignored the
padding, and thus the issue wasn't very user-visible).

Commit e127ce7699c1 ("vmxnet3: Fix missing reserved tailroom") was too eager
to also switch xdp_prepare_buff() from rcd->len to rbi->len. It really needs
to stick to rcd->len which is the actual packet length from the descriptor.
The latter we also feed into vmxnet3_process_xdp_small(), by the way, and
it indicates the correct length needed to initialize the xdp->{data,data_end}
parts. For e127ce7699c1 ("vmxnet3: Fix missing reserved tailroom") the
relevant part was adapting xdp_init_buff() to address the warning given the
xdp_data_hard_end() depends on xdp->frame_sz. With that fixed, traffic on
the wire looks good again.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/33e131a10459d16f181c8184d3f17f1c318c7002
  - https://git.kernel.org/stable/c/4c2227656d9003f4d77afc76f34dd81b95e4c2c4
  - https://git.kernel.org/stable/c/c4312c4d244aa58e811ff0297e013124d115e793
  - https://git.kernel.org/stable/c/e3ad76e36a37b0ff4a71b06d5b33530ee8c3a177

------------------------------------------------------------

CVE ID: CVE-2024-58098
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: track changes_pkt_data property for global functions

When processing calls to certain helpers, verifier invalidates all
packet pointers in a current state. For example, consider the
following program:

    __attribute__((__noinline__))
    long skb_pull_data(struct __sk_buff *sk, __u32 len)
    {
        return bpf_skb_pull_data(sk, len);
    }

    SEC("tc")
    int test_invalidate_checks(struct __sk_buff *sk)
    {
        int *p = (void *)(long)sk->data;
        if ((void *)(p + 1) > (void *)(long)sk->data_end) return TCX_DROP;
        skb_pull_data(sk, 0);
        *p = 42;
        return TCX_PASS;
    }

After a call to bpf_skb_pull_data() the pointer 'p' can't be used
safely. See function filter.c:bpf_helper_changes_pkt_data() for a list
of such helpers.

At the moment verifier invalidates packet pointers when processing
helper function calls, and does not traverse global sub-programs when
processing calls to global sub-programs. This means that calls to
helpers done from global sub-programs do not invalidate pointers in
the caller state. E.g. the program above is unsafe, but is not
rejected by verifier.

This commit fixes the omission by computing field
bpf_subprog_info->changes_pkt_data for each sub-program before main
verification pass.
changes_pkt_data should be set if:
- subprogram calls helper for which bpf_helper_changes_pkt_data
  returns true;
- subprogram calls a global function,
  for which bpf_subprog_info->changes_pkt_data should be set.

The verifier.c:check_cfg() pass is modified to compute this
information. The commit relies on depth first instruction traversal
done by check_cfg() and absence of recursive function calls:
- check_cfg() would eventually visit every call to subprogram S in a
  state when S is fully explored;
- when S is fully explored:
  - every direct helper call within S is explored
    (and thus changes_pkt_data is set if needed);
  - every call to subprogram S1 called by S was visited with S1 fully
    explored (and thus S inherits changes_pkt_data from S1).

The downside of such approach is that dead code elimination is not
taken into account: if a helper call inside global function is dead
because of current configuration, verifier would conservatively assume
that the call occurs for the purpose of the changes_pkt_data
computation.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d572c60488b52882b719ed273767ee3b280413d
  - https://git.kernel.org/stable/c/51081a3f25c742da5a659d7fc6fd77ebfdd555be
  - https://git.kernel.org/stable/c/79751e9227a5910c0e5a2c7186877d91821d957d

------------------------------------------------------------

CVE ID: CVE-2024-58100
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: check changes_pkt_data property for extension programs

When processing calls to global sub-programs, verifier decides whether
to invalidate all packet pointers in current state depending on the
changes_pkt_data property of the global sub-program.

Because of this, an extension program replacing a global sub-program
must be compatible with changes_pkt_data property of the sub-program
being replaced.

This commit:
- adds changes_pkt_data flag to struct bpf_prog_aux:
  - this flag is set in check_cfg() for main sub-program;
  - in jit_subprogs() for other sub-programs;
- modifies bpf_check_attach_btf_id() to check changes_pkt_data flag;
- moves call to check_attach_btf_id() after the call to check_cfg(),
  because it needs changes_pkt_data flag to be set:

    bpf_check:
      ...                             ...
    - check_attach_btf_id             resolve_pseudo_ldimm64
      resolve_pseudo_ldimm64   -->    bpf_prog_is_offloaded
      bpf_prog_is_offloaded           check_cfg
      check_cfg                     + check_attach_btf_id
      ...                             ...

The following fields are set by check_attach_btf_id():
- env->ops
- prog->aux->attach_btf_trace
- prog->aux->attach_func_name
- prog->aux->attach_func_proto
- prog->aux->dst_trampoline
- prog->aux->mod
- prog->aux->saved_dst_attach_type
- prog->aux->saved_dst_prog_type
- prog->expected_attach_type

Neither of these fields are used by resolve_pseudo_ldimm64() or
bpf_prog_offload_verifier_prep() (for netronome and netdevsim
drivers), so the reordering is safe.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3846e2bea565ee1c5195dcc625fda9868fb0e3b3
  - https://git.kernel.org/stable/c/7197fc4acdf238ec8ad06de5a8235df0c1f9c7d7
  - https://git.kernel.org/stable/c/81f6d0530ba031b5f038a091619bf2ff29568852

------------------------------------------------------------

CVE ID: CVE-2024-58237
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: consider that tail calls invalidate packet pointers

Tail-called programs could execute any of the helpers that invalidate
packet pointers. Hence, conservatively assume that each tail call
invalidates packet pointers.

Making the change in bpf_helper_changes_pkt_data() automatically makes
use of check_cfg() logic that computes 'changes_pkt_data' effect for
global sub-programs, such that the following program could be
rejected:

    int tail_call(struct __sk_buff *sk)
    {
    	bpf_tail_call_static(sk, &jmp_table, 0);
    	return 0;
    }

    SEC("tc")
    int not_safe(struct __sk_buff *sk)
    {
    	int *p = (void *)(long)sk->data;
    	... make p valid ...
    	tail_call(sk);
    	*p = 42; /* this is unsafe */
    	...
    }

The tc_bpf2bpf.c:subprog_tc() needs change: mark it as a function that
can invalidate packet pointers. Otherwise, it can't be freplaced with
tailcall_freplace.c:entry_freplace() that does a tail call.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1a4607ffba35bf2a630aab299e34dd3f6e658d70
  - https://git.kernel.org/stable/c/1c2244437f9ad3dd91215f920401a14f2542dbfc
  - https://git.kernel.org/stable/c/f1692ee23dcaaddc24ba407b269707ee5df1301f

------------------------------------------------------------

CVE ID: CVE-2025-1992
Description: IBM Db2 for Linux, UNIX and Windows (includes DB2 Connect Server) 11.5.0 through 11.5.9 and 12.1.0 through 12.1.1 could allow an authenticated user, under non default configurations, to cause a denial of service due to insufficient release of allocated memory after usage.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://www.ibm.com/support/pages/node/7232515

------------------------------------------------------------

CVE ID: CVE-2025-0915
Description: IBM Db2 for Linux, UNIX and Windows (includes DB2 Connect Server) 11.5.0 through 11.5.9 and 12.1.0 through 12.1.1 



under specific configurations could allow an authenticated user to cause a denial of service due to insufficient release of allocated memory resources.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://www.ibm.com/support/pages/node/7232529

------------------------------------------------------------

CVE ID: CVE-2025-1000
Description: IBM Db2 for Linux, UNIX and Windows (includes DB2 Connect Server) 11.5.0 through 11.5.9 and 12.1.0 through 12.1.1 

could allow an authenticated user to cause a denial of service when connecting to a z/OS database due to improper handling of automatic client rerouting.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://www.ibm.com/support/pages/node/7232528

------------------------------------------------------------

CVE ID: CVE-2025-1493
Description: IBM Db2 for Linux, UNIX and Windows (includes DB2 Connect Server) 12.1.0 through 12.1.1 





could allow an authenticated user to cause a denial of service due to concurrent execution of shared resources.
Severity:
  - CVSS Version: 3.1
  - Base Score: 5.3
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H
CPEs:
  - No CPE data available.
References:
  - https://www.ibm.com/support/pages/node/7232518

------------------------------------------------------------

CVE ID: CVE-2025-26262
Description: An issue in the component /internals/functions of R-fx Networks Linux Malware Detect v1.6.5 allows attackers to escalate privileges and execute arbitrary code via supplying a file that contains a crafted filename.
Severity:
  - CVSS Version: 3.1
  - Base Score: 6.5
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N
CPEs:
  - No CPE data available.
References:
  - https://github.com/rfxn/linux-malware-detect
  - https://github.com/rfxn/linux-malware-detect/blob/master/CHANGELOG

------------------------------------------------------------

CVE ID: CVE-2025-32022
Description: Finit provides fast init for Linux systems. Finit's urandom plugin has a heap buffer overwrite vulnerability at boot which leads to it overwriting other parts of the heap, possibly causing random instabilities and undefined behavior. The urandom plugin is enabled by default, so this bug affects everyone using Finit 4.2 or later that do not explicitly disable the plugin at build time. This bug is fixed in Finit 4.12. Those who cannot upgrade or backport the fix to urandom.c are strongly recommended to disable the plugin in the call to the `configure` script.
Severity:
  - CVSS Version: 3.1
  - Base Score: 4.6
  - Base Severity: MEDIUM
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:N/I:H/A:L
CPEs:
  - No CPE data available.
References:
  - https://github.com/troglobit/finit/commit/3feff37ba51fa0a6a0a06f59682a0918aa5b04de
  - https://github.com/troglobit/finit/security/advisories/GHSA-fv6v-vw8h-9x79

------------------------------------------------------------

CVE ID: CVE-2020-36791
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: keep alloc_hash updated after hash allocation

In commit 599be01ee567 ("net_sched: fix an OOB access in cls_tcindex")
I moved cp->hash calculation before the first
tcindex_alloc_perfect_hash(), but cp->alloc_hash is left untouched.
This difference could lead to another out of bound access.

cp->alloc_hash should always be the size allocated, we should
update it after this tcindex_alloc_perfect_hash().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://blog.cdthoughts.ch/2021/03/16/syzbot-bug.html
  - https://git.kernel.org/stable/c/0d1c3530e1bd38382edef72591b78e877e0edcd3
  - https://git.kernel.org/stable/c/557d015ffb27b672e24e6ad141fd887783871dc2
  - https://git.kernel.org/stable/c/9f8b6c44be178c2498a00b270872a6e30e7c8266
  - https://git.kernel.org/stable/c/bd3ee8fb6371b45c71c9345cc359b94da2ddefa9
  - https://git.kernel.org/stable/c/c4453d2833671e3a9f6bd52f0f581056c3736386
  - https://git.kernel.org/stable/c/d23faf32e577922b6da20bf3740625c1105381bf
  - https://git.kernel.org/stable/c/d6cdc5bb19b595486fb2e6661e5138d73a57f454
  - https://syzkaller.appspot.com/bug?id=ea260693da894e7b078d18fca2c9c0a19b457534

------------------------------------------------------------

CVE ID: CVE-2025-26168
Description: IXON VPN Client before 1.4.4 on Linux and macOS allows Local Privilege Escalation to root because there is code execution from a configuration file that can be controlled by a low-privileged user. There is a race condition in which a temporary configuration file, in a world-writable directory, can be overwritten.
Severity:
  - CVSS Version: 3.1
  - Base Score: 8.1
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://ixon-cloud.my.salesforce.com/sfc/p/#1t000000vlSF/a/TX000000DQmH/WRGwuYg2iMsKX6NAIK3MygCUOlg0SPQ..YvGWrwfNeM
  - https://support.ixon.cloud/s/article/VPN-Client-installation-and-uninstallation

------------------------------------------------------------

CVE ID: CVE-2025-37800
Description: In the Linux kernel, the following vulnerability has been resolved:

driver core: fix potential NULL pointer dereference in dev_uevent()

If userspace reads "uevent" device attribute at the same time as another
threads unbinds the device from its driver, change to dev->driver from a
valid pointer to NULL may result in crash. Fix this by using READ_ONCE()
when fetching the pointer, and take bus' drivers klist lock to make sure
driver instance will not disappear while we access it.

Use WRITE_ONCE() when setting the driver pointer to ensure there is no
tearing.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/18daa52418e7e4629ed1703b64777294209d2622
  - https://git.kernel.org/stable/c/2b344e779d9afd0fcb5ee4000e4d0fc7d8d867eb
  - https://git.kernel.org/stable/c/3781e4b83e174364998855de777e184cf0b62c40
  - https://git.kernel.org/stable/c/abe56be73eb10a677d16066f65ff9d30251f5eee

------------------------------------------------------------

CVE ID: CVE-2025-37801
Description: In the Linux kernel, the following vulnerability has been resolved:

spi: spi-imx: Add check for spi_imx_setupxfer()

Add check for the return value of spi_imx_setupxfer().
spi_imx->rx and spi_imx->tx function pointer can be NULL when
spi_imx_setupxfer() return error, and make NULL pointer dereference.

 Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
 Call trace:
  0x0
  spi_imx_pio_transfer+0x50/0xd8
  spi_imx_transfer_one+0x18c/0x858
  spi_transfer_one_message+0x43c/0x790
  __spi_pump_transfer_message+0x238/0x5d4
  __spi_sync+0x2b0/0x454
  spi_write_then_read+0x11c/0x200
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/055ef73bb1afc3f783a9a13b496770a781964a07
  - https://git.kernel.org/stable/c/185d376875ea6fb4256b9dc97ee0b4d2b0fdd399
  - https://git.kernel.org/stable/c/2b4479eb462ecb39001b38dfb331fc6028dedac8
  - https://git.kernel.org/stable/c/2fea0d6d7b5d27fbf55512d51851ba0a346ede52
  - https://git.kernel.org/stable/c/951a04ab3a2db4029debfa48d380ef834b93207e

------------------------------------------------------------

CVE ID: CVE-2025-37802
Description: In the Linux kernel, the following vulnerability has been resolved:

ksmbd: fix WARNING "do not call blocking ops when !TASK_RUNNING"

wait_event_timeout() will set the state of the current
task to TASK_UNINTERRUPTIBLE, before doing the condition check. This
means that ksmbd_durable_scavenger_alive() will try to acquire the mutex
while already in a sleeping state. The scheduler warns us by giving
the following warning:

do not call blocking ops when !TASK_RUNNING; state=2 set at
 [<0000000061515a6f>] prepare_to_wait_event+0x9f/0x6c0
WARNING: CPU: 2 PID: 4147 at kernel/sched/core.c:10099 __might_sleep+0x12f/0x160

mutex lock is not needed in ksmbd_durable_scavenger_alive().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1df0d4c616138784e033ad337961b6e1a6bcd999
  - https://git.kernel.org/stable/c/8f805b3746d2f41702c77cba22f94f8415fadd1a
  - https://git.kernel.org/stable/c/cd161198e091e8a62b9bd631be970ea9a87d2d6a

------------------------------------------------------------

CVE ID: CVE-2025-37803
Description: In the Linux kernel, the following vulnerability has been resolved:

udmabuf: fix a buf size overflow issue during udmabuf creation

by casting size_limit_mb to u64  when calculate pglimit.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/021ba7f1babd029e714d13a6bf2571b08af96d0f
  - https://git.kernel.org/stable/c/13fe12c037b470321436deec393030c6153cfeb9
  - https://git.kernel.org/stable/c/2b8419c6ecf69007dcff54ea0b9f0b215282c55a
  - https://git.kernel.org/stable/c/373512760e13fdaa726faa9502d0f5be2abb3d33
  - https://git.kernel.org/stable/c/3f6c9d66e0f8eb9679b57913aa64b4d2266f6fbe
  - https://git.kernel.org/stable/c/b2ff4e9c599b000833d16a917f519aa2e4a75de2
  - https://git.kernel.org/stable/c/e84a08fc7e25cdad5d9a3def42cc770ff711193f

------------------------------------------------------------

CVE ID: CVE-2025-37804
Description: In the Linux kernel, the following vulnerability has been resolved:

io_uring: always do atomic put from iowq

io_uring always switches requests to atomic refcounting for iowq
execution before there is any parallilism by setting REQ_F_REFCOUNT,
and the flag is not cleared until the request completes. That should be
fine as long as the compiler doesn't make up a non existing value for
the flags, however KCSAN still complains when the request owner changes
oter flag bits:

BUG: KCSAN: data-race in io_req_task_cancel / io_wq_free_work
...
read to 0xffff888117207448 of 8 bytes by task 3871 on cpu 0:
 req_ref_put_and_test io_uring/refs.h:22 [inline]

Skip REQ_F_REFCOUNT checks for iowq, we know it's set.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3568fd9e440ea393c7d8bee253419ea11fd8e9d9
  - https://git.kernel.org/stable/c/390513642ee6763c7ada07f0a1470474986e6c1c
  - https://git.kernel.org/stable/c/6d2753b46452a557a12f7ef1ef4ee6641b4e89d8
  - https://git.kernel.org/stable/c/c5d4d103005d8926cdad344f9fc947e651c9f2f7

------------------------------------------------------------

CVE ID: CVE-2025-37805
Description: In the Linux kernel, the following vulnerability has been resolved:

sound/virtio: Fix cancel_sync warnings on uninitialized work_structs

Betty reported hitting the following warning:

[    8.709131][  T221] WARNING: CPU: 2 PID: 221 at kernel/workqueue.c:4182
...
[    8.713282][  T221] Call trace:
[    8.713365][  T221]  __flush_work+0x8d0/0x914
[    8.713468][  T221]  __cancel_work_sync+0xac/0xfc
[    8.713570][  T221]  cancel_work_sync+0x24/0x34
[    8.713667][  T221]  virtsnd_remove+0xa8/0xf8 [virtio_snd ab15f34d0dd772f6d11327e08a81d46dc9c36276]
[    8.713868][  T221]  virtsnd_probe+0x48c/0x664 [virtio_snd ab15f34d0dd772f6d11327e08a81d46dc9c36276]
[    8.714035][  T221]  virtio_dev_probe+0x28c/0x390
[    8.714139][  T221]  really_probe+0x1bc/0x4c8
...

It seems we're hitting the error path in virtsnd_probe(), which
triggers a virtsnd_remove() which iterates over the substreams
calling cancel_work_sync() on the elapsed_period work_struct.

Looking at the code, from earlier in:
virtsnd_probe()->virtsnd_build_devs()->virtsnd_pcm_parse_cfg()

We set snd->nsubstreams, allocate the snd->substreams, and if
we then hit an error on the info allocation or something in
virtsnd_ctl_query_info() fails, we will exit without having
initialized the elapsed_period work_struct.

When that error path unwinds we then call virtsnd_remove()
which as long as the substreams array is allocated, will iterate
through calling cancel_work_sync() on the uninitialized work
struct hitting this warning.

Takashi Iwai suggested this fix, which initializes the substreams
structure right after allocation, so that if we hit the error
paths we avoid trying to cleanup uninitialized data.

Note: I have not yet managed to reproduce the issue myself, so
this patch has had limited testing.

Feedback or thoughts would be appreciated!
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3c7df2e27346eb40a0e86230db1ccab195c97cfe
  - https://git.kernel.org/stable/c/54c7b864fbe4423a07b443a4ada0106052942116
  - https://git.kernel.org/stable/c/5be9407b41eae20eef9140f5cfbfcbc3d01aaf45
  - https://git.kernel.org/stable/c/66046b586c0aaa9332483bcdbd76e3305d6138e9
  - https://git.kernel.org/stable/c/9908498ce929a5a052b79bb7942f9ea317312ce4
  - https://git.kernel.org/stable/c/e03b10c45c7675b6098190c6e7de1b656d8bcdbe

------------------------------------------------------------

CVE ID: CVE-2025-37806
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Keep write operations atomic

syzbot reported a NULL pointer dereference in __generic_file_write_iter. [1]

Before the write operation is completed, the user executes ioctl[2] to clear
the compress flag of the file, which causes the is_compressed() judgment to
return 0, further causing the program to enter the wrong process and call the
wrong ops ntfs_aops_cmpr, which triggers the null pointer dereference of
write_begin.

Use inode lock to synchronize ioctl and write to avoid this case.

[1]
Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
Mem abort info:
  ESR = 0x0000000086000006
  EC = 0x21: IABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
  FSC = 0x06: level 2 translation fault
user pgtable: 4k pages, 48-bit VAs, pgdp=000000011896d000
[0000000000000000] pgd=0800000118b44403, p4d=0800000118b44403, pud=0800000117517403, pmd=0000000000000000
Internal error: Oops: 0000000086000006 [#1] PREEMPT SMP
Modules linked in:
CPU: 0 UID: 0 PID: 6427 Comm: syz-executor347 Not tainted 6.13.0-rc3-syzkaller-g573067a5a685 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : 0x0
lr : generic_perform_write+0x29c/0x868 mm/filemap.c:4055
sp : ffff80009d4978a0
x29: ffff80009d4979c0 x28: dfff800000000000 x27: ffff80009d497bc8
x26: 0000000000000000 x25: ffff80009d497960 x24: ffff80008ba71c68
x23: 0000000000000000 x22: ffff0000c655dac0 x21: 0000000000001000
x20: 000000000000000c x19: 1ffff00013a92f2c x18: ffff0000e183aa1c
x17: 0004060000000014 x16: ffff800083275834 x15: 0000000000000001
x14: 0000000000000000 x13: 0000000000000001 x12: ffff0000c655dac0
x11: 0000000000ff0100 x10: 0000000000ff0100 x9 : 0000000000000000
x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000
x5 : ffff80009d497980 x4 : ffff80009d497960 x3 : 0000000000001000
x2 : 0000000000000000 x1 : ffff0000e183a928 x0 : ffff0000d60b0fc0
Call trace:
 0x0 (P)
 __generic_file_write_iter+0xfc/0x204 mm/filemap.c:4156
 ntfs_file_write_iter+0x54c/0x630 fs/ntfs3/file.c:1267
 new_sync_write fs/read_write.c:586 [inline]
 vfs_write+0x920/0xcf4 fs/read_write.c:679
 ksys_write+0x15c/0x26c fs/read_write.c:731
 __do_sys_write fs/read_write.c:742 [inline]
 __se_sys_write fs/read_write.c:739 [inline]
 __arm64_sys_write+0x7c/0x90 fs/read_write.c:739
 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]
 invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49
 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132
 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151
 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744
 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762

[2]
ioctl$FS_IOC_SETFLAGS(r0, 0x40086602, &(0x7f00000000c0)=0x20)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/285cec318bf5a7a6c8ba999b2b6ec96f9a20590f
  - https://git.kernel.org/stable/c/464139e18f619aa14fb921a61721862f43421c54
  - https://git.kernel.org/stable/c/8db49e89a7f8b48ee59fa9ad32b6ed0879747df8

------------------------------------------------------------

CVE ID: CVE-2025-37807
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix kmemleak warning for percpu hashmap

Vlad Poenaru reported the following kmemleak issue:

  unreferenced object 0x606fd7c44ac8 (size 32):
    backtrace (crc 0):
      pcpu_alloc_noprof+0x730/0xeb0
      bpf_map_alloc_percpu+0x69/0xc0
      prealloc_init+0x9d/0x1b0
      htab_map_alloc+0x363/0x510
      map_create+0x215/0x3a0
      __sys_bpf+0x16b/0x3e0
      __x64_sys_bpf+0x18/0x20
      do_syscall_64+0x7b/0x150
      entry_SYSCALL_64_after_hwframe+0x4b/0x53

Further investigation shows the reason is due to not 8-byte aligned
store of percpu pointer in htab_elem_set_ptr():
  *(void __percpu **)(l->key + key_size) = pptr;

Note that the whole htab_elem alignment is 8 (for x86_64). If the key_size
is 4, that means pptr is stored in a location which is 4 byte aligned but
not 8 byte aligned. In mm/kmemleak.c, scan_block() scans the memory based
on 8 byte stride, so it won't detect above pptr, hence reporting the memory
leak.

In htab_map_alloc(), we already have

        htab->elem_size = sizeof(struct htab_elem) +
                          round_up(htab->map.key_size, 8);
        if (percpu)
                htab->elem_size += sizeof(void *);
        else
                htab->elem_size += round_up(htab->map.value_size, 8);

So storing pptr with 8-byte alignment won't cause any problem and can fix
kmemleak too.

The issue can be reproduced with bpf selftest as well:
  1. Enable CONFIG_DEBUG_KMEMLEAK config
  2. Add a getchar() before skel destroy in test_hash_map() in prog_tests/for_each.c.
     The purpose is to keep map available so kmemleak can be detected.
  3. run './test_progs -t for_each/hash_map &' and a kmemleak should be reported.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11ba7ce076e5903e7bdc1fd1498979c331b3c286
  - https://git.kernel.org/stable/c/1f1c29aa1934177349c17e3c32e68ec38a7a56df
  - https://git.kernel.org/stable/c/7758e308aeda1038aba1944f7302d34161b3effe

------------------------------------------------------------

CVE ID: CVE-2025-37808
Description: In the Linux kernel, the following vulnerability has been resolved:

crypto: null - Use spin lock instead of mutex

As the null algorithm may be freed in softirq context through
af_alg, use spin locks instead of mutexes to protect the default
null algorithm.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0486de3c1b8223138dcc614846bd76364f758de6
  - https://git.kernel.org/stable/c/1b66a5920b7fc7cc6251192a3fcad115b6d75dd5
  - https://git.kernel.org/stable/c/1dd4a8561d85dea545cf93f56efc48df8176e218
  - https://git.kernel.org/stable/c/8cf2945512a8c0ef74ddd5b5a4f6b6a2fb1a4efb
  - https://git.kernel.org/stable/c/dcc47a028c24e793ce6d6efebfef1a1e92f80297
  - https://git.kernel.org/stable/c/e27244cbe10658a66b8775be7f0acc4ad2f618d6
  - https://git.kernel.org/stable/c/e307c54ac8198bf09652c72603ba6e6d97798410
  - https://git.kernel.org/stable/c/f7a5a5c8e1ec16a4b2041398abe95de0e14572ef

------------------------------------------------------------

CVE ID: CVE-2025-37809
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: typec: class: Fix NULL pointer access

Concurrent calls to typec_partner_unlink_device can lead to a NULL pointer
dereference. This patch adds a mutex to protect USB device pointers and
prevent this issue. The same mutex protects both the device pointers and
the partner device registration.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1fdde62411fe65640e69bc55ea027d5b7b2f0093
  - https://git.kernel.org/stable/c/de7c24febd21413ea8f49f61b36338b676c02852
  - https://git.kernel.org/stable/c/ec27386de23a511008c53aa2f3434ad180a3ca9a

------------------------------------------------------------

CVE ID: CVE-2025-37810
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: dwc3: gadget: check that event count does not exceed event buffer length

The event count is read from register DWC3_GEVNTCOUNT.
There is a check for the count being zero, but not for exceeding the
event buffer length.
Check that event count does not exceed event buffer length,
avoiding an out-of-bounds access when memcpy'ing the event.
Crash log:
Unable to handle kernel paging request at virtual address ffffffc0129be000
pc : __memcpy+0x114/0x180
lr : dwc3_check_event_buf+0xec/0x348
x3 : 0000000000000030 x2 : 000000000000dfc4
x1 : ffffffc0129be000 x0 : ffffff87aad60080
Call trace:
__memcpy+0x114/0x180
dwc3_interrupt+0x24/0x34
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/015c39f38e69a491d2abd5e98869a500a9459b3b
  - https://git.kernel.org/stable/c/52a7c9d930b95aa8b1620edaba4818040c32631f
  - https://git.kernel.org/stable/c/63ccd26cd1f6600421795f6ca3e625076be06c9f
  - https://git.kernel.org/stable/c/99d655119b870ee60e4dbf310aa9a1ed8d9ede3d
  - https://git.kernel.org/stable/c/a44547015287a19001384fe94dbff84c92ce4ee1
  - https://git.kernel.org/stable/c/b43225948b231b3f331194010f84512bee4d9f59
  - https://git.kernel.org/stable/c/c0079630f268843a25ed75226169cba40e0d8880
  - https://git.kernel.org/stable/c/c4d80e41cb42008dceb35e5dbf52574d93beac0d

------------------------------------------------------------

CVE ID: CVE-2025-37811
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: chipidea: ci_hdrc_imx: fix usbmisc handling

usbmisc is an optional device property so it is totally valid for the
corresponding data->usbmisc_data to have a NULL value.

Check that before dereferencing the pointer.

Found by Linux Verification Center (linuxtesting.org) with Svace static
analysis tool.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0ee460498ced49196149197c9f6d29a10e5e0798
  - https://git.kernel.org/stable/c/121e9f80ea5478bca3a8f3f26593fd66f87da649
  - https://git.kernel.org/stable/c/2aa87bd825377f5073b76701780a902cd0fc725a
  - https://git.kernel.org/stable/c/4e28f79e3dffa52d327b46d1a78dac16efb5810b
  - https://git.kernel.org/stable/c/8060b719676e8c0e5a2222c2977ba0458d9d9535
  - https://git.kernel.org/stable/c/887902ca73490f38c69fd6149ef361a041cf912f

------------------------------------------------------------

CVE ID: CVE-2025-37812
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: cdns3: Fix deadlock when using NCM gadget

The cdns3 driver has the same NCM deadlock as fixed in cdnsp by commit
58f2fcb3a845 ("usb: cdnsp: Fix deadlock issue during using NCM gadget").

Under PREEMPT_RT the deadlock can be readily triggered by heavy network
traffic, for example using "iperf --bidir" over NCM ethernet link.

The deadlock occurs because the threaded interrupt handler gets
preempted by a softirq, but both are protected by the same spinlock.
Prevent deadlock by disabling softirq during threaded irq handler.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09e90a9689a4aac7a2f726dc2aa472b0b37937b7
  - https://git.kernel.org/stable/c/48a62deb857f0694f611949015e70ad194d97159
  - https://git.kernel.org/stable/c/59a760e4796a3cd88d8b9d7706e0a638de677751
  - https://git.kernel.org/stable/c/74cd6e408a4c010e404832f0e4609d29bf1d0c41
  - https://git.kernel.org/stable/c/a1059896f2bfdcebcdc7153c3be2307ea319501f
  - https://git.kernel.org/stable/c/b96239582531775f2fdcb14de29bdb6870fd4c8c
  - https://git.kernel.org/stable/c/c27db84ed44e50ff90d9e3a2a25fae2e0a0fa015
  - https://git.kernel.org/stable/c/eebfb64c624fc738b669100173344fb441c5e719

------------------------------------------------------------

CVE ID: CVE-2025-37813
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: xhci: Fix invalid pointer dereference in Etron workaround

This check is performed before prepare_transfer() and prepare_ring(), so
enqueue can already point at the final link TRB of a segment. And indeed
it will, some 0.4% of times this code is called.

Then enqueue + 1 is an invalid pointer. It will crash the kernel right
away or load some junk which may look like a link TRB and cause the real
link TRB to be replaced with a NOOP. This wouldn't end well.

Use a functionally equivalent test which doesn't dereference the pointer
and always gives correct result.

Something has crashed my machine twice in recent days while playing with
an Etron HC, and a control transfer stress test ran for confirmation has
just crashed it again. The same test passes with this patch applied.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0624e29c595b05e7a0e6d1c368f0a05799928e30
  - https://git.kernel.org/stable/c/142273a49f2c315eabdbdf5a71c15e479b75ca91
  - https://git.kernel.org/stable/c/1ea050da5562af9b930d17cbbe9632d30f5df43a
  - https://git.kernel.org/stable/c/bce3055b08e303e28a8751f6073066f5c33a0744

------------------------------------------------------------

CVE ID: CVE-2025-37814
Description: In the Linux kernel, the following vulnerability has been resolved:

tty: Require CAP_SYS_ADMIN for all usages of TIOCL_SELMOUSEREPORT

This requirement was overeagerly loosened in commit 2f83e38a095f
("tty: Permit some TIOCL_SETSEL modes without CAP_SYS_ADMIN"), but as
it turns out,

  (1) the logic I implemented there was inconsistent (apologies!),

  (2) TIOCL_SELMOUSEREPORT might actually be a small security risk
      after all, and

  (3) TIOCL_SELMOUSEREPORT is only meant to be used by the mouse
      daemon (GPM or Consolation), which runs as CAP_SYS_ADMIN
      already.

In more detail:

1. The previous patch has inconsistent logic:

   In commit 2f83e38a095f ("tty: Permit some TIOCL_SETSEL modes
   without CAP_SYS_ADMIN"), we checked for sel_mode ==
   TIOCL_SELMOUSEREPORT, but overlooked that the lower four bits of
   this "mode" parameter were actually used as an additional way to
   pass an argument.  So the patch did actually still require
   CAP_SYS_ADMIN, if any of the mouse button bits are set, but did not
   require it if none of the mouse buttons bits are set.

   This logic is inconsistent and was not intentional.  We should have
   the same policies for using TIOCL_SELMOUSEREPORT independent of the
   value of the "hidden" mouse button argument.

   I sent a separate documentation patch to the man page list with
   more details on TIOCL_SELMOUSEREPORT:
   https://lore.kernel.org/all/20250223091342.35523-2-gnoack3000@gmail.com/

2. TIOCL_SELMOUSEREPORT is indeed a potential security risk which can
   let an attacker simulate "keyboard" input to command line
   applications on the same terminal, like TIOCSTI and some other
   TIOCLINUX "selection mode" IOCTLs.

   By enabling mouse reporting on a terminal and then injecting mouse
   reports through TIOCL_SELMOUSEREPORT, an attacker can simulate
   mouse movements on the same terminal, similar to the TIOCSTI
   keystroke injection attacks that were previously possible with
   TIOCSTI and other TIOCL_SETSEL selection modes.

   Many programs (including libreadline/bash) are then prone to
   misinterpret these mouse reports as normal keyboard input because
   they do not expect input in the X11 mouse protocol form.  The
   attacker does not have complete control over the escape sequence,
   but they can at least control the values of two consecutive bytes
   in the binary mouse reporting escape sequence.

   I went into more detail on that in the discussion at
   https://lore.kernel.org/all/20250221.0a947528d8f3@gnoack.org/

   It is not equally trivial to simulate arbitrary keystrokes as it
   was with TIOCSTI (commit 83efeeeb3d04 ("tty: Allow TIOCSTI to be
   disabled")), but the general mechanism is there, and together with
   the small number of existing legit use cases (see below), it would
   be better to revert back to requiring CAP_SYS_ADMIN for
   TIOCL_SELMOUSEREPORT, as it was already the case before
   commit 2f83e38a095f ("tty: Permit some TIOCL_SETSEL modes without
   CAP_SYS_ADMIN").

3. TIOCL_SELMOUSEREPORT is only used by the mouse daemons (GPM or
   Consolation), and they are the only legit use case:

   To quote console_codes(4):

     The mouse tracking facility is intended to return
     xterm(1)-compatible mouse status reports.  Because the console
     driver has no way to know the device or type of the mouse, these
     reports are returned in the console input stream only when the
     virtual terminal driver receives a mouse update ioctl.  These
     ioctls must be generated by a mouse-aware user-mode application
     such as the gpm(8) daemon.

   Jared Finder has also confirmed in
   https://lore.kernel.org/all/491f3df9de6593df8e70dbe77614b026@finder.org/
   that Emacs does not call TIOCL_SELMOUSEREPORT directly, and it
   would be difficult to find good reasons for doing that, given that
   it would interfere with the reports that GPM is sending.

   More information on the interaction between GPM, terminals and th
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/6f021bc0083b96125fdbed6a60d7b4396c4d6dac
  - https://git.kernel.org/stable/c/9b50c9c97db953de756a39af83d4be4d7f618aa6
  - https://git.kernel.org/stable/c/ee6a44da3c87cf64d67dd02be8c0127a5bf56175

------------------------------------------------------------

CVE ID: CVE-2025-37815
Description: In the Linux kernel, the following vulnerability has been resolved:

misc: microchip: pci1xxxx: Fix Kernel panic during IRQ handler registration

Resolve kernel panic while accessing IRQ handler associated with the
generated IRQ. This is done by acquiring the spinlock and storing the
current interrupt state before handling the interrupt request using
generic_handle_irq.

A previous fix patch was submitted where 'generic_handle_irq' was
replaced with 'handle_nested_irq'. However, this change also causes
the kernel panic where after determining which GPIO triggered the
interrupt and attempting to call handle_nested_irq with the mapped
IRQ number, leads to a failure in locating the registered handler.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1263d5f581908602c618c6665e683c4436383a09
  - https://git.kernel.org/stable/c/12cc2193f2b9548e8ea5fbce8201b44158222edf
  - https://git.kernel.org/stable/c/18eb77c75ed01439f96ae5c0f33461eb5134b907
  - https://git.kernel.org/stable/c/4e02059dc91068bc5017b8546f9ec3b930f6d6a6
  - https://git.kernel.org/stable/c/62957f58ab3aa7fa792dc6ff3575624062539a4d

------------------------------------------------------------

CVE ID: CVE-2025-37816
Description: In the Linux kernel, the following vulnerability has been resolved:

mei: vsc: Fix fortify-panic caused by invalid counted_by() use

gcc 15 honors the __counted_by(len) attribute on vsc_tp_packet.buf[]
and the vsc-tp.c code is using this in a wrong way. len does not contain
the available size in the buffer, it contains the actual packet length
*without* the crc. So as soon as vsc_tp_xfer() tries to add the crc to
buf[] the fortify-panic handler gets triggered:

[   80.842193] memcpy: detected buffer overflow: 4 byte write of buffer size 0
[   80.842243] WARNING: CPU: 4 PID: 272 at lib/string_helpers.c:1032 __fortify_report+0x45/0x50
...
[   80.843175]  __fortify_panic+0x9/0xb
[   80.843186]  vsc_tp_xfer.cold+0x67/0x67 [mei_vsc_hw]
[   80.843210]  ? seqcount_lockdep_reader_access.constprop.0+0x82/0x90
[   80.843229]  ? lockdep_hardirqs_on+0x7c/0x110
[   80.843250]  mei_vsc_hw_start+0x98/0x120 [mei_vsc]
[   80.843270]  mei_reset+0x11d/0x420 [mei]

The easiest fix would be to just drop the counted-by but with the exception
of the ack buffer in vsc_tp_xfer_helper() which only contains enough room
for the packet-header, all other uses of vsc_tp_packet always use a buffer
of VSC_TP_MAX_XFER_SIZE bytes for the packet.

Instead of just dropping the counted-by, split the vsc_tp_packet struct
definition into a header and a full-packet definition and use a fixed
size buf[] in the packet definition, this way fortify-source buffer
overrun checking still works when enabled.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/00f1cc14da0f06d2897b8c528df7c7dcf1b8da50
  - https://git.kernel.org/stable/c/3e243378f27cc7d11682a3ad720228b0723affa5
  - https://git.kernel.org/stable/c/ac04663c67f244810b3492e9ecd9f7cdbefeca2d

------------------------------------------------------------

CVE ID: CVE-2025-37817
Description: In the Linux kernel, the following vulnerability has been resolved:

mcb: fix a double free bug in chameleon_parse_gdd()

In chameleon_parse_gdd(), if mcb_device_register() fails, 'mdev'
would be released in mcb_device_register() via put_device().
Thus, goto 'err' label and free 'mdev' again causes a double free.
Just return if mcb_device_register() fails.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4ffe8c9fb561e4427dd1a3056cd5b3685b74f78d
  - https://git.kernel.org/stable/c/59f993cd36b6e28a394ba3d977e8ffe5c9884e3b
  - https://git.kernel.org/stable/c/7c7f1bfdb2249f854a736d9b79778c7e5a29a150
  - https://git.kernel.org/stable/c/96838eb1836fd372e42be5db84f0b333b65146a6
  - https://git.kernel.org/stable/c/bcc7d58ee5173e34306026bd01e1fbf75e169d37
  - https://git.kernel.org/stable/c/c5b8a549ef1fcc6066b037a3962c79d60465ba0b
  - https://git.kernel.org/stable/c/d70184958b0ea8c0fd52e2b456654b503e769fc8
  - https://git.kernel.org/stable/c/df1a5d5c6134224f9298e5189230f9d29ae50cac

------------------------------------------------------------

CVE ID: CVE-2025-37818
Description: In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Return NULL from huge_pte_offset() for invalid PMD

LoongArch's huge_pte_offset() currently returns a pointer to a PMD slot
even if the underlying entry points to invalid_pte_table (indicating no
mapping). Callers like smaps_hugetlb_range() fetch this invalid entry
value (the address of invalid_pte_table) via this pointer.

The generic is_swap_pte() check then incorrectly identifies this address
as a swap entry on LoongArch, because it satisfies the "!pte_present()
&& !pte_none()" conditions. This misinterpretation, combined with a
coincidental match by is_migration_entry() on the address bits, leads to
kernel crashes in pfn_swap_entry_to_page().

Fix this at the architecture level by modifying huge_pte_offset() to
check the PMD entry's content using pmd_none() before returning. If the
entry is invalid (i.e., it points to invalid_pte_table), return NULL
instead of the pointer to the slot.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2ca9380b12711afe95b3589bd82b59623b3c96b3
  - https://git.kernel.org/stable/c/34256805720993e37adf6127371a1265aea8376a
  - https://git.kernel.org/stable/c/51424fd171cee6a33f01f7c66b8eb23ac42289d4
  - https://git.kernel.org/stable/c/b49f085cd671addbda4802d6b9382513f7dd0f30
  - https://git.kernel.org/stable/c/bd51834d1cf65a2c801295d230c220aeebf87a73

------------------------------------------------------------

CVE ID: CVE-2025-37819
Description: In the Linux kernel, the following vulnerability has been resolved:

irqchip/gic-v2m: Prevent use after free of gicv2m_get_fwnode()

With ACPI in place, gicv2m_get_fwnode() is registered with the pci
subsystem as pci_msi_get_fwnode_cb(), which may get invoked at runtime
during a PCI host bridge probe. But, the call back is wrongly marked as
__init, causing it to be freed, while being registered with the PCI
subsystem and could trigger:

 Unable to handle kernel paging request at virtual address ffff8000816c0400
  gicv2m_get_fwnode+0x0/0x58 (P)
  pci_set_bus_msi_domain+0x74/0x88
  pci_register_host_bridge+0x194/0x548

This is easily reproducible on a Juno board with ACPI boot.

Retain the function for later use.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2f2803e4b5e4df2b08d378deaab78b1681ef9b30
  - https://git.kernel.org/stable/c/3318dc299b072a0511d6dfd8367f3304fb6d9827
  - https://git.kernel.org/stable/c/3939d6f29d34cdb60e3f68b76e39e00a964a1d51
  - https://git.kernel.org/stable/c/47bee0081b483b077c7560bc5358ad101f89c8ef
  - https://git.kernel.org/stable/c/dc0d654eb4179b06d3206e4396d072108b9ba082
  - https://git.kernel.org/stable/c/f95659affee301464f0d058d528d96b35b452da8

------------------------------------------------------------

CVE ID: CVE-2025-37820
Description: In the Linux kernel, the following vulnerability has been resolved:

xen-netfront: handle NULL returned by xdp_convert_buff_to_frame()

The function xdp_convert_buff_to_frame() may return NULL if it fails
to correctly convert the XDP buffer into an XDP frame due to memory
constraints, internal errors, or invalid data. Failing to check for NULL
may lead to a NULL pointer dereference if the result is used later in
processing, potentially causing crashes, data corruption, or undefined
behavior.

On XDP redirect failure, the associated page must be released explicitly
if it was previously retained via get_page(). Failing to do so may result
in a memory leak, as the pages reference count is not decremented.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5b83d30c63f9964acb1bc63eb8e670b9e0d2c240
  - https://git.kernel.org/stable/c/cc3628dcd851ddd8d418bf0c897024b4621ddc92
  - https://git.kernel.org/stable/c/cefd8a2e2de46209ce66e6d30c237eb59b6c5bfa
  - https://git.kernel.org/stable/c/d6a9c4e6f9b3ec3ad98468c950ad214af8a2efb9
  - https://git.kernel.org/stable/c/eefccd889df3b49d92e7349d94c4aa7e1ba19f6c

------------------------------------------------------------

CVE ID: CVE-2025-37821
Description: In the Linux kernel, the following vulnerability has been resolved:

sched/eevdf: Fix se->slice being set to U64_MAX and resulting crash

There is a code path in dequeue_entities() that can set the slice of a
sched_entity to U64_MAX, which sometimes results in a crash.

The offending case is when dequeue_entities() is called to dequeue a
delayed group entity, and then the entity's parent's dequeue is delayed.
In that case:

1. In the if (entity_is_task(se)) else block at the beginning of
   dequeue_entities(), slice is set to
   cfs_rq_min_slice(group_cfs_rq(se)). If the entity was delayed, then
   it has no queued tasks, so cfs_rq_min_slice() returns U64_MAX.
2. The first for_each_sched_entity() loop dequeues the entity.
3. If the entity was its parent's only child, then the next iteration
   tries to dequeue the parent.
4. If the parent's dequeue needs to be delayed, then it breaks from the
   first for_each_sched_entity() loop _without updating slice_.
5. The second for_each_sched_entity() loop sets the parent's ->slice to
   the saved slice, which is still U64_MAX.

This throws off subsequent calculations with potentially catastrophic
results. A manifestation we saw in production was:

6. In update_entity_lag(), se->slice is used to calculate limit, which
   ends up as a huge negative number.
7. limit is used in se->vlag = clamp(vlag, -limit, limit). Because limit
   is negative, vlag > limit, so se->vlag is set to the same huge
   negative number.
8. In place_entity(), se->vlag is scaled, which overflows and results in
   another huge (positive or negative) number.
9. The adjusted lag is subtracted from se->vruntime, which increases or
   decreases se->vruntime by a huge number.
10. pick_eevdf() calls entity_eligible()/vruntime_eligible(), which
    incorrectly returns false because the vruntime is so far from the
    other vruntimes on the queue, causing the
    (vruntime - cfs_rq->min_vruntime) * load calulation to overflow.
11. Nothing appears to be eligible, so pick_eevdf() returns NULL.
12. pick_next_entity() tries to dereference the return value of
    pick_eevdf() and crashes.

Dumping the cfs_rq states from the core dumps with drgn showed tell-tale
huge vruntime ranges and bogus vlag values, and I also traced se->slice
being set to U64_MAX on live systems (which was usually "benign" since
the rest of the runqueue needed to be in a particular state to crash).

Fix it in dequeue_entities() by always setting slice from the first
non-empty cfs_rq.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/50a665496881262519f115f1bfe5822f30580eb0
  - https://git.kernel.org/stable/c/bbce3de72be56e4b5f68924b7da9630cc89aa1a8

------------------------------------------------------------

CVE ID: CVE-2025-37822
Description: In the Linux kernel, the following vulnerability has been resolved:

riscv: uprobes: Add missing fence.i after building the XOL buffer

The XOL (execute out-of-line) buffer is used to single-step the
replaced instruction(s) for uprobes. The RISC-V port was missing a
proper fence.i (i$ flushing) after constructing the XOL buffer, which
can result in incorrect execution of stale/broken instructions.

This was found running the BPF selftests "test_progs:
uprobe_autoattach, attach_probe" on the Spacemit K1/X60, where the
uprobes tests randomly blew up.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1dbb95a36499374c51b47ee8ae258a8862c20978
  - https://git.kernel.org/stable/c/7d1d19a11cfbfd8bae1d89cc010b2cc397cd0c48
  - https://git.kernel.org/stable/c/bcf6d3158c5902d92b6d62335af4422b7bf7c4e2

------------------------------------------------------------

CVE ID: CVE-2025-37823
Description: In the Linux kernel, the following vulnerability has been resolved:

net_sched: hfsc: Fix a potential UAF in hfsc_dequeue() too

Similarly to the previous patch, we need to safe guard hfsc_dequeue()
too. But for this one, we don't have a reliable reproducer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/11bccb054c1462fb069219f8e98e97a5a730758e
  - https://git.kernel.org/stable/c/2f46d14919c39528c6e540ebc43f90055993eedc
  - https://git.kernel.org/stable/c/68f256305ceb426d545a0dc31f83c2ab1d211a1e
  - https://git.kernel.org/stable/c/6ccbda44e2cc3d26fd22af54c650d6d5d801addf
  - https://git.kernel.org/stable/c/76c4c22c2437d3d3880efc0f62eca06ef078d290
  - https://git.kernel.org/stable/c/c6936266f8bf98a53f28ef9a820e6a501e946d09
  - https://git.kernel.org/stable/c/c6f035044104c6ff656f4565cd22938dc892528c
  - https://git.kernel.org/stable/c/da7936518996d290e2fcfcaf6cd7e15bfd87804a

------------------------------------------------------------

CVE ID: CVE-2025-37824
Description: In the Linux kernel, the following vulnerability has been resolved:

tipc: fix NULL pointer dereference in tipc_mon_reinit_self()

syzbot reported:

tipc: Node number set to 1055423674
Oops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] SMP KASAN NOPTI
KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
CPU: 3 UID: 0 PID: 6017 Comm: kworker/3:5 Not tainted 6.15.0-rc1-syzkaller-00246-g900241a5cc15 #0 PREEMPT(full)
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014
Workqueue: events tipc_net_finalize_work
RIP: 0010:tipc_mon_reinit_self+0x11c/0x210 net/tipc/monitor.c:719
...
RSP: 0018:ffffc9000356fb68 EFLAGS: 00010246
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000003ee87cba
RDX: 0000000000000000 RSI: ffffffff8dbc56a7 RDI: ffff88804c2cc010
RBP: dffffc0000000000 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000007
R13: fffffbfff2111097 R14: ffff88804ead8000 R15: ffff88804ead9010
FS:  0000000000000000(0000) GS:ffff888097ab9000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000f720eb00 CR3: 000000000e182000 CR4: 0000000000352ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 tipc_net_finalize+0x10b/0x180 net/tipc/net.c:140
 process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238
 process_scheduled_works kernel/workqueue.c:3319 [inline]
 worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400
 kthread+0x3c2/0x780 kernel/kthread.c:464
 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245
 </TASK>
...
RIP: 0010:tipc_mon_reinit_self+0x11c/0x210 net/tipc/monitor.c:719
...
RSP: 0018:ffffc9000356fb68 EFLAGS: 00010246
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000003ee87cba
RDX: 0000000000000000 RSI: ffffffff8dbc56a7 RDI: ffff88804c2cc010
RBP: dffffc0000000000 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000007
R13: fffffbfff2111097 R14: ffff88804ead8000 R15: ffff88804ead9010
FS:  0000000000000000(0000) GS:ffff888097ab9000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000f720eb00 CR3: 000000000e182000 CR4: 0000000000352ef0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400

There is a racing condition between workqueue created when enabling
bearer and another thread created when disabling bearer right after
that as follow:

enabling_bearer                          | disabling_bearer
---------------                          | ----------------
tipc_disc_timeout()                      |
{                                        | bearer_disable()
 ...                                     | {
 schedule_work(&tn->work);               |  tipc_mon_delete()
 ...                                     |  {
}                                        |   ...
                                         |   write_lock_bh(&mon->lock);
                                         |   mon->self = NULL;
                                         |   write_unlock_bh(&mon->lock);
                                         |   ...
                                         |  }
tipc_net_finalize_work()                 | }
{                                        |
 ...                                     |
 tipc_net_finalize()                     |
 {                                       |
  ...                                    |
  tipc_mon_reinit_self()                 |
  {                                      |
   ...                                   |
   write_lock_bh(&mon->lock);            |
   mon->self->addr = tipc_own_addr(net); |
   write_unlock_bh(&mon->lock);          |
   ...             
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0ceef62a328ce1288598c9242576292671f21e96
  - https://git.kernel.org/stable/c/4d5e1e2d3e9d70beff7beab44fd6ce91405a405e
  - https://git.kernel.org/stable/c/5fd464fd24de93d0eca377554bf0ff2548f76f30
  - https://git.kernel.org/stable/c/a3df56010403b2cd26388096ebccf959d23c4dcc
  - https://git.kernel.org/stable/c/d63527e109e811ef11abb1c2985048fdb528b4cb
  - https://git.kernel.org/stable/c/dd6cb0a8575b00fbd503e96903184125176f4fa3
  - https://git.kernel.org/stable/c/e6613b6d41f4010c4d484cbc7bfca690d8d522a2
  - https://git.kernel.org/stable/c/e79e8e05aa46f90d21023f0ffe6f136ed6a20932

------------------------------------------------------------

CVE ID: CVE-2025-37825
Description: In the Linux kernel, the following vulnerability has been resolved:

nvmet: fix out-of-bounds access in nvmet_enable_port

When trying to enable a port that has no transport configured yet,
nvmet_enable_port() uses NVMF_TRTYPE_MAX (255) to query the transports
array, causing an out-of-bounds access:

[  106.058694] BUG: KASAN: global-out-of-bounds in nvmet_enable_port+0x42/0x1da
[  106.058719] Read of size 8 at addr ffffffff89dafa58 by task ln/632
[...]
[  106.076026] nvmet: transport type 255 not supported

Since commit 200adac75888, NVMF_TRTYPE_MAX is the default state as configured by
nvmet_ports_make().
Avoid this by checking for NVMF_TRTYPE_MAX before proceeding.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3d7aa0c7b4e96cd460826d932e44710cdeb3378b
  - https://git.kernel.org/stable/c/83c00860a37b3fcba8026cb344101f1b8af547cf

------------------------------------------------------------

CVE ID: CVE-2025-37826
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: core: Add NULL check in ufshcd_mcq_compl_pending_transfer()

Add a NULL check for the returned hwq pointer by ufshcd_mcq_req_to_hwq().

This is similar to the fix in commit 74736103fb41 ("scsi: ufs: core: Fix
ufshcd_abort_one racing issue").
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/08a966a917fe3d92150fa3cc15793ad5e57051eb
  - https://git.kernel.org/stable/c/700128d67d57bb1de4251e563ab85202def36c50
  - https://git.kernel.org/stable/c/eeab6618037be84e438e9d6ed5d9a53502faf81f

------------------------------------------------------------

CVE ID: CVE-2025-37827
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: zoned: return EIO on RAID1 block group write pointer mismatch

There was a bug report about a NULL pointer dereference in
__btrfs_add_free_space_zoned() that ultimately happens because a
conversion from the default metadata profile DUP to a RAID1 profile on two
disks.

The stack trace has the following signature:

  BTRFS error (device sdc): zoned: write pointer offset mismatch of zones in raid1 profile
  BUG: kernel NULL pointer dereference, address: 0000000000000058
  #PF: supervisor read access in kernel mode
  #PF: error_code(0x0000) - not-present page
  PGD 0 P4D 0
  Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
  RIP: 0010:__btrfs_add_free_space_zoned.isra.0+0x61/0x1a0
  RSP: 0018:ffffa236b6f3f6d0 EFLAGS: 00010246
  RAX: 0000000000000000 RBX: ffff96c8132f3400 RCX: 0000000000000001
  RDX: 0000000010000000 RSI: 0000000000000000 RDI: ffff96c8132f3410
  RBP: 0000000010000000 R08: 0000000000000003 R09: 0000000000000000
  R10: 0000000000000000 R11: 00000000ffffffff R12: 0000000000000000
  R13: ffff96c758f65a40 R14: 0000000000000001 R15: 000011aac0000000
  FS: 00007fdab1cb2900(0000) GS:ffff96e60ca00000(0000) knlGS:0000000000000000
  CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 0000000000000058 CR3: 00000001a05ae000 CR4: 0000000000350ef0
  Call Trace:
  <TASK>
  ? __die_body.cold+0x19/0x27
  ? page_fault_oops+0x15c/0x2f0
  ? exc_page_fault+0x7e/0x180
  ? asm_exc_page_fault+0x26/0x30
  ? __btrfs_add_free_space_zoned.isra.0+0x61/0x1a0
  btrfs_add_free_space_async_trimmed+0x34/0x40
  btrfs_add_new_free_space+0x107/0x120
  btrfs_make_block_group+0x104/0x2b0
  btrfs_create_chunk+0x977/0xf20
  btrfs_chunk_alloc+0x174/0x510
  ? srso_return_thunk+0x5/0x5f
  btrfs_inc_block_group_ro+0x1b1/0x230
  btrfs_relocate_block_group+0x9e/0x410
  btrfs_relocate_chunk+0x3f/0x130
  btrfs_balance+0x8ac/0x12b0
  ? srso_return_thunk+0x5/0x5f
  ? srso_return_thunk+0x5/0x5f
  ? __kmalloc_cache_noprof+0x14c/0x3e0
  btrfs_ioctl+0x2686/0x2a80
  ? srso_return_thunk+0x5/0x5f
  ? ioctl_has_perm.constprop.0.isra.0+0xd2/0x120
  __x64_sys_ioctl+0x97/0xc0
  do_syscall_64+0x82/0x160
  ? srso_return_thunk+0x5/0x5f
  ? __memcg_slab_free_hook+0x11a/0x170
  ? srso_return_thunk+0x5/0x5f
  ? kmem_cache_free+0x3f0/0x450
  ? srso_return_thunk+0x5/0x5f
  ? srso_return_thunk+0x5/0x5f
  ? syscall_exit_to_user_mode+0x10/0x210
  ? srso_return_thunk+0x5/0x5f
  ? do_syscall_64+0x8e/0x160
  ? sysfs_emit+0xaf/0xc0
  ? srso_return_thunk+0x5/0x5f
  ? srso_return_thunk+0x5/0x5f
  ? seq_read_iter+0x207/0x460
  ? srso_return_thunk+0x5/0x5f
  ? vfs_read+0x29c/0x370
  ? srso_return_thunk+0x5/0x5f
  ? srso_return_thunk+0x5/0x5f
  ? syscall_exit_to_user_mode+0x10/0x210
  ? srso_return_thunk+0x5/0x5f
  ? do_syscall_64+0x8e/0x160
  ? srso_return_thunk+0x5/0x5f
  ? exc_page_fault+0x7e/0x180
  entry_SYSCALL_64_after_hwframe+0x76/0x7e
  RIP: 0033:0x7fdab1e0ca6d
  RSP: 002b:00007ffeb2b60c80 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
  RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fdab1e0ca6d
  RDX: 00007ffeb2b60d80 RSI: 00000000c4009420 RDI: 0000000000000003
  RBP: 00007ffeb2b60cd0 R08: 0000000000000000 R09: 0000000000000013
  R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
  R13: 00007ffeb2b6343b R14: 00007ffeb2b60d80 R15: 0000000000000001
  </TASK>
  CR2: 0000000000000058
  ---[ end trace 0000000000000000 ]---

The 1st line is the most interesting here:

 BTRFS error (device sdc): zoned: write pointer offset mismatch of zones in raid1 profile

When a RAID1 block-group is created and a write pointer mismatch between
the disks in the RAID set is detected, btrfs sets the alloc_offset to the
length of the block group marking it as full. Afterwards the code expects
that a balance operation will evacuate the data in this block-group and
repair the problems.

But before this is possible, the new space of this block-group will be
accounted in the free space cache. But in __btrfs_
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/9a447f748f6c7287dad68fa91913cd382fa0fcc8
  - https://git.kernel.org/stable/c/b0c26f47992672661340dd6ea931240213016609
  - https://git.kernel.org/stable/c/f4717a02cc422cf4bb2dbb280b154a1ae65c5f84

------------------------------------------------------------

CVE ID: CVE-2025-37828
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: mcq: Add NULL check in ufshcd_mcq_abort()

A race can occur between the MCQ completion path and the abort handler:
once a request completes, __blk_mq_free_request() sets rq->mq_hctx to
NULL, meaning the subsequent ufshcd_mcq_req_to_hwq() call in
ufshcd_mcq_abort() can return a NULL pointer. If this NULL pointer is
dereferenced, the kernel will crash.

Add a NULL check for the returned hwq pointer. If hwq is NULL, log an
error and return FAILED, preventing a potential NULL-pointer
dereference.  As suggested by Bart, the ufshcd_cmd_inflight() check is
removed.

This is similar to the fix in commit 74736103fb41 ("scsi: ufs: core: Fix
ufshcd_abort_one racing issue").

This is found by our static analysis tool KNighter.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/47eec518aef3814f64a5da43df81bdd74d8c0041
  - https://git.kernel.org/stable/c/4c324085062919d4e21c69e5e78456dcec0052fe
  - https://git.kernel.org/stable/c/7d002f591486f5ef4bc02eb02025a53f931f0eb5
  - https://git.kernel.org/stable/c/d6979fabe812a168d5053e5a41d5a2e9b8afd7bf

------------------------------------------------------------

CVE ID: CVE-2025-37829
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: scpi: Fix null-ptr-deref in scpi_cpufreq_get_rate()

cpufreq_cpu_get_raw() can return NULL when the target CPU is not present
in the policy->cpus mask. scpi_cpufreq_get_rate() does not check for
this case, which results in a NULL pointer dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/124bddf123311cd1f18bffd63a5d974468d59c67
  - https://git.kernel.org/stable/c/19e0eaa62e8831f2bc0285fef3bf8faaa7f3e09b
  - https://git.kernel.org/stable/c/28fbd7b13b4d3074b16db913aedc9d8d37ab41e7
  - https://git.kernel.org/stable/c/73b24dc731731edf762f9454552cb3a5b7224949
  - https://git.kernel.org/stable/c/8fbaa76690f67a7cbad315f89d607b46e3e06ede
  - https://git.kernel.org/stable/c/ad4796f2da495b2cbbd0fccccbcbf63f2aeee613
  - https://git.kernel.org/stable/c/da8ee91e532486055ecf88478d38c2f3dc234182
  - https://git.kernel.org/stable/c/fdf035d9c5436536ffcfea0ac6adeb5dda3c3a23

------------------------------------------------------------

CVE ID: CVE-2025-37830
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: scmi: Fix null-ptr-deref in scmi_cpufreq_get_rate()

cpufreq_cpu_get_raw() can return NULL when the target CPU is not present
in the policy->cpus mask. scmi_cpufreq_get_rate() does not check for
this case, which results in a NULL pointer dereference.

Add NULL check after cpufreq_cpu_get_raw() to prevent this issue.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/484d3f15cc6cbaa52541d6259778e715b2c83c54
  - https://git.kernel.org/stable/c/4e3d1c1925d8e752992cd893d03d974e6807ac16
  - https://git.kernel.org/stable/c/7ccfadfb2562337b4f0462a86a9746a6eea89718
  - https://git.kernel.org/stable/c/cfaca93b8fe317b7faa9af732e0ba8c9081fa018
  - https://git.kernel.org/stable/c/ea834c90aa7cc80a1b456f7a91432734d5087d16
  - https://git.kernel.org/stable/c/f9c5423855e3687262d881aeee5cfb3bc8577bff

------------------------------------------------------------

CVE ID: CVE-2025-37831
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: apple-soc: Fix null-ptr-deref in apple_soc_cpufreq_get_rate()

cpufreq_cpu_get_raw() can return NULL when the target CPU is not present
in the policy->cpus mask. apple_soc_cpufreq_get_rate() does not check
for this case, which results in a NULL pointer dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/01e86ea22610d98ae6141e428019a6916e79f725
  - https://git.kernel.org/stable/c/1053dcf8a504d4933bb3f73df22bc363298d194b
  - https://git.kernel.org/stable/c/9992649f6786921873a9b89dafa5e04d8c5fef2b
  - https://git.kernel.org/stable/c/fbdba5f37413dbc09d82ad7235e5b7a2fb8e0f75

------------------------------------------------------------

CVE ID: CVE-2025-37832
Description: In the Linux kernel, the following vulnerability has been resolved:

cpufreq: sun50i: prevent out-of-bounds access

A KASAN enabled kernel reports an out-of-bounds access when handling the
nvmem cell in the sun50i cpufreq driver:
==================================================================
BUG: KASAN: slab-out-of-bounds in sun50i_cpufreq_nvmem_probe+0x180/0x3d4
Read of size 4 at addr ffff000006bf31e0 by task kworker/u16:1/38

This is because the DT specifies the nvmem cell as covering only two
bytes, but we use a u32 pointer to read the value. DTs for other SoCs
indeed specify 4 bytes, so we cannot just shorten the variable to a u16.

Fortunately nvmem_cell_read() allows to return the length of the nvmem
cell, in bytes, so we can use that information to only access the valid
portion of the data.
To cover multiple cell sizes, use memcpy() to copy the information into a
zeroed u32 buffer, then also make sure we always read the data in little
endian fashion, as this is how the data is stored in the SID efuses.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/14c8a418159e541d70dbf8fc71225d1623beaf0f
  - https://git.kernel.org/stable/c/40bf7f560ca4c2468d518cebf14561bc864f58f8
  - https://git.kernel.org/stable/c/dba5a1f963cf781c0b60f4b7f07465a6c687c27e

------------------------------------------------------------

CVE ID: CVE-2025-37833
Description: In the Linux kernel, the following vulnerability has been resolved:

net/niu: Niu requires MSIX ENTRY_DATA fields touch before entry reads

Fix niu_try_msix() to not cause a fatal trap on sparc systems.

Set PCI_DEV_FLAGS_MSIX_TOUCH_ENTRY_DATA_FIRST on the struct pci_dev to
work around a bug in the hardware or firmware.

For each vector entry in the msix table, niu chips will cause a fatal
trap if any registers in that entry are read before that entries'
ENTRY_DATA register is written to. Testing indicates writes to other
registers are not sufficient to prevent the fatal trap, however the value
does not appear to matter. This only needs to happen once after power up,
so simply rebooting into a kernel lacking this fix will NOT cause the
trap.

NON-RESUMABLE ERROR: Reporting on cpu 64
NON-RESUMABLE ERROR: TPC [0x00000000005f6900] <msix_prepare_msi_desc+0x90/0xa0>
NON-RESUMABLE ERROR: RAW [4010000000000016:00000e37f93e32ff:0000000202000080:ffffffffffffffff
NON-RESUMABLE ERROR:      0000000800000000:0000000000000000:0000000000000000:0000000000000000]
NON-RESUMABLE ERROR: handle [0x4010000000000016] stick [0x00000e37f93e32ff]
NON-RESUMABLE ERROR: type [precise nonresumable]
NON-RESUMABLE ERROR: attrs [0x02000080] < ASI sp-faulted priv >
NON-RESUMABLE ERROR: raddr [0xffffffffffffffff]
NON-RESUMABLE ERROR: insn effective address [0x000000c50020000c]
NON-RESUMABLE ERROR: size [0x8]
NON-RESUMABLE ERROR: asi [0x00]
CPU: 64 UID: 0 PID: 745 Comm: kworker/64:1 Not tainted 6.11.5 #63
Workqueue: events work_for_cpu_fn
TSTATE: 0000000011001602 TPC: 00000000005f6900 TNPC: 00000000005f6904 Y: 00000000    Not tainted
TPC: <msix_prepare_msi_desc+0x90/0xa0>
g0: 00000000000002e9 g1: 000000000000000c g2: 000000c50020000c g3: 0000000000000100
g4: ffff8000470307c0 g5: ffff800fec5be000 g6: ffff800047a08000 g7: 0000000000000000
o0: ffff800014feb000 o1: ffff800047a0b620 o2: 0000000000000011 o3: ffff800047a0b620
o4: 0000000000000080 o5: 0000000000000011 sp: ffff800047a0ad51 ret_pc: 00000000005f7128
RPC: <__pci_enable_msix_range+0x3cc/0x460>
l0: 000000000000000d l1: 000000000000c01f l2: ffff800014feb0a8 l3: 0000000000000020
l4: 000000000000c000 l5: 0000000000000001 l6: 0000000020000000 l7: ffff800047a0b734
i0: ffff800014feb000 i1: ffff800047a0b730 i2: 0000000000000001 i3: 000000000000000d
i4: 0000000000000000 i5: 0000000000000000 i6: ffff800047a0ae81 i7: 00000000101888b0
I7: <niu_try_msix.constprop.0+0xc0/0x130 [niu]>
Call Trace:
[<00000000101888b0>] niu_try_msix.constprop.0+0xc0/0x130 [niu]
[<000000001018f840>] niu_get_invariants+0x183c/0x207c [niu]
[<00000000101902fc>] niu_pci_init_one+0x27c/0x2fc [niu]
[<00000000005ef3e4>] local_pci_probe+0x28/0x74
[<0000000000469240>] work_for_cpu_fn+0x8/0x1c
[<000000000046b008>] process_scheduled_works+0x144/0x210
[<000000000046b518>] worker_thread+0x13c/0x1c0
[<00000000004710e0>] kthread+0xb8/0xc8
[<00000000004060c8>] ret_from_fork+0x1c/0x2c
[<0000000000000000>] 0x0
Kernel panic - not syncing: Non-resumable error.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/64903e4849a71cf7f7c7e5d45225ccefc1280929
  - https://git.kernel.org/stable/c/c187aaa9e79b4b6d86ac7ba941e579ad33df5538
  - https://git.kernel.org/stable/c/fbb429ddff5c8e479edcc7dde5a542c9295944e6

------------------------------------------------------------

CVE ID: CVE-2025-37834
Description: In the Linux kernel, the following vulnerability has been resolved:

mm/vmscan: don't try to reclaim hwpoison folio

Syzkaller reports a bug as follows:

Injecting memory failure for pfn 0x18b00e at process virtual address 0x20ffd000
Memory failure: 0x18b00e: dirty swapcache page still referenced by 2 users
Memory failure: 0x18b00e: recovery action for dirty swapcache page: Failed
page: refcount:2 mapcount:0 mapping:0000000000000000 index:0x20ffd pfn:0x18b00e
memcg:ffff0000dd6d9000
anon flags: 0x5ffffe00482011(locked|dirty|arch_1|swapbacked|hwpoison|node=0|zone=2|lastcpupid=0xfffff)
raw: 005ffffe00482011 dead000000000100 dead000000000122 ffff0000e232a7c9
raw: 0000000000020ffd 0000000000000000 00000002ffffffff ffff0000dd6d9000
page dumped because: VM_BUG_ON_FOLIO(!folio_test_uptodate(folio))
------------[ cut here ]------------
kernel BUG at mm/swap_state.c:184!
Internal error: Oops - BUG: 00000000f2000800 [#1] SMP
Modules linked in:
CPU: 0 PID: 60 Comm: kswapd0 Not tainted 6.6.0-gcb097e7de84e #3
Hardware name: linux,dummy-virt (DT)
pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : add_to_swap+0xbc/0x158
lr : add_to_swap+0xbc/0x158
sp : ffff800087f37340
x29: ffff800087f37340 x28: fffffc00052c0380 x27: ffff800087f37780
x26: ffff800087f37490 x25: ffff800087f37c78 x24: ffff800087f377a0
x23: ffff800087f37c50 x22: 0000000000000000 x21: fffffc00052c03b4
x20: 0000000000000000 x19: fffffc00052c0380 x18: 0000000000000000
x17: 296f696c6f662865 x16: 7461646f7470755f x15: 747365745f6f696c
x14: 6f6621284f494c4f x13: 0000000000000001 x12: ffff600036d8b97b
x11: 1fffe00036d8b97a x10: ffff600036d8b97a x9 : dfff800000000000
x8 : 00009fffc9274686 x7 : ffff0001b6c5cbd3 x6 : 0000000000000001
x5 : ffff0000c25896c0 x4 : 0000000000000000 x3 : 0000000000000000
x2 : 0000000000000000 x1 : ffff0000c25896c0 x0 : 0000000000000000
Call trace:
 add_to_swap+0xbc/0x158
 shrink_folio_list+0x12ac/0x2648
 shrink_inactive_list+0x318/0x948
 shrink_lruvec+0x450/0x720
 shrink_node_memcgs+0x280/0x4a8
 shrink_node+0x128/0x978
 balance_pgdat+0x4f0/0xb20
 kswapd+0x228/0x438
 kthread+0x214/0x230
 ret_from_fork+0x10/0x20

I can reproduce this issue with the following steps:

1) When a dirty swapcache page is isolated by reclaim process and the
   page isn't locked, inject memory failure for the page. 
   me_swapcache_dirty() clears uptodate flag and tries to delete from lru,
   but fails.  Reclaim process will put the hwpoisoned page back to lru.

2) The process that maps the hwpoisoned page exits, the page is deleted
   the page will never be freed and will be in the lru forever.

3) If we trigger a reclaim again and tries to reclaim the page,
   add_to_swap() will trigger VM_BUG_ON_FOLIO due to the uptodate flag is
   cleared.

To fix it, skip the hwpoisoned page in shrink_folio_list().  Besides, the
hwpoison folio may not be unmapped by hwpoison_user_mappings() yet, unmap
it in shrink_folio_list(), otherwise the folio will fail to be unmaped by
hwpoison_user_mappings() since the folio isn't in lru list.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1b0449544c6482179ac84530b61fc192a6527bfd
  - https://git.kernel.org/stable/c/1c9798bf8145a92abf45aa9d38a6406d9eb8bdf0
  - https://git.kernel.org/stable/c/912e9f0300c3564b72a8808db406e313193a37ad

------------------------------------------------------------

CVE ID: CVE-2025-37836
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: Fix reference leak in pci_register_host_bridge()

If device_register() fails, call put_device() to give up the reference to
avoid a memory leak, per the comment at device_register().

Found by code review.

[bhelgaas: squash Dan Carpenter's double free fix from
https://lore.kernel.org/r/db806a6c-a91b-4e5a-a84b-6b7e01bdac85@stanley.mountain]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3297497ad2246eb9243849bfbbc57a0dea97d76e
  - https://git.kernel.org/stable/c/804443c1f27883926de94c849d91f5b7d7d696e9
  - https://git.kernel.org/stable/c/9707d0c932f41006a2701afc926b232b50e356b4
  - https://git.kernel.org/stable/c/b783478e0c53ffb4f04f25fb4e21ef7f482b05df
  - https://git.kernel.org/stable/c/bbba4c50a2d2a1d3f3bf31cc4b8280cb492bf2c7
  - https://git.kernel.org/stable/c/bd2a352a0d72575f1842d28c14c10089f0cfe1ae
  - https://git.kernel.org/stable/c/f4db1b2c9ae3d013733c302ee70cac943b7070c0
  - https://git.kernel.org/stable/c/f9208aec86226524ec1cb68a09ac70e974ea6536

------------------------------------------------------------

CVE ID: CVE-2025-37837
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu/tegra241-cmdqv: Fix warnings due to dmam_free_coherent()

Two WARNINGs are observed when SMMU driver rolls back upon failure:
 arm-smmu-v3.9.auto: Failed to register iommu
 arm-smmu-v3.9.auto: probe with driver arm-smmu-v3 failed with error -22
 ------------[ cut here ]------------
 WARNING: CPU: 5 PID: 1 at kernel/dma/mapping.c:74 dmam_free_coherent+0xc0/0xd8
 Call trace:
  dmam_free_coherent+0xc0/0xd8 (P)
  tegra241_vintf_free_lvcmdq+0x74/0x188
  tegra241_cmdqv_remove_vintf+0x60/0x148
  tegra241_cmdqv_remove+0x48/0xc8
  arm_smmu_impl_remove+0x28/0x60
  devm_action_release+0x1c/0x40
 ------------[ cut here ]------------
 128 pages are still in use!
 WARNING: CPU: 16 PID: 1 at mm/page_alloc.c:6902 free_contig_range+0x18c/0x1c8
 Call trace:
  free_contig_range+0x18c/0x1c8 (P)
  cma_release+0x154/0x2f0
  dma_free_contiguous+0x38/0xa0
  dma_direct_free+0x10c/0x248
  dma_free_attrs+0x100/0x290
  dmam_free_coherent+0x78/0xd8
  tegra241_vintf_free_lvcmdq+0x74/0x160
  tegra241_cmdqv_remove+0x98/0x198
  arm_smmu_impl_remove+0x28/0x60
  devm_action_release+0x1c/0x40

This is because the LVCMDQ queue memory are managed by devres, while that
dmam_free_coherent() is called in the context of devm_action_release().

Jason pointed out that "arm_smmu_impl_probe() has mis-ordered the devres
callbacks if ops->device_remove() is going to be manually freeing things
that probe allocated":
https://lore.kernel.org/linux-iommu/20250407174408.GB1722458@nvidia.com/

In fact, tegra241_cmdqv_init_structures() only allocates memory resources
which means any failure that it generates would be similar to -ENOMEM, so
there is no point in having that "falling back to standard SMMU" routine,
as the standard SMMU would likely fail to allocate memory too.

Remove the unwind part in tegra241_cmdqv_init_structures(), and return a
proper error code to ask SMMU driver to call tegra241_cmdqv_remove() via
impl_ops->device_remove(). Then, drop tegra241_vintf_free_lvcmdq() since
devres will take care of that.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5584dbf393df509159813645a487b1ef76557722
  - https://git.kernel.org/stable/c/767e22001dfce64cc03b7def1562338591ab6031
  - https://git.kernel.org/stable/c/e38ed6908080047d8fa1763d1da86b584f9eb55b
  - https://git.kernel.org/stable/c/e5dd974d6e00704553308ef1a88659f8dcfb39d4

------------------------------------------------------------

CVE ID: CVE-2025-37839
Description: In the Linux kernel, the following vulnerability has been resolved:

jbd2: remove wrong sb->s_sequence check

Journal emptiness is not determined by sb->s_sequence == 0 but rather by
sb->s_start == 0 (which is set a few lines above). Furthermore 0 is a
valid transaction ID so the check can spuriously trigger. Remove the
invalid WARN_ON.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/3b4643ffaf72d7a5a357e9bf68b1775f8cfe7e77
  - https://git.kernel.org/stable/c/9eaec071f111cd2124ce9a5b93536d3f6837d457
  - https://git.kernel.org/stable/c/ad926f735b4d4f10768fec7d080cadeb6d075cac
  - https://git.kernel.org/stable/c/b0cca357f85beb6144ab60c62dcc98508cc044bf
  - https://git.kernel.org/stable/c/b479839525fe7906966cdc4b5b2afbca048558a1
  - https://git.kernel.org/stable/c/c88f7328bb0fff66520fc9164f02b1d06e083c1b
  - https://git.kernel.org/stable/c/c98eb9ffb1d9c98237b5e1668eee17654e129fb0
  - https://git.kernel.org/stable/c/cf30432f5b3064ff85d85639c2f0106f89c566f6
  - https://git.kernel.org/stable/c/e6eff39dd0fe4190c6146069cc16d160e71d1148

------------------------------------------------------------

CVE ID: CVE-2025-37840
Description: In the Linux kernel, the following vulnerability has been resolved:

mtd: rawnand: brcmnand: fix PM resume warning

Fixed warning on PM resume as shown below caused due to uninitialized
struct nand_operation that checks chip select field :
WARN_ON(op->cs >= nanddev_ntargets(&chip->base)

[   14.588522] ------------[ cut here ]------------
[   14.588529] WARNING: CPU: 0 PID: 1392 at drivers/mtd/nand/raw/internals.h:139 nand_reset_op+0x1e0/0x1f8
[   14.588553] Modules linked in: bdc udc_core
[   14.588579] CPU: 0 UID: 0 PID: 1392 Comm: rtcwake Tainted: G        W          6.14.0-rc4-g5394eea10651 #16
[   14.588590] Tainted: [W]=WARN
[   14.588593] Hardware name: Broadcom STB (Flattened Device Tree)
[   14.588598] Call trace:
[   14.588604]  dump_backtrace from show_stack+0x18/0x1c
[   14.588622]  r7:00000009 r6:0000008b r5:60000153 r4:c0fa558c
[   14.588625]  show_stack from dump_stack_lvl+0x70/0x7c
[   14.588639]  dump_stack_lvl from dump_stack+0x18/0x1c
[   14.588653]  r5:c08d40b0 r4:c1003cb0
[   14.588656]  dump_stack from __warn+0x84/0xe4
[   14.588668]  __warn from warn_slowpath_fmt+0x18c/0x194
[   14.588678]  r7:c08d40b0 r6:c1003cb0 r5:00000000 r4:00000000
[   14.588681]  warn_slowpath_fmt from nand_reset_op+0x1e0/0x1f8
[   14.588695]  r8:70c40dff r7:89705f41 r6:36b4a597 r5:c26c9444 r4:c26b0048
[   14.588697]  nand_reset_op from brcmnand_resume+0x13c/0x150
[   14.588714]  r9:00000000 r8:00000000 r7:c24f8010 r6:c228a3f8 r5:c26c94bc r4:c26b0040
[   14.588717]  brcmnand_resume from platform_pm_resume+0x34/0x54
[   14.588735]  r5:00000010 r4:c0840a50
[   14.588738]  platform_pm_resume from dpm_run_callback+0x5c/0x14c
[   14.588757]  dpm_run_callback from device_resume+0xc0/0x324
[   14.588776]  r9:c24f8054 r8:c24f80a0 r7:00000000 r6:00000000 r5:00000010 r4:c24f8010
[   14.588779]  device_resume from dpm_resume+0x130/0x160
[   14.588799]  r9:c22539e4 r8:00000010 r7:c22bebb0 r6:c24f8010 r5:c22539dc r4:c22539b0
[   14.588802]  dpm_resume from dpm_resume_end+0x14/0x20
[   14.588822]  r10:c2204e40 r9:00000000 r8:c228a3fc r7:00000000 r6:00000003 r5:c228a414
[   14.588826]  r4:00000010
[   14.588828]  dpm_resume_end from suspend_devices_and_enter+0x274/0x6f8
[   14.588848]  r5:c228a414 r4:00000000
[   14.588851]  suspend_devices_and_enter from pm_suspend+0x228/0x2bc
[   14.588868]  r10:c3502910 r9:c3501f40 r8:00000004 r7:c228a438 r6:c0f95e18 r5:00000000
[   14.588871]  r4:00000003
[   14.588874]  pm_suspend from state_store+0x74/0xd0
[   14.588889]  r7:c228a438 r6:c0f934c8 r5:00000003 r4:00000003
[   14.588892]  state_store from kobj_attr_store+0x1c/0x28
[   14.588913]  r9:00000000 r8:00000000 r7:f09f9f08 r6:00000004 r5:c3502900 r4:c0283250
[   14.588916]  kobj_attr_store from sysfs_kf_write+0x40/0x4c
[   14.588936]  r5:c3502900 r4:c0d92a48
[   14.588939]  sysfs_kf_write from kernfs_fop_write_iter+0x104/0x1f0
[   14.588956]  r5:c3502900 r4:c3501f40
[   14.588960]  kernfs_fop_write_iter from vfs_write+0x250/0x420
[   14.588980]  r10:c0e14b48 r9:00000000 r8:c25f5780 r7:00443398 r6:f09f9f68 r5:c34f7f00
[   14.588983]  r4:c042a88c
[   14.588987]  vfs_write from ksys_write+0x74/0xe4
[   14.589005]  r10:00000004 r9:c25f5780 r8:c02002fA0 r7:00000000 r6:00000000 r5:c34f7f00
[   14.589008]  r4:c34f7f00
[   14.589011]  ksys_write from sys_write+0x10/0x14
[   14.589029]  r7:00000004 r6:004421c0 r5:00443398 r4:00000004
[   14.589032]  sys_write from ret_fast_syscall+0x0/0x5c
[   14.589044] Exception stack(0xf09f9fa8 to 0xf09f9ff0)
[   14.589050] 9fa0:                   00000004 00443398 00000004 00443398 00000004 00000001
[   14.589056] 9fc0: 00000004 00443398 004421c0 00000004 b6ecbd58 00000008 bebfbc38 0043eb78
[   14.589062] 9fe0: 00440eb0 bebfbaf8 b6de18a0 b6e579e8
[   14.589065] ---[ end trace 0000000000000000 ]---

The fix uses the higher level nand_reset(chip, chipnr); where chipnr = 0, when
doing PM resume operation in compliance with the controller support for single
die nand chip. Switching from nand_reset_op() to nan
---truncated---
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/659b1f29f3e2fd5d751fdf35c5526d1f1c9b3dd2
  - https://git.kernel.org/stable/c/6f567c6a5250e3531cfd9c7ff254ecc2650464fa
  - https://git.kernel.org/stable/c/7266066b9469f04ed1d4c0fdddaea1425835eb55
  - https://git.kernel.org/stable/c/8775581e1c48e1bdd04a893d6f6bbe5128ad0ea7
  - https://git.kernel.org/stable/c/9bd51723ab51580e077c91d494c37e80703b8524
  - https://git.kernel.org/stable/c/9dd161f707ecb7db38e5f529e979a5b6eb565b2d
  - https://git.kernel.org/stable/c/c2eb3cffb0d972c5503e4d48921971c81def0fe5
  - https://git.kernel.org/stable/c/ddc210cf8b8a8be68051ad958bf3e2cef6b681c2
  - https://git.kernel.org/stable/c/fbcb584efa5cd912ff8a151d67b8fe22f4162a85

------------------------------------------------------------

CVE ID: CVE-2025-37841
Description: In the Linux kernel, the following vulnerability has been resolved:

pm: cpupower: bench: Prevent NULL dereference on malloc failure

If malloc returns NULL due to low memory, 'config' pointer can be NULL.
Add a check to prevent NULL dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0e297a02e03dceb2874789ca40bd4e65c5371704
  - https://git.kernel.org/stable/c/208baa3ec9043a664d9acfb8174b332e6b17fb69
  - https://git.kernel.org/stable/c/34a9394794b0f97af6afedc0c9ee2012c24b28ed
  - https://git.kernel.org/stable/c/5e38122aa3fd0f9788186e86a677925bfec0b2d1
  - https://git.kernel.org/stable/c/79bded9d70142d2a11d931fc029afece471641db
  - https://git.kernel.org/stable/c/87b9f0867c0afa7e892f4b30c36cff6bf2707f85
  - https://git.kernel.org/stable/c/942a4b97fc77516678b1d8af1521ff9a94c13b3e
  - https://git.kernel.org/stable/c/ceec06f464d5cfc0ba966225f7d50506ceb62242
  - https://git.kernel.org/stable/c/f8d28fa305b78c5d1073b63f26db265ba8291ae1

------------------------------------------------------------

CVE ID: CVE-2025-37842
Description: In the Linux kernel, the following vulnerability has been resolved:

spi: fsl-qspi: use devm function instead of driver remove

Driver use devm APIs to manage clk/irq/resources and register the spi
controller, but the legacy remove function will be called first during
device detach and trigger kernel panic. Drop the remove function and use
devm_add_action_or_reset() for driver cleanup to ensure the release
sequence.

Trigger kernel panic on i.MX8MQ by
echo 30bb0000.spi >/sys/bus/platform/drivers/fsl-quadspi/unbind
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/40369bfe717e96e26650eeecfa5a6363563df6e4
  - https://git.kernel.org/stable/c/439688dbe82baa10d4430dc3252bb5ef1183a171
  - https://git.kernel.org/stable/c/f9bfb3a5f6f616f3eb7665c8ff3bcb9760ae33c8

------------------------------------------------------------

CVE ID: CVE-2025-37843
Description: In the Linux kernel, the following vulnerability has been resolved:

PCI: pciehp: Avoid unnecessary device replacement check

Hot-removal of nested PCI hotplug ports suffers from a long-standing race
condition which can lead to a deadlock:  A parent hotplug port acquires
pci_lock_rescan_remove(), then waits for pciehp to unbind from a child
hotplug port.  Meanwhile that child hotplug port tries to acquire
pci_lock_rescan_remove() as well in order to remove its own children.

The deadlock only occurs if the parent acquires pci_lock_rescan_remove()
first, not if the child happens to acquire it first.

Several workarounds to avoid the issue have been proposed and discarded
over the years, e.g.:

https://lore.kernel.org/r/4c882e25194ba8282b78fe963fec8faae7cf23eb.1529173804.git.lukas@wunner.de/

A proper fix is being worked on, but needs more time as it is nontrivial
and necessarily intrusive.

Recent commit 9d573d19547b ("PCI: pciehp: Detect device replacement during
system sleep") provokes more frequent occurrence of the deadlock when
removing more than one Thunderbolt device during system sleep.  The commit
sought to detect device replacement, but also triggered on device removal.
Differentiating reliably between replacement and removal is impossible
because pci_get_dsn() returns 0 both if the device was removed, as well as
if it was replaced with one lacking a Device Serial Number.

Avoid the more frequent occurrence of the deadlock by checking whether the
hotplug port itself was hot-removed.  If so, there's no sense in checking
whether its child device was replaced.

This works because the ->resume_noirq() callback is invoked in top-down
order for the entire hierarchy:  A parent hotplug port detecting device
replacement (or removal) marks all children as removed using
pci_dev_set_disconnected() and a child hotplug port can then reliably
detect being removed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d0bbd01f7c0ac7d1be9f85aaf2cd0baec34655f
  - https://git.kernel.org/stable/c/7535d10a2c61baeff493300070cf04d9ddda216b
  - https://git.kernel.org/stable/c/e3260237aaadc9799107ccb940c6688195c4518d
  - https://git.kernel.org/stable/c/e4a1d7defbc2d806540720a5adebe24ec3488683

------------------------------------------------------------

CVE ID: CVE-2025-37844
Description: In the Linux kernel, the following vulnerability has been resolved:

cifs: avoid NULL pointer dereference in dbg call

cifs_server_dbg() implies server to be non-NULL so
move call under condition to avoid NULL pointer dereference.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/20048e658652e731f5cadf4a695925e570ca0ff9
  - https://git.kernel.org/stable/c/6c14ee6af8f1f188b668afd6d003f7516a507b08
  - https://git.kernel.org/stable/c/864ba5c651b03830f36f0906c21af05b15c1aaa6
  - https://git.kernel.org/stable/c/9c9000cb91b986eb7f75835340c67857ab97c09b
  - https://git.kernel.org/stable/c/b2a1833e1c63e2585867ebeaf4dd41494dcede4b
  - https://git.kernel.org/stable/c/b4885bd5935bb26f0a414ad55679a372e53f9b9b
  - https://git.kernel.org/stable/c/ba3ce6c60cd5db258687dfeba9fc608f5e7cadf3
  - https://git.kernel.org/stable/c/e0717385f5c51e290c2cd2ad4699a778316b5132

------------------------------------------------------------

CVE ID: CVE-2025-37845
Description: In the Linux kernel, the following vulnerability has been resolved:

tracing: fprobe events: Fix possible UAF on modules

Commit ac91052f0ae5 ("tracing: tprobe-events: Fix leakage of module
refcount") moved try_module_get() from __find_tracepoint_module_cb()
to find_tracepoint() caller, but that introduced a possible UAF
because the module can be unloaded before try_module_get(). In this
case, the module object should be freed too. Thus, try_module_get()
does not only fail but may access to the freed object.

To avoid that, try_module_get() in __find_tracepoint_module_cb()
again.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/626f01f4d26e8cf92e69c1df53036153c8e98a20
  - https://git.kernel.org/stable/c/868df4eb784c3ccc7e4340a9ea993cbbedca167e
  - https://git.kernel.org/stable/c/a27d2de2472b1cc7d582ab405d1d5832a80481de
  - https://git.kernel.org/stable/c/dd941507a9486252d6fcf11814387666792020f3

------------------------------------------------------------

CVE ID: CVE-2025-37846
Description: In the Linux kernel, the following vulnerability has been resolved:

arm64: mops: Do not dereference src reg for a set operation

The source register is not used for SET* and reading it can result in
a UBSAN out-of-bounds array access error, specifically when the MOPS
exception is taken from a SET* sequence with XZR (reg 31) as the
source. Architecturally this is the only case where a src/dst/size
field in the ESR can be reported as 31.

Prior to 2de451a329cf662b the code in do_el0_mops() was benign as the
use of pt_regs_read_reg() prevented the out-of-bounds access.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/43267d934eacff6c70e15545d804ebbcab8a0bf5
  - https://git.kernel.org/stable/c/5f6022a74147675124b781fdc056b291850e7786
  - https://git.kernel.org/stable/c/a13bfa4fe0d6949cea14718df2d1fe84c38cd113
  - https://git.kernel.org/stable/c/eec737e17e5567e08148550a7f1d94d495b9fb17

------------------------------------------------------------

CVE ID: CVE-2025-37847
Description: In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix deadlock in ivpu_ms_cleanup()

Fix deadlock in ivpu_ms_cleanup() by preventing runtime resume after
file_priv->ms_lock is acquired.

During a failure in runtime resume, a cold boot is executed, which
calls ivpu_ms_cleanup_all(). This function calls ivpu_ms_cleanup()
that acquires file_priv->ms_lock and causes the deadlock.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/019634f27a16796eab749e8107dae32099945f29
  - https://git.kernel.org/stable/c/7d12a7d43c7bab9097ba466581d8db702e7908dc
  - https://git.kernel.org/stable/c/9a6f56762d23a1f3af15e67901493c927caaf882
  - https://git.kernel.org/stable/c/f996ecc789b5dbaaf38b6ec0a1917821789cbd9c

------------------------------------------------------------

CVE ID: CVE-2025-37848
Description: In the Linux kernel, the following vulnerability has been resolved:

accel/ivpu: Fix PM related deadlocks in MS IOCTLs

Prevent runtime resume/suspend while MS IOCTLs are in progress.
Failed suspend will call ivpu_ms_cleanup() that would try to acquire
file_priv->ms_lock, which is already held by the IOCTLs.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/84547128526441b45c3c241419dececf20c30104
  - https://git.kernel.org/stable/c/afada73000bef7c79a22f0d7e93fac414eeff19e
  - https://git.kernel.org/stable/c/c3d9fc2f2746b52e9f820a13c53b4418bec04b48
  - https://git.kernel.org/stable/c/d893da85e06edf54737bb80648bb58ba8fd56d9f

------------------------------------------------------------

CVE ID: CVE-2025-37849
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: arm64: Tear down vGIC on failed vCPU creation

If kvm_arch_vcpu_create() fails to share the vCPU page with the
hypervisor, we propagate the error back to the ioctl but leave the
vGIC vCPU data initialised. Note only does this leak the corresponding
memory when the vCPU is destroyed but it can also lead to use-after-free
if the redistributor device handling tries to walk into the vCPU.

Add the missing cleanup to kvm_arch_vcpu_create(), ensuring that the
vGIC vCPU structures are destroyed on error.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/07476e0d932afc53c05468076393ac35d0b4999e
  - https://git.kernel.org/stable/c/2480326eba8ae9ccc5e4c3c2dc8d407db68e3c52
  - https://git.kernel.org/stable/c/250f25367b58d8c65a1b060a2dda037eea09a672
  - https://git.kernel.org/stable/c/5085e02362b9948f82fceca979b8f8e12acb1cc5
  - https://git.kernel.org/stable/c/c322789613407647a05ff5c451a7bf545fb34e73
  - https://git.kernel.org/stable/c/f1e9087abaeedec9bf2894a282ee4f0d8383f299

------------------------------------------------------------

CVE ID: CVE-2025-37850
Description: In the Linux kernel, the following vulnerability has been resolved:

pwm: mediatek: Prevent divide-by-zero in pwm_mediatek_config()

With CONFIG_COMPILE_TEST && !CONFIG_HAVE_CLK, pwm_mediatek_config() has a
divide-by-zero in the following line:

	do_div(resolution, clk_get_rate(pc->clk_pwms[pwm->hwpwm]));

due to the fact that the !CONFIG_HAVE_CLK version of clk_get_rate()
returns zero.

This is presumably just a theoretical problem: COMPILE_TEST overrides
the dependency on RALINK which would select COMMON_CLK.  Regardless it's
a good idea to check for the error explicitly to avoid divide-by-zero.

Fixes the following warning:

  drivers/pwm/pwm-mediatek.o: warning: objtool: .text: unexpected end of section

[ukleinek: s/CONFIG_CLK/CONFIG_HAVE_CLK/]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/4cb15042b5f3ec0474e91cf379120cc597625dbb
  - https://git.kernel.org/stable/c/77fb96dbe350e8a5ae4965ff9f6e7049f3966a6b
  - https://git.kernel.org/stable/c/7ca59947b5fcf94e7ea4029d1bd0f7c41500a161
  - https://git.kernel.org/stable/c/8b9f60725d74b72c238e4437c957d0217746b506
  - https://git.kernel.org/stable/c/8ddbec73ea2598d8414e8f7103241b55cf877010
  - https://git.kernel.org/stable/c/c343856ff2689ce0afef823592732fc178ef4aac
  - https://git.kernel.org/stable/c/e1206d8e1651c9f62e5640b69b14d925b1a0a00a
  - https://git.kernel.org/stable/c/e3cf0c38d3ce754ad63005102fcfeb0b7ff3290b
  - https://git.kernel.org/stable/c/f3e9cf266c2c103cf071e15d7a17e2c699fff3c5

------------------------------------------------------------

CVE ID: CVE-2025-37851
Description: In the Linux kernel, the following vulnerability has been resolved:

fbdev: omapfb: Add 'plane' value check

Function dispc_ovl_setup is not intended to work with the value OMAP_DSS_WB
of the enum parameter plane.

The value of this parameter is initialized in dss_init_overlays and in the
current state of the code it cannot take this value so it's not a real
problem.

For the purposes of defensive coding it wouldn't be superfluous to check
the parameter value, because some functions down the call stack process
this value correctly and some not.

For example, in dispc_ovl_setup_global_alpha it may lead to buffer
overflow.

Add check for this value.

Found by Linux Verification Center (linuxtesting.org) with SVACE static
analysis tool.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/09dbf22fd68c2f1a81ab89670ffa1ec3033436c4
  - https://git.kernel.org/stable/c/3e411827f31db7f938a30a3c7a7599839401ec30
  - https://git.kernel.org/stable/c/4efd8ef5e40f2c7a4a91a5a9f03140bfa827da89
  - https://git.kernel.org/stable/c/52eafaa56f8f6d6a0cdff9282b25b4acbde34edc
  - https://git.kernel.org/stable/c/660a53a0694d1f3789802509fe729dd4656fc5e0
  - https://git.kernel.org/stable/c/9b0a41589ee70529b20e1e0108d03f10c649bdc4
  - https://git.kernel.org/stable/c/a570efb4d877adbf3db2dc95487f2ba6bfdd148a
  - https://git.kernel.org/stable/c/cdf41d72e8b015d9ea68f5a1c0a79624e7c312aa
  - https://git.kernel.org/stable/c/fda15c5b96b883d62fb2d84a3a1422aa87717897

------------------------------------------------------------

CVE ID: CVE-2025-37852
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: handle amdgpu_cgs_create_device() errors in amd_powerplay_create()

Add error handling to propagate amdgpu_cgs_create_device() failures
to the caller. When amdgpu_cgs_create_device() fails, release hwmgr
and return -ENOMEM to prevent null pointer dereference.

[v1]->[v2]: Change error code from -EINVAL to -ENOMEM. Free hwmgr.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1435e895d4fc967d64e9f5bf81e992ac32f5ac76
  - https://git.kernel.org/stable/c/22ea19cc089013b55c240134dbb2797700ff5a6a
  - https://git.kernel.org/stable/c/55ef52c30c3e747f145a64de96192e37a8fed670
  - https://git.kernel.org/stable/c/b784734811438f11533e2fb9e0deb327844bdb56
  - https://git.kernel.org/stable/c/dc4380f34613eaae997b3ed263bd1cb3d0fd0075
  - https://git.kernel.org/stable/c/f8693e1bae9c08233a2f535c3f412e157df32b33

------------------------------------------------------------

CVE ID: CVE-2025-37853
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: debugfs hang_hws skip GPU with MES

debugfs hang_hws is used by GPU reset test with HWS, for MES this crash
the kernel with NULL pointer access because dqm->packet_mgr is not setup
for MES path.

Skip GPU with MES for now, MES hang_hws debugfs interface will be
supported later.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1a322b330dc0b775d1d7a84e55c752d9451bfe7d
  - https://git.kernel.org/stable/c/24b9e0e2e6147314c22d821f0542c4dd9a320c40
  - https://git.kernel.org/stable/c/a36f8d544522a19ef06ed9e84667d154dcb6be52
  - https://git.kernel.org/stable/c/f84c57906f0fd2185e557d2552b20aa8430a4677
  - https://git.kernel.org/stable/c/fe9d0061c413f8fb8c529b18b592b04170850ded

------------------------------------------------------------

CVE ID: CVE-2025-37854
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Fix mode1 reset crash issue

If HW scheduler hangs and mode1 reset is used to recover GPU, KFD signal
user space to abort the processes. After process abort exit, user queues
still use the GPU to access system memory before h/w is reset while KFD
cleanup worker free system memory and free VRAM.

There is use-after-free race bug that KFD allocate and reuse the freed
system memory, and user queue write to the same system memory to corrupt
the data structure and cause driver crash.

To fix this race, KFD cleanup worker terminate user queues, then flush
reset_domain wq to wait for any GPU ongoing reset complete, and then
free outstanding BOs.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/57c9dabda80ac167de8cd71231baae37cc2f442d
  - https://git.kernel.org/stable/c/6f30a847432cae84c7428e9b684b3e3fa49b2391
  - https://git.kernel.org/stable/c/89af6b39f028c130d4362f57042927f005423e6a
  - https://git.kernel.org/stable/c/9c4bcdf4068aae3e17e31c144300be405cfa03ff
  - https://git.kernel.org/stable/c/f0b4440cdc1807bb6ec3dce0d6de81170803569b
  - https://git.kernel.org/stable/c/ffd37d7d44d7e0b6e769d4fe6590e327f8cc3951

------------------------------------------------------------

CVE ID: CVE-2025-37855
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Guard Possible Null Pointer Dereference

[WHY]
In some situations, dc->res_pool may be null.

[HOW]
Check if pointer is null before dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/c87d202692de34ee71d1fd4679a549a29095658a
  - https://git.kernel.org/stable/c/dc2de1ac7145f882f3c03d2d6f84583ae7e35d41

------------------------------------------------------------

CVE ID: CVE-2025-37856
Description: In the Linux kernel, the following vulnerability has been resolved:

btrfs: harden block_group::bg_list against list_del() races

As far as I can tell, these calls of list_del_init() on bg_list cannot
run concurrently with btrfs_mark_bg_unused() or btrfs_mark_bg_to_reclaim(),
as they are in transaction error paths and situations where the block
group is readonly.

However, if there is any chance at all of racing with mark_bg_unused(),
or a different future user of bg_list, better to be safe than sorry.

Otherwise we risk the following interleaving (bg_list refcount in parens)

T1 (some random op)                       T2 (btrfs_mark_bg_unused)
                                        !list_empty(&bg->bg_list); (1)
list_del_init(&bg->bg_list); (1)
                                        list_move_tail (1)
btrfs_put_block_group (0)
                                        btrfs_delete_unused_bgs
                                             bg = list_first_entry
                                             list_del_init(&bg->bg_list);
                                             btrfs_put_block_group(bg); (-1)

Ultimately, this results in a broken ref count that hits zero one deref
early and the real final deref underflows the refcount, resulting in a WARNING.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/185fd73e5ac06027c4be9a129e59193f6a3ef202
  - https://git.kernel.org/stable/c/7511e29cf1355b2c47d0effb39e463119913e2f6
  - https://git.kernel.org/stable/c/909e60fb469d4101c6b08cf6e622efb062bb24a1
  - https://git.kernel.org/stable/c/bf089c4d1141b27332c092b1dcca5022c415a3b6

------------------------------------------------------------

CVE ID: CVE-2025-37857
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: st: Fix array overflow in st_setup()

Change the array size to follow parms size instead of a fixed value.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/574b399a7fb6ae71c97e26d122205c4a720c0e43
  - https://git.kernel.org/stable/c/736ae988bfb5932c05625baff70fba224d547c08
  - https://git.kernel.org/stable/c/7fe3b4deed8b93609058c37c9a11df1d2b2c0423
  - https://git.kernel.org/stable/c/a018d1cf990d0c339fe0e29b762ea5dc10567d67
  - https://git.kernel.org/stable/c/ad4c3037dc77739a625246a2a0fb23b8f3402c06
  - https://git.kernel.org/stable/c/c6015d0f7a2236ddb3928b2dfcb1c556a1368b55
  - https://git.kernel.org/stable/c/e4d1ca0a84a6650d3172eb8c07ef2fbc585b0d96
  - https://git.kernel.org/stable/c/e6b585d016c47ca8a37b92ea8a3fe35c0b585256
  - https://git.kernel.org/stable/c/f746fe0c51e044d1248dc67918328bfb3d86b639

------------------------------------------------------------

CVE ID: CVE-2025-37858
Description: In the Linux kernel, the following vulnerability has been resolved:

fs/jfs: Prevent integer overflow in AG size calculation

The JFS filesystem calculates allocation group (AG) size using 1 <<
l2agsize in dbExtendFS(). When l2agsize exceeds 31 (possible with >2TB
aggregates on 32-bit systems), this 32-bit shift operation causes undefined
behavior and improper AG sizing.

On 32-bit architectures:
- Left-shifting 1 by 32+ bits results in 0 due to integer overflow
- This creates invalid AG sizes (0 or garbage values) in
sbi->bmap->db_agsize
- Subsequent block allocations would reference invalid AG structures
- Could lead to:
  - Filesystem corruption during extend operations
  - Kernel crashes due to invalid memory accesses
  - Security vulnerabilities via malformed on-disk structures

Fix by casting to s64 before shifting:
bmp->db_agsize = (s64)1 << l2agsize;

This ensures 64-bit arithmetic even on 32-bit architectures. The cast
matches the data type of db_agsize (s64) and follows similar patterns in
JFS block calculation code.

Found by Linux Verification Center (linuxtesting.org) with SVACE.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/211ed8f5e39e61f9e4d18edd64ce8005a67a1b2a
  - https://git.kernel.org/stable/c/3d8a45f87010a802aa214bf39702ca9d99cbf3ba
  - https://git.kernel.org/stable/c/55edbf5dbf60a8195c21e92124c4028939ae16b2
  - https://git.kernel.org/stable/c/7ccf3b35274512b60ecb614e0637e76bd6f2d829
  - https://git.kernel.org/stable/c/7fcbf789629cdb9fbf4e2172ce31136cfed11e5e
  - https://git.kernel.org/stable/c/8bb29629a5e4090e1ef7199cb42db04a52802239
  - https://git.kernel.org/stable/c/c802a6a4009f585111f903e810b3be9c6d0da329
  - https://git.kernel.org/stable/c/dd07a985e2ded47b6c7d69fc93c1fe02977c8454
  - https://git.kernel.org/stable/c/ec34cdf4f917cc6abd306cf091f8b8361fedac88

------------------------------------------------------------

CVE ID: CVE-2025-37859
Description: In the Linux kernel, the following vulnerability has been resolved:

page_pool: avoid infinite loop to schedule delayed worker

We noticed the kworker in page_pool_release_retry() was waken
up repeatedly and infinitely in production because of the
buggy driver causing the inflight less than 0 and warning
us in page_pool_inflight()[1].

Since the inflight value goes negative, it means we should
not expect the whole page_pool to get back to work normally.

This patch mitigates the adverse effect by not rescheduling
the kworker when detecting the inflight negative in
page_pool_release_retry().

[1]
[Mon Feb 10 20:36:11 2025] ------------[ cut here ]------------
[Mon Feb 10 20:36:11 2025] Negative(-51446) inflight packet-pages
...
[Mon Feb 10 20:36:11 2025] Call Trace:
[Mon Feb 10 20:36:11 2025]  page_pool_release_retry+0x23/0x70
[Mon Feb 10 20:36:11 2025]  process_one_work+0x1b1/0x370
[Mon Feb 10 20:36:11 2025]  worker_thread+0x37/0x3a0
[Mon Feb 10 20:36:11 2025]  kthread+0x11a/0x140
[Mon Feb 10 20:36:11 2025]  ? process_one_work+0x370/0x370
[Mon Feb 10 20:36:11 2025]  ? __kthread_cancel_work+0x40/0x40
[Mon Feb 10 20:36:11 2025]  ret_from_fork+0x35/0x40
[Mon Feb 10 20:36:11 2025] ---[ end trace ebffe800f33e7e34 ]---
Note: before this patch, the above calltrace would flood the
dmesg due to repeated reschedule of release_dw kworker.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/43130d02baa137033c25297aaae95fd0edc41654
  - https://git.kernel.org/stable/c/7204335d1991c23fc615ab76f31f175748a578e1
  - https://git.kernel.org/stable/c/738d1812ec2e395e953258aea912ddd867d11a13
  - https://git.kernel.org/stable/c/90e089a64504982f8d62f223027cb9f903781f78
  - https://git.kernel.org/stable/c/91522aba56e9fcdf64da25ffef9b27f8fad48e0f
  - https://git.kernel.org/stable/c/95f17738b86fd198924d874a5639bcdc49c7e5b8
  - https://git.kernel.org/stable/c/9f71db4fb82deb889e0bac4a51b34daea7d506a3
  - https://git.kernel.org/stable/c/c3c7c57017ce1d4b2d3788c1fc59e7e39026e158
  - https://git.kernel.org/stable/c/e74e5aa33228c5e2cb4fc80ad103541a7b7805ec

------------------------------------------------------------

CVE ID: CVE-2025-37861
Description: In the Linux kernel, the following vulnerability has been resolved:

scsi: mpi3mr: Synchronous access b/w reset and tm thread for reply queue

When the task management thread processes reply queues while the reset
thread resets them, the task management thread accesses an invalid queue ID
(0xFFFF), set by the reset thread, which points to unallocated memory,
causing a crash.

Add flag 'io_admin_reset_sync' to synchronize access between the reset,
I/O, and admin threads. Before a reset, the reset handler sets this flag to
block I/O and admin processing threads. If any thread bypasses the initial
check, the reset thread waits up to 10 seconds for processing to finish. If
the wait exceeds 10 seconds, the controller is marked as unrecoverable.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/65ba18c84dbd03afe9b38c06c151239d97a09834
  - https://git.kernel.org/stable/c/75b67dca4195e11ccf966a704787b2aa2754a457
  - https://git.kernel.org/stable/c/8d310d66e2b0f5f9f709764641647e8a3a4924fa
  - https://git.kernel.org/stable/c/f195fc060c738d303a21fae146dbf85e1595fb4c

------------------------------------------------------------

CVE ID: CVE-2025-37862
Description: In the Linux kernel, the following vulnerability has been resolved:

HID: pidff: Fix null pointer dereference in pidff_find_fields

This function triggered a null pointer dereference if used to search for
a report that isn't implemented on the device. This happened both for
optional and required reports alike.

The same logic was applied to pidff_find_special_field and although
pidff_init_fields should return an error earlier if one of the required
reports is missing, future modifications could change this logic and
resurface this possible null pointer dereference again.

LKML bug report:
https://lore.kernel.org/all/CAL-gK7f5=R0nrrQdPtaZZr1fd-cdAMbDMuZ_NLA8vM0SX+nGSw@mail.gmail.com
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/22a05462c3d0eee15154faf8d13c49e6295270a5
  - https://git.kernel.org/stable/c/3a507184f9307e19cb441b897c49e7843c94e56b
  - https://git.kernel.org/stable/c/44a1b8b2027afbb37e418993fb23561bdb9efb38
  - https://git.kernel.org/stable/c/6b4449e4f03326fbd2136e67bfcc1e6ffe61541d
  - https://git.kernel.org/stable/c/be706a48bb7896d4130edc82811233d1d62158e7
  - https://git.kernel.org/stable/c/d230becb9d38b7325c5c38d051693e4c26b1829b
  - https://git.kernel.org/stable/c/ddb147885225d768025f6818df533d30edf3e102
  - https://git.kernel.org/stable/c/e368698da79af821f18c099520deab1219c2044b
  - https://git.kernel.org/stable/c/f8f4d77710e1c38f4a2bd26c88c4878b5b5e817a

------------------------------------------------------------

CVE ID: CVE-2025-37863
Description: In the Linux kernel, the following vulnerability has been resolved:

ovl: don't allow datadir only

In theory overlayfs could support upper layer directly referring to a data
layer, but there's no current use case for this.

Originally, when data-only layers were introduced, this wasn't allowed,
only introduced by the "datadir+" feature, but without actually handling
this case, resulting in an Oops.

Fix by disallowing datadir without lowerdir.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0874b629f65320778e7e3e206177770666d9db18
  - https://git.kernel.org/stable/c/21d2ffb0e9838a175064c22f3a9de97d1f56f27d
  - https://git.kernel.org/stable/c/b9e3579213ba648fa23f780e8d53e99011c62331
  - https://git.kernel.org/stable/c/eb3a04a8516ee9b5174379306f94279fc90424c4

------------------------------------------------------------

CVE ID: CVE-2025-37864
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: clean up FDB, MDB, VLAN entries on unbind

As explained in many places such as commit b117e1e8a86d ("net: dsa:
delete dsa_legacy_fdb_add and dsa_legacy_fdb_del"), DSA is written given
the assumption that higher layers have balanced additions/deletions.
As such, it only makes sense to be extremely vocal when those
assumptions are violated and the driver unbinds with entries still
present.

But Ido Schimmel points out a very simple situation where that is wrong:
https://lore.kernel.org/netdev/ZDazSM5UsPPjQuKr@shredder/
(also briefly discussed by me in the aforementioned commit).

Basically, while the bridge bypass operations are not something that DSA
explicitly documents, and for the majority of DSA drivers this API
simply causes them to go to promiscuous mode, that isn't the case for
all drivers. Some have the necessary requirements for bridge bypass
operations to do something useful - see dsa_switch_supports_uc_filtering().

Although in tools/testing/selftests/net/forwarding/local_termination.sh,
we made an effort to popularize better mechanisms to manage address
filters on DSA interfaces from user space - namely macvlan for unicast,
and setsockopt(IP_ADD_MEMBERSHIP) - through mtools - for multicast, the
fact is that 'bridge fdb add ... self static local' also exists as
kernel UAPI, and might be useful to someone, even if only for a quick
hack.

It seems counter-productive to block that path by implementing shim
.ndo_fdb_add and .ndo_fdb_del operations which just return -EOPNOTSUPP
in order to prevent the ndo_dflt_fdb_add() and ndo_dflt_fdb_del() from
running, although we could do that.

Accepting that cleanup is necessary seems to be the only option.
Especially since we appear to be coming back at this from a different
angle as well. Russell King is noticing that the WARN_ON() triggers even
for VLANs:
https://lore.kernel.org/netdev/Z_li8Bj8bD4-BYKQ@shell.armlinux.org.uk/

What happens in the bug report above is that dsa_port_do_vlan_del() fails,
then the VLAN entry lingers on, and then we warn on unbind and leak it.

This is not a straight revert of the blamed commit, but we now add an
informational print to the kernel log (to still have a way to see
that bugs exist), and some extra comments gathered from past years'
experience, to justify the logic.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/7afb5fb42d4950f33af2732b8147c552659f79b7
  - https://git.kernel.org/stable/c/86c6613a69bca815f1865ed8cedfd4b9142621ab
  - https://git.kernel.org/stable/c/8fcc1e6f808912977caf17366c625b95dc29ba4f
  - https://git.kernel.org/stable/c/99c50c98803425378e08a7394dc885506dc85f06

------------------------------------------------------------

CVE ID: CVE-2025-37865
Description: In the Linux kernel, the following vulnerability has been resolved:

net: dsa: mv88e6xxx: fix -ENOENT when deleting VLANs and MST is unsupported

Russell King reports that on the ZII dev rev B, deleting a bridge VLAN
from a user port fails with -ENOENT:
https://lore.kernel.org/netdev/Z_lQXNP0s5-IiJzd@shell.armlinux.org.uk/

This comes from mv88e6xxx_port_vlan_leave() -> mv88e6xxx_mst_put(),
which tries to find an MST entry in &chip->msts associated with the SID,
but fails and returns -ENOENT as such.

But we know that this chip does not support MST at all, so that is not
surprising. The question is why does the guard in mv88e6xxx_mst_put()
not exit early:

	if (!sid)
		return 0;

And the answer seems to be simple: the sid comes from vlan.sid which
supposedly was previously populated by mv88e6xxx_vtu_get().
But some chip->info->ops->vtu_getnext() implementations do not populate
vlan.sid, for example see mv88e6185_g1_vtu_getnext(). In that case,
later in mv88e6xxx_port_vlan_leave() we are using a garbage sid which is
just residual stack memory.

Testing for sid == 0 covers all cases of a non-bridge VLAN or a bridge
VLAN mapped to the default MSTI. For some chips, SID 0 is valid and
installed by mv88e6xxx_stu_setup(). A chip which does not support the
STU would implicitly only support mapping all VLANs to the default MSTI,
so although SID 0 is not valid, it would be sufficient, if we were to
zero-initialize the vlan structure, to fix the bug, due to the
coincidence that a test for vlan.sid == 0 already exists and leads to
the same (correct) behavior.

Another option which would be sufficient would be to add a test for
mv88e6xxx_has_stu() inside mv88e6xxx_mst_put(), symmetric to the one
which already exists in mv88e6xxx_mst_get(). But that placement means
the caller will have to dereference vlan.sid, which means it will access
uninitialized memory, which is not nice even if it ignores it later.

So we end up making both modifications, in order to not rely just on the
sid == 0 coincidence, but also to avoid having uninitialized structure
fields which might get temporarily accessed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/35cde75c08a1fa1a5ac0467afe2709caceeef002
  - https://git.kernel.org/stable/c/9da4acbd60664271d34a627f7f63cd5bad8eba74
  - https://git.kernel.org/stable/c/9ee6d3a368ed34f2457863da3085c676e9e37a3d
  - https://git.kernel.org/stable/c/afae9087301471970254a9180e5a26d3d8e8af09
  - https://git.kernel.org/stable/c/ea08dfc35f83cfc73493c52f63ae4f2e29edfe8d

------------------------------------------------------------

CVE ID: CVE-2025-37866
Description: In the Linux kernel, the following vulnerability has been resolved:

mlxbf-bootctl: use sysfs_emit_at() in secure_boot_fuse_state_show()

A warning is seen when running the latest kernel on a BlueField SOC:
[251.512704] ------------[ cut here ]------------
[251.512711] invalid sysfs_emit: buf:0000000003aa32ae
[251.512720] WARNING: CPU: 1 PID: 705264 at fs/sysfs/file.c:767 sysfs_emit+0xac/0xc8

The warning is triggered because the mlxbf-bootctl driver invokes
"sysfs_emit()" with a buffer pointer that is not aligned to the
start of the page. The driver should instead use "sysfs_emit_at()"
to support non-zero offsets into the destination buffer.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/5e1dcc5bfd7a2896178c604bc69d6ab9650967da
  - https://git.kernel.org/stable/c/b129005ddfc0e6daf04a6d3b928a9e474f9b3918

------------------------------------------------------------

CVE ID: CVE-2025-37867
Description: In the Linux kernel, the following vulnerability has been resolved:

RDMA/core: Silence oversized kvmalloc() warning

syzkaller triggered an oversized kvmalloc() warning.
Silence it by adding __GFP_NOWARN.

syzkaller log:
 WARNING: CPU: 7 PID: 518 at mm/util.c:665 __kvmalloc_node_noprof+0x175/0x180
 CPU: 7 UID: 0 PID: 518 Comm: c_repro Not tainted 6.11.0-rc6+ #6
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
 RIP: 0010:__kvmalloc_node_noprof+0x175/0x180
 RSP: 0018:ffffc90001e67c10 EFLAGS: 00010246
 RAX: 0000000000000100 RBX: 0000000000000400 RCX: ffffffff8149d46b
 RDX: 0000000000000000 RSI: ffff8881030fae80 RDI: 0000000000000002
 RBP: 000000712c800000 R08: 0000000000000100 R09: 0000000000000000
 R10: ffffc90001e67c10 R11: 0030ae0601000000 R12: 0000000000000000
 R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000000
 FS:  00007fde79159740(0000) GS:ffff88813bdc0000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000020000180 CR3: 0000000105eb4005 CR4: 00000000003706b0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 Call Trace:
  <TASK>
  ib_umem_odp_get+0x1f6/0x390
  mlx5_ib_reg_user_mr+0x1e8/0x450
  ib_uverbs_reg_mr+0x28b/0x440
  ib_uverbs_write+0x7d3/0xa30
  vfs_write+0x1ac/0x6c0
  ksys_write+0x134/0x170
  ? __sanitizer_cov_trace_pc+0x1c/0x50
  do_syscall_64+0x50/0x110
  entry_SYSCALL_64_after_hwframe+0x76/0x7e
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0d81bb58a203ad5f4044dc18cfbc230c194f650a
  - https://git.kernel.org/stable/c/6c588e9afbab240c921f936cb676dac72e2e2b66
  - https://git.kernel.org/stable/c/791daf8240cedf27af8794038ae1d32ef643bce6
  - https://git.kernel.org/stable/c/9a0e6f15029e1a8a21e40f06fd05aa52b7f063de
  - https://git.kernel.org/stable/c/ae470d06320dea4002d441784d691f0a26b4322d
  - https://git.kernel.org/stable/c/f476eba25fdf70faa7b19a3e0fb00e65c5b53106
  - https://git.kernel.org/stable/c/f94ac90ce7bd6f9266ad0d99044ed86e8d1416c1

------------------------------------------------------------

CVE ID: CVE-2025-37868
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe/userptr: fix notifier vs folio deadlock

User is reporting what smells like notifier vs folio deadlock, where
migrate_pages_batch() on core kernel side is holding folio lock(s) and
then interacting with the mappings of it, however those mappings are
tied to some userptr, which means calling into the notifier callback and
grabbing the notifier lock. With perfect timing it looks possible that
the pages we pulled from the hmm fault can get sniped by
migrate_pages_batch() at the same time that we are holding the notifier
lock to mark the pages as accessed/dirty, but at this point we also want
to grab the folio locks(s) to mark them as dirty, but if they are
contended from notifier/migrate_pages_batch side then we deadlock since
folio lock won't be dropped until we drop the notifier lock.

Fortunately the mark_page_accessed/dirty is not really needed in the
first place it seems and should have already been done by hmm fault, so
just remove it.

(cherry picked from commit bd7c0cb695e87c0e43247be8196b4919edbe0e85)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2577b202458cddff85cc154b1fe7f313e0d1f418
  - https://git.kernel.org/stable/c/65dc4e3d5b01db0179fc95c1f0bdb87194c28ab5
  - https://git.kernel.org/stable/c/90574ecf6052be83971d91d16600c5cf07003bbb

------------------------------------------------------------

CVE ID: CVE-2025-37869
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/xe: Use local fence in error path of xe_migrate_clear

The intent of the error path in xe_migrate_clear is to wait on locally
generated fence and then return. The code is waiting on m->fence which
could be the local fence but this is only stable under the job mutex
leading to a possible UAF. Fix code to wait on local fence.

(cherry picked from commit 762b7e95362170b3e13a8704f38d5e47eca4ba74)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/20659d3150f1a2a258a173fe011013178ff2a197
  - https://git.kernel.org/stable/c/2ac5f466f62892a7d1ac2d1a3eb6cd14efbe2f2d
  - https://git.kernel.org/stable/c/dc712938aa26b001f448d5e93f59d57fa80f2dbd

------------------------------------------------------------

CVE ID: CVE-2025-37870
Description: In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: prevent hang on link training fail

[Why]
When link training fails, the phy clock will be disabled. However, in
enable_streams, it is assumed that link training succeeded and the
mux selects the phy clock, causing a hang when a register write is made.

[How]
When enable_stream is hit, check if link training failed. If it did, fall
back to the ref clock to avoid a hang and keep the system in a recoverable
state.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0363c03672cd3191f037905bf981eb523a3b71b1
  - https://git.kernel.org/stable/c/04bf4f2a497e9877c425c5124652e61fb8a1a0aa
  - https://git.kernel.org/stable/c/8058061ed9d6bc259d1e678607b07d259342c08f

------------------------------------------------------------

CVE ID: CVE-2025-37871
Description: In the Linux kernel, the following vulnerability has been resolved:

nfsd: decrease sc_count directly if fail to queue dl_recall

A deadlock warning occurred when invoking nfs4_put_stid following a failed
dl_recall queue operation:
            T1                            T2
                                nfs4_laundromat
                                 nfs4_get_client_reaplist
                                  nfs4_anylock_blockers
__break_lease
 spin_lock // ctx->flc_lock
                                   spin_lock // clp->cl_lock
                                   nfs4_lockowner_has_blockers
                                    locks_owner_has_blockers
                                     spin_lock // flctx->flc_lock
 nfsd_break_deleg_cb
  nfsd_break_one_deleg
   nfs4_put_stid
    refcount_dec_and_lock
     spin_lock // clp->cl_lock

When a file is opened, an nfs4_delegation is allocated with sc_count
initialized to 1, and the file_lease holds a reference to the delegation.
The file_lease is then associated with the file through kernel_setlease.

The disassociation is performed in nfsd4_delegreturn via the following
call chain:
nfsd4_delegreturn --> destroy_delegation --> destroy_unhashed_deleg -->
nfs4_unlock_deleg_lease --> kernel_setlease --> generic_delete_lease
The corresponding sc_count reference will be released after this
disassociation.

Since nfsd_break_one_deleg executes while holding the flc_lock, the
disassociation process becomes blocked when attempting to acquire flc_lock
in generic_delete_lease. This means:
1) sc_count in nfsd_break_one_deleg will not be decremented to 0;
2) The nfs4_put_stid called by nfsd_break_one_deleg will not attempt to
acquire cl_lock;
3) Consequently, no deadlock condition is created.

Given that sc_count in nfsd_break_one_deleg remains non-zero, we can
safely perform refcount_dec on sc_count directly. This approach
effectively avoids triggering deadlock warnings.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/14985d66b9b99c12995dd99d1c6c8dec4114c2a5
  - https://git.kernel.org/stable/c/7d192e27a431026c58d60edf66dc6cd98d0c01fc
  - https://git.kernel.org/stable/c/a1d14d931bf700c1025db8c46d6731aa5cf440f9
  - https://git.kernel.org/stable/c/a70832d3555987035fc430ccd703acd89393eadb
  - https://git.kernel.org/stable/c/a7fce086f6ca84db409b9d58493ea77c1978897c
  - https://git.kernel.org/stable/c/b9bbe8f9d5663311d06667ce36d6ed255ead1a26
  - https://git.kernel.org/stable/c/ba903539fff745d592d893c71b30e5e268a95413

------------------------------------------------------------

CVE ID: CVE-2025-37872
Description: In the Linux kernel, the following vulnerability has been resolved:

net: txgbe: fix memory leak in txgbe_probe() error path

When txgbe_sw_init() is called, memory is allocated for wx->rss_key
in wx_init_rss_key(). However, in txgbe_probe() function, the subsequent
error paths after txgbe_sw_init() don't free the rss_key. Fix that by
freeing it in error path along with wx->mac_table.

Also change the label to which execution jumps when txgbe_sw_init()
fails, because otherwise, it could lead to a double free for rss_key,
when the mac_table allocation fails in wx_sw_init().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/635863d93deb8e352d63a8eba852efeaf1ac3539
  - https://git.kernel.org/stable/c/837197a722919f5b0eeb967fe7cb0cc1e83173b9
  - https://git.kernel.org/stable/c/b2727326d0a53709380aa147018085d71a6d4843

------------------------------------------------------------

CVE ID: CVE-2025-37873
Description: In the Linux kernel, the following vulnerability has been resolved:

eth: bnxt: fix missing ring index trim on error path

Commit under Fixes converted tx_prod to be free running but missed
masking it on the Tx error path. This crashes on error conditions,
for example when DMA mapping fails.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/12f2d033fae957d84c2c0ce604d2a077e61fa2c0
  - https://git.kernel.org/stable/c/21e70f694bc0dcb40174b0940cc52a7769fc19e0
  - https://git.kernel.org/stable/c/3742c55de00266fa7c8fd2c5d61a453d223a9cd1

------------------------------------------------------------

CVE ID: CVE-2025-37874
Description: In the Linux kernel, the following vulnerability has been resolved:

net: ngbe: fix memory leak in ngbe_probe() error path

When ngbe_sw_init() is called, memory is allocated for wx->rss_key
in wx_init_rss_key(). However, in ngbe_probe() function, the subsequent
error paths after ngbe_sw_init() don't free the rss_key. Fix that by
freeing it in error path along with wx->mac_table.

Also change the label to which execution jumps when ngbe_sw_init()
fails, because otherwise, it could lead to a double free for rss_key,
when the mac_table allocation fails in wx_sw_init().
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/397487338eff1891c4654ce7deaafbf72a1688b2
  - https://git.kernel.org/stable/c/7c2b66a31c7a4866400f7e6fb43cb32021bfca01
  - https://git.kernel.org/stable/c/8335a3feb9d0d97e5e8f76d38b6bb8573d5b4a29
  - https://git.kernel.org/stable/c/88fa80021b77732bc98f73fb69d69c7cc37b9f0d

------------------------------------------------------------

CVE ID: CVE-2025-37875
Description: In the Linux kernel, the following vulnerability has been resolved:

igc: fix PTM cycle trigger logic

Writing to clear the PTM status 'valid' bit while the PTM cycle is
triggered results in unreliable PTM operation. To fix this, clear the
PTM 'trigger' and status after each PTM transaction.

The issue can be reproduced with the following:

$ sudo phc2sys -R 1000 -O 0 -i tsn0 -m

Note: 1000 Hz (-R 1000) is unrealistically large, but provides a way to
quickly reproduce the issue.

PHC2SYS exits with:

"ioctl PTP_OFFSET_PRECISE: Connection timed out" when the PTM transaction
  fails

This patch also fixes a hang in igc_probe() when loading the igc
driver in the kdump kernel on systems supporting PTM.

The igc driver running in the base kernel enables PTM trigger in
igc_probe().  Therefore the driver is always in PTM trigger mode,
except in brief periods when manually triggering a PTM cycle.

When a crash occurs, the NIC is reset while PTM trigger is enabled.
Due to a hardware problem, the NIC is subsequently in a bad busmaster
state and doesn't handle register reads/writes.  When running
igc_probe() in the kdump kernel, the first register access to a NIC
register hangs driver probing and ultimately breaks kdump.

With this patch, igc has PTM trigger disabled most of the time,
and the trigger is only enabled for very brief (10 - 100 us) periods
when manually triggering a PTM cycle.  Chances that a crash occurs
during a PTM trigger are not 0, but extremely reduced.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0c03e4fbe1321697d9d04587e21e416705e1b19f
  - https://git.kernel.org/stable/c/16194ca3f3b4448a062650c869a7b3b206c6f5d3
  - https://git.kernel.org/stable/c/31959e06143692f7e02b8eef7d7d6ac645637906
  - https://git.kernel.org/stable/c/8e404ad95d2c10c261e2ef6992c7c12dde03df0e
  - https://git.kernel.org/stable/c/c1f174edaccc5a00f8e218c42a0aa9156efd5f76
  - https://git.kernel.org/stable/c/f3516229cd12dcd45f23ed01adab17e8772b1bd5

------------------------------------------------------------

CVE ID: CVE-2025-37876
Description: In the Linux kernel, the following vulnerability has been resolved:

netfs: Only create /proc/fs/netfs with CONFIG_PROC_FS

When testing a special config:

CONFIG_NETFS_SUPPORTS=y
CONFIG_PROC_FS=n

The system crashes with something like:

[    3.766197] ------------[ cut here ]------------
[    3.766484] kernel BUG at mm/mempool.c:560!
[    3.766789] Oops: invalid opcode: 0000 [#1] SMP NOPTI
[    3.767123] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G        W
[    3.767777] Tainted: [W]=WARN
[    3.767968] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),
[    3.768523] RIP: 0010:mempool_alloc_slab.cold+0x17/0x19
[    3.768847] Code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00
[    3.769977] RSP: 0018:ffffc90000013998 EFLAGS: 00010286
[    3.770315] RAX: 000000000000002f RBX: ffff888100ba8640 RCX: 0000000000000000
[    3.770749] RDX: 0000000000000000 RSI: 0000000000000003 RDI: 00000000ffffffff
[    3.771217] RBP: 0000000000092880 R08: 0000000000000000 R09: ffffc90000013828
[    3.771664] R10: 0000000000000001 R11: 00000000ffffffea R12: 0000000000092cc0
[    3.772117] R13: 0000000000000400 R14: ffff8881004b1620 R15: ffffea0004ef7e40
[    3.772554] FS:  0000000000000000(0000) GS:ffff8881b5f3c000(0000) knlGS:0000000000000000
[    3.773061] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    3.773443] CR2: ffffffff830901b4 CR3: 0000000004296001 CR4: 0000000000770ef0
[    3.773884] PKRU: 55555554
[    3.774058] Call Trace:
[    3.774232]  <TASK>
[    3.774371]  mempool_alloc_noprof+0x6a/0x190
[    3.774649]  ? _printk+0x57/0x80
[    3.774862]  netfs_alloc_request+0x85/0x2ce
[    3.775147]  netfs_readahead+0x28/0x170
[    3.775395]  read_pages+0x6c/0x350
[    3.775623]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.775928]  page_cache_ra_unbounded+0x1bd/0x2a0
[    3.776247]  filemap_get_pages+0x139/0x970
[    3.776510]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.776820]  filemap_read+0xf9/0x580
[    3.777054]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.777368]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.777674]  ? find_held_lock+0x32/0x90
[    3.777929]  ? netfs_start_io_read+0x19/0x70
[    3.778221]  ? netfs_start_io_read+0x19/0x70
[    3.778489]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.778800]  ? lock_acquired+0x1e6/0x450
[    3.779054]  ? srso_alias_return_thunk+0x5/0xfbef5
[    3.779379]  netfs_buffered_read_iter+0x57/0x80
[    3.779670]  __kernel_read+0x158/0x2c0
[    3.779927]  bprm_execve+0x300/0x7a0
[    3.780185]  kernel_execve+0x10c/0x140
[    3.780423]  ? __pfx_kernel_init+0x10/0x10
[    3.780690]  kernel_init+0xd5/0x150
[    3.780910]  ret_from_fork+0x2d/0x50
[    3.781156]  ? __pfx_kernel_init+0x10/0x10
[    3.781414]  ret_from_fork_asm+0x1a/0x30
[    3.781677]  </TASK>
[    3.781823] Modules linked in:
[    3.782065] ---[ end trace 0000000000000000 ]---

This is caused by the following error path in netfs_init():

        if (!proc_mkdir("fs/netfs", NULL))
                goto error_proc;

Fix this by adding ifdef in netfs_main(), so that /proc/fs/netfs is only
created with CONFIG_PROC_FS.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/2ef6eea2efce01d1956ace483216f6b6e26330c9
  - https://git.kernel.org/stable/c/40cb48eba3b4b79e110c1a35d33a48cac54507a2
  - https://git.kernel.org/stable/c/6c4c5e0b96a90f2a11c378e66edc1f25165e10b6

------------------------------------------------------------

CVE ID: CVE-2025-37877
Description: In the Linux kernel, the following vulnerability has been resolved:

iommu: Clear iommu-dma ops on cleanup

If iommu_device_register() encounters an error, it can end up tearing
down already-configured groups and default domains, however this
currently still leaves devices hooked up to iommu-dma (and even
historically the behaviour in this area was at best inconsistent across
architectures/drivers...) Although in the case that an IOMMU is present
whose driver has failed to probe, users cannot necessarily expect DMA to
work anyway, it's still arguable that we should do our best to put
things back as if the IOMMU driver was never there at all, and certainly
the potential for crashing in iommu-dma itself is undesirable. Make sure
we clean up the dev->dma_iommu flag along with everything else.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/104a84276821aed0ed241ce0d82d6c3267e3fcb8
  - https://git.kernel.org/stable/c/280e5a30100578106a4305ce0118e0aa9b866f12
  - https://git.kernel.org/stable/c/b14d98641312d972bb3f38e82eddf92898522389

------------------------------------------------------------

CVE ID: CVE-2025-37878
Description: In the Linux kernel, the following vulnerability has been resolved:

perf/core: Fix WARN_ON(!ctx) in __free_event() for partial init

Move the get_ctx(child_ctx) call and the child_event->ctx assignment to
occur immediately after the child event is allocated. Ensure that
child_event->ctx is non-NULL before any subsequent error path within
inherit_event calls free_event(), satisfying the assumptions of the
cleanup code.

Details:

There's no clear Fixes tag, because this bug is a side-effect of
multiple interacting commits over time (up to 15 years old), not
a single regression.

The code initially incremented refcount then assigned context
immediately after the child_event was created. Later, an early
validity check for child_event was added before the
refcount/assignment. Even later, a WARN_ON_ONCE() cleanup check was
added, assuming event->ctx is valid if the pmu_ctx is valid.
The problem is that the WARN_ON_ONCE() could trigger after the initial
check passed but before child_event->ctx was assigned, violating its
precondition. The solution is to assign child_event->ctx right after
its initial validation. This ensures the context exists for any
subsequent checks or cleanup routines, resolving the WARN_ON_ONCE().

To resolve it, defer the refcount update and child_event->ctx assignment
directly after child_event->pmu_ctx is set but before checking if the
parent event is orphaned. The cleanup routine depends on
event->pmu_ctx being non-NULL before it verifies event->ctx is
non-NULL. This also maintains the author's original intent of passing
in child_ctx to find_get_pmu_context before its refcount/assignment.

[ mingo: Expanded the changelog from another email by Gabriel Shahrouzi. ]
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0ba3a4ab76fd3367b9cb680cad70182c896c795c
  - https://git.kernel.org/stable/c/1fe9b92eede32574dbe05b5bdb6ad666b350bed0
  - https://git.kernel.org/stable/c/90dc6c1e3b200812da8d0aa030e1b7fda8226d0e
  - https://git.kernel.org/stable/c/cb56cd11feabf99e08bc18960700a53322ffcea7

------------------------------------------------------------

CVE ID: CVE-2025-37879
Description: In the Linux kernel, the following vulnerability has been resolved:

9p/net: fix improper handling of bogus negative read/write replies

In p9_client_write() and p9_client_read_once(), if the server
incorrectly replies with success but a negative write/read count then we
would consider written (negative) <= rsize (positive) because both
variables were signed.

Make variables unsigned to avoid this problem.

The reproducer linked below now fails with the following error instead
of a null pointer deref:
9pnet: bogus RWRITE count (4294967295 > 3)
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/374e4cd75617c8c2552f562f39dd989583f5c330
  - https://git.kernel.org/stable/c/468ff4a7c61fb811c596a7c44b6a5455e40fd12b
  - https://git.kernel.org/stable/c/a68768e280b7d0c967ea509e791bb9b90adc94a5
  - https://git.kernel.org/stable/c/c548f95688e2b5ae0e2ae43d53cf717156c7d034
  - https://git.kernel.org/stable/c/d0259a856afca31d699b706ed5e2adf11086c73b

------------------------------------------------------------

CVE ID: CVE-2025-37880
Description: In the Linux kernel, the following vulnerability has been resolved:

um: work around sched_yield not yielding in time-travel mode

sched_yield by a userspace may not actually cause scheduling in
time-travel mode as no time has passed. In the case seen it appears to
be a badly implemented userspace spinlock in ASAN. Unfortunately, with
time-travel it causes an extreme slowdown or even deadlock depending on
the kernel configuration (CONFIG_UML_MAX_USERSPACE_ITERATIONS).

Work around it by accounting time to the process whenever it executes a
sched_yield syscall.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/887c5c12e80c8424bd471122d2e8b6b462e12874
  - https://git.kernel.org/stable/c/990ddc65173776f1e01e7135d8c1fd5f8fd4d5d2
  - https://git.kernel.org/stable/c/da780c4a075ba2deb05ae29f0af4a990578c7901

------------------------------------------------------------

CVE ID: CVE-2025-37881
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: aspeed: Add NULL pointer check in ast_vhub_init_dev()

The variable d->name, returned by devm_kasprintf(), could be NULL.
A pointer check is added to prevent potential NULL pointer dereference.
This is similar to the fix in commit 3027e7b15b02
("ice: Fix some null pointer dereference issues in ice_ptp.c").

This issue is found by our static analysis tool
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/052fb65335befeae8500e88d69ea022266baaf6d
  - https://git.kernel.org/stable/c/36d68151712e525450f0fbb3045e7110f0d9b610
  - https://git.kernel.org/stable/c/61006ca381b4d65d2b8ca695ea8da1ce18d6dee3
  - https://git.kernel.org/stable/c/8c75f3e6a433d92084ad4e78b029ae680865420f
  - https://git.kernel.org/stable/c/a777ccfb9ba8d43f745e41b69ba39d4a506a081e
  - https://git.kernel.org/stable/c/c8d4faf452a627f9b09c3a5c366133a19e5b7a28
  - https://git.kernel.org/stable/c/cfa7984f69359761b07a7831c1258c0fde1e0389
  - https://git.kernel.org/stable/c/d26a6093d52904cacdbb75424c323c19b443a890

------------------------------------------------------------

CVE ID: CVE-2025-37882
Description: In the Linux kernel, the following vulnerability has been resolved:

usb: xhci: Fix isochronous Ring Underrun/Overrun event handling

The TRB pointer of these events points at enqueue at the time of error
occurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time we
are handling the event, a new TD may be queued at this ring position.

I can trigger this race by rising interrupt moderation to increase IRQ
handling delay. Similar delay may occur naturally due to system load.

If this ever happens after a Missed Service Error, missed TDs will be
skipped and the new TD processed as if it matched the event. It could
be given back prematurely, risking data loss or buffer UAF by the xHC.

Don't complete TDs on xrun events and don't warn if queued TDs don't
match the event's TRB pointer, which can be NULL or a link/no-op TRB.
Don't warn if there are no queued TDs at all.

Now that it's safe, also handle xrun events if the skip flag is clear.
This ensures completion of any TD stuck in 'error mid TD' state right
before the xrun event, which could happen if a driver submits a finite
number of URBs to a buggy HC and then an error occurs on the last TD.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/16a7a8e6c47fea5c847beb696c8c21a7a44c1915
  - https://git.kernel.org/stable/c/39a080a2925c81b0f1da0add44722ef2b78e5454
  - https://git.kernel.org/stable/c/906dec15b9b321b546fd31a3c99ffc13724c7af4

------------------------------------------------------------

CVE ID: CVE-2025-37883
Description: In the Linux kernel, the following vulnerability has been resolved:

s390/sclp: Add check for get_zeroed_page()

Add check for the return value of get_zeroed_page() in
sclp_console_init() to prevent null pointer dereference.
Furthermore, to solve the memory leak caused by the loop
allocation, add a free helper to do the free job.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/28e5a867aa542e369e211c2baba7044228809a99
  - https://git.kernel.org/stable/c/397254706eba9d8f99fd237feede7ab3169a7f9a
  - https://git.kernel.org/stable/c/3b3aa72636a6205933609ec274a8747720c1ee3f
  - https://git.kernel.org/stable/c/3db42c75a921854a99db0a2775814fef97415bac
  - https://git.kernel.org/stable/c/e1e00dc45648125ef7cb87ebc3b581ac224e7b39
  - https://git.kernel.org/stable/c/f69f8a93aacf6e99af7b1cc992d8ca2cc07b96fb

------------------------------------------------------------

CVE ID: CVE-2025-37884
Description: In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix deadlock between rcu_tasks_trace and event_mutex.

Fix the following deadlock:
CPU A
_free_event()
  perf_kprobe_destroy()
    mutex_lock(&event_mutex)
      perf_trace_event_unreg()
        synchronize_rcu_tasks_trace()

There are several paths where _free_event() grabs event_mutex
and calls sync_rcu_tasks_trace. Above is one such case.

CPU B
bpf_prog_test_run_syscall()
  rcu_read_lock_trace()
    bpf_prog_run_pin_on_cpu()
      bpf_prog_load()
        bpf_tracing_func_proto()
          trace_set_clr_event()
            mutex_lock(&event_mutex)

Delegate trace_set_clr_event() to workqueue to avoid
such lock dependency.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/255cbc9db7067a83713fd2f4b31034ddd266549a
  - https://git.kernel.org/stable/c/45286680b385f2592db3003554872388dee66d68
  - https://git.kernel.org/stable/c/4580f4e0ebdf8dc8d506ae926b88510395a0c1d1
  - https://git.kernel.org/stable/c/b5a528a34e1f613565115a7a6016862ccbfcb9ac
  - https://git.kernel.org/stable/c/c5c833f6375f8ecf9254dd27946c927c7d645421

------------------------------------------------------------

CVE ID: CVE-2025-37885
Description: In the Linux kernel, the following vulnerability has been resolved:

KVM: x86: Reset IRTE to host control if *new* route isn't postable

Restore an IRTE back to host control (remapped or posted MSI mode) if the
*new* GSI route prevents posting the IRQ directly to a vCPU, regardless of
the GSI routing type.  Updating the IRTE if and only if the new GSI is an
MSI results in KVM leaving an IRTE posting to a vCPU.

The dangling IRTE can result in interrupts being incorrectly delivered to
the guest, and in the worst case scenario can result in use-after-free,
e.g. if the VM is torn down, but the underlying host IRQ isn't freed.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/023816bd5fa46fab94d1e7917fe131b79ed1fb41
  - https://git.kernel.org/stable/c/116c7d35b8f72eac383b9fd371d7c1a8ffc2968b
  - https://git.kernel.org/stable/c/3066ec21d1a33896125747f68638725f456308db
  - https://git.kernel.org/stable/c/3481fd96d801715942b6f69fe251133128156f30
  - https://git.kernel.org/stable/c/9bcac97dc42d2f4da8229d18feb0fe2b1ce523a2
  - https://git.kernel.org/stable/c/b5de7ac74f69603ad803c524b840bffd36368fc3
  - https://git.kernel.org/stable/c/e5f2dee9f7fcd2ff4b97869f3c66a0d89c167769

------------------------------------------------------------

CVE ID: CVE-2025-37886
Description: In the Linux kernel, the following vulnerability has been resolved:

pds_core: make wait_context part of q_info

Make the wait_context a full part of the q_info struct rather
than a stack variable that goes away after pdsc_adminq_post()
is done so that the context is still available after the wait
loop has given up.

There was a case where a slow development firmware caused
the adminq request to time out, but then later the FW finally
finished the request and sent the interrupt.  The handler tried
to complete_all() the completion context that had been created
on the stack in pdsc_adminq_post() but no longer existed.
This caused bad pointer usage, kernel crashes, and much wailing
and gnashing of teeth.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/1d7c4b2b0bbfb09b55b2dc0e2355d7936bf89381
  - https://git.kernel.org/stable/c/3f77c3dfffc7063428b100c4945ca2a7a8680380
  - https://git.kernel.org/stable/c/520f012fe75fb8efc9f16a57ef929a7a2115d892
  - https://git.kernel.org/stable/c/66d7702b42ffdf0dce4808626088268a4e905ca6

------------------------------------------------------------

CVE ID: CVE-2025-37887
Description: In the Linux kernel, the following vulnerability has been resolved:

pds_core: handle unsupported PDS_CORE_CMD_FW_CONTROL result

If the FW doesn't support the PDS_CORE_CMD_FW_CONTROL command
the driver might at the least print garbage and at the worst
crash when the user runs the "devlink dev info" devlink command.

This happens because the stack variable fw_list is not 0
initialized which results in fw_list.num_fw_slots being a
garbage value from the stack.  Then the driver tries to access
fw_list.fw_names[i] with i >= ARRAY_SIZE and runs off the end
of the array.

Fix this by initializing the fw_list and by not failing
completely if the devcmd fails because other useful information
is printed via devlink dev info even if the devcmd fails.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/12a4651a80dbe4589a84e26785fbbe1ed4d043b7
  - https://git.kernel.org/stable/c/2567daad69cd1107fc0ec29b1615f110d7cf7385
  - https://git.kernel.org/stable/c/6702f5c6b22deaa95bf84f526148174a160a02cb
  - https://git.kernel.org/stable/c/cdd784c96fe2e5edbf0ed9b3e96fe776e8092385

------------------------------------------------------------

CVE ID: CVE-2025-37888
Description: In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Fix null-ptr-deref in mlx5_create_{inner_,}ttc_table()

Add NULL check for mlx5_get_flow_namespace() returns in
mlx5_create_inner_ttc_table() and mlx5_create_ttc_table() to prevent
NULL pointer dereference.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0b682680b12b08cd62b113ea92b2938195de1dfe
  - https://git.kernel.org/stable/c/91037037ee3d611ce17f39d75f79c7de394b122a
  - https://git.kernel.org/stable/c/ecd9d2647ddb4f42a121de648e48659ae1856c39

------------------------------------------------------------

CVE ID: CVE-2025-37889
Description: In the Linux kernel, the following vulnerability has been resolved:

ASoC: ops: Consistently treat platform_max as control value

This reverts commit 9bdd10d57a88 ("ASoC: ops: Shift tested values in
snd_soc_put_volsw() by +min"), and makes some additional related
updates.

There are two ways the platform_max could be interpreted; the maximum
register value, or the maximum value the control can be set to. The
patch moved from treating the value as a control value to a register
one. When the patch was applied it was technically correct as
snd_soc_limit_volume() also used the register interpretation. However,
even then most of the other usages treated platform_max as a
control value, and snd_soc_limit_volume() has since been updated to
also do so in commit fb9ad24485087 ("ASoC: ops: add correct range
check for limiting volume"). That patch however, missed updating
snd_soc_put_volsw() back to the control interpretation, and fixing
snd_soc_info_volsw_range(). The control interpretation makes more
sense as limiting is typically done from the machine driver, so it is
appropriate to use the customer facing representation rather than the
internal codec representation. Update all the code to consistently use
this interpretation of platform_max.

Finally, also add some comments to the soc_mixer_control struct to
hopefully avoid further patches switching between the two approaches.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/0eba2a7e858907a746ba69cd002eb9eb4dbd7bf3
  - https://git.kernel.org/stable/c/296c8295ae34045da0214882628d49c1c060dd8a
  - https://git.kernel.org/stable/c/544055329560d4b64fe204fc6be325ebc24c72ca
  - https://git.kernel.org/stable/c/694110bc2407a61f02a770cbb5f39b51e4ec77c6
  - https://git.kernel.org/stable/c/a46a9371f8b9a0eeff53a21e11ed3b65f52d9cf6
  - https://git.kernel.org/stable/c/c402f184a053c8e7ca325e50f04bbbc1e4fee019

------------------------------------------------------------

CVE ID: CVE-2023-53145
Description: In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btsdio: fix use after free bug in btsdio_remove due to race condition

In btsdio_probe, the data->work is bound with btsdio_work. It will be
started in btsdio_send_frame.

If the btsdio_remove runs with a unfinished work, there may be a race
condition that hdev is freed but used in btsdio_work. Fix it by
canceling the work before do cleanup in btsdio_remove.
Severity:
  - CVSS Version: None
  - Base Score: None
  - Base Severity: None
  - CVSS Vector: None
CPEs:
  - No CPE data available.
References:
  - https://git.kernel.org/stable/c/179c65828593aff1f444e15debd40a477cb23cf4
  - https://git.kernel.org/stable/c/3efcbf25e5ab4d4ad1b7e6ba0869ff85540e3f6e
  - https://git.kernel.org/stable/c/6c3653627397a0d6eab19b20a59423e118985a6b
  - https://git.kernel.org/stable/c/73f7b171b7c09139eb3c6a5677c200dc1be5f318
  - https://git.kernel.org/stable/c/746b363bef41cc159c051c47f9e30800bc6b520d
  - https://git.kernel.org/stable/c/a5c2a467e9e789ae0891de55b766daac52e3b7b3
  - https://git.kernel.org/stable/c/a6650d27ab2c12a8ee750f396edb5ac8b4558b2e

------------------------------------------------------------

CVE ID: CVE-2025-1079
Description: Client RCE on macOS and Linux via improper symbolic link resolution in Google Web Designer's preview feature
Severity:
  - CVSS Version: 3.1
  - Base Score: 7.8
  - Base Severity: HIGH
  - CVSS Vector: CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H
CPEs:
  - No CPE data available.
References:
  - https://balintmagyar.com/articles/google-web-designer-symlink-client-side-rce-cve-2025-1079

------------------------------------------------------------

